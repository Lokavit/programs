(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VirtualMachine"] = factory();
	else
		root["VirtualMachine"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js-exposed");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-loader/lib!./src/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const VirtualMachine = __webpack_require__(/*! ./virtual-machine */ "./src/virtual-machine.js");

module.exports = VirtualMachine;

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/decode-html/index.js":
/*!*******************************************!*\
  !*** ./node_modules/decode-html/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Store markers outside of the function scope,
// not to recreate them on every call
var entities = {
  'amp': '&',
  'apos': '\'',
  'lt': '<',
  'gt': '>',
  'quot': '"',
  'nbsp': '\xa0'
};
var entityPattern = /&([a-z]+);/ig;

module.exports = function decodeHTMLEntities(text) {
  // A single replace pass with a static RegExp is faster than a loop
  return text.replace(entityPattern, function(match, entity) {
    entity = entity.toLowerCase();
    if (entities.hasOwnProperty(entity)) {
      return entities[entity];
    }
    // return original string if there is no matching entity (no replace)
    return match;
  });
};


/***/ }),

/***/ "./node_modules/dom-serializer/foreignNames.json":
/*!*******************************************************!*\
  !*** ./node_modules/dom-serializer/foreignNames.json ***!
  \*******************************************************/
/*! exports provided: elementNames, attributeNames, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"elementNames\":{\"altglyph\":\"altGlyph\",\"altglyphdef\":\"altGlyphDef\",\"altglyphitem\":\"altGlyphItem\",\"animatecolor\":\"animateColor\",\"animatemotion\":\"animateMotion\",\"animatetransform\":\"animateTransform\",\"clippath\":\"clipPath\",\"feblend\":\"feBlend\",\"fecolormatrix\":\"feColorMatrix\",\"fecomponenttransfer\":\"feComponentTransfer\",\"fecomposite\":\"feComposite\",\"feconvolvematrix\":\"feConvolveMatrix\",\"fediffuselighting\":\"feDiffuseLighting\",\"fedisplacementmap\":\"feDisplacementMap\",\"fedistantlight\":\"feDistantLight\",\"fedropshadow\":\"feDropShadow\",\"feflood\":\"feFlood\",\"fefunca\":\"feFuncA\",\"fefuncb\":\"feFuncB\",\"fefuncg\":\"feFuncG\",\"fefuncr\":\"feFuncR\",\"fegaussianblur\":\"feGaussianBlur\",\"feimage\":\"feImage\",\"femerge\":\"feMerge\",\"femergenode\":\"feMergeNode\",\"femorphology\":\"feMorphology\",\"feoffset\":\"feOffset\",\"fepointlight\":\"fePointLight\",\"fespecularlighting\":\"feSpecularLighting\",\"fespotlight\":\"feSpotLight\",\"fetile\":\"feTile\",\"feturbulence\":\"feTurbulence\",\"foreignobject\":\"foreignObject\",\"glyphref\":\"glyphRef\",\"lineargradient\":\"linearGradient\",\"radialgradient\":\"radialGradient\",\"textpath\":\"textPath\"},\"attributeNames\":{\"definitionurl\":\"definitionURL\",\"attributename\":\"attributeName\",\"attributetype\":\"attributeType\",\"basefrequency\":\"baseFrequency\",\"baseprofile\":\"baseProfile\",\"calcmode\":\"calcMode\",\"clippathunits\":\"clipPathUnits\",\"diffuseconstant\":\"diffuseConstant\",\"edgemode\":\"edgeMode\",\"filterunits\":\"filterUnits\",\"glyphref\":\"glyphRef\",\"gradienttransform\":\"gradientTransform\",\"gradientunits\":\"gradientUnits\",\"kernelmatrix\":\"kernelMatrix\",\"kernelunitlength\":\"kernelUnitLength\",\"keypoints\":\"keyPoints\",\"keysplines\":\"keySplines\",\"keytimes\":\"keyTimes\",\"lengthadjust\":\"lengthAdjust\",\"limitingconeangle\":\"limitingConeAngle\",\"markerheight\":\"markerHeight\",\"markerunits\":\"markerUnits\",\"markerwidth\":\"markerWidth\",\"maskcontentunits\":\"maskContentUnits\",\"maskunits\":\"maskUnits\",\"numoctaves\":\"numOctaves\",\"pathlength\":\"pathLength\",\"patterncontentunits\":\"patternContentUnits\",\"patterntransform\":\"patternTransform\",\"patternunits\":\"patternUnits\",\"pointsatx\":\"pointsAtX\",\"pointsaty\":\"pointsAtY\",\"pointsatz\":\"pointsAtZ\",\"preservealpha\":\"preserveAlpha\",\"preserveaspectratio\":\"preserveAspectRatio\",\"primitiveunits\":\"primitiveUnits\",\"refx\":\"refX\",\"refy\":\"refY\",\"repeatcount\":\"repeatCount\",\"repeatdur\":\"repeatDur\",\"requiredextensions\":\"requiredExtensions\",\"requiredfeatures\":\"requiredFeatures\",\"specularconstant\":\"specularConstant\",\"specularexponent\":\"specularExponent\",\"spreadmethod\":\"spreadMethod\",\"startoffset\":\"startOffset\",\"stddeviation\":\"stdDeviation\",\"stitchtiles\":\"stitchTiles\",\"surfacescale\":\"surfaceScale\",\"systemlanguage\":\"systemLanguage\",\"tablevalues\":\"tableValues\",\"targetx\":\"targetX\",\"targety\":\"targetY\",\"textlength\":\"textLength\",\"viewbox\":\"viewBox\",\"viewtarget\":\"viewTarget\",\"xchannelselector\":\"xChannelSelector\",\"ychannelselector\":\"yChannelSelector\",\"zoomandpan\":\"zoomAndPan\"}}");

/***/ }),

/***/ "./node_modules/dom-serializer/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dom-serializer/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
  Module dependencies
*/
var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/dom-serializer/node_modules/domelementtype/lib/index.js");
var entities = __webpack_require__(/*! entities */ "./node_modules/dom-serializer/node_modules/entities/lib/index.js");

/* mixed-case SVG and MathML tags & attributes
   recognized by the HTML parser, see
   https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
*/
var foreignNames = __webpack_require__(/*! ./foreignNames.json */ "./node_modules/dom-serializer/foreignNames.json");
foreignNames.elementNames.__proto__ = null; /* use as a simple dictionary */
foreignNames.attributeNames.__proto__ = null;

var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function formatAttrs(attributes, opts) {
  if (!attributes) return;

  var output = '';
  var value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }

    if (opts.xmlMode === 'foreign') {
      /* fix up mixed-case attribute names */
      key = foreignNames.attributeNames[key] || key;
    }
    output += key;
    if ((value !== null && value !== '') || opts.xmlMode) {
      output +=
        '="' +
        (opts.decodeEntities
          ? entities.encodeXML(value)
          : value.replace(/\"/g, '&quot;')) +
        '"';
    }
  }

  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

var render = (module.exports = function(dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};

  var output = '';

  for (var i = 0; i < dom.length; i++) {
    var elem = dom[i];

    if (elem.type === 'root') output += render(elem.children, opts);
    else if (ElementType.isTag(elem)) output += renderTag(elem, opts);
    else if (elem.type === ElementType.Directive)
      output += renderDirective(elem);
    else if (elem.type === ElementType.Comment) output += renderComment(elem);
    else if (elem.type === ElementType.CDATA) output += renderCdata(elem);
    else output += renderText(elem, opts);
  }

  return output;
});

var foreignModeIntegrationPoints = [
  'mi',
  'mo',
  'mn',
  'ms',
  'mtext',
  'annotation-xml',
  'foreignObject',
  'desc',
  'title'
];

function renderTag(elem, opts) {
  // Handle SVG / MathML in HTML
  if (opts.xmlMode === 'foreign') {
    /* fix up mixed-case element names */
    elem.name = foreignNames.elementNames[elem.name] || elem.name;
    /* exit foreign mode at integration points */
    if (
      elem.parent &&
      foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0
    )
      opts = Object.assign({}, opts, { xmlMode: false });
  }
  if (!opts.xmlMode && ['svg', 'math'].indexOf(elem.name) >= 0) {
    opts = Object.assign({}, opts, { xmlMode: 'foreign' });
  }

  var tag = '<' + elem.name;
  var attribs = formatAttrs(elem.attribs, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += render(elem.children, opts);
    }

    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag;
}

function renderDirective(elem) {
  return '<' + elem.data + '>';
}

function renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (
    opts.decodeEntities &&
    !(elem.parent && elem.parent.name in unencodedElements)
  ) {
    data = entities.encodeXML(data);
  }

  return data;
}

function renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}

function renderComment(elem) {
  return '<!--' + elem.data + '-->';
}


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/domelementtype/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/domelementtype/lib/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.isTag = void 0;
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === "tag" /* Tag */ ||
        elem.type === "script" /* Script */ ||
        elem.type === "style" /* Style */);
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for Text */
exports.Text = "text" /* Text */;
/** Type for <? ... ?> */
exports.Directive = "directive" /* Directive */;
/** Type for <!-- ... --> */
exports.Comment = "comment" /* Comment */;
/** Type for <script> tags */
exports.Script = "script" /* Script */;
/** Type for <style> tags */
exports.Style = "style" /* Style */;
/** Type for Any tag */
exports.Tag = "tag" /* Tag */;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = "cdata" /* CDATA */;
/** Type for <!doctype ...> */
exports.Doctype = "doctype" /* Doctype */;


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/decode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/decode.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
var entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json"));
var legacy_json_1 = __importDefault(__webpack_require__(/*! ./maps/legacy.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json"));
var xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json"));
var decode_codepoint_1 = __importDefault(__webpack_require__(/*! ./decode_codepoint */ "./node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js"));
exports.decodeXML = getStrictDecoder(xml_json_1.default);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
function getStrictDecoder(map) {
    var keys = Object.keys(map).join("|");
    var replace = getReplacer(map);
    keys += "|#[xX][\\da-fA-F]+|#\\d+";
    var re = new RegExp("&(?:" + keys + ");", "g");
    return function (str) { return String(str).replace(re, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
exports.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        return map[str.slice(1, -1)];
    };
}


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var decode_json_1 = __importDefault(__webpack_require__(/*! ./maps/decode.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json"));
// Modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    var output = "";
    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }
    output += String.fromCharCode(codePoint);
    return output;
}
exports.default = decodeCodePoint;


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/encode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/encode.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.escape = exports.encodeHTML = exports.encodeXML = void 0;
var xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json"));
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
exports.encodeXML = getInverse(inverseXML, xmlReplacer);
var entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json"));
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
function singleCharReplacer(c) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return "&#x" + c.codePointAt(0).toString(16).toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reXmlChars = getInverseReplacer(inverseXML);
function escape(data) {
    return data
        .replace(reXmlChars, singleCharReplacer)
        .replace(reNonASCII, singleCharReplacer);
}
exports.escape = escape;


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escape = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = __webpack_require__(/*! ./decode */ "./node_modules/dom-serializer/node_modules/entities/lib/decode.js");
var encode_1 = __webpack_require__(/*! ./encode */ "./node_modules/dom-serializer/node_modules/entities/lib/encode.js");
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */
function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 */
function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = __webpack_require__(/*! ./encode */ "./node_modules/dom-serializer/node_modules/entities/lib/encode.js");
Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
// Legacy aliases
Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
var decode_2 = __webpack_require__(/*! ./decode */ "./node_modules/dom-serializer/node_modules/entities/lib/decode.js");
Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
// Legacy aliases
Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } });


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json":
/*!********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json ***!
  \********************************************************************************/
/*! exports provided: 0, 128, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 142, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 158, 159, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"0\":65533,\"128\":8364,\"130\":8218,\"131\":402,\"132\":8222,\"133\":8230,\"134\":8224,\"135\":8225,\"136\":710,\"137\":8240,\"138\":352,\"139\":8249,\"140\":338,\"142\":381,\"145\":8216,\"146\":8217,\"147\":8220,\"148\":8221,\"149\":8226,\"150\":8211,\"151\":8212,\"152\":732,\"153\":8482,\"154\":353,\"155\":8250,\"156\":339,\"158\":382,\"159\":376}");

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json":
/*!**********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json ***!
  \**********************************************************************************/
/*! exports provided: Aacute, aacute, Abreve, abreve, ac, acd, acE, Acirc, acirc, acute, Acy, acy, AElig, aelig, af, Afr, afr, Agrave, agrave, alefsym, aleph, Alpha, alpha, Amacr, amacr, amalg, amp, AMP, andand, And, and, andd, andslope, andv, ang, ange, angle, angmsdaa, angmsdab, angmsdac, angmsdad, angmsdae, angmsdaf, angmsdag, angmsdah, angmsd, angrt, angrtvb, angrtvbd, angsph, angst, angzarr, Aogon, aogon, Aopf, aopf, apacir, ap, apE, ape, apid, apos, ApplyFunction, approx, approxeq, Aring, aring, Ascr, ascr, Assign, ast, asymp, asympeq, Atilde, atilde, Auml, auml, awconint, awint, backcong, backepsilon, backprime, backsim, backsimeq, Backslash, Barv, barvee, barwed, Barwed, barwedge, bbrk, bbrktbrk, bcong, Bcy, bcy, bdquo, becaus, because, Because, bemptyv, bepsi, bernou, Bernoullis, Beta, beta, beth, between, Bfr, bfr, bigcap, bigcirc, bigcup, bigodot, bigoplus, bigotimes, bigsqcup, bigstar, bigtriangledown, bigtriangleup, biguplus, bigvee, bigwedge, bkarow, blacklozenge, blacksquare, blacktriangle, blacktriangledown, blacktriangleleft, blacktriangleright, blank, blk12, blk14, blk34, block, bne, bnequiv, bNot, bnot, Bopf, bopf, bot, bottom, bowtie, boxbox, boxdl, boxdL, boxDl, boxDL, boxdr, boxdR, boxDr, boxDR, boxh, boxH, boxhd, boxHd, boxhD, boxHD, boxhu, boxHu, boxhU, boxHU, boxminus, boxplus, boxtimes, boxul, boxuL, boxUl, boxUL, boxur, boxuR, boxUr, boxUR, boxv, boxV, boxvh, boxvH, boxVh, boxVH, boxvl, boxvL, boxVl, boxVL, boxvr, boxvR, boxVr, boxVR, bprime, breve, Breve, brvbar, bscr, Bscr, bsemi, bsim, bsime, bsolb, bsol, bsolhsub, bull, bullet, bump, bumpE, bumpe, Bumpeq, bumpeq, Cacute, cacute, capand, capbrcup, capcap, cap, Cap, capcup, capdot, CapitalDifferentialD, caps, caret, caron, Cayleys, ccaps, Ccaron, ccaron, Ccedil, ccedil, Ccirc, ccirc, Cconint, ccups, ccupssm, Cdot, cdot, cedil, Cedilla, cemptyv, cent, centerdot, CenterDot, cfr, Cfr, CHcy, chcy, check, checkmark, Chi, chi, circ, circeq, circlearrowleft, circlearrowright, circledast, circledcirc, circleddash, CircleDot, circledR, circledS, CircleMinus, CirclePlus, CircleTimes, cir, cirE, cire, cirfnint, cirmid, cirscir, ClockwiseContourIntegral, CloseCurlyDoubleQuote, CloseCurlyQuote, clubs, clubsuit, colon, Colon, Colone, colone, coloneq, comma, commat, comp, compfn, complement, complexes, cong, congdot, Congruent, conint, Conint, ContourIntegral, copf, Copf, coprod, Coproduct, copy, COPY, copysr, CounterClockwiseContourIntegral, crarr, cross, Cross, Cscr, cscr, csub, csube, csup, csupe, ctdot, cudarrl, cudarrr, cuepr, cuesc, cularr, cularrp, cupbrcap, cupcap, CupCap, cup, Cup, cupcup, cupdot, cupor, cups, curarr, curarrm, curlyeqprec, curlyeqsucc, curlyvee, curlywedge, curren, curvearrowleft, curvearrowright, cuvee, cuwed, cwconint, cwint, cylcty, dagger, Dagger, daleth, darr, Darr, dArr, dash, Dashv, dashv, dbkarow, dblac, Dcaron, dcaron, Dcy, dcy, ddagger, ddarr, DD, dd, DDotrahd, ddotseq, deg, Del, Delta, delta, demptyv, dfisht, Dfr, dfr, dHar, dharl, dharr, DiacriticalAcute, DiacriticalDot, DiacriticalDoubleAcute, DiacriticalGrave, DiacriticalTilde, diam, diamond, Diamond, diamondsuit, diams, die, DifferentialD, digamma, disin, div, divide, divideontimes, divonx, DJcy, djcy, dlcorn, dlcrop, dollar, Dopf, dopf, Dot, dot, DotDot, doteq, doteqdot, DotEqual, dotminus, dotplus, dotsquare, doublebarwedge, DoubleContourIntegral, DoubleDot, DoubleDownArrow, DoubleLeftArrow, DoubleLeftRightArrow, DoubleLeftTee, DoubleLongLeftArrow, DoubleLongLeftRightArrow, DoubleLongRightArrow, DoubleRightArrow, DoubleRightTee, DoubleUpArrow, DoubleUpDownArrow, DoubleVerticalBar, DownArrowBar, downarrow, DownArrow, Downarrow, DownArrowUpArrow, DownBreve, downdownarrows, downharpoonleft, downharpoonright, DownLeftRightVector, DownLeftTeeVector, DownLeftVectorBar, DownLeftVector, DownRightTeeVector, DownRightVectorBar, DownRightVector, DownTeeArrow, DownTee, drbkarow, drcorn, drcrop, Dscr, dscr, DScy, dscy, dsol, Dstrok, dstrok, dtdot, dtri, dtrif, duarr, duhar, dwangle, DZcy, dzcy, dzigrarr, Eacute, eacute, easter, Ecaron, ecaron, Ecirc, ecirc, ecir, ecolon, Ecy, ecy, eDDot, Edot, edot, eDot, ee, efDot, Efr, efr, eg, Egrave, egrave, egs, egsdot, el, Element, elinters, ell, els, elsdot, Emacr, emacr, empty, emptyset, EmptySmallSquare, emptyv, EmptyVerySmallSquare, emsp13, emsp14, emsp, ENG, eng, ensp, Eogon, eogon, Eopf, eopf, epar, eparsl, eplus, epsi, Epsilon, epsilon, epsiv, eqcirc, eqcolon, eqsim, eqslantgtr, eqslantless, Equal, equals, EqualTilde, equest, Equilibrium, equiv, equivDD, eqvparsl, erarr, erDot, escr, Escr, esdot, Esim, esim, Eta, eta, ETH, eth, Euml, euml, euro, excl, exist, Exists, expectation, exponentiale, ExponentialE, fallingdotseq, Fcy, fcy, female, ffilig, fflig, ffllig, Ffr, ffr, filig, FilledSmallSquare, FilledVerySmallSquare, fjlig, flat, fllig, fltns, fnof, Fopf, fopf, forall, ForAll, fork, forkv, Fouriertrf, fpartint, frac12, frac13, frac14, frac15, frac16, frac18, frac23, frac25, frac34, frac35, frac38, frac45, frac56, frac58, frac78, frasl, frown, fscr, Fscr, gacute, Gamma, gamma, Gammad, gammad, gap, Gbreve, gbreve, Gcedil, Gcirc, gcirc, Gcy, gcy, Gdot, gdot, ge, gE, gEl, gel, geq, geqq, geqslant, gescc, ges, gesdot, gesdoto, gesdotol, gesl, gesles, Gfr, gfr, gg, Gg, ggg, gimel, GJcy, gjcy, gla, gl, glE, glj, gnap, gnapprox, gne, gnE, gneq, gneqq, gnsim, Gopf, gopf, grave, GreaterEqual, GreaterEqualLess, GreaterFullEqual, GreaterGreater, GreaterLess, GreaterSlantEqual, GreaterTilde, Gscr, gscr, gsim, gsime, gsiml, gtcc, gtcir, gt, GT, Gt, gtdot, gtlPar, gtquest, gtrapprox, gtrarr, gtrdot, gtreqless, gtreqqless, gtrless, gtrsim, gvertneqq, gvnE, Hacek, hairsp, half, hamilt, HARDcy, hardcy, harrcir, harr, hArr, harrw, Hat, hbar, Hcirc, hcirc, hearts, heartsuit, hellip, hercon, hfr, Hfr, HilbertSpace, hksearow, hkswarow, hoarr, homtht, hookleftarrow, hookrightarrow, hopf, Hopf, horbar, HorizontalLine, hscr, Hscr, hslash, Hstrok, hstrok, HumpDownHump, HumpEqual, hybull, hyphen, Iacute, iacute, ic, Icirc, icirc, Icy, icy, Idot, IEcy, iecy, iexcl, iff, ifr, Ifr, Igrave, igrave, ii, iiiint, iiint, iinfin, iiota, IJlig, ijlig, Imacr, imacr, image, ImaginaryI, imagline, imagpart, imath, Im, imof, imped, Implies, incare, in, infin, infintie, inodot, intcal, int, Int, integers, Integral, intercal, Intersection, intlarhk, intprod, InvisibleComma, InvisibleTimes, IOcy, iocy, Iogon, iogon, Iopf, iopf, Iota, iota, iprod, iquest, iscr, Iscr, isin, isindot, isinE, isins, isinsv, isinv, it, Itilde, itilde, Iukcy, iukcy, Iuml, iuml, Jcirc, jcirc, Jcy, jcy, Jfr, jfr, jmath, Jopf, jopf, Jscr, jscr, Jsercy, jsercy, Jukcy, jukcy, Kappa, kappa, kappav, Kcedil, kcedil, Kcy, kcy, Kfr, kfr, kgreen, KHcy, khcy, KJcy, kjcy, Kopf, kopf, Kscr, kscr, lAarr, Lacute, lacute, laemptyv, lagran, Lambda, lambda, lang, Lang, langd, langle, lap, Laplacetrf, laquo, larrb, larrbfs, larr, Larr, lArr, larrfs, larrhk, larrlp, larrpl, larrsim, larrtl, latail, lAtail, lat, late, lates, lbarr, lBarr, lbbrk, lbrace, lbrack, lbrke, lbrksld, lbrkslu, Lcaron, lcaron, Lcedil, lcedil, lceil, lcub, Lcy, lcy, ldca, ldquo, ldquor, ldrdhar, ldrushar, ldsh, le, lE, LeftAngleBracket, LeftArrowBar, leftarrow, LeftArrow, Leftarrow, LeftArrowRightArrow, leftarrowtail, LeftCeiling, LeftDoubleBracket, LeftDownTeeVector, LeftDownVectorBar, LeftDownVector, LeftFloor, leftharpoondown, leftharpoonup, leftleftarrows, leftrightarrow, LeftRightArrow, Leftrightarrow, leftrightarrows, leftrightharpoons, leftrightsquigarrow, LeftRightVector, LeftTeeArrow, LeftTee, LeftTeeVector, leftthreetimes, LeftTriangleBar, LeftTriangle, LeftTriangleEqual, LeftUpDownVector, LeftUpTeeVector, LeftUpVectorBar, LeftUpVector, LeftVectorBar, LeftVector, lEg, leg, leq, leqq, leqslant, lescc, les, lesdot, lesdoto, lesdotor, lesg, lesges, lessapprox, lessdot, lesseqgtr, lesseqqgtr, LessEqualGreater, LessFullEqual, LessGreater, lessgtr, LessLess, lesssim, LessSlantEqual, LessTilde, lfisht, lfloor, Lfr, lfr, lg, lgE, lHar, lhard, lharu, lharul, lhblk, LJcy, ljcy, llarr, ll, Ll, llcorner, Lleftarrow, llhard, lltri, Lmidot, lmidot, lmoustache, lmoust, lnap, lnapprox, lne, lnE, lneq, lneqq, lnsim, loang, loarr, lobrk, longleftarrow, LongLeftArrow, Longleftarrow, longleftrightarrow, LongLeftRightArrow, Longleftrightarrow, longmapsto, longrightarrow, LongRightArrow, Longrightarrow, looparrowleft, looparrowright, lopar, Lopf, lopf, loplus, lotimes, lowast, lowbar, LowerLeftArrow, LowerRightArrow, loz, lozenge, lozf, lpar, lparlt, lrarr, lrcorner, lrhar, lrhard, lrm, lrtri, lsaquo, lscr, Lscr, lsh, Lsh, lsim, lsime, lsimg, lsqb, lsquo, lsquor, Lstrok, lstrok, ltcc, ltcir, lt, LT, Lt, ltdot, lthree, ltimes, ltlarr, ltquest, ltri, ltrie, ltrif, ltrPar, lurdshar, luruhar, lvertneqq, lvnE, macr, male, malt, maltese, Map, map, mapsto, mapstodown, mapstoleft, mapstoup, marker, mcomma, Mcy, mcy, mdash, mDDot, measuredangle, MediumSpace, Mellintrf, Mfr, mfr, mho, micro, midast, midcir, mid, middot, minusb, minus, minusd, minusdu, MinusPlus, mlcp, mldr, mnplus, models, Mopf, mopf, mp, mscr, Mscr, mstpos, Mu, mu, multimap, mumap, nabla, Nacute, nacute, nang, nap, napE, napid, napos, napprox, natural, naturals, natur, nbsp, nbump, nbumpe, ncap, Ncaron, ncaron, Ncedil, ncedil, ncong, ncongdot, ncup, Ncy, ncy, ndash, nearhk, nearr, neArr, nearrow, ne, nedot, NegativeMediumSpace, NegativeThickSpace, NegativeThinSpace, NegativeVeryThinSpace, nequiv, nesear, nesim, NestedGreaterGreater, NestedLessLess, NewLine, nexist, nexists, Nfr, nfr, ngE, nge, ngeq, ngeqq, ngeqslant, nges, nGg, ngsim, nGt, ngt, ngtr, nGtv, nharr, nhArr, nhpar, ni, nis, nisd, niv, NJcy, njcy, nlarr, nlArr, nldr, nlE, nle, nleftarrow, nLeftarrow, nleftrightarrow, nLeftrightarrow, nleq, nleqq, nleqslant, nles, nless, nLl, nlsim, nLt, nlt, nltri, nltrie, nLtv, nmid, NoBreak, NonBreakingSpace, nopf, Nopf, Not, not, NotCongruent, NotCupCap, NotDoubleVerticalBar, NotElement, NotEqual, NotEqualTilde, NotExists, NotGreater, NotGreaterEqual, NotGreaterFullEqual, NotGreaterGreater, NotGreaterLess, NotGreaterSlantEqual, NotGreaterTilde, NotHumpDownHump, NotHumpEqual, notin, notindot, notinE, notinva, notinvb, notinvc, NotLeftTriangleBar, NotLeftTriangle, NotLeftTriangleEqual, NotLess, NotLessEqual, NotLessGreater, NotLessLess, NotLessSlantEqual, NotLessTilde, NotNestedGreaterGreater, NotNestedLessLess, notni, notniva, notnivb, notnivc, NotPrecedes, NotPrecedesEqual, NotPrecedesSlantEqual, NotReverseElement, NotRightTriangleBar, NotRightTriangle, NotRightTriangleEqual, NotSquareSubset, NotSquareSubsetEqual, NotSquareSuperset, NotSquareSupersetEqual, NotSubset, NotSubsetEqual, NotSucceeds, NotSucceedsEqual, NotSucceedsSlantEqual, NotSucceedsTilde, NotSuperset, NotSupersetEqual, NotTilde, NotTildeEqual, NotTildeFullEqual, NotTildeTilde, NotVerticalBar, nparallel, npar, nparsl, npart, npolint, npr, nprcue, nprec, npreceq, npre, nrarrc, nrarr, nrArr, nrarrw, nrightarrow, nRightarrow, nrtri, nrtrie, nsc, nsccue, nsce, Nscr, nscr, nshortmid, nshortparallel, nsim, nsime, nsimeq, nsmid, nspar, nsqsube, nsqsupe, nsub, nsubE, nsube, nsubset, nsubseteq, nsubseteqq, nsucc, nsucceq, nsup, nsupE, nsupe, nsupset, nsupseteq, nsupseteqq, ntgl, Ntilde, ntilde, ntlg, ntriangleleft, ntrianglelefteq, ntriangleright, ntrianglerighteq, Nu, nu, num, numero, numsp, nvap, nvdash, nvDash, nVdash, nVDash, nvge, nvgt, nvHarr, nvinfin, nvlArr, nvle, nvlt, nvltrie, nvrArr, nvrtrie, nvsim, nwarhk, nwarr, nwArr, nwarrow, nwnear, Oacute, oacute, oast, Ocirc, ocirc, ocir, Ocy, ocy, odash, Odblac, odblac, odiv, odot, odsold, OElig, oelig, ofcir, Ofr, ofr, ogon, Ograve, ograve, ogt, ohbar, ohm, oint, olarr, olcir, olcross, oline, olt, Omacr, omacr, Omega, omega, Omicron, omicron, omid, ominus, Oopf, oopf, opar, OpenCurlyDoubleQuote, OpenCurlyQuote, operp, oplus, orarr, Or, or, ord, order, orderof, ordf, ordm, origof, oror, orslope, orv, oS, Oscr, oscr, Oslash, oslash, osol, Otilde, otilde, otimesas, Otimes, otimes, Ouml, ouml, ovbar, OverBar, OverBrace, OverBracket, OverParenthesis, para, parallel, par, parsim, parsl, part, PartialD, Pcy, pcy, percnt, period, permil, perp, pertenk, Pfr, pfr, Phi, phi, phiv, phmmat, phone, Pi, pi, pitchfork, piv, planck, planckh, plankv, plusacir, plusb, pluscir, plus, plusdo, plusdu, pluse, PlusMinus, plusmn, plussim, plustwo, pm, Poincareplane, pointint, popf, Popf, pound, prap, Pr, pr, prcue, precapprox, prec, preccurlyeq, Precedes, PrecedesEqual, PrecedesSlantEqual, PrecedesTilde, preceq, precnapprox, precneqq, precnsim, pre, prE, precsim, prime, Prime, primes, prnap, prnE, prnsim, prod, Product, profalar, profline, profsurf, prop, Proportional, Proportion, propto, prsim, prurel, Pscr, pscr, Psi, psi, puncsp, Qfr, qfr, qint, qopf, Qopf, qprime, Qscr, qscr, quaternions, quatint, quest, questeq, quot, QUOT, rAarr, race, Racute, racute, radic, raemptyv, rang, Rang, rangd, range, rangle, raquo, rarrap, rarrb, rarrbfs, rarrc, rarr, Rarr, rArr, rarrfs, rarrhk, rarrlp, rarrpl, rarrsim, Rarrtl, rarrtl, rarrw, ratail, rAtail, ratio, rationals, rbarr, rBarr, RBarr, rbbrk, rbrace, rbrack, rbrke, rbrksld, rbrkslu, Rcaron, rcaron, Rcedil, rcedil, rceil, rcub, Rcy, rcy, rdca, rdldhar, rdquo, rdquor, rdsh, real, realine, realpart, reals, Re, rect, reg, REG, ReverseElement, ReverseEquilibrium, ReverseUpEquilibrium, rfisht, rfloor, rfr, Rfr, rHar, rhard, rharu, rharul, Rho, rho, rhov, RightAngleBracket, RightArrowBar, rightarrow, RightArrow, Rightarrow, RightArrowLeftArrow, rightarrowtail, RightCeiling, RightDoubleBracket, RightDownTeeVector, RightDownVectorBar, RightDownVector, RightFloor, rightharpoondown, rightharpoonup, rightleftarrows, rightleftharpoons, rightrightarrows, rightsquigarrow, RightTeeArrow, RightTee, RightTeeVector, rightthreetimes, RightTriangleBar, RightTriangle, RightTriangleEqual, RightUpDownVector, RightUpTeeVector, RightUpVectorBar, RightUpVector, RightVectorBar, RightVector, ring, risingdotseq, rlarr, rlhar, rlm, rmoustache, rmoust, rnmid, roang, roarr, robrk, ropar, ropf, Ropf, roplus, rotimes, RoundImplies, rpar, rpargt, rppolint, rrarr, Rrightarrow, rsaquo, rscr, Rscr, rsh, Rsh, rsqb, rsquo, rsquor, rthree, rtimes, rtri, rtrie, rtrif, rtriltri, RuleDelayed, ruluhar, rx, Sacute, sacute, sbquo, scap, Scaron, scaron, Sc, sc, sccue, sce, scE, Scedil, scedil, Scirc, scirc, scnap, scnE, scnsim, scpolint, scsim, Scy, scy, sdotb, sdot, sdote, searhk, searr, seArr, searrow, sect, semi, seswar, setminus, setmn, sext, Sfr, sfr, sfrown, sharp, SHCHcy, shchcy, SHcy, shcy, ShortDownArrow, ShortLeftArrow, shortmid, shortparallel, ShortRightArrow, ShortUpArrow, shy, Sigma, sigma, sigmaf, sigmav, sim, simdot, sime, simeq, simg, simgE, siml, simlE, simne, simplus, simrarr, slarr, SmallCircle, smallsetminus, smashp, smeparsl, smid, smile, smt, smte, smtes, SOFTcy, softcy, solbar, solb, sol, Sopf, sopf, spades, spadesuit, spar, sqcap, sqcaps, sqcup, sqcups, Sqrt, sqsub, sqsube, sqsubset, sqsubseteq, sqsup, sqsupe, sqsupset, sqsupseteq, square, Square, SquareIntersection, SquareSubset, SquareSubsetEqual, SquareSuperset, SquareSupersetEqual, SquareUnion, squarf, squ, squf, srarr, Sscr, sscr, ssetmn, ssmile, sstarf, Star, star, starf, straightepsilon, straightphi, strns, sub, Sub, subdot, subE, sube, subedot, submult, subnE, subne, subplus, subrarr, subset, Subset, subseteq, subseteqq, SubsetEqual, subsetneq, subsetneqq, subsim, subsub, subsup, succapprox, succ, succcurlyeq, Succeeds, SucceedsEqual, SucceedsSlantEqual, SucceedsTilde, succeq, succnapprox, succneqq, succnsim, succsim, SuchThat, sum, Sum, sung, sup1, sup2, sup3, sup, Sup, supdot, supdsub, supE, supe, supedot, Superset, SupersetEqual, suphsol, suphsub, suplarr, supmult, supnE, supne, supplus, supset, Supset, supseteq, supseteqq, supsetneq, supsetneqq, supsim, supsub, supsup, swarhk, swarr, swArr, swarrow, swnwar, szlig, Tab, target, Tau, tau, tbrk, Tcaron, tcaron, Tcedil, tcedil, Tcy, tcy, tdot, telrec, Tfr, tfr, there4, therefore, Therefore, Theta, theta, thetasym, thetav, thickapprox, thicksim, ThickSpace, ThinSpace, thinsp, thkap, thksim, THORN, thorn, tilde, Tilde, TildeEqual, TildeFullEqual, TildeTilde, timesbar, timesb, times, timesd, tint, toea, topbot, topcir, top, Topf, topf, topfork, tosa, tprime, trade, TRADE, triangle, triangledown, triangleleft, trianglelefteq, triangleq, triangleright, trianglerighteq, tridot, trie, triminus, TripleDot, triplus, trisb, tritime, trpezium, Tscr, tscr, TScy, tscy, TSHcy, tshcy, Tstrok, tstrok, twixt, twoheadleftarrow, twoheadrightarrow, Uacute, uacute, uarr, Uarr, uArr, Uarrocir, Ubrcy, ubrcy, Ubreve, ubreve, Ucirc, ucirc, Ucy, ucy, udarr, Udblac, udblac, udhar, ufisht, Ufr, ufr, Ugrave, ugrave, uHar, uharl, uharr, uhblk, ulcorn, ulcorner, ulcrop, ultri, Umacr, umacr, uml, UnderBar, UnderBrace, UnderBracket, UnderParenthesis, Union, UnionPlus, Uogon, uogon, Uopf, uopf, UpArrowBar, uparrow, UpArrow, Uparrow, UpArrowDownArrow, updownarrow, UpDownArrow, Updownarrow, UpEquilibrium, upharpoonleft, upharpoonright, uplus, UpperLeftArrow, UpperRightArrow, upsi, Upsi, upsih, Upsilon, upsilon, UpTeeArrow, UpTee, upuparrows, urcorn, urcorner, urcrop, Uring, uring, urtri, Uscr, uscr, utdot, Utilde, utilde, utri, utrif, uuarr, Uuml, uuml, uwangle, vangrt, varepsilon, varkappa, varnothing, varphi, varpi, varpropto, varr, vArr, varrho, varsigma, varsubsetneq, varsubsetneqq, varsupsetneq, varsupsetneqq, vartheta, vartriangleleft, vartriangleright, vBar, Vbar, vBarv, Vcy, vcy, vdash, vDash, Vdash, VDash, Vdashl, veebar, vee, Vee, veeeq, vellip, verbar, Verbar, vert, Vert, VerticalBar, VerticalLine, VerticalSeparator, VerticalTilde, VeryThinSpace, Vfr, vfr, vltri, vnsub, vnsup, Vopf, vopf, vprop, vrtri, Vscr, vscr, vsubnE, vsubne, vsupnE, vsupne, Vvdash, vzigzag, Wcirc, wcirc, wedbar, wedge, Wedge, wedgeq, weierp, Wfr, wfr, Wopf, wopf, wp, wr, wreath, Wscr, wscr, xcap, xcirc, xcup, xdtri, Xfr, xfr, xharr, xhArr, Xi, xi, xlarr, xlArr, xmap, xnis, xodot, Xopf, xopf, xoplus, xotime, xrarr, xrArr, Xscr, xscr, xsqcup, xuplus, xutri, xvee, xwedge, Yacute, yacute, YAcy, yacy, Ycirc, ycirc, Ycy, ycy, yen, Yfr, yfr, YIcy, yicy, Yopf, yopf, Yscr, yscr, YUcy, yucy, yuml, Yuml, Zacute, zacute, Zcaron, zcaron, Zcy, zcy, Zdot, zdot, zeetrf, ZeroWidthSpace, Zeta, zeta, zfr, Zfr, ZHcy, zhcy, zigrarr, zopf, Zopf, Zscr, zscr, zwj, zwnj, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"\",\"aacute\":\"\",\"Abreve\":\"\",\"abreve\":\"\",\"ac\":\"\",\"acd\":\"\",\"acE\":\"\",\"Acirc\":\"\",\"acirc\":\"\",\"acute\":\"\",\"Acy\":\"\",\"acy\":\"\",\"AElig\":\"\",\"aelig\":\"\",\"af\":\"\",\"Afr\":\"\",\"afr\":\"\",\"Agrave\":\"\",\"agrave\":\"\",\"alefsym\":\"\",\"aleph\":\"\",\"Alpha\":\"\",\"alpha\":\"\",\"Amacr\":\"\",\"amacr\":\"\",\"amalg\":\"\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"\",\"And\":\"\",\"and\":\"\",\"andd\":\"\",\"andslope\":\"\",\"andv\":\"\",\"ang\":\"\",\"ange\":\"\",\"angle\":\"\",\"angmsdaa\":\"\",\"angmsdab\":\"\",\"angmsdac\":\"\",\"angmsdad\":\"\",\"angmsdae\":\"\",\"angmsdaf\":\"\",\"angmsdag\":\"\",\"angmsdah\":\"\",\"angmsd\":\"\",\"angrt\":\"\",\"angrtvb\":\"\",\"angrtvbd\":\"\",\"angsph\":\"\",\"angst\":\"\",\"angzarr\":\"\",\"Aogon\":\"\",\"aogon\":\"\",\"Aopf\":\"\",\"aopf\":\"\",\"apacir\":\"\",\"ap\":\"\",\"apE\":\"\",\"ape\":\"\",\"apid\":\"\",\"apos\":\"'\",\"ApplyFunction\":\"\",\"approx\":\"\",\"approxeq\":\"\",\"Aring\":\"\",\"aring\":\"\",\"Ascr\":\"\",\"ascr\":\"\",\"Assign\":\"\",\"ast\":\"*\",\"asymp\":\"\",\"asympeq\":\"\",\"Atilde\":\"\",\"atilde\":\"\",\"Auml\":\"\",\"auml\":\"\",\"awconint\":\"\",\"awint\":\"\",\"backcong\":\"\",\"backepsilon\":\"\",\"backprime\":\"\",\"backsim\":\"\",\"backsimeq\":\"\",\"Backslash\":\"\",\"Barv\":\"\",\"barvee\":\"\",\"barwed\":\"\",\"Barwed\":\"\",\"barwedge\":\"\",\"bbrk\":\"\",\"bbrktbrk\":\"\",\"bcong\":\"\",\"Bcy\":\"\",\"bcy\":\"\",\"bdquo\":\"\",\"becaus\":\"\",\"because\":\"\",\"Because\":\"\",\"bemptyv\":\"\",\"bepsi\":\"\",\"bernou\":\"\",\"Bernoullis\":\"\",\"Beta\":\"\",\"beta\":\"\",\"beth\":\"\",\"between\":\"\",\"Bfr\":\"\",\"bfr\":\"\",\"bigcap\":\"\",\"bigcirc\":\"\",\"bigcup\":\"\",\"bigodot\":\"\",\"bigoplus\":\"\",\"bigotimes\":\"\",\"bigsqcup\":\"\",\"bigstar\":\"\",\"bigtriangledown\":\"\",\"bigtriangleup\":\"\",\"biguplus\":\"\",\"bigvee\":\"\",\"bigwedge\":\"\",\"bkarow\":\"\",\"blacklozenge\":\"\",\"blacksquare\":\"\",\"blacktriangle\":\"\",\"blacktriangledown\":\"\",\"blacktriangleleft\":\"\",\"blacktriangleright\":\"\",\"blank\":\"\",\"blk12\":\"\",\"blk14\":\"\",\"blk34\":\"\",\"block\":\"\",\"bne\":\"=\",\"bnequiv\":\"\",\"bNot\":\"\",\"bnot\":\"\",\"Bopf\":\"\",\"bopf\":\"\",\"bot\":\"\",\"bottom\":\"\",\"bowtie\":\"\",\"boxbox\":\"\",\"boxdl\":\"\",\"boxdL\":\"\",\"boxDl\":\"\",\"boxDL\":\"\",\"boxdr\":\"\",\"boxdR\":\"\",\"boxDr\":\"\",\"boxDR\":\"\",\"boxh\":\"\",\"boxH\":\"\",\"boxhd\":\"\",\"boxHd\":\"\",\"boxhD\":\"\",\"boxHD\":\"\",\"boxhu\":\"\",\"boxHu\":\"\",\"boxhU\":\"\",\"boxHU\":\"\",\"boxminus\":\"\",\"boxplus\":\"\",\"boxtimes\":\"\",\"boxul\":\"\",\"boxuL\":\"\",\"boxUl\":\"\",\"boxUL\":\"\",\"boxur\":\"\",\"boxuR\":\"\",\"boxUr\":\"\",\"boxUR\":\"\",\"boxv\":\"\",\"boxV\":\"\",\"boxvh\":\"\",\"boxvH\":\"\",\"boxVh\":\"\",\"boxVH\":\"\",\"boxvl\":\"\",\"boxvL\":\"\",\"boxVl\":\"\",\"boxVL\":\"\",\"boxvr\":\"\",\"boxvR\":\"\",\"boxVr\":\"\",\"boxVR\":\"\",\"bprime\":\"\",\"breve\":\"\",\"Breve\":\"\",\"brvbar\":\"\",\"bscr\":\"\",\"Bscr\":\"\",\"bsemi\":\"\",\"bsim\":\"\",\"bsime\":\"\",\"bsolb\":\"\",\"bsol\":\"\\\\\",\"bsolhsub\":\"\",\"bull\":\"\",\"bullet\":\"\",\"bump\":\"\",\"bumpE\":\"\",\"bumpe\":\"\",\"Bumpeq\":\"\",\"bumpeq\":\"\",\"Cacute\":\"\",\"cacute\":\"\",\"capand\":\"\",\"capbrcup\":\"\",\"capcap\":\"\",\"cap\":\"\",\"Cap\":\"\",\"capcup\":\"\",\"capdot\":\"\",\"CapitalDifferentialD\":\"\",\"caps\":\"\",\"caret\":\"\",\"caron\":\"\",\"Cayleys\":\"\",\"ccaps\":\"\",\"Ccaron\":\"\",\"ccaron\":\"\",\"Ccedil\":\"\",\"ccedil\":\"\",\"Ccirc\":\"\",\"ccirc\":\"\",\"Cconint\":\"\",\"ccups\":\"\",\"ccupssm\":\"\",\"Cdot\":\"\",\"cdot\":\"\",\"cedil\":\"\",\"Cedilla\":\"\",\"cemptyv\":\"\",\"cent\":\"\",\"centerdot\":\"\",\"CenterDot\":\"\",\"cfr\":\"\",\"Cfr\":\"\",\"CHcy\":\"\",\"chcy\":\"\",\"check\":\"\",\"checkmark\":\"\",\"Chi\":\"\",\"chi\":\"\",\"circ\":\"\",\"circeq\":\"\",\"circlearrowleft\":\"\",\"circlearrowright\":\"\",\"circledast\":\"\",\"circledcirc\":\"\",\"circleddash\":\"\",\"CircleDot\":\"\",\"circledR\":\"\",\"circledS\":\"\",\"CircleMinus\":\"\",\"CirclePlus\":\"\",\"CircleTimes\":\"\",\"cir\":\"\",\"cirE\":\"\",\"cire\":\"\",\"cirfnint\":\"\",\"cirmid\":\"\",\"cirscir\":\"\",\"ClockwiseContourIntegral\":\"\",\"CloseCurlyDoubleQuote\":\"\",\"CloseCurlyQuote\":\"\",\"clubs\":\"\",\"clubsuit\":\"\",\"colon\":\":\",\"Colon\":\"\",\"Colone\":\"\",\"colone\":\"\",\"coloneq\":\"\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"\",\"compfn\":\"\",\"complement\":\"\",\"complexes\":\"\",\"cong\":\"\",\"congdot\":\"\",\"Congruent\":\"\",\"conint\":\"\",\"Conint\":\"\",\"ContourIntegral\":\"\",\"copf\":\"\",\"Copf\":\"\",\"coprod\":\"\",\"Coproduct\":\"\",\"copy\":\"\",\"COPY\":\"\",\"copysr\":\"\",\"CounterClockwiseContourIntegral\":\"\",\"crarr\":\"\",\"cross\":\"\",\"Cross\":\"\",\"Cscr\":\"\",\"cscr\":\"\",\"csub\":\"\",\"csube\":\"\",\"csup\":\"\",\"csupe\":\"\",\"ctdot\":\"\",\"cudarrl\":\"\",\"cudarrr\":\"\",\"cuepr\":\"\",\"cuesc\":\"\",\"cularr\":\"\",\"cularrp\":\"\",\"cupbrcap\":\"\",\"cupcap\":\"\",\"CupCap\":\"\",\"cup\":\"\",\"Cup\":\"\",\"cupcup\":\"\",\"cupdot\":\"\",\"cupor\":\"\",\"cups\":\"\",\"curarr\":\"\",\"curarrm\":\"\",\"curlyeqprec\":\"\",\"curlyeqsucc\":\"\",\"curlyvee\":\"\",\"curlywedge\":\"\",\"curren\":\"\",\"curvearrowleft\":\"\",\"curvearrowright\":\"\",\"cuvee\":\"\",\"cuwed\":\"\",\"cwconint\":\"\",\"cwint\":\"\",\"cylcty\":\"\",\"dagger\":\"\",\"Dagger\":\"\",\"daleth\":\"\",\"darr\":\"\",\"Darr\":\"\",\"dArr\":\"\",\"dash\":\"\",\"Dashv\":\"\",\"dashv\":\"\",\"dbkarow\":\"\",\"dblac\":\"\",\"Dcaron\":\"\",\"dcaron\":\"\",\"Dcy\":\"\",\"dcy\":\"\",\"ddagger\":\"\",\"ddarr\":\"\",\"DD\":\"\",\"dd\":\"\",\"DDotrahd\":\"\",\"ddotseq\":\"\",\"deg\":\"\",\"Del\":\"\",\"Delta\":\"\",\"delta\":\"\",\"demptyv\":\"\",\"dfisht\":\"\",\"Dfr\":\"\",\"dfr\":\"\",\"dHar\":\"\",\"dharl\":\"\",\"dharr\":\"\",\"DiacriticalAcute\":\"\",\"DiacriticalDot\":\"\",\"DiacriticalDoubleAcute\":\"\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"\",\"diam\":\"\",\"diamond\":\"\",\"Diamond\":\"\",\"diamondsuit\":\"\",\"diams\":\"\",\"die\":\"\",\"DifferentialD\":\"\",\"digamma\":\"\",\"disin\":\"\",\"div\":\"\",\"divide\":\"\",\"divideontimes\":\"\",\"divonx\":\"\",\"DJcy\":\"\",\"djcy\":\"\",\"dlcorn\":\"\",\"dlcrop\":\"\",\"dollar\":\"$\",\"Dopf\":\"\",\"dopf\":\"\",\"Dot\":\"\",\"dot\":\"\",\"DotDot\":\"\",\"doteq\":\"\",\"doteqdot\":\"\",\"DotEqual\":\"\",\"dotminus\":\"\",\"dotplus\":\"\",\"dotsquare\":\"\",\"doublebarwedge\":\"\",\"DoubleContourIntegral\":\"\",\"DoubleDot\":\"\",\"DoubleDownArrow\":\"\",\"DoubleLeftArrow\":\"\",\"DoubleLeftRightArrow\":\"\",\"DoubleLeftTee\":\"\",\"DoubleLongLeftArrow\":\"\",\"DoubleLongLeftRightArrow\":\"\",\"DoubleLongRightArrow\":\"\",\"DoubleRightArrow\":\"\",\"DoubleRightTee\":\"\",\"DoubleUpArrow\":\"\",\"DoubleUpDownArrow\":\"\",\"DoubleVerticalBar\":\"\",\"DownArrowBar\":\"\",\"downarrow\":\"\",\"DownArrow\":\"\",\"Downarrow\":\"\",\"DownArrowUpArrow\":\"\",\"DownBreve\":\"\",\"downdownarrows\":\"\",\"downharpoonleft\":\"\",\"downharpoonright\":\"\",\"DownLeftRightVector\":\"\",\"DownLeftTeeVector\":\"\",\"DownLeftVectorBar\":\"\",\"DownLeftVector\":\"\",\"DownRightTeeVector\":\"\",\"DownRightVectorBar\":\"\",\"DownRightVector\":\"\",\"DownTeeArrow\":\"\",\"DownTee\":\"\",\"drbkarow\":\"\",\"drcorn\":\"\",\"drcrop\":\"\",\"Dscr\":\"\",\"dscr\":\"\",\"DScy\":\"\",\"dscy\":\"\",\"dsol\":\"\",\"Dstrok\":\"\",\"dstrok\":\"\",\"dtdot\":\"\",\"dtri\":\"\",\"dtrif\":\"\",\"duarr\":\"\",\"duhar\":\"\",\"dwangle\":\"\",\"DZcy\":\"\",\"dzcy\":\"\",\"dzigrarr\":\"\",\"Eacute\":\"\",\"eacute\":\"\",\"easter\":\"\",\"Ecaron\":\"\",\"ecaron\":\"\",\"Ecirc\":\"\",\"ecirc\":\"\",\"ecir\":\"\",\"ecolon\":\"\",\"Ecy\":\"\",\"ecy\":\"\",\"eDDot\":\"\",\"Edot\":\"\",\"edot\":\"\",\"eDot\":\"\",\"ee\":\"\",\"efDot\":\"\",\"Efr\":\"\",\"efr\":\"\",\"eg\":\"\",\"Egrave\":\"\",\"egrave\":\"\",\"egs\":\"\",\"egsdot\":\"\",\"el\":\"\",\"Element\":\"\",\"elinters\":\"\",\"ell\":\"\",\"els\":\"\",\"elsdot\":\"\",\"Emacr\":\"\",\"emacr\":\"\",\"empty\":\"\",\"emptyset\":\"\",\"EmptySmallSquare\":\"\",\"emptyv\":\"\",\"EmptyVerySmallSquare\":\"\",\"emsp13\":\"\",\"emsp14\":\"\",\"emsp\":\"\",\"ENG\":\"\",\"eng\":\"\",\"ensp\":\"\",\"Eogon\":\"\",\"eogon\":\"\",\"Eopf\":\"\",\"eopf\":\"\",\"epar\":\"\",\"eparsl\":\"\",\"eplus\":\"\",\"epsi\":\"\",\"Epsilon\":\"\",\"epsilon\":\"\",\"epsiv\":\"\",\"eqcirc\":\"\",\"eqcolon\":\"\",\"eqsim\":\"\",\"eqslantgtr\":\"\",\"eqslantless\":\"\",\"Equal\":\"\",\"equals\":\"=\",\"EqualTilde\":\"\",\"equest\":\"\",\"Equilibrium\":\"\",\"equiv\":\"\",\"equivDD\":\"\",\"eqvparsl\":\"\",\"erarr\":\"\",\"erDot\":\"\",\"escr\":\"\",\"Escr\":\"\",\"esdot\":\"\",\"Esim\":\"\",\"esim\":\"\",\"Eta\":\"\",\"eta\":\"\",\"ETH\":\"\",\"eth\":\"\",\"Euml\":\"\",\"euml\":\"\",\"euro\":\"\",\"excl\":\"!\",\"exist\":\"\",\"Exists\":\"\",\"expectation\":\"\",\"exponentiale\":\"\",\"ExponentialE\":\"\",\"fallingdotseq\":\"\",\"Fcy\":\"\",\"fcy\":\"\",\"female\":\"\",\"ffilig\":\"\",\"fflig\":\"\",\"ffllig\":\"\",\"Ffr\":\"\",\"ffr\":\"\",\"filig\":\"\",\"FilledSmallSquare\":\"\",\"FilledVerySmallSquare\":\"\",\"fjlig\":\"fj\",\"flat\":\"\",\"fllig\":\"\",\"fltns\":\"\",\"fnof\":\"\",\"Fopf\":\"\",\"fopf\":\"\",\"forall\":\"\",\"ForAll\":\"\",\"fork\":\"\",\"forkv\":\"\",\"Fouriertrf\":\"\",\"fpartint\":\"\",\"frac12\":\"\",\"frac13\":\"\",\"frac14\":\"\",\"frac15\":\"\",\"frac16\":\"\",\"frac18\":\"\",\"frac23\":\"\",\"frac25\":\"\",\"frac34\":\"\",\"frac35\":\"\",\"frac38\":\"\",\"frac45\":\"\",\"frac56\":\"\",\"frac58\":\"\",\"frac78\":\"\",\"frasl\":\"\",\"frown\":\"\",\"fscr\":\"\",\"Fscr\":\"\",\"gacute\":\"\",\"Gamma\":\"\",\"gamma\":\"\",\"Gammad\":\"\",\"gammad\":\"\",\"gap\":\"\",\"Gbreve\":\"\",\"gbreve\":\"\",\"Gcedil\":\"\",\"Gcirc\":\"\",\"gcirc\":\"\",\"Gcy\":\"\",\"gcy\":\"\",\"Gdot\":\"\",\"gdot\":\"\",\"ge\":\"\",\"gE\":\"\",\"gEl\":\"\",\"gel\":\"\",\"geq\":\"\",\"geqq\":\"\",\"geqslant\":\"\",\"gescc\":\"\",\"ges\":\"\",\"gesdot\":\"\",\"gesdoto\":\"\",\"gesdotol\":\"\",\"gesl\":\"\",\"gesles\":\"\",\"Gfr\":\"\",\"gfr\":\"\",\"gg\":\"\",\"Gg\":\"\",\"ggg\":\"\",\"gimel\":\"\",\"GJcy\":\"\",\"gjcy\":\"\",\"gla\":\"\",\"gl\":\"\",\"glE\":\"\",\"glj\":\"\",\"gnap\":\"\",\"gnapprox\":\"\",\"gne\":\"\",\"gnE\":\"\",\"gneq\":\"\",\"gneqq\":\"\",\"gnsim\":\"\",\"Gopf\":\"\",\"gopf\":\"\",\"grave\":\"`\",\"GreaterEqual\":\"\",\"GreaterEqualLess\":\"\",\"GreaterFullEqual\":\"\",\"GreaterGreater\":\"\",\"GreaterLess\":\"\",\"GreaterSlantEqual\":\"\",\"GreaterTilde\":\"\",\"Gscr\":\"\",\"gscr\":\"\",\"gsim\":\"\",\"gsime\":\"\",\"gsiml\":\"\",\"gtcc\":\"\",\"gtcir\":\"\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"\",\"gtdot\":\"\",\"gtlPar\":\"\",\"gtquest\":\"\",\"gtrapprox\":\"\",\"gtrarr\":\"\",\"gtrdot\":\"\",\"gtreqless\":\"\",\"gtreqqless\":\"\",\"gtrless\":\"\",\"gtrsim\":\"\",\"gvertneqq\":\"\",\"gvnE\":\"\",\"Hacek\":\"\",\"hairsp\":\"\",\"half\":\"\",\"hamilt\":\"\",\"HARDcy\":\"\",\"hardcy\":\"\",\"harrcir\":\"\",\"harr\":\"\",\"hArr\":\"\",\"harrw\":\"\",\"Hat\":\"^\",\"hbar\":\"\",\"Hcirc\":\"\",\"hcirc\":\"\",\"hearts\":\"\",\"heartsuit\":\"\",\"hellip\":\"\",\"hercon\":\"\",\"hfr\":\"\",\"Hfr\":\"\",\"HilbertSpace\":\"\",\"hksearow\":\"\",\"hkswarow\":\"\",\"hoarr\":\"\",\"homtht\":\"\",\"hookleftarrow\":\"\",\"hookrightarrow\":\"\",\"hopf\":\"\",\"Hopf\":\"\",\"horbar\":\"\",\"HorizontalLine\":\"\",\"hscr\":\"\",\"Hscr\":\"\",\"hslash\":\"\",\"Hstrok\":\"\",\"hstrok\":\"\",\"HumpDownHump\":\"\",\"HumpEqual\":\"\",\"hybull\":\"\",\"hyphen\":\"\",\"Iacute\":\"\",\"iacute\":\"\",\"ic\":\"\",\"Icirc\":\"\",\"icirc\":\"\",\"Icy\":\"\",\"icy\":\"\",\"Idot\":\"\",\"IEcy\":\"\",\"iecy\":\"\",\"iexcl\":\"\",\"iff\":\"\",\"ifr\":\"\",\"Ifr\":\"\",\"Igrave\":\"\",\"igrave\":\"\",\"ii\":\"\",\"iiiint\":\"\",\"iiint\":\"\",\"iinfin\":\"\",\"iiota\":\"\",\"IJlig\":\"\",\"ijlig\":\"\",\"Imacr\":\"\",\"imacr\":\"\",\"image\":\"\",\"ImaginaryI\":\"\",\"imagline\":\"\",\"imagpart\":\"\",\"imath\":\"\",\"Im\":\"\",\"imof\":\"\",\"imped\":\"\",\"Implies\":\"\",\"incare\":\"\",\"in\":\"\",\"infin\":\"\",\"infintie\":\"\",\"inodot\":\"\",\"intcal\":\"\",\"int\":\"\",\"Int\":\"\",\"integers\":\"\",\"Integral\":\"\",\"intercal\":\"\",\"Intersection\":\"\",\"intlarhk\":\"\",\"intprod\":\"\",\"InvisibleComma\":\"\",\"InvisibleTimes\":\"\",\"IOcy\":\"\",\"iocy\":\"\",\"Iogon\":\"\",\"iogon\":\"\",\"Iopf\":\"\",\"iopf\":\"\",\"Iota\":\"\",\"iota\":\"\",\"iprod\":\"\",\"iquest\":\"\",\"iscr\":\"\",\"Iscr\":\"\",\"isin\":\"\",\"isindot\":\"\",\"isinE\":\"\",\"isins\":\"\",\"isinsv\":\"\",\"isinv\":\"\",\"it\":\"\",\"Itilde\":\"\",\"itilde\":\"\",\"Iukcy\":\"\",\"iukcy\":\"\",\"Iuml\":\"\",\"iuml\":\"\",\"Jcirc\":\"\",\"jcirc\":\"\",\"Jcy\":\"\",\"jcy\":\"\",\"Jfr\":\"\",\"jfr\":\"\",\"jmath\":\"\",\"Jopf\":\"\",\"jopf\":\"\",\"Jscr\":\"\",\"jscr\":\"\",\"Jsercy\":\"\",\"jsercy\":\"\",\"Jukcy\":\"\",\"jukcy\":\"\",\"Kappa\":\"\",\"kappa\":\"\",\"kappav\":\"\",\"Kcedil\":\"\",\"kcedil\":\"\",\"Kcy\":\"\",\"kcy\":\"\",\"Kfr\":\"\",\"kfr\":\"\",\"kgreen\":\"\",\"KHcy\":\"\",\"khcy\":\"\",\"KJcy\":\"\",\"kjcy\":\"\",\"Kopf\":\"\",\"kopf\":\"\",\"Kscr\":\"\",\"kscr\":\"\",\"lAarr\":\"\",\"Lacute\":\"\",\"lacute\":\"\",\"laemptyv\":\"\",\"lagran\":\"\",\"Lambda\":\"\",\"lambda\":\"\",\"lang\":\"\",\"Lang\":\"\",\"langd\":\"\",\"langle\":\"\",\"lap\":\"\",\"Laplacetrf\":\"\",\"laquo\":\"\",\"larrb\":\"\",\"larrbfs\":\"\",\"larr\":\"\",\"Larr\":\"\",\"lArr\":\"\",\"larrfs\":\"\",\"larrhk\":\"\",\"larrlp\":\"\",\"larrpl\":\"\",\"larrsim\":\"\",\"larrtl\":\"\",\"latail\":\"\",\"lAtail\":\"\",\"lat\":\"\",\"late\":\"\",\"lates\":\"\",\"lbarr\":\"\",\"lBarr\":\"\",\"lbbrk\":\"\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"\",\"lbrksld\":\"\",\"lbrkslu\":\"\",\"Lcaron\":\"\",\"lcaron\":\"\",\"Lcedil\":\"\",\"lcedil\":\"\",\"lceil\":\"\",\"lcub\":\"{\",\"Lcy\":\"\",\"lcy\":\"\",\"ldca\":\"\",\"ldquo\":\"\",\"ldquor\":\"\",\"ldrdhar\":\"\",\"ldrushar\":\"\",\"ldsh\":\"\",\"le\":\"\",\"lE\":\"\",\"LeftAngleBracket\":\"\",\"LeftArrowBar\":\"\",\"leftarrow\":\"\",\"LeftArrow\":\"\",\"Leftarrow\":\"\",\"LeftArrowRightArrow\":\"\",\"leftarrowtail\":\"\",\"LeftCeiling\":\"\",\"LeftDoubleBracket\":\"\",\"LeftDownTeeVector\":\"\",\"LeftDownVectorBar\":\"\",\"LeftDownVector\":\"\",\"LeftFloor\":\"\",\"leftharpoondown\":\"\",\"leftharpoonup\":\"\",\"leftleftarrows\":\"\",\"leftrightarrow\":\"\",\"LeftRightArrow\":\"\",\"Leftrightarrow\":\"\",\"leftrightarrows\":\"\",\"leftrightharpoons\":\"\",\"leftrightsquigarrow\":\"\",\"LeftRightVector\":\"\",\"LeftTeeArrow\":\"\",\"LeftTee\":\"\",\"LeftTeeVector\":\"\",\"leftthreetimes\":\"\",\"LeftTriangleBar\":\"\",\"LeftTriangle\":\"\",\"LeftTriangleEqual\":\"\",\"LeftUpDownVector\":\"\",\"LeftUpTeeVector\":\"\",\"LeftUpVectorBar\":\"\",\"LeftUpVector\":\"\",\"LeftVectorBar\":\"\",\"LeftVector\":\"\",\"lEg\":\"\",\"leg\":\"\",\"leq\":\"\",\"leqq\":\"\",\"leqslant\":\"\",\"lescc\":\"\",\"les\":\"\",\"lesdot\":\"\",\"lesdoto\":\"\",\"lesdotor\":\"\",\"lesg\":\"\",\"lesges\":\"\",\"lessapprox\":\"\",\"lessdot\":\"\",\"lesseqgtr\":\"\",\"lesseqqgtr\":\"\",\"LessEqualGreater\":\"\",\"LessFullEqual\":\"\",\"LessGreater\":\"\",\"lessgtr\":\"\",\"LessLess\":\"\",\"lesssim\":\"\",\"LessSlantEqual\":\"\",\"LessTilde\":\"\",\"lfisht\":\"\",\"lfloor\":\"\",\"Lfr\":\"\",\"lfr\":\"\",\"lg\":\"\",\"lgE\":\"\",\"lHar\":\"\",\"lhard\":\"\",\"lharu\":\"\",\"lharul\":\"\",\"lhblk\":\"\",\"LJcy\":\"\",\"ljcy\":\"\",\"llarr\":\"\",\"ll\":\"\",\"Ll\":\"\",\"llcorner\":\"\",\"Lleftarrow\":\"\",\"llhard\":\"\",\"lltri\":\"\",\"Lmidot\":\"\",\"lmidot\":\"\",\"lmoustache\":\"\",\"lmoust\":\"\",\"lnap\":\"\",\"lnapprox\":\"\",\"lne\":\"\",\"lnE\":\"\",\"lneq\":\"\",\"lneqq\":\"\",\"lnsim\":\"\",\"loang\":\"\",\"loarr\":\"\",\"lobrk\":\"\",\"longleftarrow\":\"\",\"LongLeftArrow\":\"\",\"Longleftarrow\":\"\",\"longleftrightarrow\":\"\",\"LongLeftRightArrow\":\"\",\"Longleftrightarrow\":\"\",\"longmapsto\":\"\",\"longrightarrow\":\"\",\"LongRightArrow\":\"\",\"Longrightarrow\":\"\",\"looparrowleft\":\"\",\"looparrowright\":\"\",\"lopar\":\"\",\"Lopf\":\"\",\"lopf\":\"\",\"loplus\":\"\",\"lotimes\":\"\",\"lowast\":\"\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"\",\"LowerRightArrow\":\"\",\"loz\":\"\",\"lozenge\":\"\",\"lozf\":\"\",\"lpar\":\"(\",\"lparlt\":\"\",\"lrarr\":\"\",\"lrcorner\":\"\",\"lrhar\":\"\",\"lrhard\":\"\",\"lrm\":\"\",\"lrtri\":\"\",\"lsaquo\":\"\",\"lscr\":\"\",\"Lscr\":\"\",\"lsh\":\"\",\"Lsh\":\"\",\"lsim\":\"\",\"lsime\":\"\",\"lsimg\":\"\",\"lsqb\":\"[\",\"lsquo\":\"\",\"lsquor\":\"\",\"Lstrok\":\"\",\"lstrok\":\"\",\"ltcc\":\"\",\"ltcir\":\"\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"\",\"ltdot\":\"\",\"lthree\":\"\",\"ltimes\":\"\",\"ltlarr\":\"\",\"ltquest\":\"\",\"ltri\":\"\",\"ltrie\":\"\",\"ltrif\":\"\",\"ltrPar\":\"\",\"lurdshar\":\"\",\"luruhar\":\"\",\"lvertneqq\":\"\",\"lvnE\":\"\",\"macr\":\"\",\"male\":\"\",\"malt\":\"\",\"maltese\":\"\",\"Map\":\"\",\"map\":\"\",\"mapsto\":\"\",\"mapstodown\":\"\",\"mapstoleft\":\"\",\"mapstoup\":\"\",\"marker\":\"\",\"mcomma\":\"\",\"Mcy\":\"\",\"mcy\":\"\",\"mdash\":\"\",\"mDDot\":\"\",\"measuredangle\":\"\",\"MediumSpace\":\"\",\"Mellintrf\":\"\",\"Mfr\":\"\",\"mfr\":\"\",\"mho\":\"\",\"micro\":\"\",\"midast\":\"*\",\"midcir\":\"\",\"mid\":\"\",\"middot\":\"\",\"minusb\":\"\",\"minus\":\"\",\"minusd\":\"\",\"minusdu\":\"\",\"MinusPlus\":\"\",\"mlcp\":\"\",\"mldr\":\"\",\"mnplus\":\"\",\"models\":\"\",\"Mopf\":\"\",\"mopf\":\"\",\"mp\":\"\",\"mscr\":\"\",\"Mscr\":\"\",\"mstpos\":\"\",\"Mu\":\"\",\"mu\":\"\",\"multimap\":\"\",\"mumap\":\"\",\"nabla\":\"\",\"Nacute\":\"\",\"nacute\":\"\",\"nang\":\"\",\"nap\":\"\",\"napE\":\"\",\"napid\":\"\",\"napos\":\"\",\"napprox\":\"\",\"natural\":\"\",\"naturals\":\"\",\"natur\":\"\",\"nbsp\":\"\",\"nbump\":\"\",\"nbumpe\":\"\",\"ncap\":\"\",\"Ncaron\":\"\",\"ncaron\":\"\",\"Ncedil\":\"\",\"ncedil\":\"\",\"ncong\":\"\",\"ncongdot\":\"\",\"ncup\":\"\",\"Ncy\":\"\",\"ncy\":\"\",\"ndash\":\"\",\"nearhk\":\"\",\"nearr\":\"\",\"neArr\":\"\",\"nearrow\":\"\",\"ne\":\"\",\"nedot\":\"\",\"NegativeMediumSpace\":\"\",\"NegativeThickSpace\":\"\",\"NegativeThinSpace\":\"\",\"NegativeVeryThinSpace\":\"\",\"nequiv\":\"\",\"nesear\":\"\",\"nesim\":\"\",\"NestedGreaterGreater\":\"\",\"NestedLessLess\":\"\",\"NewLine\":\"\\n\",\"nexist\":\"\",\"nexists\":\"\",\"Nfr\":\"\",\"nfr\":\"\",\"ngE\":\"\",\"nge\":\"\",\"ngeq\":\"\",\"ngeqq\":\"\",\"ngeqslant\":\"\",\"nges\":\"\",\"nGg\":\"\",\"ngsim\":\"\",\"nGt\":\"\",\"ngt\":\"\",\"ngtr\":\"\",\"nGtv\":\"\",\"nharr\":\"\",\"nhArr\":\"\",\"nhpar\":\"\",\"ni\":\"\",\"nis\":\"\",\"nisd\":\"\",\"niv\":\"\",\"NJcy\":\"\",\"njcy\":\"\",\"nlarr\":\"\",\"nlArr\":\"\",\"nldr\":\"\",\"nlE\":\"\",\"nle\":\"\",\"nleftarrow\":\"\",\"nLeftarrow\":\"\",\"nleftrightarrow\":\"\",\"nLeftrightarrow\":\"\",\"nleq\":\"\",\"nleqq\":\"\",\"nleqslant\":\"\",\"nles\":\"\",\"nless\":\"\",\"nLl\":\"\",\"nlsim\":\"\",\"nLt\":\"\",\"nlt\":\"\",\"nltri\":\"\",\"nltrie\":\"\",\"nLtv\":\"\",\"nmid\":\"\",\"NoBreak\":\"\",\"NonBreakingSpace\":\"\",\"nopf\":\"\",\"Nopf\":\"\",\"Not\":\"\",\"not\":\"\",\"NotCongruent\":\"\",\"NotCupCap\":\"\",\"NotDoubleVerticalBar\":\"\",\"NotElement\":\"\",\"NotEqual\":\"\",\"NotEqualTilde\":\"\",\"NotExists\":\"\",\"NotGreater\":\"\",\"NotGreaterEqual\":\"\",\"NotGreaterFullEqual\":\"\",\"NotGreaterGreater\":\"\",\"NotGreaterLess\":\"\",\"NotGreaterSlantEqual\":\"\",\"NotGreaterTilde\":\"\",\"NotHumpDownHump\":\"\",\"NotHumpEqual\":\"\",\"notin\":\"\",\"notindot\":\"\",\"notinE\":\"\",\"notinva\":\"\",\"notinvb\":\"\",\"notinvc\":\"\",\"NotLeftTriangleBar\":\"\",\"NotLeftTriangle\":\"\",\"NotLeftTriangleEqual\":\"\",\"NotLess\":\"\",\"NotLessEqual\":\"\",\"NotLessGreater\":\"\",\"NotLessLess\":\"\",\"NotLessSlantEqual\":\"\",\"NotLessTilde\":\"\",\"NotNestedGreaterGreater\":\"\",\"NotNestedLessLess\":\"\",\"notni\":\"\",\"notniva\":\"\",\"notnivb\":\"\",\"notnivc\":\"\",\"NotPrecedes\":\"\",\"NotPrecedesEqual\":\"\",\"NotPrecedesSlantEqual\":\"\",\"NotReverseElement\":\"\",\"NotRightTriangleBar\":\"\",\"NotRightTriangle\":\"\",\"NotRightTriangleEqual\":\"\",\"NotSquareSubset\":\"\",\"NotSquareSubsetEqual\":\"\",\"NotSquareSuperset\":\"\",\"NotSquareSupersetEqual\":\"\",\"NotSubset\":\"\",\"NotSubsetEqual\":\"\",\"NotSucceeds\":\"\",\"NotSucceedsEqual\":\"\",\"NotSucceedsSlantEqual\":\"\",\"NotSucceedsTilde\":\"\",\"NotSuperset\":\"\",\"NotSupersetEqual\":\"\",\"NotTilde\":\"\",\"NotTildeEqual\":\"\",\"NotTildeFullEqual\":\"\",\"NotTildeTilde\":\"\",\"NotVerticalBar\":\"\",\"nparallel\":\"\",\"npar\":\"\",\"nparsl\":\"\",\"npart\":\"\",\"npolint\":\"\",\"npr\":\"\",\"nprcue\":\"\",\"nprec\":\"\",\"npreceq\":\"\",\"npre\":\"\",\"nrarrc\":\"\",\"nrarr\":\"\",\"nrArr\":\"\",\"nrarrw\":\"\",\"nrightarrow\":\"\",\"nRightarrow\":\"\",\"nrtri\":\"\",\"nrtrie\":\"\",\"nsc\":\"\",\"nsccue\":\"\",\"nsce\":\"\",\"Nscr\":\"\",\"nscr\":\"\",\"nshortmid\":\"\",\"nshortparallel\":\"\",\"nsim\":\"\",\"nsime\":\"\",\"nsimeq\":\"\",\"nsmid\":\"\",\"nspar\":\"\",\"nsqsube\":\"\",\"nsqsupe\":\"\",\"nsub\":\"\",\"nsubE\":\"\",\"nsube\":\"\",\"nsubset\":\"\",\"nsubseteq\":\"\",\"nsubseteqq\":\"\",\"nsucc\":\"\",\"nsucceq\":\"\",\"nsup\":\"\",\"nsupE\":\"\",\"nsupe\":\"\",\"nsupset\":\"\",\"nsupseteq\":\"\",\"nsupseteqq\":\"\",\"ntgl\":\"\",\"Ntilde\":\"\",\"ntilde\":\"\",\"ntlg\":\"\",\"ntriangleleft\":\"\",\"ntrianglelefteq\":\"\",\"ntriangleright\":\"\",\"ntrianglerighteq\":\"\",\"Nu\":\"\",\"nu\":\"\",\"num\":\"#\",\"numero\":\"\",\"numsp\":\"\",\"nvap\":\"\",\"nvdash\":\"\",\"nvDash\":\"\",\"nVdash\":\"\",\"nVDash\":\"\",\"nvge\":\"\",\"nvgt\":\">\",\"nvHarr\":\"\",\"nvinfin\":\"\",\"nvlArr\":\"\",\"nvle\":\"\",\"nvlt\":\"<\",\"nvltrie\":\"\",\"nvrArr\":\"\",\"nvrtrie\":\"\",\"nvsim\":\"\",\"nwarhk\":\"\",\"nwarr\":\"\",\"nwArr\":\"\",\"nwarrow\":\"\",\"nwnear\":\"\",\"Oacute\":\"\",\"oacute\":\"\",\"oast\":\"\",\"Ocirc\":\"\",\"ocirc\":\"\",\"ocir\":\"\",\"Ocy\":\"\",\"ocy\":\"\",\"odash\":\"\",\"Odblac\":\"\",\"odblac\":\"\",\"odiv\":\"\",\"odot\":\"\",\"odsold\":\"\",\"OElig\":\"\",\"oelig\":\"\",\"ofcir\":\"\",\"Ofr\":\"\",\"ofr\":\"\",\"ogon\":\"\",\"Ograve\":\"\",\"ograve\":\"\",\"ogt\":\"\",\"ohbar\":\"\",\"ohm\":\"\",\"oint\":\"\",\"olarr\":\"\",\"olcir\":\"\",\"olcross\":\"\",\"oline\":\"\",\"olt\":\"\",\"Omacr\":\"\",\"omacr\":\"\",\"Omega\":\"\",\"omega\":\"\",\"Omicron\":\"\",\"omicron\":\"\",\"omid\":\"\",\"ominus\":\"\",\"Oopf\":\"\",\"oopf\":\"\",\"opar\":\"\",\"OpenCurlyDoubleQuote\":\"\",\"OpenCurlyQuote\":\"\",\"operp\":\"\",\"oplus\":\"\",\"orarr\":\"\",\"Or\":\"\",\"or\":\"\",\"ord\":\"\",\"order\":\"\",\"orderof\":\"\",\"ordf\":\"\",\"ordm\":\"\",\"origof\":\"\",\"oror\":\"\",\"orslope\":\"\",\"orv\":\"\",\"oS\":\"\",\"Oscr\":\"\",\"oscr\":\"\",\"Oslash\":\"\",\"oslash\":\"\",\"osol\":\"\",\"Otilde\":\"\",\"otilde\":\"\",\"otimesas\":\"\",\"Otimes\":\"\",\"otimes\":\"\",\"Ouml\":\"\",\"ouml\":\"\",\"ovbar\":\"\",\"OverBar\":\"\",\"OverBrace\":\"\",\"OverBracket\":\"\",\"OverParenthesis\":\"\",\"para\":\"\",\"parallel\":\"\",\"par\":\"\",\"parsim\":\"\",\"parsl\":\"\",\"part\":\"\",\"PartialD\":\"\",\"Pcy\":\"\",\"pcy\":\"\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"\",\"perp\":\"\",\"pertenk\":\"\",\"Pfr\":\"\",\"pfr\":\"\",\"Phi\":\"\",\"phi\":\"\",\"phiv\":\"\",\"phmmat\":\"\",\"phone\":\"\",\"Pi\":\"\",\"pi\":\"\",\"pitchfork\":\"\",\"piv\":\"\",\"planck\":\"\",\"planckh\":\"\",\"plankv\":\"\",\"plusacir\":\"\",\"plusb\":\"\",\"pluscir\":\"\",\"plus\":\"+\",\"plusdo\":\"\",\"plusdu\":\"\",\"pluse\":\"\",\"PlusMinus\":\"\",\"plusmn\":\"\",\"plussim\":\"\",\"plustwo\":\"\",\"pm\":\"\",\"Poincareplane\":\"\",\"pointint\":\"\",\"popf\":\"\",\"Popf\":\"\",\"pound\":\"\",\"prap\":\"\",\"Pr\":\"\",\"pr\":\"\",\"prcue\":\"\",\"precapprox\":\"\",\"prec\":\"\",\"preccurlyeq\":\"\",\"Precedes\":\"\",\"PrecedesEqual\":\"\",\"PrecedesSlantEqual\":\"\",\"PrecedesTilde\":\"\",\"preceq\":\"\",\"precnapprox\":\"\",\"precneqq\":\"\",\"precnsim\":\"\",\"pre\":\"\",\"prE\":\"\",\"precsim\":\"\",\"prime\":\"\",\"Prime\":\"\",\"primes\":\"\",\"prnap\":\"\",\"prnE\":\"\",\"prnsim\":\"\",\"prod\":\"\",\"Product\":\"\",\"profalar\":\"\",\"profline\":\"\",\"profsurf\":\"\",\"prop\":\"\",\"Proportional\":\"\",\"Proportion\":\"\",\"propto\":\"\",\"prsim\":\"\",\"prurel\":\"\",\"Pscr\":\"\",\"pscr\":\"\",\"Psi\":\"\",\"psi\":\"\",\"puncsp\":\"\",\"Qfr\":\"\",\"qfr\":\"\",\"qint\":\"\",\"qopf\":\"\",\"Qopf\":\"\",\"qprime\":\"\",\"Qscr\":\"\",\"qscr\":\"\",\"quaternions\":\"\",\"quatint\":\"\",\"quest\":\"?\",\"questeq\":\"\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"rAarr\":\"\",\"race\":\"\",\"Racute\":\"\",\"racute\":\"\",\"radic\":\"\",\"raemptyv\":\"\",\"rang\":\"\",\"Rang\":\"\",\"rangd\":\"\",\"range\":\"\",\"rangle\":\"\",\"raquo\":\"\",\"rarrap\":\"\",\"rarrb\":\"\",\"rarrbfs\":\"\",\"rarrc\":\"\",\"rarr\":\"\",\"Rarr\":\"\",\"rArr\":\"\",\"rarrfs\":\"\",\"rarrhk\":\"\",\"rarrlp\":\"\",\"rarrpl\":\"\",\"rarrsim\":\"\",\"Rarrtl\":\"\",\"rarrtl\":\"\",\"rarrw\":\"\",\"ratail\":\"\",\"rAtail\":\"\",\"ratio\":\"\",\"rationals\":\"\",\"rbarr\":\"\",\"rBarr\":\"\",\"RBarr\":\"\",\"rbbrk\":\"\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"\",\"rbrksld\":\"\",\"rbrkslu\":\"\",\"Rcaron\":\"\",\"rcaron\":\"\",\"Rcedil\":\"\",\"rcedil\":\"\",\"rceil\":\"\",\"rcub\":\"}\",\"Rcy\":\"\",\"rcy\":\"\",\"rdca\":\"\",\"rdldhar\":\"\",\"rdquo\":\"\",\"rdquor\":\"\",\"rdsh\":\"\",\"real\":\"\",\"realine\":\"\",\"realpart\":\"\",\"reals\":\"\",\"Re\":\"\",\"rect\":\"\",\"reg\":\"\",\"REG\":\"\",\"ReverseElement\":\"\",\"ReverseEquilibrium\":\"\",\"ReverseUpEquilibrium\":\"\",\"rfisht\":\"\",\"rfloor\":\"\",\"rfr\":\"\",\"Rfr\":\"\",\"rHar\":\"\",\"rhard\":\"\",\"rharu\":\"\",\"rharul\":\"\",\"Rho\":\"\",\"rho\":\"\",\"rhov\":\"\",\"RightAngleBracket\":\"\",\"RightArrowBar\":\"\",\"rightarrow\":\"\",\"RightArrow\":\"\",\"Rightarrow\":\"\",\"RightArrowLeftArrow\":\"\",\"rightarrowtail\":\"\",\"RightCeiling\":\"\",\"RightDoubleBracket\":\"\",\"RightDownTeeVector\":\"\",\"RightDownVectorBar\":\"\",\"RightDownVector\":\"\",\"RightFloor\":\"\",\"rightharpoondown\":\"\",\"rightharpoonup\":\"\",\"rightleftarrows\":\"\",\"rightleftharpoons\":\"\",\"rightrightarrows\":\"\",\"rightsquigarrow\":\"\",\"RightTeeArrow\":\"\",\"RightTee\":\"\",\"RightTeeVector\":\"\",\"rightthreetimes\":\"\",\"RightTriangleBar\":\"\",\"RightTriangle\":\"\",\"RightTriangleEqual\":\"\",\"RightUpDownVector\":\"\",\"RightUpTeeVector\":\"\",\"RightUpVectorBar\":\"\",\"RightUpVector\":\"\",\"RightVectorBar\":\"\",\"RightVector\":\"\",\"ring\":\"\",\"risingdotseq\":\"\",\"rlarr\":\"\",\"rlhar\":\"\",\"rlm\":\"\",\"rmoustache\":\"\",\"rmoust\":\"\",\"rnmid\":\"\",\"roang\":\"\",\"roarr\":\"\",\"robrk\":\"\",\"ropar\":\"\",\"ropf\":\"\",\"Ropf\":\"\",\"roplus\":\"\",\"rotimes\":\"\",\"RoundImplies\":\"\",\"rpar\":\")\",\"rpargt\":\"\",\"rppolint\":\"\",\"rrarr\":\"\",\"Rrightarrow\":\"\",\"rsaquo\":\"\",\"rscr\":\"\",\"Rscr\":\"\",\"rsh\":\"\",\"Rsh\":\"\",\"rsqb\":\"]\",\"rsquo\":\"\",\"rsquor\":\"\",\"rthree\":\"\",\"rtimes\":\"\",\"rtri\":\"\",\"rtrie\":\"\",\"rtrif\":\"\",\"rtriltri\":\"\",\"RuleDelayed\":\"\",\"ruluhar\":\"\",\"rx\":\"\",\"Sacute\":\"\",\"sacute\":\"\",\"sbquo\":\"\",\"scap\":\"\",\"Scaron\":\"\",\"scaron\":\"\",\"Sc\":\"\",\"sc\":\"\",\"sccue\":\"\",\"sce\":\"\",\"scE\":\"\",\"Scedil\":\"\",\"scedil\":\"\",\"Scirc\":\"\",\"scirc\":\"\",\"scnap\":\"\",\"scnE\":\"\",\"scnsim\":\"\",\"scpolint\":\"\",\"scsim\":\"\",\"Scy\":\"\",\"scy\":\"\",\"sdotb\":\"\",\"sdot\":\"\",\"sdote\":\"\",\"searhk\":\"\",\"searr\":\"\",\"seArr\":\"\",\"searrow\":\"\",\"sect\":\"\",\"semi\":\";\",\"seswar\":\"\",\"setminus\":\"\",\"setmn\":\"\",\"sext\":\"\",\"Sfr\":\"\",\"sfr\":\"\",\"sfrown\":\"\",\"sharp\":\"\",\"SHCHcy\":\"\",\"shchcy\":\"\",\"SHcy\":\"\",\"shcy\":\"\",\"ShortDownArrow\":\"\",\"ShortLeftArrow\":\"\",\"shortmid\":\"\",\"shortparallel\":\"\",\"ShortRightArrow\":\"\",\"ShortUpArrow\":\"\",\"shy\":\"\",\"Sigma\":\"\",\"sigma\":\"\",\"sigmaf\":\"\",\"sigmav\":\"\",\"sim\":\"\",\"simdot\":\"\",\"sime\":\"\",\"simeq\":\"\",\"simg\":\"\",\"simgE\":\"\",\"siml\":\"\",\"simlE\":\"\",\"simne\":\"\",\"simplus\":\"\",\"simrarr\":\"\",\"slarr\":\"\",\"SmallCircle\":\"\",\"smallsetminus\":\"\",\"smashp\":\"\",\"smeparsl\":\"\",\"smid\":\"\",\"smile\":\"\",\"smt\":\"\",\"smte\":\"\",\"smtes\":\"\",\"SOFTcy\":\"\",\"softcy\":\"\",\"solbar\":\"\",\"solb\":\"\",\"sol\":\"/\",\"Sopf\":\"\",\"sopf\":\"\",\"spades\":\"\",\"spadesuit\":\"\",\"spar\":\"\",\"sqcap\":\"\",\"sqcaps\":\"\",\"sqcup\":\"\",\"sqcups\":\"\",\"Sqrt\":\"\",\"sqsub\":\"\",\"sqsube\":\"\",\"sqsubset\":\"\",\"sqsubseteq\":\"\",\"sqsup\":\"\",\"sqsupe\":\"\",\"sqsupset\":\"\",\"sqsupseteq\":\"\",\"square\":\"\",\"Square\":\"\",\"SquareIntersection\":\"\",\"SquareSubset\":\"\",\"SquareSubsetEqual\":\"\",\"SquareSuperset\":\"\",\"SquareSupersetEqual\":\"\",\"SquareUnion\":\"\",\"squarf\":\"\",\"squ\":\"\",\"squf\":\"\",\"srarr\":\"\",\"Sscr\":\"\",\"sscr\":\"\",\"ssetmn\":\"\",\"ssmile\":\"\",\"sstarf\":\"\",\"Star\":\"\",\"star\":\"\",\"starf\":\"\",\"straightepsilon\":\"\",\"straightphi\":\"\",\"strns\":\"\",\"sub\":\"\",\"Sub\":\"\",\"subdot\":\"\",\"subE\":\"\",\"sube\":\"\",\"subedot\":\"\",\"submult\":\"\",\"subnE\":\"\",\"subne\":\"\",\"subplus\":\"\",\"subrarr\":\"\",\"subset\":\"\",\"Subset\":\"\",\"subseteq\":\"\",\"subseteqq\":\"\",\"SubsetEqual\":\"\",\"subsetneq\":\"\",\"subsetneqq\":\"\",\"subsim\":\"\",\"subsub\":\"\",\"subsup\":\"\",\"succapprox\":\"\",\"succ\":\"\",\"succcurlyeq\":\"\",\"Succeeds\":\"\",\"SucceedsEqual\":\"\",\"SucceedsSlantEqual\":\"\",\"SucceedsTilde\":\"\",\"succeq\":\"\",\"succnapprox\":\"\",\"succneqq\":\"\",\"succnsim\":\"\",\"succsim\":\"\",\"SuchThat\":\"\",\"sum\":\"\",\"Sum\":\"\",\"sung\":\"\",\"sup1\":\"\",\"sup2\":\"\",\"sup3\":\"\",\"sup\":\"\",\"Sup\":\"\",\"supdot\":\"\",\"supdsub\":\"\",\"supE\":\"\",\"supe\":\"\",\"supedot\":\"\",\"Superset\":\"\",\"SupersetEqual\":\"\",\"suphsol\":\"\",\"suphsub\":\"\",\"suplarr\":\"\",\"supmult\":\"\",\"supnE\":\"\",\"supne\":\"\",\"supplus\":\"\",\"supset\":\"\",\"Supset\":\"\",\"supseteq\":\"\",\"supseteqq\":\"\",\"supsetneq\":\"\",\"supsetneqq\":\"\",\"supsim\":\"\",\"supsub\":\"\",\"supsup\":\"\",\"swarhk\":\"\",\"swarr\":\"\",\"swArr\":\"\",\"swarrow\":\"\",\"swnwar\":\"\",\"szlig\":\"\",\"Tab\":\"\\t\",\"target\":\"\",\"Tau\":\"\",\"tau\":\"\",\"tbrk\":\"\",\"Tcaron\":\"\",\"tcaron\":\"\",\"Tcedil\":\"\",\"tcedil\":\"\",\"Tcy\":\"\",\"tcy\":\"\",\"tdot\":\"\",\"telrec\":\"\",\"Tfr\":\"\",\"tfr\":\"\",\"there4\":\"\",\"therefore\":\"\",\"Therefore\":\"\",\"Theta\":\"\",\"theta\":\"\",\"thetasym\":\"\",\"thetav\":\"\",\"thickapprox\":\"\",\"thicksim\":\"\",\"ThickSpace\":\"\",\"ThinSpace\":\"\",\"thinsp\":\"\",\"thkap\":\"\",\"thksim\":\"\",\"THORN\":\"\",\"thorn\":\"\",\"tilde\":\"\",\"Tilde\":\"\",\"TildeEqual\":\"\",\"TildeFullEqual\":\"\",\"TildeTilde\":\"\",\"timesbar\":\"\",\"timesb\":\"\",\"times\":\"\",\"timesd\":\"\",\"tint\":\"\",\"toea\":\"\",\"topbot\":\"\",\"topcir\":\"\",\"top\":\"\",\"Topf\":\"\",\"topf\":\"\",\"topfork\":\"\",\"tosa\":\"\",\"tprime\":\"\",\"trade\":\"\",\"TRADE\":\"\",\"triangle\":\"\",\"triangledown\":\"\",\"triangleleft\":\"\",\"trianglelefteq\":\"\",\"triangleq\":\"\",\"triangleright\":\"\",\"trianglerighteq\":\"\",\"tridot\":\"\",\"trie\":\"\",\"triminus\":\"\",\"TripleDot\":\"\",\"triplus\":\"\",\"trisb\":\"\",\"tritime\":\"\",\"trpezium\":\"\",\"Tscr\":\"\",\"tscr\":\"\",\"TScy\":\"\",\"tscy\":\"\",\"TSHcy\":\"\",\"tshcy\":\"\",\"Tstrok\":\"\",\"tstrok\":\"\",\"twixt\":\"\",\"twoheadleftarrow\":\"\",\"twoheadrightarrow\":\"\",\"Uacute\":\"\",\"uacute\":\"\",\"uarr\":\"\",\"Uarr\":\"\",\"uArr\":\"\",\"Uarrocir\":\"\",\"Ubrcy\":\"\",\"ubrcy\":\"\",\"Ubreve\":\"\",\"ubreve\":\"\",\"Ucirc\":\"\",\"ucirc\":\"\",\"Ucy\":\"\",\"ucy\":\"\",\"udarr\":\"\",\"Udblac\":\"\",\"udblac\":\"\",\"udhar\":\"\",\"ufisht\":\"\",\"Ufr\":\"\",\"ufr\":\"\",\"Ugrave\":\"\",\"ugrave\":\"\",\"uHar\":\"\",\"uharl\":\"\",\"uharr\":\"\",\"uhblk\":\"\",\"ulcorn\":\"\",\"ulcorner\":\"\",\"ulcrop\":\"\",\"ultri\":\"\",\"Umacr\":\"\",\"umacr\":\"\",\"uml\":\"\",\"UnderBar\":\"_\",\"UnderBrace\":\"\",\"UnderBracket\":\"\",\"UnderParenthesis\":\"\",\"Union\":\"\",\"UnionPlus\":\"\",\"Uogon\":\"\",\"uogon\":\"\",\"Uopf\":\"\",\"uopf\":\"\",\"UpArrowBar\":\"\",\"uparrow\":\"\",\"UpArrow\":\"\",\"Uparrow\":\"\",\"UpArrowDownArrow\":\"\",\"updownarrow\":\"\",\"UpDownArrow\":\"\",\"Updownarrow\":\"\",\"UpEquilibrium\":\"\",\"upharpoonleft\":\"\",\"upharpoonright\":\"\",\"uplus\":\"\",\"UpperLeftArrow\":\"\",\"UpperRightArrow\":\"\",\"upsi\":\"\",\"Upsi\":\"\",\"upsih\":\"\",\"Upsilon\":\"\",\"upsilon\":\"\",\"UpTeeArrow\":\"\",\"UpTee\":\"\",\"upuparrows\":\"\",\"urcorn\":\"\",\"urcorner\":\"\",\"urcrop\":\"\",\"Uring\":\"\",\"uring\":\"\",\"urtri\":\"\",\"Uscr\":\"\",\"uscr\":\"\",\"utdot\":\"\",\"Utilde\":\"\",\"utilde\":\"\",\"utri\":\"\",\"utrif\":\"\",\"uuarr\":\"\",\"Uuml\":\"\",\"uuml\":\"\",\"uwangle\":\"\",\"vangrt\":\"\",\"varepsilon\":\"\",\"varkappa\":\"\",\"varnothing\":\"\",\"varphi\":\"\",\"varpi\":\"\",\"varpropto\":\"\",\"varr\":\"\",\"vArr\":\"\",\"varrho\":\"\",\"varsigma\":\"\",\"varsubsetneq\":\"\",\"varsubsetneqq\":\"\",\"varsupsetneq\":\"\",\"varsupsetneqq\":\"\",\"vartheta\":\"\",\"vartriangleleft\":\"\",\"vartriangleright\":\"\",\"vBar\":\"\",\"Vbar\":\"\",\"vBarv\":\"\",\"Vcy\":\"\",\"vcy\":\"\",\"vdash\":\"\",\"vDash\":\"\",\"Vdash\":\"\",\"VDash\":\"\",\"Vdashl\":\"\",\"veebar\":\"\",\"vee\":\"\",\"Vee\":\"\",\"veeeq\":\"\",\"vellip\":\"\",\"verbar\":\"|\",\"Verbar\":\"\",\"vert\":\"|\",\"Vert\":\"\",\"VerticalBar\":\"\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"\",\"VerticalTilde\":\"\",\"VeryThinSpace\":\"\",\"Vfr\":\"\",\"vfr\":\"\",\"vltri\":\"\",\"vnsub\":\"\",\"vnsup\":\"\",\"Vopf\":\"\",\"vopf\":\"\",\"vprop\":\"\",\"vrtri\":\"\",\"Vscr\":\"\",\"vscr\":\"\",\"vsubnE\":\"\",\"vsubne\":\"\",\"vsupnE\":\"\",\"vsupne\":\"\",\"Vvdash\":\"\",\"vzigzag\":\"\",\"Wcirc\":\"\",\"wcirc\":\"\",\"wedbar\":\"\",\"wedge\":\"\",\"Wedge\":\"\",\"wedgeq\":\"\",\"weierp\":\"\",\"Wfr\":\"\",\"wfr\":\"\",\"Wopf\":\"\",\"wopf\":\"\",\"wp\":\"\",\"wr\":\"\",\"wreath\":\"\",\"Wscr\":\"\",\"wscr\":\"\",\"xcap\":\"\",\"xcirc\":\"\",\"xcup\":\"\",\"xdtri\":\"\",\"Xfr\":\"\",\"xfr\":\"\",\"xharr\":\"\",\"xhArr\":\"\",\"Xi\":\"\",\"xi\":\"\",\"xlarr\":\"\",\"xlArr\":\"\",\"xmap\":\"\",\"xnis\":\"\",\"xodot\":\"\",\"Xopf\":\"\",\"xopf\":\"\",\"xoplus\":\"\",\"xotime\":\"\",\"xrarr\":\"\",\"xrArr\":\"\",\"Xscr\":\"\",\"xscr\":\"\",\"xsqcup\":\"\",\"xuplus\":\"\",\"xutri\":\"\",\"xvee\":\"\",\"xwedge\":\"\",\"Yacute\":\"\",\"yacute\":\"\",\"YAcy\":\"\",\"yacy\":\"\",\"Ycirc\":\"\",\"ycirc\":\"\",\"Ycy\":\"\",\"ycy\":\"\",\"yen\":\"\",\"Yfr\":\"\",\"yfr\":\"\",\"YIcy\":\"\",\"yicy\":\"\",\"Yopf\":\"\",\"yopf\":\"\",\"Yscr\":\"\",\"yscr\":\"\",\"YUcy\":\"\",\"yucy\":\"\",\"yuml\":\"\",\"Yuml\":\"\",\"Zacute\":\"\",\"zacute\":\"\",\"Zcaron\":\"\",\"zcaron\":\"\",\"Zcy\":\"\",\"zcy\":\"\",\"Zdot\":\"\",\"zdot\":\"\",\"zeetrf\":\"\",\"ZeroWidthSpace\":\"\",\"Zeta\":\"\",\"zeta\":\"\",\"zfr\":\"\",\"Zfr\":\"\",\"ZHcy\":\"\",\"zhcy\":\"\",\"zigrarr\":\"\",\"zopf\":\"\",\"Zopf\":\"\",\"Zscr\":\"\",\"zscr\":\"\",\"zwj\":\"\",\"zwnj\":\"\"}");

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json":
/*!********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json ***!
  \********************************************************************************/
/*! exports provided: Aacute, aacute, Acirc, acirc, acute, AElig, aelig, Agrave, agrave, amp, AMP, Aring, aring, Atilde, atilde, Auml, auml, brvbar, Ccedil, ccedil, cedil, cent, copy, COPY, curren, deg, divide, Eacute, eacute, Ecirc, ecirc, Egrave, egrave, ETH, eth, Euml, euml, frac12, frac14, frac34, gt, GT, Iacute, iacute, Icirc, icirc, iexcl, Igrave, igrave, iquest, Iuml, iuml, laquo, lt, LT, macr, micro, middot, nbsp, not, Ntilde, ntilde, Oacute, oacute, Ocirc, ocirc, Ograve, ograve, ordf, ordm, Oslash, oslash, Otilde, otilde, Ouml, ouml, para, plusmn, pound, quot, QUOT, raquo, reg, REG, sect, shy, sup1, sup2, sup3, szlig, THORN, thorn, times, Uacute, uacute, Ucirc, ucirc, Ugrave, ugrave, uml, Uuml, uuml, Yacute, yacute, yen, yuml, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"\",\"aacute\":\"\",\"Acirc\":\"\",\"acirc\":\"\",\"acute\":\"\",\"AElig\":\"\",\"aelig\":\"\",\"Agrave\":\"\",\"agrave\":\"\",\"amp\":\"&\",\"AMP\":\"&\",\"Aring\":\"\",\"aring\":\"\",\"Atilde\":\"\",\"atilde\":\"\",\"Auml\":\"\",\"auml\":\"\",\"brvbar\":\"\",\"Ccedil\":\"\",\"ccedil\":\"\",\"cedil\":\"\",\"cent\":\"\",\"copy\":\"\",\"COPY\":\"\",\"curren\":\"\",\"deg\":\"\",\"divide\":\"\",\"Eacute\":\"\",\"eacute\":\"\",\"Ecirc\":\"\",\"ecirc\":\"\",\"Egrave\":\"\",\"egrave\":\"\",\"ETH\":\"\",\"eth\":\"\",\"Euml\":\"\",\"euml\":\"\",\"frac12\":\"\",\"frac14\":\"\",\"frac34\":\"\",\"gt\":\">\",\"GT\":\">\",\"Iacute\":\"\",\"iacute\":\"\",\"Icirc\":\"\",\"icirc\":\"\",\"iexcl\":\"\",\"Igrave\":\"\",\"igrave\":\"\",\"iquest\":\"\",\"Iuml\":\"\",\"iuml\":\"\",\"laquo\":\"\",\"lt\":\"<\",\"LT\":\"<\",\"macr\":\"\",\"micro\":\"\",\"middot\":\"\",\"nbsp\":\"\",\"not\":\"\",\"Ntilde\":\"\",\"ntilde\":\"\",\"Oacute\":\"\",\"oacute\":\"\",\"Ocirc\":\"\",\"ocirc\":\"\",\"Ograve\":\"\",\"ograve\":\"\",\"ordf\":\"\",\"ordm\":\"\",\"Oslash\":\"\",\"oslash\":\"\",\"Otilde\":\"\",\"otilde\":\"\",\"Ouml\":\"\",\"ouml\":\"\",\"para\":\"\",\"plusmn\":\"\",\"pound\":\"\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"raquo\":\"\",\"reg\":\"\",\"REG\":\"\",\"sect\":\"\",\"shy\":\"\",\"sup1\":\"\",\"sup2\":\"\",\"sup3\":\"\",\"szlig\":\"\",\"THORN\":\"\",\"thorn\":\"\",\"times\":\"\",\"Uacute\":\"\",\"uacute\":\"\",\"Ucirc\":\"\",\"ucirc\":\"\",\"Ugrave\":\"\",\"ugrave\":\"\",\"uml\":\"\",\"Uuml\":\"\",\"uuml\":\"\",\"Yacute\":\"\",\"yacute\":\"\",\"yen\":\"\",\"yuml\":\"\"}");

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json":
/*!*****************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json ***!
  \*****************************************************************************/
/*! exports provided: amp, apos, gt, lt, quot, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"amp\":\"&\",\"apos\":\"'\",\"gt\":\">\",\"lt\":\"<\",\"quot\":\"\\\"\"}");

/***/ }),

/***/ "./node_modules/domelementtype/index.js":
/*!**********************************************!*\
  !*** ./node_modules/domelementtype/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//Types of elements found in the DOM
module.exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>
	Doctype: "doctype",

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};


/***/ }),

/***/ "./node_modules/domhandler/index.js":
/*!******************************************!*\
  !*** ./node_modules/domhandler/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/index.js");

var re_whitespace = /\s+/g;
var NodePrototype = __webpack_require__(/*! ./lib/node */ "./node_modules/domhandler/lib/node.js");
var ElementPrototype = __webpack_require__(/*! ./lib/element */ "./node_modules/domhandler/lib/element.js");

function DomHandler(callback, options, elementCB){
	if(typeof callback === "object"){
		elementCB = options;
		options = callback;
		callback = null;
	} else if(typeof options === "function"){
		elementCB = options;
		options = defaultOpts;
	}
	this._callback = callback;
	this._options = options || defaultOpts;
	this._elementCB = elementCB;
	this.dom = [];
	this._done = false;
	this._tagStack = [];
	this._parser = this._parser || null;
}

//default options
var defaultOpts = {
	normalizeWhitespace: false, //Replace all whitespace with single spaces
	withStartIndices: false, //Add startIndex properties to nodes
	withEndIndices: false, //Add endIndex properties to nodes
};

DomHandler.prototype.onparserinit = function(parser){
	this._parser = parser;
};

//Resets the handler back to starting state
DomHandler.prototype.onreset = function(){
	DomHandler.call(this, this._callback, this._options, this._elementCB);
};

//Signals the handler that parsing is done
DomHandler.prototype.onend = function(){
	if(this._done) return;
	this._done = true;
	this._parser = null;
	this._handleCallback(null);
};

DomHandler.prototype._handleCallback =
DomHandler.prototype.onerror = function(error){
	if(typeof this._callback === "function"){
		this._callback(error, this.dom);
	} else {
		if(error) throw error;
	}
};

DomHandler.prototype.onclosetag = function(){
	//if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));
	
	var elem = this._tagStack.pop();

	if(this._options.withEndIndices && elem){
		elem.endIndex = this._parser.endIndex;
	}

	if(this._elementCB) this._elementCB(elem);
};

DomHandler.prototype._createDomElement = function(properties){
	if (!this._options.withDomLvl1) return properties;

	var element;
	if (properties.type === "tag") {
		element = Object.create(ElementPrototype);
	} else {
		element = Object.create(NodePrototype);
	}

	for (var key in properties) {
		if (properties.hasOwnProperty(key)) {
			element[key] = properties[key];
		}
	}

	return element;
};

DomHandler.prototype._addDomElement = function(element){
	var parent = this._tagStack[this._tagStack.length - 1];
	var siblings = parent ? parent.children : this.dom;
	var previousSibling = siblings[siblings.length - 1];

	element.next = null;

	if(this._options.withStartIndices){
		element.startIndex = this._parser.startIndex;
	}
	if(this._options.withEndIndices){
		element.endIndex = this._parser.endIndex;
	}

	if(previousSibling){
		element.prev = previousSibling;
		previousSibling.next = element;
	} else {
		element.prev = null;
	}

	siblings.push(element);
	element.parent = parent || null;
};

DomHandler.prototype.onopentag = function(name, attribs){
	var properties = {
		type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
		name: name,
		attribs: attribs,
		children: []
	};

	var element = this._createDomElement(properties);

	this._addDomElement(element);

	this._tagStack.push(element);
};

DomHandler.prototype.ontext = function(data){
	//the ignoreWhitespace is officially dropped, but for now,
	//it's an alias for normalizeWhitespace
	var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;

	var lastTag;

	if(!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length-1]).type === ElementType.Text){
		if(normalize){
			lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
		} else {
			lastTag.data += data;
		}
	} else {
		if(
			this._tagStack.length &&
			(lastTag = this._tagStack[this._tagStack.length - 1]) &&
			(lastTag = lastTag.children[lastTag.children.length - 1]) &&
			lastTag.type === ElementType.Text
		){
			if(normalize){
				lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
			} else {
				lastTag.data += data;
			}
		} else {
			if(normalize){
				data = data.replace(re_whitespace, " ");
			}

			var element = this._createDomElement({
				data: data,
				type: ElementType.Text
			});

			this._addDomElement(element);
		}
	}
};

DomHandler.prototype.oncomment = function(data){
	var lastTag = this._tagStack[this._tagStack.length - 1];

	if(lastTag && lastTag.type === ElementType.Comment){
		lastTag.data += data;
		return;
	}

	var properties = {
		data: data,
		type: ElementType.Comment
	};

	var element = this._createDomElement(properties);

	this._addDomElement(element);
	this._tagStack.push(element);
};

DomHandler.prototype.oncdatastart = function(){
	var properties = {
		children: [{
			data: "",
			type: ElementType.Text
		}],
		type: ElementType.CDATA
	};

	var element = this._createDomElement(properties);

	this._addDomElement(element);
	this._tagStack.push(element);
};

DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function(){
	this._tagStack.pop();
};

DomHandler.prototype.onprocessinginstruction = function(name, data){
	var element = this._createDomElement({
		name: name,
		data: data,
		type: ElementType.Directive
	});

	this._addDomElement(element);
};

module.exports = DomHandler;


/***/ }),

/***/ "./node_modules/domhandler/lib/element.js":
/*!************************************************!*\
  !*** ./node_modules/domhandler/lib/element.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// DOM-Level-1-compliant structure
var NodePrototype = __webpack_require__(/*! ./node */ "./node_modules/domhandler/lib/node.js");
var ElementPrototype = module.exports = Object.create(NodePrototype);

var domLvl1 = {
	tagName: "name"
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(ElementPrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});


/***/ }),

/***/ "./node_modules/domhandler/lib/node.js":
/*!*********************************************!*\
  !*** ./node_modules/domhandler/lib/node.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var NodePrototype = module.exports = {
	get firstChild() {
		var children = this.children;
		return children && children[0] || null;
	},
	get lastChild() {
		var children = this.children;
		return children && children[children.length - 1] || null;
	},
	get nodeType() {
		return nodeTypes[this.type] || nodeTypes.element;
	}
};

var domLvl1 = {
	tagName: "name",
	childNodes: "children",
	parentNode: "parent",
	previousSibling: "prev",
	nextSibling: "next",
	nodeValue: "data"
};

var nodeTypes = {
	element: 1,
	text: 3,
	cdata: 4,
	comment: 8
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(NodePrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});


/***/ }),

/***/ "./node_modules/domutils/index.js":
/*!****************************************!*\
  !*** ./node_modules/domutils/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DomUtils = module.exports;

[
	__webpack_require__(/*! ./lib/stringify */ "./node_modules/domutils/lib/stringify.js"),
	__webpack_require__(/*! ./lib/traversal */ "./node_modules/domutils/lib/traversal.js"),
	__webpack_require__(/*! ./lib/manipulation */ "./node_modules/domutils/lib/manipulation.js"),
	__webpack_require__(/*! ./lib/querying */ "./node_modules/domutils/lib/querying.js"),
	__webpack_require__(/*! ./lib/legacy */ "./node_modules/domutils/lib/legacy.js"),
	__webpack_require__(/*! ./lib/helpers */ "./node_modules/domutils/lib/helpers.js")
].forEach(function(ext){
	Object.keys(ext).forEach(function(key){
		DomUtils[key] = ext[key].bind(DomUtils);
	});
});


/***/ }),

/***/ "./node_modules/domutils/lib/helpers.js":
/*!**********************************************!*\
  !*** ./node_modules/domutils/lib/helpers.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
exports.removeSubsets = function(nodes) {
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while (--idx > -1) {
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while (ancestor) {
			if (nodes.indexOf(ancestor) > -1) {
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = ancestor.parent;
		}

		// If the node has been found to be unique, re-insert it.
		if (replace) {
			nodes[idx] = node;
		}
	}

	return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var POSITION = {
	DISCONNECTED: 1,
	PRECEDING: 2,
	FOLLOWING: 4,
	CONTAINS: 8,
	CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
	var aParents = [];
	var bParents = [];
	var current, sharedParent, siblings, aSibling, bSibling, idx;

	if (nodeA === nodeB) {
		return 0;
	}

	current = nodeA;
	while (current) {
		aParents.unshift(current);
		current = current.parent;
	}
	current = nodeB;
	while (current) {
		bParents.unshift(current);
		current = current.parent;
	}

	idx = 0;
	while (aParents[idx] === bParents[idx]) {
		idx++;
	}

	if (idx === 0) {
		return POSITION.DISCONNECTED;
	}

	sharedParent = aParents[idx - 1];
	siblings = sharedParent.children;
	aSibling = aParents[idx];
	bSibling = bParents[idx];

	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		if (sharedParent === nodeB) {
			return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
		}
		return POSITION.FOLLOWING;
	} else {
		if (sharedParent === nodeA) {
			return POSITION.PRECEDING | POSITION.CONTAINS;
		}
		return POSITION.PRECEDING;
	}
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
exports.uniqueSort = function(nodes) {
	var idx = nodes.length, node, position;

	nodes = nodes.slice();

	while (--idx > -1) {
		node = nodes[idx];
		position = nodes.indexOf(node);
		if (position > -1 && position < idx) {
			nodes.splice(idx, 1);
		}
	}
	nodes.sort(function(a, b) {
		var relative = comparePos(a, b);
		if (relative & POSITION.PRECEDING) {
			return -1;
		} else if (relative & POSITION.FOLLOWING) {
			return 1;
		}
		return 0;
	});

	return nodes;
};


/***/ }),

/***/ "./node_modules/domutils/lib/legacy.js":
/*!*********************************************!*\
  !*** ./node_modules/domutils/lib/legacy.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/index.js");
var isTag = exports.isTag = ElementType.isTag;

exports.testElement = function(options, element){
	for(var key in options){
		if(!options.hasOwnProperty(key));
		else if(key === "tag_name"){
			if(!isTag(element) || !options.tag_name(element.name)){
				return false;
			}
		} else if(key === "tag_type"){
			if(!options.tag_type(element.type)) return false;
		} else if(key === "tag_contains"){
			if(isTag(element) || !options.tag_contains(element.data)){
				return false;
			}
		} else if(!element.attribs || !options[key](element.attribs[key])){
			return false;
		}
	}
	return true;
};

var Checks = {
	tag_name: function(name){
		if(typeof name === "function"){
			return function(elem){ return isTag(elem) && name(elem.name); };
		} else if(name === "*"){
			return isTag;
		} else {
			return function(elem){ return isTag(elem) && elem.name === name; };
		}
	},
	tag_type: function(type){
		if(typeof type === "function"){
			return function(elem){ return type(elem.type); };
		} else {
			return function(elem){ return elem.type === type; };
		}
	},
	tag_contains: function(data){
		if(typeof data === "function"){
			return function(elem){ return !isTag(elem) && data(elem.data); };
		} else {
			return function(elem){ return !isTag(elem) && elem.data === data; };
		}
	}
};

function getAttribCheck(attrib, value){
	if(typeof value === "function"){
		return function(elem){ return elem.attribs && value(elem.attribs[attrib]); };
	} else {
		return function(elem){ return elem.attribs && elem.attribs[attrib] === value; };
	}
}

function combineFuncs(a, b){
	return function(elem){
		return a(elem) || b(elem);
	};
}

exports.getElements = function(options, element, recurse, limit){
	var funcs = Object.keys(options).map(function(key){
		var value = options[key];
		return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
	});

	return funcs.length === 0 ? [] : this.filter(
		funcs.reduce(combineFuncs),
		element, recurse, limit
	);
};

exports.getElementById = function(id, element, recurse){
	if(!Array.isArray(element)) element = [element];
	return this.findOne(getAttribCheck("id", id), element, recurse !== false);
};

exports.getElementsByTagName = function(name, element, recurse, limit){
	return this.filter(Checks.tag_name(name), element, recurse, limit);
};

exports.getElementsByTagType = function(type, element, recurse, limit){
	return this.filter(Checks.tag_type(type), element, recurse, limit);
};


/***/ }),

/***/ "./node_modules/domutils/lib/manipulation.js":
/*!***************************************************!*\
  !*** ./node_modules/domutils/lib/manipulation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.removeElement = function(elem){
	if(elem.prev) elem.prev.next = elem.next;
	if(elem.next) elem.next.prev = elem.prev;

	if(elem.parent){
		var childs = elem.parent.children;
		childs.splice(childs.lastIndexOf(elem), 1);
	}
};

exports.replaceElement = function(elem, replacement){
	var prev = replacement.prev = elem.prev;
	if(prev){
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if(next){
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs[childs.lastIndexOf(elem)] = replacement;
	}
};

exports.appendChild = function(elem, child){
	child.parent = elem;

	if(elem.children.push(child) !== 1){
		var sibling = elem.children[elem.children.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
};

exports.append = function(elem, next){
	var parent = elem.parent,
		currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if(currNext){
		currNext.prev = next;
		if(parent){
			var childs = parent.children;
			childs.splice(childs.lastIndexOf(currNext), 0, next);
		}
	} else if(parent){
		parent.children.push(next);
	}
};

exports.prepend = function(elem, prev){
	var parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs.splice(childs.lastIndexOf(elem), 0, prev);
	}

	if(elem.prev){
		elem.prev.next = prev;
	}
	
	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
};




/***/ }),

/***/ "./node_modules/domutils/lib/querying.js":
/*!***********************************************!*\
  !*** ./node_modules/domutils/lib/querying.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isTag = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/index.js").isTag;

module.exports = {
	filter: filter,
	find: find,
	findOneChild: findOneChild,
	findOne: findOne,
	existsOne: existsOne,
	findAll: findAll
};

function filter(test, element, recurse, limit){
	if(!Array.isArray(element)) element = [element];

	if(typeof limit !== "number" || !isFinite(limit)){
		limit = Infinity;
	}
	return find(test, element, recurse !== false, limit);
}

function find(test, elems, recurse, limit){
	var result = [], childs;

	for(var i = 0, j = elems.length; i < j; i++){
		if(test(elems[i])){
			result.push(elems[i]);
			if(--limit <= 0) break;
		}

		childs = elems[i].children;
		if(recurse && childs && childs.length > 0){
			childs = find(test, childs, recurse, limit);
			result = result.concat(childs);
			limit -= childs.length;
			if(limit <= 0) break;
		}
	}

	return result;
}

function findOneChild(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(test(elems[i])) return elems[i];
	}

	return null;
}

function findOne(test, elems){
	var elem = null;

	for(var i = 0, l = elems.length; i < l && !elem; i++){
		if(!isTag(elems[i])){
			continue;
		} else if(test(elems[i])){
			elem = elems[i];
		} else if(elems[i].children.length > 0){
			elem = findOne(test, elems[i].children);
		}
	}

	return elem;
}

function existsOne(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(
			isTag(elems[i]) && (
				test(elems[i]) || (
					elems[i].children.length > 0 &&
					existsOne(test, elems[i].children)
				)
			)
		){
			return true;
		}
	}

	return false;
}

function findAll(test, rootElems){
	var result = [];
	var stack = rootElems.slice();
	while(stack.length){
		var elem = stack.shift();
		if(!isTag(elem)) continue;
		if (elem.children && elem.children.length > 0) {
			stack.unshift.apply(stack, elem.children);
		}
		if(test(elem)) result.push(elem);
	}
	return result;
}


/***/ }),

/***/ "./node_modules/domutils/lib/stringify.js":
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/stringify.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/index.js"),
    getOuterHTML = __webpack_require__(/*! dom-serializer */ "./node_modules/dom-serializer/index.js"),
    isTag = ElementType.isTag;

module.exports = {
	getInnerHTML: getInnerHTML,
	getOuterHTML: getOuterHTML,
	getText: getText
};

function getInnerHTML(elem, opts){
	return elem.children ? elem.children.map(function(elem){
		return getOuterHTML(elem, opts);
	}).join("") : "";
}

function getText(elem){
	if(Array.isArray(elem)) return elem.map(getText).join("");
	if(isTag(elem)) return elem.name === "br" ? "\n" : getText(elem.children);
	if(elem.type === ElementType.CDATA) return getText(elem.children);
	if(elem.type === ElementType.Text) return elem.data;
	return "";
}


/***/ }),

/***/ "./node_modules/domutils/lib/traversal.js":
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/traversal.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var getChildren = exports.getChildren = function(elem){
	return elem.children;
};

var getParent = exports.getParent = function(elem){
	return elem.parent;
};

exports.getSiblings = function(elem){
	var parent = getParent(elem);
	return parent ? getChildren(parent) : [elem];
};

exports.getAttributeValue = function(elem, name){
	return elem.attribs && elem.attribs[name];
};

exports.hasAttrib = function(elem, name){
	return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};

exports.getName = function(elem){
	return elem.name;
};


/***/ }),

/***/ "./node_modules/entities/lib/decode_codepoint.js":
/*!*******************************************************!*\
  !*** ./node_modules/entities/lib/decode_codepoint.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var decodeMap = __webpack_require__(/*! ../maps/decode.json */ "./node_modules/entities/maps/decode.json");

module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }

    if (codePoint in decodeMap) {
        codePoint = decodeMap[codePoint];
    }

    var output = "";

    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }

    output += String.fromCharCode(codePoint);
    return output;
}


/***/ }),

/***/ "./node_modules/entities/maps/decode.json":
/*!************************************************!*\
  !*** ./node_modules/entities/maps/decode.json ***!
  \************************************************/
/*! exports provided: 0, 128, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 142, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 158, 159, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"0\":65533,\"128\":8364,\"130\":8218,\"131\":402,\"132\":8222,\"133\":8230,\"134\":8224,\"135\":8225,\"136\":710,\"137\":8240,\"138\":352,\"139\":8249,\"140\":338,\"142\":381,\"145\":8216,\"146\":8217,\"147\":8220,\"148\":8221,\"149\":8226,\"150\":8211,\"151\":8212,\"152\":732,\"153\":8482,\"154\":353,\"155\":8250,\"156\":339,\"158\":382,\"159\":376}");

/***/ }),

/***/ "./node_modules/entities/maps/entities.json":
/*!**************************************************!*\
  !*** ./node_modules/entities/maps/entities.json ***!
  \**************************************************/
/*! exports provided: Aacute, aacute, Abreve, abreve, ac, acd, acE, Acirc, acirc, acute, Acy, acy, AElig, aelig, af, Afr, afr, Agrave, agrave, alefsym, aleph, Alpha, alpha, Amacr, amacr, amalg, amp, AMP, andand, And, and, andd, andslope, andv, ang, ange, angle, angmsdaa, angmsdab, angmsdac, angmsdad, angmsdae, angmsdaf, angmsdag, angmsdah, angmsd, angrt, angrtvb, angrtvbd, angsph, angst, angzarr, Aogon, aogon, Aopf, aopf, apacir, ap, apE, ape, apid, apos, ApplyFunction, approx, approxeq, Aring, aring, Ascr, ascr, Assign, ast, asymp, asympeq, Atilde, atilde, Auml, auml, awconint, awint, backcong, backepsilon, backprime, backsim, backsimeq, Backslash, Barv, barvee, barwed, Barwed, barwedge, bbrk, bbrktbrk, bcong, Bcy, bcy, bdquo, becaus, because, Because, bemptyv, bepsi, bernou, Bernoullis, Beta, beta, beth, between, Bfr, bfr, bigcap, bigcirc, bigcup, bigodot, bigoplus, bigotimes, bigsqcup, bigstar, bigtriangledown, bigtriangleup, biguplus, bigvee, bigwedge, bkarow, blacklozenge, blacksquare, blacktriangle, blacktriangledown, blacktriangleleft, blacktriangleright, blank, blk12, blk14, blk34, block, bne, bnequiv, bNot, bnot, Bopf, bopf, bot, bottom, bowtie, boxbox, boxdl, boxdL, boxDl, boxDL, boxdr, boxdR, boxDr, boxDR, boxh, boxH, boxhd, boxHd, boxhD, boxHD, boxhu, boxHu, boxhU, boxHU, boxminus, boxplus, boxtimes, boxul, boxuL, boxUl, boxUL, boxur, boxuR, boxUr, boxUR, boxv, boxV, boxvh, boxvH, boxVh, boxVH, boxvl, boxvL, boxVl, boxVL, boxvr, boxvR, boxVr, boxVR, bprime, breve, Breve, brvbar, bscr, Bscr, bsemi, bsim, bsime, bsolb, bsol, bsolhsub, bull, bullet, bump, bumpE, bumpe, Bumpeq, bumpeq, Cacute, cacute, capand, capbrcup, capcap, cap, Cap, capcup, capdot, CapitalDifferentialD, caps, caret, caron, Cayleys, ccaps, Ccaron, ccaron, Ccedil, ccedil, Ccirc, ccirc, Cconint, ccups, ccupssm, Cdot, cdot, cedil, Cedilla, cemptyv, cent, centerdot, CenterDot, cfr, Cfr, CHcy, chcy, check, checkmark, Chi, chi, circ, circeq, circlearrowleft, circlearrowright, circledast, circledcirc, circleddash, CircleDot, circledR, circledS, CircleMinus, CirclePlus, CircleTimes, cir, cirE, cire, cirfnint, cirmid, cirscir, ClockwiseContourIntegral, CloseCurlyDoubleQuote, CloseCurlyQuote, clubs, clubsuit, colon, Colon, Colone, colone, coloneq, comma, commat, comp, compfn, complement, complexes, cong, congdot, Congruent, conint, Conint, ContourIntegral, copf, Copf, coprod, Coproduct, copy, COPY, copysr, CounterClockwiseContourIntegral, crarr, cross, Cross, Cscr, cscr, csub, csube, csup, csupe, ctdot, cudarrl, cudarrr, cuepr, cuesc, cularr, cularrp, cupbrcap, cupcap, CupCap, cup, Cup, cupcup, cupdot, cupor, cups, curarr, curarrm, curlyeqprec, curlyeqsucc, curlyvee, curlywedge, curren, curvearrowleft, curvearrowright, cuvee, cuwed, cwconint, cwint, cylcty, dagger, Dagger, daleth, darr, Darr, dArr, dash, Dashv, dashv, dbkarow, dblac, Dcaron, dcaron, Dcy, dcy, ddagger, ddarr, DD, dd, DDotrahd, ddotseq, deg, Del, Delta, delta, demptyv, dfisht, Dfr, dfr, dHar, dharl, dharr, DiacriticalAcute, DiacriticalDot, DiacriticalDoubleAcute, DiacriticalGrave, DiacriticalTilde, diam, diamond, Diamond, diamondsuit, diams, die, DifferentialD, digamma, disin, div, divide, divideontimes, divonx, DJcy, djcy, dlcorn, dlcrop, dollar, Dopf, dopf, Dot, dot, DotDot, doteq, doteqdot, DotEqual, dotminus, dotplus, dotsquare, doublebarwedge, DoubleContourIntegral, DoubleDot, DoubleDownArrow, DoubleLeftArrow, DoubleLeftRightArrow, DoubleLeftTee, DoubleLongLeftArrow, DoubleLongLeftRightArrow, DoubleLongRightArrow, DoubleRightArrow, DoubleRightTee, DoubleUpArrow, DoubleUpDownArrow, DoubleVerticalBar, DownArrowBar, downarrow, DownArrow, Downarrow, DownArrowUpArrow, DownBreve, downdownarrows, downharpoonleft, downharpoonright, DownLeftRightVector, DownLeftTeeVector, DownLeftVectorBar, DownLeftVector, DownRightTeeVector, DownRightVectorBar, DownRightVector, DownTeeArrow, DownTee, drbkarow, drcorn, drcrop, Dscr, dscr, DScy, dscy, dsol, Dstrok, dstrok, dtdot, dtri, dtrif, duarr, duhar, dwangle, DZcy, dzcy, dzigrarr, Eacute, eacute, easter, Ecaron, ecaron, Ecirc, ecirc, ecir, ecolon, Ecy, ecy, eDDot, Edot, edot, eDot, ee, efDot, Efr, efr, eg, Egrave, egrave, egs, egsdot, el, Element, elinters, ell, els, elsdot, Emacr, emacr, empty, emptyset, EmptySmallSquare, emptyv, EmptyVerySmallSquare, emsp13, emsp14, emsp, ENG, eng, ensp, Eogon, eogon, Eopf, eopf, epar, eparsl, eplus, epsi, Epsilon, epsilon, epsiv, eqcirc, eqcolon, eqsim, eqslantgtr, eqslantless, Equal, equals, EqualTilde, equest, Equilibrium, equiv, equivDD, eqvparsl, erarr, erDot, escr, Escr, esdot, Esim, esim, Eta, eta, ETH, eth, Euml, euml, euro, excl, exist, Exists, expectation, exponentiale, ExponentialE, fallingdotseq, Fcy, fcy, female, ffilig, fflig, ffllig, Ffr, ffr, filig, FilledSmallSquare, FilledVerySmallSquare, fjlig, flat, fllig, fltns, fnof, Fopf, fopf, forall, ForAll, fork, forkv, Fouriertrf, fpartint, frac12, frac13, frac14, frac15, frac16, frac18, frac23, frac25, frac34, frac35, frac38, frac45, frac56, frac58, frac78, frasl, frown, fscr, Fscr, gacute, Gamma, gamma, Gammad, gammad, gap, Gbreve, gbreve, Gcedil, Gcirc, gcirc, Gcy, gcy, Gdot, gdot, ge, gE, gEl, gel, geq, geqq, geqslant, gescc, ges, gesdot, gesdoto, gesdotol, gesl, gesles, Gfr, gfr, gg, Gg, ggg, gimel, GJcy, gjcy, gla, gl, glE, glj, gnap, gnapprox, gne, gnE, gneq, gneqq, gnsim, Gopf, gopf, grave, GreaterEqual, GreaterEqualLess, GreaterFullEqual, GreaterGreater, GreaterLess, GreaterSlantEqual, GreaterTilde, Gscr, gscr, gsim, gsime, gsiml, gtcc, gtcir, gt, GT, Gt, gtdot, gtlPar, gtquest, gtrapprox, gtrarr, gtrdot, gtreqless, gtreqqless, gtrless, gtrsim, gvertneqq, gvnE, Hacek, hairsp, half, hamilt, HARDcy, hardcy, harrcir, harr, hArr, harrw, Hat, hbar, Hcirc, hcirc, hearts, heartsuit, hellip, hercon, hfr, Hfr, HilbertSpace, hksearow, hkswarow, hoarr, homtht, hookleftarrow, hookrightarrow, hopf, Hopf, horbar, HorizontalLine, hscr, Hscr, hslash, Hstrok, hstrok, HumpDownHump, HumpEqual, hybull, hyphen, Iacute, iacute, ic, Icirc, icirc, Icy, icy, Idot, IEcy, iecy, iexcl, iff, ifr, Ifr, Igrave, igrave, ii, iiiint, iiint, iinfin, iiota, IJlig, ijlig, Imacr, imacr, image, ImaginaryI, imagline, imagpart, imath, Im, imof, imped, Implies, incare, in, infin, infintie, inodot, intcal, int, Int, integers, Integral, intercal, Intersection, intlarhk, intprod, InvisibleComma, InvisibleTimes, IOcy, iocy, Iogon, iogon, Iopf, iopf, Iota, iota, iprod, iquest, iscr, Iscr, isin, isindot, isinE, isins, isinsv, isinv, it, Itilde, itilde, Iukcy, iukcy, Iuml, iuml, Jcirc, jcirc, Jcy, jcy, Jfr, jfr, jmath, Jopf, jopf, Jscr, jscr, Jsercy, jsercy, Jukcy, jukcy, Kappa, kappa, kappav, Kcedil, kcedil, Kcy, kcy, Kfr, kfr, kgreen, KHcy, khcy, KJcy, kjcy, Kopf, kopf, Kscr, kscr, lAarr, Lacute, lacute, laemptyv, lagran, Lambda, lambda, lang, Lang, langd, langle, lap, Laplacetrf, laquo, larrb, larrbfs, larr, Larr, lArr, larrfs, larrhk, larrlp, larrpl, larrsim, larrtl, latail, lAtail, lat, late, lates, lbarr, lBarr, lbbrk, lbrace, lbrack, lbrke, lbrksld, lbrkslu, Lcaron, lcaron, Lcedil, lcedil, lceil, lcub, Lcy, lcy, ldca, ldquo, ldquor, ldrdhar, ldrushar, ldsh, le, lE, LeftAngleBracket, LeftArrowBar, leftarrow, LeftArrow, Leftarrow, LeftArrowRightArrow, leftarrowtail, LeftCeiling, LeftDoubleBracket, LeftDownTeeVector, LeftDownVectorBar, LeftDownVector, LeftFloor, leftharpoondown, leftharpoonup, leftleftarrows, leftrightarrow, LeftRightArrow, Leftrightarrow, leftrightarrows, leftrightharpoons, leftrightsquigarrow, LeftRightVector, LeftTeeArrow, LeftTee, LeftTeeVector, leftthreetimes, LeftTriangleBar, LeftTriangle, LeftTriangleEqual, LeftUpDownVector, LeftUpTeeVector, LeftUpVectorBar, LeftUpVector, LeftVectorBar, LeftVector, lEg, leg, leq, leqq, leqslant, lescc, les, lesdot, lesdoto, lesdotor, lesg, lesges, lessapprox, lessdot, lesseqgtr, lesseqqgtr, LessEqualGreater, LessFullEqual, LessGreater, lessgtr, LessLess, lesssim, LessSlantEqual, LessTilde, lfisht, lfloor, Lfr, lfr, lg, lgE, lHar, lhard, lharu, lharul, lhblk, LJcy, ljcy, llarr, ll, Ll, llcorner, Lleftarrow, llhard, lltri, Lmidot, lmidot, lmoustache, lmoust, lnap, lnapprox, lne, lnE, lneq, lneqq, lnsim, loang, loarr, lobrk, longleftarrow, LongLeftArrow, Longleftarrow, longleftrightarrow, LongLeftRightArrow, Longleftrightarrow, longmapsto, longrightarrow, LongRightArrow, Longrightarrow, looparrowleft, looparrowright, lopar, Lopf, lopf, loplus, lotimes, lowast, lowbar, LowerLeftArrow, LowerRightArrow, loz, lozenge, lozf, lpar, lparlt, lrarr, lrcorner, lrhar, lrhard, lrm, lrtri, lsaquo, lscr, Lscr, lsh, Lsh, lsim, lsime, lsimg, lsqb, lsquo, lsquor, Lstrok, lstrok, ltcc, ltcir, lt, LT, Lt, ltdot, lthree, ltimes, ltlarr, ltquest, ltri, ltrie, ltrif, ltrPar, lurdshar, luruhar, lvertneqq, lvnE, macr, male, malt, maltese, Map, map, mapsto, mapstodown, mapstoleft, mapstoup, marker, mcomma, Mcy, mcy, mdash, mDDot, measuredangle, MediumSpace, Mellintrf, Mfr, mfr, mho, micro, midast, midcir, mid, middot, minusb, minus, minusd, minusdu, MinusPlus, mlcp, mldr, mnplus, models, Mopf, mopf, mp, mscr, Mscr, mstpos, Mu, mu, multimap, mumap, nabla, Nacute, nacute, nang, nap, napE, napid, napos, napprox, natural, naturals, natur, nbsp, nbump, nbumpe, ncap, Ncaron, ncaron, Ncedil, ncedil, ncong, ncongdot, ncup, Ncy, ncy, ndash, nearhk, nearr, neArr, nearrow, ne, nedot, NegativeMediumSpace, NegativeThickSpace, NegativeThinSpace, NegativeVeryThinSpace, nequiv, nesear, nesim, NestedGreaterGreater, NestedLessLess, NewLine, nexist, nexists, Nfr, nfr, ngE, nge, ngeq, ngeqq, ngeqslant, nges, nGg, ngsim, nGt, ngt, ngtr, nGtv, nharr, nhArr, nhpar, ni, nis, nisd, niv, NJcy, njcy, nlarr, nlArr, nldr, nlE, nle, nleftarrow, nLeftarrow, nleftrightarrow, nLeftrightarrow, nleq, nleqq, nleqslant, nles, nless, nLl, nlsim, nLt, nlt, nltri, nltrie, nLtv, nmid, NoBreak, NonBreakingSpace, nopf, Nopf, Not, not, NotCongruent, NotCupCap, NotDoubleVerticalBar, NotElement, NotEqual, NotEqualTilde, NotExists, NotGreater, NotGreaterEqual, NotGreaterFullEqual, NotGreaterGreater, NotGreaterLess, NotGreaterSlantEqual, NotGreaterTilde, NotHumpDownHump, NotHumpEqual, notin, notindot, notinE, notinva, notinvb, notinvc, NotLeftTriangleBar, NotLeftTriangle, NotLeftTriangleEqual, NotLess, NotLessEqual, NotLessGreater, NotLessLess, NotLessSlantEqual, NotLessTilde, NotNestedGreaterGreater, NotNestedLessLess, notni, notniva, notnivb, notnivc, NotPrecedes, NotPrecedesEqual, NotPrecedesSlantEqual, NotReverseElement, NotRightTriangleBar, NotRightTriangle, NotRightTriangleEqual, NotSquareSubset, NotSquareSubsetEqual, NotSquareSuperset, NotSquareSupersetEqual, NotSubset, NotSubsetEqual, NotSucceeds, NotSucceedsEqual, NotSucceedsSlantEqual, NotSucceedsTilde, NotSuperset, NotSupersetEqual, NotTilde, NotTildeEqual, NotTildeFullEqual, NotTildeTilde, NotVerticalBar, nparallel, npar, nparsl, npart, npolint, npr, nprcue, nprec, npreceq, npre, nrarrc, nrarr, nrArr, nrarrw, nrightarrow, nRightarrow, nrtri, nrtrie, nsc, nsccue, nsce, Nscr, nscr, nshortmid, nshortparallel, nsim, nsime, nsimeq, nsmid, nspar, nsqsube, nsqsupe, nsub, nsubE, nsube, nsubset, nsubseteq, nsubseteqq, nsucc, nsucceq, nsup, nsupE, nsupe, nsupset, nsupseteq, nsupseteqq, ntgl, Ntilde, ntilde, ntlg, ntriangleleft, ntrianglelefteq, ntriangleright, ntrianglerighteq, Nu, nu, num, numero, numsp, nvap, nvdash, nvDash, nVdash, nVDash, nvge, nvgt, nvHarr, nvinfin, nvlArr, nvle, nvlt, nvltrie, nvrArr, nvrtrie, nvsim, nwarhk, nwarr, nwArr, nwarrow, nwnear, Oacute, oacute, oast, Ocirc, ocirc, ocir, Ocy, ocy, odash, Odblac, odblac, odiv, odot, odsold, OElig, oelig, ofcir, Ofr, ofr, ogon, Ograve, ograve, ogt, ohbar, ohm, oint, olarr, olcir, olcross, oline, olt, Omacr, omacr, Omega, omega, Omicron, omicron, omid, ominus, Oopf, oopf, opar, OpenCurlyDoubleQuote, OpenCurlyQuote, operp, oplus, orarr, Or, or, ord, order, orderof, ordf, ordm, origof, oror, orslope, orv, oS, Oscr, oscr, Oslash, oslash, osol, Otilde, otilde, otimesas, Otimes, otimes, Ouml, ouml, ovbar, OverBar, OverBrace, OverBracket, OverParenthesis, para, parallel, par, parsim, parsl, part, PartialD, Pcy, pcy, percnt, period, permil, perp, pertenk, Pfr, pfr, Phi, phi, phiv, phmmat, phone, Pi, pi, pitchfork, piv, planck, planckh, plankv, plusacir, plusb, pluscir, plus, plusdo, plusdu, pluse, PlusMinus, plusmn, plussim, plustwo, pm, Poincareplane, pointint, popf, Popf, pound, prap, Pr, pr, prcue, precapprox, prec, preccurlyeq, Precedes, PrecedesEqual, PrecedesSlantEqual, PrecedesTilde, preceq, precnapprox, precneqq, precnsim, pre, prE, precsim, prime, Prime, primes, prnap, prnE, prnsim, prod, Product, profalar, profline, profsurf, prop, Proportional, Proportion, propto, prsim, prurel, Pscr, pscr, Psi, psi, puncsp, Qfr, qfr, qint, qopf, Qopf, qprime, Qscr, qscr, quaternions, quatint, quest, questeq, quot, QUOT, rAarr, race, Racute, racute, radic, raemptyv, rang, Rang, rangd, range, rangle, raquo, rarrap, rarrb, rarrbfs, rarrc, rarr, Rarr, rArr, rarrfs, rarrhk, rarrlp, rarrpl, rarrsim, Rarrtl, rarrtl, rarrw, ratail, rAtail, ratio, rationals, rbarr, rBarr, RBarr, rbbrk, rbrace, rbrack, rbrke, rbrksld, rbrkslu, Rcaron, rcaron, Rcedil, rcedil, rceil, rcub, Rcy, rcy, rdca, rdldhar, rdquo, rdquor, rdsh, real, realine, realpart, reals, Re, rect, reg, REG, ReverseElement, ReverseEquilibrium, ReverseUpEquilibrium, rfisht, rfloor, rfr, Rfr, rHar, rhard, rharu, rharul, Rho, rho, rhov, RightAngleBracket, RightArrowBar, rightarrow, RightArrow, Rightarrow, RightArrowLeftArrow, rightarrowtail, RightCeiling, RightDoubleBracket, RightDownTeeVector, RightDownVectorBar, RightDownVector, RightFloor, rightharpoondown, rightharpoonup, rightleftarrows, rightleftharpoons, rightrightarrows, rightsquigarrow, RightTeeArrow, RightTee, RightTeeVector, rightthreetimes, RightTriangleBar, RightTriangle, RightTriangleEqual, RightUpDownVector, RightUpTeeVector, RightUpVectorBar, RightUpVector, RightVectorBar, RightVector, ring, risingdotseq, rlarr, rlhar, rlm, rmoustache, rmoust, rnmid, roang, roarr, robrk, ropar, ropf, Ropf, roplus, rotimes, RoundImplies, rpar, rpargt, rppolint, rrarr, Rrightarrow, rsaquo, rscr, Rscr, rsh, Rsh, rsqb, rsquo, rsquor, rthree, rtimes, rtri, rtrie, rtrif, rtriltri, RuleDelayed, ruluhar, rx, Sacute, sacute, sbquo, scap, Scaron, scaron, Sc, sc, sccue, sce, scE, Scedil, scedil, Scirc, scirc, scnap, scnE, scnsim, scpolint, scsim, Scy, scy, sdotb, sdot, sdote, searhk, searr, seArr, searrow, sect, semi, seswar, setminus, setmn, sext, Sfr, sfr, sfrown, sharp, SHCHcy, shchcy, SHcy, shcy, ShortDownArrow, ShortLeftArrow, shortmid, shortparallel, ShortRightArrow, ShortUpArrow, shy, Sigma, sigma, sigmaf, sigmav, sim, simdot, sime, simeq, simg, simgE, siml, simlE, simne, simplus, simrarr, slarr, SmallCircle, smallsetminus, smashp, smeparsl, smid, smile, smt, smte, smtes, SOFTcy, softcy, solbar, solb, sol, Sopf, sopf, spades, spadesuit, spar, sqcap, sqcaps, sqcup, sqcups, Sqrt, sqsub, sqsube, sqsubset, sqsubseteq, sqsup, sqsupe, sqsupset, sqsupseteq, square, Square, SquareIntersection, SquareSubset, SquareSubsetEqual, SquareSuperset, SquareSupersetEqual, SquareUnion, squarf, squ, squf, srarr, Sscr, sscr, ssetmn, ssmile, sstarf, Star, star, starf, straightepsilon, straightphi, strns, sub, Sub, subdot, subE, sube, subedot, submult, subnE, subne, subplus, subrarr, subset, Subset, subseteq, subseteqq, SubsetEqual, subsetneq, subsetneqq, subsim, subsub, subsup, succapprox, succ, succcurlyeq, Succeeds, SucceedsEqual, SucceedsSlantEqual, SucceedsTilde, succeq, succnapprox, succneqq, succnsim, succsim, SuchThat, sum, Sum, sung, sup1, sup2, sup3, sup, Sup, supdot, supdsub, supE, supe, supedot, Superset, SupersetEqual, suphsol, suphsub, suplarr, supmult, supnE, supne, supplus, supset, Supset, supseteq, supseteqq, supsetneq, supsetneqq, supsim, supsub, supsup, swarhk, swarr, swArr, swarrow, swnwar, szlig, Tab, target, Tau, tau, tbrk, Tcaron, tcaron, Tcedil, tcedil, Tcy, tcy, tdot, telrec, Tfr, tfr, there4, therefore, Therefore, Theta, theta, thetasym, thetav, thickapprox, thicksim, ThickSpace, ThinSpace, thinsp, thkap, thksim, THORN, thorn, tilde, Tilde, TildeEqual, TildeFullEqual, TildeTilde, timesbar, timesb, times, timesd, tint, toea, topbot, topcir, top, Topf, topf, topfork, tosa, tprime, trade, TRADE, triangle, triangledown, triangleleft, trianglelefteq, triangleq, triangleright, trianglerighteq, tridot, trie, triminus, TripleDot, triplus, trisb, tritime, trpezium, Tscr, tscr, TScy, tscy, TSHcy, tshcy, Tstrok, tstrok, twixt, twoheadleftarrow, twoheadrightarrow, Uacute, uacute, uarr, Uarr, uArr, Uarrocir, Ubrcy, ubrcy, Ubreve, ubreve, Ucirc, ucirc, Ucy, ucy, udarr, Udblac, udblac, udhar, ufisht, Ufr, ufr, Ugrave, ugrave, uHar, uharl, uharr, uhblk, ulcorn, ulcorner, ulcrop, ultri, Umacr, umacr, uml, UnderBar, UnderBrace, UnderBracket, UnderParenthesis, Union, UnionPlus, Uogon, uogon, Uopf, uopf, UpArrowBar, uparrow, UpArrow, Uparrow, UpArrowDownArrow, updownarrow, UpDownArrow, Updownarrow, UpEquilibrium, upharpoonleft, upharpoonright, uplus, UpperLeftArrow, UpperRightArrow, upsi, Upsi, upsih, Upsilon, upsilon, UpTeeArrow, UpTee, upuparrows, urcorn, urcorner, urcrop, Uring, uring, urtri, Uscr, uscr, utdot, Utilde, utilde, utri, utrif, uuarr, Uuml, uuml, uwangle, vangrt, varepsilon, varkappa, varnothing, varphi, varpi, varpropto, varr, vArr, varrho, varsigma, varsubsetneq, varsubsetneqq, varsupsetneq, varsupsetneqq, vartheta, vartriangleleft, vartriangleright, vBar, Vbar, vBarv, Vcy, vcy, vdash, vDash, Vdash, VDash, Vdashl, veebar, vee, Vee, veeeq, vellip, verbar, Verbar, vert, Vert, VerticalBar, VerticalLine, VerticalSeparator, VerticalTilde, VeryThinSpace, Vfr, vfr, vltri, vnsub, vnsup, Vopf, vopf, vprop, vrtri, Vscr, vscr, vsubnE, vsubne, vsupnE, vsupne, Vvdash, vzigzag, Wcirc, wcirc, wedbar, wedge, Wedge, wedgeq, weierp, Wfr, wfr, Wopf, wopf, wp, wr, wreath, Wscr, wscr, xcap, xcirc, xcup, xdtri, Xfr, xfr, xharr, xhArr, Xi, xi, xlarr, xlArr, xmap, xnis, xodot, Xopf, xopf, xoplus, xotime, xrarr, xrArr, Xscr, xscr, xsqcup, xuplus, xutri, xvee, xwedge, Yacute, yacute, YAcy, yacy, Ycirc, ycirc, Ycy, ycy, yen, Yfr, yfr, YIcy, yicy, Yopf, yopf, Yscr, yscr, YUcy, yucy, yuml, Yuml, Zacute, zacute, Zcaron, zcaron, Zcy, zcy, Zdot, zdot, zeetrf, ZeroWidthSpace, Zeta, zeta, zfr, Zfr, ZHcy, zhcy, zigrarr, zopf, Zopf, Zscr, zscr, zwj, zwnj, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"\",\"aacute\":\"\",\"Abreve\":\"\",\"abreve\":\"\",\"ac\":\"\",\"acd\":\"\",\"acE\":\"\",\"Acirc\":\"\",\"acirc\":\"\",\"acute\":\"\",\"Acy\":\"\",\"acy\":\"\",\"AElig\":\"\",\"aelig\":\"\",\"af\":\"\",\"Afr\":\"\",\"afr\":\"\",\"Agrave\":\"\",\"agrave\":\"\",\"alefsym\":\"\",\"aleph\":\"\",\"Alpha\":\"\",\"alpha\":\"\",\"Amacr\":\"\",\"amacr\":\"\",\"amalg\":\"\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"\",\"And\":\"\",\"and\":\"\",\"andd\":\"\",\"andslope\":\"\",\"andv\":\"\",\"ang\":\"\",\"ange\":\"\",\"angle\":\"\",\"angmsdaa\":\"\",\"angmsdab\":\"\",\"angmsdac\":\"\",\"angmsdad\":\"\",\"angmsdae\":\"\",\"angmsdaf\":\"\",\"angmsdag\":\"\",\"angmsdah\":\"\",\"angmsd\":\"\",\"angrt\":\"\",\"angrtvb\":\"\",\"angrtvbd\":\"\",\"angsph\":\"\",\"angst\":\"\",\"angzarr\":\"\",\"Aogon\":\"\",\"aogon\":\"\",\"Aopf\":\"\",\"aopf\":\"\",\"apacir\":\"\",\"ap\":\"\",\"apE\":\"\",\"ape\":\"\",\"apid\":\"\",\"apos\":\"'\",\"ApplyFunction\":\"\",\"approx\":\"\",\"approxeq\":\"\",\"Aring\":\"\",\"aring\":\"\",\"Ascr\":\"\",\"ascr\":\"\",\"Assign\":\"\",\"ast\":\"*\",\"asymp\":\"\",\"asympeq\":\"\",\"Atilde\":\"\",\"atilde\":\"\",\"Auml\":\"\",\"auml\":\"\",\"awconint\":\"\",\"awint\":\"\",\"backcong\":\"\",\"backepsilon\":\"\",\"backprime\":\"\",\"backsim\":\"\",\"backsimeq\":\"\",\"Backslash\":\"\",\"Barv\":\"\",\"barvee\":\"\",\"barwed\":\"\",\"Barwed\":\"\",\"barwedge\":\"\",\"bbrk\":\"\",\"bbrktbrk\":\"\",\"bcong\":\"\",\"Bcy\":\"\",\"bcy\":\"\",\"bdquo\":\"\",\"becaus\":\"\",\"because\":\"\",\"Because\":\"\",\"bemptyv\":\"\",\"bepsi\":\"\",\"bernou\":\"\",\"Bernoullis\":\"\",\"Beta\":\"\",\"beta\":\"\",\"beth\":\"\",\"between\":\"\",\"Bfr\":\"\",\"bfr\":\"\",\"bigcap\":\"\",\"bigcirc\":\"\",\"bigcup\":\"\",\"bigodot\":\"\",\"bigoplus\":\"\",\"bigotimes\":\"\",\"bigsqcup\":\"\",\"bigstar\":\"\",\"bigtriangledown\":\"\",\"bigtriangleup\":\"\",\"biguplus\":\"\",\"bigvee\":\"\",\"bigwedge\":\"\",\"bkarow\":\"\",\"blacklozenge\":\"\",\"blacksquare\":\"\",\"blacktriangle\":\"\",\"blacktriangledown\":\"\",\"blacktriangleleft\":\"\",\"blacktriangleright\":\"\",\"blank\":\"\",\"blk12\":\"\",\"blk14\":\"\",\"blk34\":\"\",\"block\":\"\",\"bne\":\"=\",\"bnequiv\":\"\",\"bNot\":\"\",\"bnot\":\"\",\"Bopf\":\"\",\"bopf\":\"\",\"bot\":\"\",\"bottom\":\"\",\"bowtie\":\"\",\"boxbox\":\"\",\"boxdl\":\"\",\"boxdL\":\"\",\"boxDl\":\"\",\"boxDL\":\"\",\"boxdr\":\"\",\"boxdR\":\"\",\"boxDr\":\"\",\"boxDR\":\"\",\"boxh\":\"\",\"boxH\":\"\",\"boxhd\":\"\",\"boxHd\":\"\",\"boxhD\":\"\",\"boxHD\":\"\",\"boxhu\":\"\",\"boxHu\":\"\",\"boxhU\":\"\",\"boxHU\":\"\",\"boxminus\":\"\",\"boxplus\":\"\",\"boxtimes\":\"\",\"boxul\":\"\",\"boxuL\":\"\",\"boxUl\":\"\",\"boxUL\":\"\",\"boxur\":\"\",\"boxuR\":\"\",\"boxUr\":\"\",\"boxUR\":\"\",\"boxv\":\"\",\"boxV\":\"\",\"boxvh\":\"\",\"boxvH\":\"\",\"boxVh\":\"\",\"boxVH\":\"\",\"boxvl\":\"\",\"boxvL\":\"\",\"boxVl\":\"\",\"boxVL\":\"\",\"boxvr\":\"\",\"boxvR\":\"\",\"boxVr\":\"\",\"boxVR\":\"\",\"bprime\":\"\",\"breve\":\"\",\"Breve\":\"\",\"brvbar\":\"\",\"bscr\":\"\",\"Bscr\":\"\",\"bsemi\":\"\",\"bsim\":\"\",\"bsime\":\"\",\"bsolb\":\"\",\"bsol\":\"\\\\\",\"bsolhsub\":\"\",\"bull\":\"\",\"bullet\":\"\",\"bump\":\"\",\"bumpE\":\"\",\"bumpe\":\"\",\"Bumpeq\":\"\",\"bumpeq\":\"\",\"Cacute\":\"\",\"cacute\":\"\",\"capand\":\"\",\"capbrcup\":\"\",\"capcap\":\"\",\"cap\":\"\",\"Cap\":\"\",\"capcup\":\"\",\"capdot\":\"\",\"CapitalDifferentialD\":\"\",\"caps\":\"\",\"caret\":\"\",\"caron\":\"\",\"Cayleys\":\"\",\"ccaps\":\"\",\"Ccaron\":\"\",\"ccaron\":\"\",\"Ccedil\":\"\",\"ccedil\":\"\",\"Ccirc\":\"\",\"ccirc\":\"\",\"Cconint\":\"\",\"ccups\":\"\",\"ccupssm\":\"\",\"Cdot\":\"\",\"cdot\":\"\",\"cedil\":\"\",\"Cedilla\":\"\",\"cemptyv\":\"\",\"cent\":\"\",\"centerdot\":\"\",\"CenterDot\":\"\",\"cfr\":\"\",\"Cfr\":\"\",\"CHcy\":\"\",\"chcy\":\"\",\"check\":\"\",\"checkmark\":\"\",\"Chi\":\"\",\"chi\":\"\",\"circ\":\"\",\"circeq\":\"\",\"circlearrowleft\":\"\",\"circlearrowright\":\"\",\"circledast\":\"\",\"circledcirc\":\"\",\"circleddash\":\"\",\"CircleDot\":\"\",\"circledR\":\"\",\"circledS\":\"\",\"CircleMinus\":\"\",\"CirclePlus\":\"\",\"CircleTimes\":\"\",\"cir\":\"\",\"cirE\":\"\",\"cire\":\"\",\"cirfnint\":\"\",\"cirmid\":\"\",\"cirscir\":\"\",\"ClockwiseContourIntegral\":\"\",\"CloseCurlyDoubleQuote\":\"\",\"CloseCurlyQuote\":\"\",\"clubs\":\"\",\"clubsuit\":\"\",\"colon\":\":\",\"Colon\":\"\",\"Colone\":\"\",\"colone\":\"\",\"coloneq\":\"\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"\",\"compfn\":\"\",\"complement\":\"\",\"complexes\":\"\",\"cong\":\"\",\"congdot\":\"\",\"Congruent\":\"\",\"conint\":\"\",\"Conint\":\"\",\"ContourIntegral\":\"\",\"copf\":\"\",\"Copf\":\"\",\"coprod\":\"\",\"Coproduct\":\"\",\"copy\":\"\",\"COPY\":\"\",\"copysr\":\"\",\"CounterClockwiseContourIntegral\":\"\",\"crarr\":\"\",\"cross\":\"\",\"Cross\":\"\",\"Cscr\":\"\",\"cscr\":\"\",\"csub\":\"\",\"csube\":\"\",\"csup\":\"\",\"csupe\":\"\",\"ctdot\":\"\",\"cudarrl\":\"\",\"cudarrr\":\"\",\"cuepr\":\"\",\"cuesc\":\"\",\"cularr\":\"\",\"cularrp\":\"\",\"cupbrcap\":\"\",\"cupcap\":\"\",\"CupCap\":\"\",\"cup\":\"\",\"Cup\":\"\",\"cupcup\":\"\",\"cupdot\":\"\",\"cupor\":\"\",\"cups\":\"\",\"curarr\":\"\",\"curarrm\":\"\",\"curlyeqprec\":\"\",\"curlyeqsucc\":\"\",\"curlyvee\":\"\",\"curlywedge\":\"\",\"curren\":\"\",\"curvearrowleft\":\"\",\"curvearrowright\":\"\",\"cuvee\":\"\",\"cuwed\":\"\",\"cwconint\":\"\",\"cwint\":\"\",\"cylcty\":\"\",\"dagger\":\"\",\"Dagger\":\"\",\"daleth\":\"\",\"darr\":\"\",\"Darr\":\"\",\"dArr\":\"\",\"dash\":\"\",\"Dashv\":\"\",\"dashv\":\"\",\"dbkarow\":\"\",\"dblac\":\"\",\"Dcaron\":\"\",\"dcaron\":\"\",\"Dcy\":\"\",\"dcy\":\"\",\"ddagger\":\"\",\"ddarr\":\"\",\"DD\":\"\",\"dd\":\"\",\"DDotrahd\":\"\",\"ddotseq\":\"\",\"deg\":\"\",\"Del\":\"\",\"Delta\":\"\",\"delta\":\"\",\"demptyv\":\"\",\"dfisht\":\"\",\"Dfr\":\"\",\"dfr\":\"\",\"dHar\":\"\",\"dharl\":\"\",\"dharr\":\"\",\"DiacriticalAcute\":\"\",\"DiacriticalDot\":\"\",\"DiacriticalDoubleAcute\":\"\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"\",\"diam\":\"\",\"diamond\":\"\",\"Diamond\":\"\",\"diamondsuit\":\"\",\"diams\":\"\",\"die\":\"\",\"DifferentialD\":\"\",\"digamma\":\"\",\"disin\":\"\",\"div\":\"\",\"divide\":\"\",\"divideontimes\":\"\",\"divonx\":\"\",\"DJcy\":\"\",\"djcy\":\"\",\"dlcorn\":\"\",\"dlcrop\":\"\",\"dollar\":\"$\",\"Dopf\":\"\",\"dopf\":\"\",\"Dot\":\"\",\"dot\":\"\",\"DotDot\":\"\",\"doteq\":\"\",\"doteqdot\":\"\",\"DotEqual\":\"\",\"dotminus\":\"\",\"dotplus\":\"\",\"dotsquare\":\"\",\"doublebarwedge\":\"\",\"DoubleContourIntegral\":\"\",\"DoubleDot\":\"\",\"DoubleDownArrow\":\"\",\"DoubleLeftArrow\":\"\",\"DoubleLeftRightArrow\":\"\",\"DoubleLeftTee\":\"\",\"DoubleLongLeftArrow\":\"\",\"DoubleLongLeftRightArrow\":\"\",\"DoubleLongRightArrow\":\"\",\"DoubleRightArrow\":\"\",\"DoubleRightTee\":\"\",\"DoubleUpArrow\":\"\",\"DoubleUpDownArrow\":\"\",\"DoubleVerticalBar\":\"\",\"DownArrowBar\":\"\",\"downarrow\":\"\",\"DownArrow\":\"\",\"Downarrow\":\"\",\"DownArrowUpArrow\":\"\",\"DownBreve\":\"\",\"downdownarrows\":\"\",\"downharpoonleft\":\"\",\"downharpoonright\":\"\",\"DownLeftRightVector\":\"\",\"DownLeftTeeVector\":\"\",\"DownLeftVectorBar\":\"\",\"DownLeftVector\":\"\",\"DownRightTeeVector\":\"\",\"DownRightVectorBar\":\"\",\"DownRightVector\":\"\",\"DownTeeArrow\":\"\",\"DownTee\":\"\",\"drbkarow\":\"\",\"drcorn\":\"\",\"drcrop\":\"\",\"Dscr\":\"\",\"dscr\":\"\",\"DScy\":\"\",\"dscy\":\"\",\"dsol\":\"\",\"Dstrok\":\"\",\"dstrok\":\"\",\"dtdot\":\"\",\"dtri\":\"\",\"dtrif\":\"\",\"duarr\":\"\",\"duhar\":\"\",\"dwangle\":\"\",\"DZcy\":\"\",\"dzcy\":\"\",\"dzigrarr\":\"\",\"Eacute\":\"\",\"eacute\":\"\",\"easter\":\"\",\"Ecaron\":\"\",\"ecaron\":\"\",\"Ecirc\":\"\",\"ecirc\":\"\",\"ecir\":\"\",\"ecolon\":\"\",\"Ecy\":\"\",\"ecy\":\"\",\"eDDot\":\"\",\"Edot\":\"\",\"edot\":\"\",\"eDot\":\"\",\"ee\":\"\",\"efDot\":\"\",\"Efr\":\"\",\"efr\":\"\",\"eg\":\"\",\"Egrave\":\"\",\"egrave\":\"\",\"egs\":\"\",\"egsdot\":\"\",\"el\":\"\",\"Element\":\"\",\"elinters\":\"\",\"ell\":\"\",\"els\":\"\",\"elsdot\":\"\",\"Emacr\":\"\",\"emacr\":\"\",\"empty\":\"\",\"emptyset\":\"\",\"EmptySmallSquare\":\"\",\"emptyv\":\"\",\"EmptyVerySmallSquare\":\"\",\"emsp13\":\"\",\"emsp14\":\"\",\"emsp\":\"\",\"ENG\":\"\",\"eng\":\"\",\"ensp\":\"\",\"Eogon\":\"\",\"eogon\":\"\",\"Eopf\":\"\",\"eopf\":\"\",\"epar\":\"\",\"eparsl\":\"\",\"eplus\":\"\",\"epsi\":\"\",\"Epsilon\":\"\",\"epsilon\":\"\",\"epsiv\":\"\",\"eqcirc\":\"\",\"eqcolon\":\"\",\"eqsim\":\"\",\"eqslantgtr\":\"\",\"eqslantless\":\"\",\"Equal\":\"\",\"equals\":\"=\",\"EqualTilde\":\"\",\"equest\":\"\",\"Equilibrium\":\"\",\"equiv\":\"\",\"equivDD\":\"\",\"eqvparsl\":\"\",\"erarr\":\"\",\"erDot\":\"\",\"escr\":\"\",\"Escr\":\"\",\"esdot\":\"\",\"Esim\":\"\",\"esim\":\"\",\"Eta\":\"\",\"eta\":\"\",\"ETH\":\"\",\"eth\":\"\",\"Euml\":\"\",\"euml\":\"\",\"euro\":\"\",\"excl\":\"!\",\"exist\":\"\",\"Exists\":\"\",\"expectation\":\"\",\"exponentiale\":\"\",\"ExponentialE\":\"\",\"fallingdotseq\":\"\",\"Fcy\":\"\",\"fcy\":\"\",\"female\":\"\",\"ffilig\":\"\",\"fflig\":\"\",\"ffllig\":\"\",\"Ffr\":\"\",\"ffr\":\"\",\"filig\":\"\",\"FilledSmallSquare\":\"\",\"FilledVerySmallSquare\":\"\",\"fjlig\":\"fj\",\"flat\":\"\",\"fllig\":\"\",\"fltns\":\"\",\"fnof\":\"\",\"Fopf\":\"\",\"fopf\":\"\",\"forall\":\"\",\"ForAll\":\"\",\"fork\":\"\",\"forkv\":\"\",\"Fouriertrf\":\"\",\"fpartint\":\"\",\"frac12\":\"\",\"frac13\":\"\",\"frac14\":\"\",\"frac15\":\"\",\"frac16\":\"\",\"frac18\":\"\",\"frac23\":\"\",\"frac25\":\"\",\"frac34\":\"\",\"frac35\":\"\",\"frac38\":\"\",\"frac45\":\"\",\"frac56\":\"\",\"frac58\":\"\",\"frac78\":\"\",\"frasl\":\"\",\"frown\":\"\",\"fscr\":\"\",\"Fscr\":\"\",\"gacute\":\"\",\"Gamma\":\"\",\"gamma\":\"\",\"Gammad\":\"\",\"gammad\":\"\",\"gap\":\"\",\"Gbreve\":\"\",\"gbreve\":\"\",\"Gcedil\":\"\",\"Gcirc\":\"\",\"gcirc\":\"\",\"Gcy\":\"\",\"gcy\":\"\",\"Gdot\":\"\",\"gdot\":\"\",\"ge\":\"\",\"gE\":\"\",\"gEl\":\"\",\"gel\":\"\",\"geq\":\"\",\"geqq\":\"\",\"geqslant\":\"\",\"gescc\":\"\",\"ges\":\"\",\"gesdot\":\"\",\"gesdoto\":\"\",\"gesdotol\":\"\",\"gesl\":\"\",\"gesles\":\"\",\"Gfr\":\"\",\"gfr\":\"\",\"gg\":\"\",\"Gg\":\"\",\"ggg\":\"\",\"gimel\":\"\",\"GJcy\":\"\",\"gjcy\":\"\",\"gla\":\"\",\"gl\":\"\",\"glE\":\"\",\"glj\":\"\",\"gnap\":\"\",\"gnapprox\":\"\",\"gne\":\"\",\"gnE\":\"\",\"gneq\":\"\",\"gneqq\":\"\",\"gnsim\":\"\",\"Gopf\":\"\",\"gopf\":\"\",\"grave\":\"`\",\"GreaterEqual\":\"\",\"GreaterEqualLess\":\"\",\"GreaterFullEqual\":\"\",\"GreaterGreater\":\"\",\"GreaterLess\":\"\",\"GreaterSlantEqual\":\"\",\"GreaterTilde\":\"\",\"Gscr\":\"\",\"gscr\":\"\",\"gsim\":\"\",\"gsime\":\"\",\"gsiml\":\"\",\"gtcc\":\"\",\"gtcir\":\"\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"\",\"gtdot\":\"\",\"gtlPar\":\"\",\"gtquest\":\"\",\"gtrapprox\":\"\",\"gtrarr\":\"\",\"gtrdot\":\"\",\"gtreqless\":\"\",\"gtreqqless\":\"\",\"gtrless\":\"\",\"gtrsim\":\"\",\"gvertneqq\":\"\",\"gvnE\":\"\",\"Hacek\":\"\",\"hairsp\":\"\",\"half\":\"\",\"hamilt\":\"\",\"HARDcy\":\"\",\"hardcy\":\"\",\"harrcir\":\"\",\"harr\":\"\",\"hArr\":\"\",\"harrw\":\"\",\"Hat\":\"^\",\"hbar\":\"\",\"Hcirc\":\"\",\"hcirc\":\"\",\"hearts\":\"\",\"heartsuit\":\"\",\"hellip\":\"\",\"hercon\":\"\",\"hfr\":\"\",\"Hfr\":\"\",\"HilbertSpace\":\"\",\"hksearow\":\"\",\"hkswarow\":\"\",\"hoarr\":\"\",\"homtht\":\"\",\"hookleftarrow\":\"\",\"hookrightarrow\":\"\",\"hopf\":\"\",\"Hopf\":\"\",\"horbar\":\"\",\"HorizontalLine\":\"\",\"hscr\":\"\",\"Hscr\":\"\",\"hslash\":\"\",\"Hstrok\":\"\",\"hstrok\":\"\",\"HumpDownHump\":\"\",\"HumpEqual\":\"\",\"hybull\":\"\",\"hyphen\":\"\",\"Iacute\":\"\",\"iacute\":\"\",\"ic\":\"\",\"Icirc\":\"\",\"icirc\":\"\",\"Icy\":\"\",\"icy\":\"\",\"Idot\":\"\",\"IEcy\":\"\",\"iecy\":\"\",\"iexcl\":\"\",\"iff\":\"\",\"ifr\":\"\",\"Ifr\":\"\",\"Igrave\":\"\",\"igrave\":\"\",\"ii\":\"\",\"iiiint\":\"\",\"iiint\":\"\",\"iinfin\":\"\",\"iiota\":\"\",\"IJlig\":\"\",\"ijlig\":\"\",\"Imacr\":\"\",\"imacr\":\"\",\"image\":\"\",\"ImaginaryI\":\"\",\"imagline\":\"\",\"imagpart\":\"\",\"imath\":\"\",\"Im\":\"\",\"imof\":\"\",\"imped\":\"\",\"Implies\":\"\",\"incare\":\"\",\"in\":\"\",\"infin\":\"\",\"infintie\":\"\",\"inodot\":\"\",\"intcal\":\"\",\"int\":\"\",\"Int\":\"\",\"integers\":\"\",\"Integral\":\"\",\"intercal\":\"\",\"Intersection\":\"\",\"intlarhk\":\"\",\"intprod\":\"\",\"InvisibleComma\":\"\",\"InvisibleTimes\":\"\",\"IOcy\":\"\",\"iocy\":\"\",\"Iogon\":\"\",\"iogon\":\"\",\"Iopf\":\"\",\"iopf\":\"\",\"Iota\":\"\",\"iota\":\"\",\"iprod\":\"\",\"iquest\":\"\",\"iscr\":\"\",\"Iscr\":\"\",\"isin\":\"\",\"isindot\":\"\",\"isinE\":\"\",\"isins\":\"\",\"isinsv\":\"\",\"isinv\":\"\",\"it\":\"\",\"Itilde\":\"\",\"itilde\":\"\",\"Iukcy\":\"\",\"iukcy\":\"\",\"Iuml\":\"\",\"iuml\":\"\",\"Jcirc\":\"\",\"jcirc\":\"\",\"Jcy\":\"\",\"jcy\":\"\",\"Jfr\":\"\",\"jfr\":\"\",\"jmath\":\"\",\"Jopf\":\"\",\"jopf\":\"\",\"Jscr\":\"\",\"jscr\":\"\",\"Jsercy\":\"\",\"jsercy\":\"\",\"Jukcy\":\"\",\"jukcy\":\"\",\"Kappa\":\"\",\"kappa\":\"\",\"kappav\":\"\",\"Kcedil\":\"\",\"kcedil\":\"\",\"Kcy\":\"\",\"kcy\":\"\",\"Kfr\":\"\",\"kfr\":\"\",\"kgreen\":\"\",\"KHcy\":\"\",\"khcy\":\"\",\"KJcy\":\"\",\"kjcy\":\"\",\"Kopf\":\"\",\"kopf\":\"\",\"Kscr\":\"\",\"kscr\":\"\",\"lAarr\":\"\",\"Lacute\":\"\",\"lacute\":\"\",\"laemptyv\":\"\",\"lagran\":\"\",\"Lambda\":\"\",\"lambda\":\"\",\"lang\":\"\",\"Lang\":\"\",\"langd\":\"\",\"langle\":\"\",\"lap\":\"\",\"Laplacetrf\":\"\",\"laquo\":\"\",\"larrb\":\"\",\"larrbfs\":\"\",\"larr\":\"\",\"Larr\":\"\",\"lArr\":\"\",\"larrfs\":\"\",\"larrhk\":\"\",\"larrlp\":\"\",\"larrpl\":\"\",\"larrsim\":\"\",\"larrtl\":\"\",\"latail\":\"\",\"lAtail\":\"\",\"lat\":\"\",\"late\":\"\",\"lates\":\"\",\"lbarr\":\"\",\"lBarr\":\"\",\"lbbrk\":\"\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"\",\"lbrksld\":\"\",\"lbrkslu\":\"\",\"Lcaron\":\"\",\"lcaron\":\"\",\"Lcedil\":\"\",\"lcedil\":\"\",\"lceil\":\"\",\"lcub\":\"{\",\"Lcy\":\"\",\"lcy\":\"\",\"ldca\":\"\",\"ldquo\":\"\",\"ldquor\":\"\",\"ldrdhar\":\"\",\"ldrushar\":\"\",\"ldsh\":\"\",\"le\":\"\",\"lE\":\"\",\"LeftAngleBracket\":\"\",\"LeftArrowBar\":\"\",\"leftarrow\":\"\",\"LeftArrow\":\"\",\"Leftarrow\":\"\",\"LeftArrowRightArrow\":\"\",\"leftarrowtail\":\"\",\"LeftCeiling\":\"\",\"LeftDoubleBracket\":\"\",\"LeftDownTeeVector\":\"\",\"LeftDownVectorBar\":\"\",\"LeftDownVector\":\"\",\"LeftFloor\":\"\",\"leftharpoondown\":\"\",\"leftharpoonup\":\"\",\"leftleftarrows\":\"\",\"leftrightarrow\":\"\",\"LeftRightArrow\":\"\",\"Leftrightarrow\":\"\",\"leftrightarrows\":\"\",\"leftrightharpoons\":\"\",\"leftrightsquigarrow\":\"\",\"LeftRightVector\":\"\",\"LeftTeeArrow\":\"\",\"LeftTee\":\"\",\"LeftTeeVector\":\"\",\"leftthreetimes\":\"\",\"LeftTriangleBar\":\"\",\"LeftTriangle\":\"\",\"LeftTriangleEqual\":\"\",\"LeftUpDownVector\":\"\",\"LeftUpTeeVector\":\"\",\"LeftUpVectorBar\":\"\",\"LeftUpVector\":\"\",\"LeftVectorBar\":\"\",\"LeftVector\":\"\",\"lEg\":\"\",\"leg\":\"\",\"leq\":\"\",\"leqq\":\"\",\"leqslant\":\"\",\"lescc\":\"\",\"les\":\"\",\"lesdot\":\"\",\"lesdoto\":\"\",\"lesdotor\":\"\",\"lesg\":\"\",\"lesges\":\"\",\"lessapprox\":\"\",\"lessdot\":\"\",\"lesseqgtr\":\"\",\"lesseqqgtr\":\"\",\"LessEqualGreater\":\"\",\"LessFullEqual\":\"\",\"LessGreater\":\"\",\"lessgtr\":\"\",\"LessLess\":\"\",\"lesssim\":\"\",\"LessSlantEqual\":\"\",\"LessTilde\":\"\",\"lfisht\":\"\",\"lfloor\":\"\",\"Lfr\":\"\",\"lfr\":\"\",\"lg\":\"\",\"lgE\":\"\",\"lHar\":\"\",\"lhard\":\"\",\"lharu\":\"\",\"lharul\":\"\",\"lhblk\":\"\",\"LJcy\":\"\",\"ljcy\":\"\",\"llarr\":\"\",\"ll\":\"\",\"Ll\":\"\",\"llcorner\":\"\",\"Lleftarrow\":\"\",\"llhard\":\"\",\"lltri\":\"\",\"Lmidot\":\"\",\"lmidot\":\"\",\"lmoustache\":\"\",\"lmoust\":\"\",\"lnap\":\"\",\"lnapprox\":\"\",\"lne\":\"\",\"lnE\":\"\",\"lneq\":\"\",\"lneqq\":\"\",\"lnsim\":\"\",\"loang\":\"\",\"loarr\":\"\",\"lobrk\":\"\",\"longleftarrow\":\"\",\"LongLeftArrow\":\"\",\"Longleftarrow\":\"\",\"longleftrightarrow\":\"\",\"LongLeftRightArrow\":\"\",\"Longleftrightarrow\":\"\",\"longmapsto\":\"\",\"longrightarrow\":\"\",\"LongRightArrow\":\"\",\"Longrightarrow\":\"\",\"looparrowleft\":\"\",\"looparrowright\":\"\",\"lopar\":\"\",\"Lopf\":\"\",\"lopf\":\"\",\"loplus\":\"\",\"lotimes\":\"\",\"lowast\":\"\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"\",\"LowerRightArrow\":\"\",\"loz\":\"\",\"lozenge\":\"\",\"lozf\":\"\",\"lpar\":\"(\",\"lparlt\":\"\",\"lrarr\":\"\",\"lrcorner\":\"\",\"lrhar\":\"\",\"lrhard\":\"\",\"lrm\":\"\",\"lrtri\":\"\",\"lsaquo\":\"\",\"lscr\":\"\",\"Lscr\":\"\",\"lsh\":\"\",\"Lsh\":\"\",\"lsim\":\"\",\"lsime\":\"\",\"lsimg\":\"\",\"lsqb\":\"[\",\"lsquo\":\"\",\"lsquor\":\"\",\"Lstrok\":\"\",\"lstrok\":\"\",\"ltcc\":\"\",\"ltcir\":\"\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"\",\"ltdot\":\"\",\"lthree\":\"\",\"ltimes\":\"\",\"ltlarr\":\"\",\"ltquest\":\"\",\"ltri\":\"\",\"ltrie\":\"\",\"ltrif\":\"\",\"ltrPar\":\"\",\"lurdshar\":\"\",\"luruhar\":\"\",\"lvertneqq\":\"\",\"lvnE\":\"\",\"macr\":\"\",\"male\":\"\",\"malt\":\"\",\"maltese\":\"\",\"Map\":\"\",\"map\":\"\",\"mapsto\":\"\",\"mapstodown\":\"\",\"mapstoleft\":\"\",\"mapstoup\":\"\",\"marker\":\"\",\"mcomma\":\"\",\"Mcy\":\"\",\"mcy\":\"\",\"mdash\":\"\",\"mDDot\":\"\",\"measuredangle\":\"\",\"MediumSpace\":\"\",\"Mellintrf\":\"\",\"Mfr\":\"\",\"mfr\":\"\",\"mho\":\"\",\"micro\":\"\",\"midast\":\"*\",\"midcir\":\"\",\"mid\":\"\",\"middot\":\"\",\"minusb\":\"\",\"minus\":\"\",\"minusd\":\"\",\"minusdu\":\"\",\"MinusPlus\":\"\",\"mlcp\":\"\",\"mldr\":\"\",\"mnplus\":\"\",\"models\":\"\",\"Mopf\":\"\",\"mopf\":\"\",\"mp\":\"\",\"mscr\":\"\",\"Mscr\":\"\",\"mstpos\":\"\",\"Mu\":\"\",\"mu\":\"\",\"multimap\":\"\",\"mumap\":\"\",\"nabla\":\"\",\"Nacute\":\"\",\"nacute\":\"\",\"nang\":\"\",\"nap\":\"\",\"napE\":\"\",\"napid\":\"\",\"napos\":\"\",\"napprox\":\"\",\"natural\":\"\",\"naturals\":\"\",\"natur\":\"\",\"nbsp\":\"\",\"nbump\":\"\",\"nbumpe\":\"\",\"ncap\":\"\",\"Ncaron\":\"\",\"ncaron\":\"\",\"Ncedil\":\"\",\"ncedil\":\"\",\"ncong\":\"\",\"ncongdot\":\"\",\"ncup\":\"\",\"Ncy\":\"\",\"ncy\":\"\",\"ndash\":\"\",\"nearhk\":\"\",\"nearr\":\"\",\"neArr\":\"\",\"nearrow\":\"\",\"ne\":\"\",\"nedot\":\"\",\"NegativeMediumSpace\":\"\",\"NegativeThickSpace\":\"\",\"NegativeThinSpace\":\"\",\"NegativeVeryThinSpace\":\"\",\"nequiv\":\"\",\"nesear\":\"\",\"nesim\":\"\",\"NestedGreaterGreater\":\"\",\"NestedLessLess\":\"\",\"NewLine\":\"\\n\",\"nexist\":\"\",\"nexists\":\"\",\"Nfr\":\"\",\"nfr\":\"\",\"ngE\":\"\",\"nge\":\"\",\"ngeq\":\"\",\"ngeqq\":\"\",\"ngeqslant\":\"\",\"nges\":\"\",\"nGg\":\"\",\"ngsim\":\"\",\"nGt\":\"\",\"ngt\":\"\",\"ngtr\":\"\",\"nGtv\":\"\",\"nharr\":\"\",\"nhArr\":\"\",\"nhpar\":\"\",\"ni\":\"\",\"nis\":\"\",\"nisd\":\"\",\"niv\":\"\",\"NJcy\":\"\",\"njcy\":\"\",\"nlarr\":\"\",\"nlArr\":\"\",\"nldr\":\"\",\"nlE\":\"\",\"nle\":\"\",\"nleftarrow\":\"\",\"nLeftarrow\":\"\",\"nleftrightarrow\":\"\",\"nLeftrightarrow\":\"\",\"nleq\":\"\",\"nleqq\":\"\",\"nleqslant\":\"\",\"nles\":\"\",\"nless\":\"\",\"nLl\":\"\",\"nlsim\":\"\",\"nLt\":\"\",\"nlt\":\"\",\"nltri\":\"\",\"nltrie\":\"\",\"nLtv\":\"\",\"nmid\":\"\",\"NoBreak\":\"\",\"NonBreakingSpace\":\"\",\"nopf\":\"\",\"Nopf\":\"\",\"Not\":\"\",\"not\":\"\",\"NotCongruent\":\"\",\"NotCupCap\":\"\",\"NotDoubleVerticalBar\":\"\",\"NotElement\":\"\",\"NotEqual\":\"\",\"NotEqualTilde\":\"\",\"NotExists\":\"\",\"NotGreater\":\"\",\"NotGreaterEqual\":\"\",\"NotGreaterFullEqual\":\"\",\"NotGreaterGreater\":\"\",\"NotGreaterLess\":\"\",\"NotGreaterSlantEqual\":\"\",\"NotGreaterTilde\":\"\",\"NotHumpDownHump\":\"\",\"NotHumpEqual\":\"\",\"notin\":\"\",\"notindot\":\"\",\"notinE\":\"\",\"notinva\":\"\",\"notinvb\":\"\",\"notinvc\":\"\",\"NotLeftTriangleBar\":\"\",\"NotLeftTriangle\":\"\",\"NotLeftTriangleEqual\":\"\",\"NotLess\":\"\",\"NotLessEqual\":\"\",\"NotLessGreater\":\"\",\"NotLessLess\":\"\",\"NotLessSlantEqual\":\"\",\"NotLessTilde\":\"\",\"NotNestedGreaterGreater\":\"\",\"NotNestedLessLess\":\"\",\"notni\":\"\",\"notniva\":\"\",\"notnivb\":\"\",\"notnivc\":\"\",\"NotPrecedes\":\"\",\"NotPrecedesEqual\":\"\",\"NotPrecedesSlantEqual\":\"\",\"NotReverseElement\":\"\",\"NotRightTriangleBar\":\"\",\"NotRightTriangle\":\"\",\"NotRightTriangleEqual\":\"\",\"NotSquareSubset\":\"\",\"NotSquareSubsetEqual\":\"\",\"NotSquareSuperset\":\"\",\"NotSquareSupersetEqual\":\"\",\"NotSubset\":\"\",\"NotSubsetEqual\":\"\",\"NotSucceeds\":\"\",\"NotSucceedsEqual\":\"\",\"NotSucceedsSlantEqual\":\"\",\"NotSucceedsTilde\":\"\",\"NotSuperset\":\"\",\"NotSupersetEqual\":\"\",\"NotTilde\":\"\",\"NotTildeEqual\":\"\",\"NotTildeFullEqual\":\"\",\"NotTildeTilde\":\"\",\"NotVerticalBar\":\"\",\"nparallel\":\"\",\"npar\":\"\",\"nparsl\":\"\",\"npart\":\"\",\"npolint\":\"\",\"npr\":\"\",\"nprcue\":\"\",\"nprec\":\"\",\"npreceq\":\"\",\"npre\":\"\",\"nrarrc\":\"\",\"nrarr\":\"\",\"nrArr\":\"\",\"nrarrw\":\"\",\"nrightarrow\":\"\",\"nRightarrow\":\"\",\"nrtri\":\"\",\"nrtrie\":\"\",\"nsc\":\"\",\"nsccue\":\"\",\"nsce\":\"\",\"Nscr\":\"\",\"nscr\":\"\",\"nshortmid\":\"\",\"nshortparallel\":\"\",\"nsim\":\"\",\"nsime\":\"\",\"nsimeq\":\"\",\"nsmid\":\"\",\"nspar\":\"\",\"nsqsube\":\"\",\"nsqsupe\":\"\",\"nsub\":\"\",\"nsubE\":\"\",\"nsube\":\"\",\"nsubset\":\"\",\"nsubseteq\":\"\",\"nsubseteqq\":\"\",\"nsucc\":\"\",\"nsucceq\":\"\",\"nsup\":\"\",\"nsupE\":\"\",\"nsupe\":\"\",\"nsupset\":\"\",\"nsupseteq\":\"\",\"nsupseteqq\":\"\",\"ntgl\":\"\",\"Ntilde\":\"\",\"ntilde\":\"\",\"ntlg\":\"\",\"ntriangleleft\":\"\",\"ntrianglelefteq\":\"\",\"ntriangleright\":\"\",\"ntrianglerighteq\":\"\",\"Nu\":\"\",\"nu\":\"\",\"num\":\"#\",\"numero\":\"\",\"numsp\":\"\",\"nvap\":\"\",\"nvdash\":\"\",\"nvDash\":\"\",\"nVdash\":\"\",\"nVDash\":\"\",\"nvge\":\"\",\"nvgt\":\">\",\"nvHarr\":\"\",\"nvinfin\":\"\",\"nvlArr\":\"\",\"nvle\":\"\",\"nvlt\":\"<\",\"nvltrie\":\"\",\"nvrArr\":\"\",\"nvrtrie\":\"\",\"nvsim\":\"\",\"nwarhk\":\"\",\"nwarr\":\"\",\"nwArr\":\"\",\"nwarrow\":\"\",\"nwnear\":\"\",\"Oacute\":\"\",\"oacute\":\"\",\"oast\":\"\",\"Ocirc\":\"\",\"ocirc\":\"\",\"ocir\":\"\",\"Ocy\":\"\",\"ocy\":\"\",\"odash\":\"\",\"Odblac\":\"\",\"odblac\":\"\",\"odiv\":\"\",\"odot\":\"\",\"odsold\":\"\",\"OElig\":\"\",\"oelig\":\"\",\"ofcir\":\"\",\"Ofr\":\"\",\"ofr\":\"\",\"ogon\":\"\",\"Ograve\":\"\",\"ograve\":\"\",\"ogt\":\"\",\"ohbar\":\"\",\"ohm\":\"\",\"oint\":\"\",\"olarr\":\"\",\"olcir\":\"\",\"olcross\":\"\",\"oline\":\"\",\"olt\":\"\",\"Omacr\":\"\",\"omacr\":\"\",\"Omega\":\"\",\"omega\":\"\",\"Omicron\":\"\",\"omicron\":\"\",\"omid\":\"\",\"ominus\":\"\",\"Oopf\":\"\",\"oopf\":\"\",\"opar\":\"\",\"OpenCurlyDoubleQuote\":\"\",\"OpenCurlyQuote\":\"\",\"operp\":\"\",\"oplus\":\"\",\"orarr\":\"\",\"Or\":\"\",\"or\":\"\",\"ord\":\"\",\"order\":\"\",\"orderof\":\"\",\"ordf\":\"\",\"ordm\":\"\",\"origof\":\"\",\"oror\":\"\",\"orslope\":\"\",\"orv\":\"\",\"oS\":\"\",\"Oscr\":\"\",\"oscr\":\"\",\"Oslash\":\"\",\"oslash\":\"\",\"osol\":\"\",\"Otilde\":\"\",\"otilde\":\"\",\"otimesas\":\"\",\"Otimes\":\"\",\"otimes\":\"\",\"Ouml\":\"\",\"ouml\":\"\",\"ovbar\":\"\",\"OverBar\":\"\",\"OverBrace\":\"\",\"OverBracket\":\"\",\"OverParenthesis\":\"\",\"para\":\"\",\"parallel\":\"\",\"par\":\"\",\"parsim\":\"\",\"parsl\":\"\",\"part\":\"\",\"PartialD\":\"\",\"Pcy\":\"\",\"pcy\":\"\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"\",\"perp\":\"\",\"pertenk\":\"\",\"Pfr\":\"\",\"pfr\":\"\",\"Phi\":\"\",\"phi\":\"\",\"phiv\":\"\",\"phmmat\":\"\",\"phone\":\"\",\"Pi\":\"\",\"pi\":\"\",\"pitchfork\":\"\",\"piv\":\"\",\"planck\":\"\",\"planckh\":\"\",\"plankv\":\"\",\"plusacir\":\"\",\"plusb\":\"\",\"pluscir\":\"\",\"plus\":\"+\",\"plusdo\":\"\",\"plusdu\":\"\",\"pluse\":\"\",\"PlusMinus\":\"\",\"plusmn\":\"\",\"plussim\":\"\",\"plustwo\":\"\",\"pm\":\"\",\"Poincareplane\":\"\",\"pointint\":\"\",\"popf\":\"\",\"Popf\":\"\",\"pound\":\"\",\"prap\":\"\",\"Pr\":\"\",\"pr\":\"\",\"prcue\":\"\",\"precapprox\":\"\",\"prec\":\"\",\"preccurlyeq\":\"\",\"Precedes\":\"\",\"PrecedesEqual\":\"\",\"PrecedesSlantEqual\":\"\",\"PrecedesTilde\":\"\",\"preceq\":\"\",\"precnapprox\":\"\",\"precneqq\":\"\",\"precnsim\":\"\",\"pre\":\"\",\"prE\":\"\",\"precsim\":\"\",\"prime\":\"\",\"Prime\":\"\",\"primes\":\"\",\"prnap\":\"\",\"prnE\":\"\",\"prnsim\":\"\",\"prod\":\"\",\"Product\":\"\",\"profalar\":\"\",\"profline\":\"\",\"profsurf\":\"\",\"prop\":\"\",\"Proportional\":\"\",\"Proportion\":\"\",\"propto\":\"\",\"prsim\":\"\",\"prurel\":\"\",\"Pscr\":\"\",\"pscr\":\"\",\"Psi\":\"\",\"psi\":\"\",\"puncsp\":\"\",\"Qfr\":\"\",\"qfr\":\"\",\"qint\":\"\",\"qopf\":\"\",\"Qopf\":\"\",\"qprime\":\"\",\"Qscr\":\"\",\"qscr\":\"\",\"quaternions\":\"\",\"quatint\":\"\",\"quest\":\"?\",\"questeq\":\"\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"rAarr\":\"\",\"race\":\"\",\"Racute\":\"\",\"racute\":\"\",\"radic\":\"\",\"raemptyv\":\"\",\"rang\":\"\",\"Rang\":\"\",\"rangd\":\"\",\"range\":\"\",\"rangle\":\"\",\"raquo\":\"\",\"rarrap\":\"\",\"rarrb\":\"\",\"rarrbfs\":\"\",\"rarrc\":\"\",\"rarr\":\"\",\"Rarr\":\"\",\"rArr\":\"\",\"rarrfs\":\"\",\"rarrhk\":\"\",\"rarrlp\":\"\",\"rarrpl\":\"\",\"rarrsim\":\"\",\"Rarrtl\":\"\",\"rarrtl\":\"\",\"rarrw\":\"\",\"ratail\":\"\",\"rAtail\":\"\",\"ratio\":\"\",\"rationals\":\"\",\"rbarr\":\"\",\"rBarr\":\"\",\"RBarr\":\"\",\"rbbrk\":\"\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"\",\"rbrksld\":\"\",\"rbrkslu\":\"\",\"Rcaron\":\"\",\"rcaron\":\"\",\"Rcedil\":\"\",\"rcedil\":\"\",\"rceil\":\"\",\"rcub\":\"}\",\"Rcy\":\"\",\"rcy\":\"\",\"rdca\":\"\",\"rdldhar\":\"\",\"rdquo\":\"\",\"rdquor\":\"\",\"rdsh\":\"\",\"real\":\"\",\"realine\":\"\",\"realpart\":\"\",\"reals\":\"\",\"Re\":\"\",\"rect\":\"\",\"reg\":\"\",\"REG\":\"\",\"ReverseElement\":\"\",\"ReverseEquilibrium\":\"\",\"ReverseUpEquilibrium\":\"\",\"rfisht\":\"\",\"rfloor\":\"\",\"rfr\":\"\",\"Rfr\":\"\",\"rHar\":\"\",\"rhard\":\"\",\"rharu\":\"\",\"rharul\":\"\",\"Rho\":\"\",\"rho\":\"\",\"rhov\":\"\",\"RightAngleBracket\":\"\",\"RightArrowBar\":\"\",\"rightarrow\":\"\",\"RightArrow\":\"\",\"Rightarrow\":\"\",\"RightArrowLeftArrow\":\"\",\"rightarrowtail\":\"\",\"RightCeiling\":\"\",\"RightDoubleBracket\":\"\",\"RightDownTeeVector\":\"\",\"RightDownVectorBar\":\"\",\"RightDownVector\":\"\",\"RightFloor\":\"\",\"rightharpoondown\":\"\",\"rightharpoonup\":\"\",\"rightleftarrows\":\"\",\"rightleftharpoons\":\"\",\"rightrightarrows\":\"\",\"rightsquigarrow\":\"\",\"RightTeeArrow\":\"\",\"RightTee\":\"\",\"RightTeeVector\":\"\",\"rightthreetimes\":\"\",\"RightTriangleBar\":\"\",\"RightTriangle\":\"\",\"RightTriangleEqual\":\"\",\"RightUpDownVector\":\"\",\"RightUpTeeVector\":\"\",\"RightUpVectorBar\":\"\",\"RightUpVector\":\"\",\"RightVectorBar\":\"\",\"RightVector\":\"\",\"ring\":\"\",\"risingdotseq\":\"\",\"rlarr\":\"\",\"rlhar\":\"\",\"rlm\":\"\",\"rmoustache\":\"\",\"rmoust\":\"\",\"rnmid\":\"\",\"roang\":\"\",\"roarr\":\"\",\"robrk\":\"\",\"ropar\":\"\",\"ropf\":\"\",\"Ropf\":\"\",\"roplus\":\"\",\"rotimes\":\"\",\"RoundImplies\":\"\",\"rpar\":\")\",\"rpargt\":\"\",\"rppolint\":\"\",\"rrarr\":\"\",\"Rrightarrow\":\"\",\"rsaquo\":\"\",\"rscr\":\"\",\"Rscr\":\"\",\"rsh\":\"\",\"Rsh\":\"\",\"rsqb\":\"]\",\"rsquo\":\"\",\"rsquor\":\"\",\"rthree\":\"\",\"rtimes\":\"\",\"rtri\":\"\",\"rtrie\":\"\",\"rtrif\":\"\",\"rtriltri\":\"\",\"RuleDelayed\":\"\",\"ruluhar\":\"\",\"rx\":\"\",\"Sacute\":\"\",\"sacute\":\"\",\"sbquo\":\"\",\"scap\":\"\",\"Scaron\":\"\",\"scaron\":\"\",\"Sc\":\"\",\"sc\":\"\",\"sccue\":\"\",\"sce\":\"\",\"scE\":\"\",\"Scedil\":\"\",\"scedil\":\"\",\"Scirc\":\"\",\"scirc\":\"\",\"scnap\":\"\",\"scnE\":\"\",\"scnsim\":\"\",\"scpolint\":\"\",\"scsim\":\"\",\"Scy\":\"\",\"scy\":\"\",\"sdotb\":\"\",\"sdot\":\"\",\"sdote\":\"\",\"searhk\":\"\",\"searr\":\"\",\"seArr\":\"\",\"searrow\":\"\",\"sect\":\"\",\"semi\":\";\",\"seswar\":\"\",\"setminus\":\"\",\"setmn\":\"\",\"sext\":\"\",\"Sfr\":\"\",\"sfr\":\"\",\"sfrown\":\"\",\"sharp\":\"\",\"SHCHcy\":\"\",\"shchcy\":\"\",\"SHcy\":\"\",\"shcy\":\"\",\"ShortDownArrow\":\"\",\"ShortLeftArrow\":\"\",\"shortmid\":\"\",\"shortparallel\":\"\",\"ShortRightArrow\":\"\",\"ShortUpArrow\":\"\",\"shy\":\"\",\"Sigma\":\"\",\"sigma\":\"\",\"sigmaf\":\"\",\"sigmav\":\"\",\"sim\":\"\",\"simdot\":\"\",\"sime\":\"\",\"simeq\":\"\",\"simg\":\"\",\"simgE\":\"\",\"siml\":\"\",\"simlE\":\"\",\"simne\":\"\",\"simplus\":\"\",\"simrarr\":\"\",\"slarr\":\"\",\"SmallCircle\":\"\",\"smallsetminus\":\"\",\"smashp\":\"\",\"smeparsl\":\"\",\"smid\":\"\",\"smile\":\"\",\"smt\":\"\",\"smte\":\"\",\"smtes\":\"\",\"SOFTcy\":\"\",\"softcy\":\"\",\"solbar\":\"\",\"solb\":\"\",\"sol\":\"/\",\"Sopf\":\"\",\"sopf\":\"\",\"spades\":\"\",\"spadesuit\":\"\",\"spar\":\"\",\"sqcap\":\"\",\"sqcaps\":\"\",\"sqcup\":\"\",\"sqcups\":\"\",\"Sqrt\":\"\",\"sqsub\":\"\",\"sqsube\":\"\",\"sqsubset\":\"\",\"sqsubseteq\":\"\",\"sqsup\":\"\",\"sqsupe\":\"\",\"sqsupset\":\"\",\"sqsupseteq\":\"\",\"square\":\"\",\"Square\":\"\",\"SquareIntersection\":\"\",\"SquareSubset\":\"\",\"SquareSubsetEqual\":\"\",\"SquareSuperset\":\"\",\"SquareSupersetEqual\":\"\",\"SquareUnion\":\"\",\"squarf\":\"\",\"squ\":\"\",\"squf\":\"\",\"srarr\":\"\",\"Sscr\":\"\",\"sscr\":\"\",\"ssetmn\":\"\",\"ssmile\":\"\",\"sstarf\":\"\",\"Star\":\"\",\"star\":\"\",\"starf\":\"\",\"straightepsilon\":\"\",\"straightphi\":\"\",\"strns\":\"\",\"sub\":\"\",\"Sub\":\"\",\"subdot\":\"\",\"subE\":\"\",\"sube\":\"\",\"subedot\":\"\",\"submult\":\"\",\"subnE\":\"\",\"subne\":\"\",\"subplus\":\"\",\"subrarr\":\"\",\"subset\":\"\",\"Subset\":\"\",\"subseteq\":\"\",\"subseteqq\":\"\",\"SubsetEqual\":\"\",\"subsetneq\":\"\",\"subsetneqq\":\"\",\"subsim\":\"\",\"subsub\":\"\",\"subsup\":\"\",\"succapprox\":\"\",\"succ\":\"\",\"succcurlyeq\":\"\",\"Succeeds\":\"\",\"SucceedsEqual\":\"\",\"SucceedsSlantEqual\":\"\",\"SucceedsTilde\":\"\",\"succeq\":\"\",\"succnapprox\":\"\",\"succneqq\":\"\",\"succnsim\":\"\",\"succsim\":\"\",\"SuchThat\":\"\",\"sum\":\"\",\"Sum\":\"\",\"sung\":\"\",\"sup1\":\"\",\"sup2\":\"\",\"sup3\":\"\",\"sup\":\"\",\"Sup\":\"\",\"supdot\":\"\",\"supdsub\":\"\",\"supE\":\"\",\"supe\":\"\",\"supedot\":\"\",\"Superset\":\"\",\"SupersetEqual\":\"\",\"suphsol\":\"\",\"suphsub\":\"\",\"suplarr\":\"\",\"supmult\":\"\",\"supnE\":\"\",\"supne\":\"\",\"supplus\":\"\",\"supset\":\"\",\"Supset\":\"\",\"supseteq\":\"\",\"supseteqq\":\"\",\"supsetneq\":\"\",\"supsetneqq\":\"\",\"supsim\":\"\",\"supsub\":\"\",\"supsup\":\"\",\"swarhk\":\"\",\"swarr\":\"\",\"swArr\":\"\",\"swarrow\":\"\",\"swnwar\":\"\",\"szlig\":\"\",\"Tab\":\"\\t\",\"target\":\"\",\"Tau\":\"\",\"tau\":\"\",\"tbrk\":\"\",\"Tcaron\":\"\",\"tcaron\":\"\",\"Tcedil\":\"\",\"tcedil\":\"\",\"Tcy\":\"\",\"tcy\":\"\",\"tdot\":\"\",\"telrec\":\"\",\"Tfr\":\"\",\"tfr\":\"\",\"there4\":\"\",\"therefore\":\"\",\"Therefore\":\"\",\"Theta\":\"\",\"theta\":\"\",\"thetasym\":\"\",\"thetav\":\"\",\"thickapprox\":\"\",\"thicksim\":\"\",\"ThickSpace\":\"\",\"ThinSpace\":\"\",\"thinsp\":\"\",\"thkap\":\"\",\"thksim\":\"\",\"THORN\":\"\",\"thorn\":\"\",\"tilde\":\"\",\"Tilde\":\"\",\"TildeEqual\":\"\",\"TildeFullEqual\":\"\",\"TildeTilde\":\"\",\"timesbar\":\"\",\"timesb\":\"\",\"times\":\"\",\"timesd\":\"\",\"tint\":\"\",\"toea\":\"\",\"topbot\":\"\",\"topcir\":\"\",\"top\":\"\",\"Topf\":\"\",\"topf\":\"\",\"topfork\":\"\",\"tosa\":\"\",\"tprime\":\"\",\"trade\":\"\",\"TRADE\":\"\",\"triangle\":\"\",\"triangledown\":\"\",\"triangleleft\":\"\",\"trianglelefteq\":\"\",\"triangleq\":\"\",\"triangleright\":\"\",\"trianglerighteq\":\"\",\"tridot\":\"\",\"trie\":\"\",\"triminus\":\"\",\"TripleDot\":\"\",\"triplus\":\"\",\"trisb\":\"\",\"tritime\":\"\",\"trpezium\":\"\",\"Tscr\":\"\",\"tscr\":\"\",\"TScy\":\"\",\"tscy\":\"\",\"TSHcy\":\"\",\"tshcy\":\"\",\"Tstrok\":\"\",\"tstrok\":\"\",\"twixt\":\"\",\"twoheadleftarrow\":\"\",\"twoheadrightarrow\":\"\",\"Uacute\":\"\",\"uacute\":\"\",\"uarr\":\"\",\"Uarr\":\"\",\"uArr\":\"\",\"Uarrocir\":\"\",\"Ubrcy\":\"\",\"ubrcy\":\"\",\"Ubreve\":\"\",\"ubreve\":\"\",\"Ucirc\":\"\",\"ucirc\":\"\",\"Ucy\":\"\",\"ucy\":\"\",\"udarr\":\"\",\"Udblac\":\"\",\"udblac\":\"\",\"udhar\":\"\",\"ufisht\":\"\",\"Ufr\":\"\",\"ufr\":\"\",\"Ugrave\":\"\",\"ugrave\":\"\",\"uHar\":\"\",\"uharl\":\"\",\"uharr\":\"\",\"uhblk\":\"\",\"ulcorn\":\"\",\"ulcorner\":\"\",\"ulcrop\":\"\",\"ultri\":\"\",\"Umacr\":\"\",\"umacr\":\"\",\"uml\":\"\",\"UnderBar\":\"_\",\"UnderBrace\":\"\",\"UnderBracket\":\"\",\"UnderParenthesis\":\"\",\"Union\":\"\",\"UnionPlus\":\"\",\"Uogon\":\"\",\"uogon\":\"\",\"Uopf\":\"\",\"uopf\":\"\",\"UpArrowBar\":\"\",\"uparrow\":\"\",\"UpArrow\":\"\",\"Uparrow\":\"\",\"UpArrowDownArrow\":\"\",\"updownarrow\":\"\",\"UpDownArrow\":\"\",\"Updownarrow\":\"\",\"UpEquilibrium\":\"\",\"upharpoonleft\":\"\",\"upharpoonright\":\"\",\"uplus\":\"\",\"UpperLeftArrow\":\"\",\"UpperRightArrow\":\"\",\"upsi\":\"\",\"Upsi\":\"\",\"upsih\":\"\",\"Upsilon\":\"\",\"upsilon\":\"\",\"UpTeeArrow\":\"\",\"UpTee\":\"\",\"upuparrows\":\"\",\"urcorn\":\"\",\"urcorner\":\"\",\"urcrop\":\"\",\"Uring\":\"\",\"uring\":\"\",\"urtri\":\"\",\"Uscr\":\"\",\"uscr\":\"\",\"utdot\":\"\",\"Utilde\":\"\",\"utilde\":\"\",\"utri\":\"\",\"utrif\":\"\",\"uuarr\":\"\",\"Uuml\":\"\",\"uuml\":\"\",\"uwangle\":\"\",\"vangrt\":\"\",\"varepsilon\":\"\",\"varkappa\":\"\",\"varnothing\":\"\",\"varphi\":\"\",\"varpi\":\"\",\"varpropto\":\"\",\"varr\":\"\",\"vArr\":\"\",\"varrho\":\"\",\"varsigma\":\"\",\"varsubsetneq\":\"\",\"varsubsetneqq\":\"\",\"varsupsetneq\":\"\",\"varsupsetneqq\":\"\",\"vartheta\":\"\",\"vartriangleleft\":\"\",\"vartriangleright\":\"\",\"vBar\":\"\",\"Vbar\":\"\",\"vBarv\":\"\",\"Vcy\":\"\",\"vcy\":\"\",\"vdash\":\"\",\"vDash\":\"\",\"Vdash\":\"\",\"VDash\":\"\",\"Vdashl\":\"\",\"veebar\":\"\",\"vee\":\"\",\"Vee\":\"\",\"veeeq\":\"\",\"vellip\":\"\",\"verbar\":\"|\",\"Verbar\":\"\",\"vert\":\"|\",\"Vert\":\"\",\"VerticalBar\":\"\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"\",\"VerticalTilde\":\"\",\"VeryThinSpace\":\"\",\"Vfr\":\"\",\"vfr\":\"\",\"vltri\":\"\",\"vnsub\":\"\",\"vnsup\":\"\",\"Vopf\":\"\",\"vopf\":\"\",\"vprop\":\"\",\"vrtri\":\"\",\"Vscr\":\"\",\"vscr\":\"\",\"vsubnE\":\"\",\"vsubne\":\"\",\"vsupnE\":\"\",\"vsupne\":\"\",\"Vvdash\":\"\",\"vzigzag\":\"\",\"Wcirc\":\"\",\"wcirc\":\"\",\"wedbar\":\"\",\"wedge\":\"\",\"Wedge\":\"\",\"wedgeq\":\"\",\"weierp\":\"\",\"Wfr\":\"\",\"wfr\":\"\",\"Wopf\":\"\",\"wopf\":\"\",\"wp\":\"\",\"wr\":\"\",\"wreath\":\"\",\"Wscr\":\"\",\"wscr\":\"\",\"xcap\":\"\",\"xcirc\":\"\",\"xcup\":\"\",\"xdtri\":\"\",\"Xfr\":\"\",\"xfr\":\"\",\"xharr\":\"\",\"xhArr\":\"\",\"Xi\":\"\",\"xi\":\"\",\"xlarr\":\"\",\"xlArr\":\"\",\"xmap\":\"\",\"xnis\":\"\",\"xodot\":\"\",\"Xopf\":\"\",\"xopf\":\"\",\"xoplus\":\"\",\"xotime\":\"\",\"xrarr\":\"\",\"xrArr\":\"\",\"Xscr\":\"\",\"xscr\":\"\",\"xsqcup\":\"\",\"xuplus\":\"\",\"xutri\":\"\",\"xvee\":\"\",\"xwedge\":\"\",\"Yacute\":\"\",\"yacute\":\"\",\"YAcy\":\"\",\"yacy\":\"\",\"Ycirc\":\"\",\"ycirc\":\"\",\"Ycy\":\"\",\"ycy\":\"\",\"yen\":\"\",\"Yfr\":\"\",\"yfr\":\"\",\"YIcy\":\"\",\"yicy\":\"\",\"Yopf\":\"\",\"yopf\":\"\",\"Yscr\":\"\",\"yscr\":\"\",\"YUcy\":\"\",\"yucy\":\"\",\"yuml\":\"\",\"Yuml\":\"\",\"Zacute\":\"\",\"zacute\":\"\",\"Zcaron\":\"\",\"zcaron\":\"\",\"Zcy\":\"\",\"zcy\":\"\",\"Zdot\":\"\",\"zdot\":\"\",\"zeetrf\":\"\",\"ZeroWidthSpace\":\"\",\"Zeta\":\"\",\"zeta\":\"\",\"zfr\":\"\",\"Zfr\":\"\",\"ZHcy\":\"\",\"zhcy\":\"\",\"zigrarr\":\"\",\"zopf\":\"\",\"Zopf\":\"\",\"Zscr\":\"\",\"zscr\":\"\",\"zwj\":\"\",\"zwnj\":\"\"}");

/***/ }),

/***/ "./node_modules/entities/maps/legacy.json":
/*!************************************************!*\
  !*** ./node_modules/entities/maps/legacy.json ***!
  \************************************************/
/*! exports provided: Aacute, aacute, Acirc, acirc, acute, AElig, aelig, Agrave, agrave, amp, AMP, Aring, aring, Atilde, atilde, Auml, auml, brvbar, Ccedil, ccedil, cedil, cent, copy, COPY, curren, deg, divide, Eacute, eacute, Ecirc, ecirc, Egrave, egrave, ETH, eth, Euml, euml, frac12, frac14, frac34, gt, GT, Iacute, iacute, Icirc, icirc, iexcl, Igrave, igrave, iquest, Iuml, iuml, laquo, lt, LT, macr, micro, middot, nbsp, not, Ntilde, ntilde, Oacute, oacute, Ocirc, ocirc, Ograve, ograve, ordf, ordm, Oslash, oslash, Otilde, otilde, Ouml, ouml, para, plusmn, pound, quot, QUOT, raquo, reg, REG, sect, shy, sup1, sup2, sup3, szlig, THORN, thorn, times, Uacute, uacute, Ucirc, ucirc, Ugrave, ugrave, uml, Uuml, uuml, Yacute, yacute, yen, yuml, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"\",\"aacute\":\"\",\"Acirc\":\"\",\"acirc\":\"\",\"acute\":\"\",\"AElig\":\"\",\"aelig\":\"\",\"Agrave\":\"\",\"agrave\":\"\",\"amp\":\"&\",\"AMP\":\"&\",\"Aring\":\"\",\"aring\":\"\",\"Atilde\":\"\",\"atilde\":\"\",\"Auml\":\"\",\"auml\":\"\",\"brvbar\":\"\",\"Ccedil\":\"\",\"ccedil\":\"\",\"cedil\":\"\",\"cent\":\"\",\"copy\":\"\",\"COPY\":\"\",\"curren\":\"\",\"deg\":\"\",\"divide\":\"\",\"Eacute\":\"\",\"eacute\":\"\",\"Ecirc\":\"\",\"ecirc\":\"\",\"Egrave\":\"\",\"egrave\":\"\",\"ETH\":\"\",\"eth\":\"\",\"Euml\":\"\",\"euml\":\"\",\"frac12\":\"\",\"frac14\":\"\",\"frac34\":\"\",\"gt\":\">\",\"GT\":\">\",\"Iacute\":\"\",\"iacute\":\"\",\"Icirc\":\"\",\"icirc\":\"\",\"iexcl\":\"\",\"Igrave\":\"\",\"igrave\":\"\",\"iquest\":\"\",\"Iuml\":\"\",\"iuml\":\"\",\"laquo\":\"\",\"lt\":\"<\",\"LT\":\"<\",\"macr\":\"\",\"micro\":\"\",\"middot\":\"\",\"nbsp\":\"\",\"not\":\"\",\"Ntilde\":\"\",\"ntilde\":\"\",\"Oacute\":\"\",\"oacute\":\"\",\"Ocirc\":\"\",\"ocirc\":\"\",\"Ograve\":\"\",\"ograve\":\"\",\"ordf\":\"\",\"ordm\":\"\",\"Oslash\":\"\",\"oslash\":\"\",\"Otilde\":\"\",\"otilde\":\"\",\"Ouml\":\"\",\"ouml\":\"\",\"para\":\"\",\"plusmn\":\"\",\"pound\":\"\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"raquo\":\"\",\"reg\":\"\",\"REG\":\"\",\"sect\":\"\",\"shy\":\"\",\"sup1\":\"\",\"sup2\":\"\",\"sup3\":\"\",\"szlig\":\"\",\"THORN\":\"\",\"thorn\":\"\",\"times\":\"\",\"Uacute\":\"\",\"uacute\":\"\",\"Ucirc\":\"\",\"ucirc\":\"\",\"Ugrave\":\"\",\"ugrave\":\"\",\"uml\":\"\",\"Uuml\":\"\",\"uuml\":\"\",\"Yacute\":\"\",\"yacute\":\"\",\"yen\":\"\",\"yuml\":\"\"}");

/***/ }),

/***/ "./node_modules/entities/maps/xml.json":
/*!*********************************************!*\
  !*** ./node_modules/entities/maps/xml.json ***!
  \*********************************************/
/*! exports provided: amp, apos, gt, lt, quot, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"amp\":\"&\",\"apos\":\"'\",\"gt\":\">\",\"lt\":\"<\",\"quot\":\"\\\"\"}");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),

/***/ "./node_modules/format-message-formats/index.js":
/*!******************************************************!*\
  !*** ./node_modules/format-message-formats/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// @flow
var LONG = 'long'
var SHORT = 'short'
var NARROW = 'narrow'
var NUMERIC = 'numeric'
var TWODIGIT = '2-digit'

/**
 * formatting information
 **/
module.exports = {
  number: {
    decimal: {
      style: 'decimal'
    },
    integer: {
      style: 'decimal',
      maximumFractionDigits: 0
    },
    currency: {
      style: 'currency',
      currency: 'USD'
    },
    percent: {
      style: 'percent'
    },
    default: {
      style: 'decimal'
    }
  },
  date: {
    short: {
      month: NUMERIC,
      day: NUMERIC,
      year: TWODIGIT
    },
    medium: {
      month: SHORT,
      day: NUMERIC,
      year: NUMERIC
    },
    long: {
      month: LONG,
      day: NUMERIC,
      year: NUMERIC
    },
    full: {
      month: LONG,
      day: NUMERIC,
      year: NUMERIC,
      weekday: LONG
    },
    default: {
      month: SHORT,
      day: NUMERIC,
      year: NUMERIC
    }
  },
  time: {
    short: {
      hour: NUMERIC,
      minute: NUMERIC
    },
    medium: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC
    },
    long: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC,
      timeZoneName: SHORT
    },
    full: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC,
      timeZoneName: SHORT
    },
    default: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC
    }
  },
  duration: {
    default: {
      hours: {
        minimumIntegerDigits: 1,
        maximumFractionDigits: 0
      },
      minutes: {
        minimumIntegerDigits: 2,
        maximumFractionDigits: 0
      },
      seconds: {
        minimumIntegerDigits: 2,
        maximumFractionDigits: 3
      }
    }
  },
  parseNumberPattern: function (pattern/*: ?string */) {
    if (!pattern) return
    var options = {}
    var currency = pattern.match(/\b[A-Z]{3}\b/i)
    var syms = pattern.replace(/[^]/g, '').length
    if (!syms && currency) syms = 1
    if (syms) {
      options.style = 'currency'
      options.currencyDisplay = syms === 1 ? 'symbol' : syms === 2 ? 'code' : 'name'
      options.currency = currency ? currency[0].toUpperCase() : 'USD'
    } else if (pattern.indexOf('%') >= 0) {
      options.style = 'percent'
    }
    if (!/[@#0]/.test(pattern)) return options.style ? options : undefined
    options.useGrouping = pattern.indexOf(',') >= 0
    if (/E\+?[@#0]+/i.test(pattern) || pattern.indexOf('@') >= 0) {
      var size = pattern.replace(/E\+?[@#0]+|[^@#0]/gi, '')
      options.minimumSignificantDigits = Math.min(Math.max(size.replace(/[^@0]/g, '').length, 1), 21)
      options.maximumSignificantDigits = Math.min(Math.max(size.length, 1), 21)
    } else {
      var parts = pattern.replace(/[^#0.]/g, '').split('.')
      var integer = parts[0]
      var n = integer.length - 1
      while (integer[n] === '0') --n
      options.minimumIntegerDigits = Math.min(Math.max(integer.length - 1 - n, 1), 21)
      var fraction = parts[1] || ''
      n = 0
      while (fraction[n] === '0') ++n
      options.minimumFractionDigits = Math.min(Math.max(n, 0), 20)
      while (fraction[n] === '#') ++n
      options.maximumFractionDigits = Math.min(Math.max(n, 0), 20)
    }
    return options
  },
  parseDatePattern: function (pattern/*: ?string */) {
    if (!pattern) return
    var options = {}
    for (var i = 0; i < pattern.length;) {
      var current = pattern[i]
      var n = 1
      while (pattern[++i] === current) ++n
      switch (current) {
        case 'G':
          options.era = n === 5 ? NARROW : n === 4 ? LONG : SHORT
          break
        case 'y':
        case 'Y':
          options.year = n === 2 ? TWODIGIT : NUMERIC
          break
        case 'M':
        case 'L':
          n = Math.min(Math.max(n - 1, 0), 4)
          options.month = [ NUMERIC, TWODIGIT, SHORT, LONG, NARROW ][n]
          break
        case 'E':
        case 'e':
        case 'c':
          options.weekday = n === 5 ? NARROW : n === 4 ? LONG : SHORT
          break
        case 'd':
        case 'D':
          options.day = n === 2 ? TWODIGIT : NUMERIC
          break
        case 'h':
        case 'K':
          options.hour12 = true
          options.hour = n === 2 ? TWODIGIT : NUMERIC
          break
        case 'H':
        case 'k':
          options.hour12 = false
          options.hour = n === 2 ? TWODIGIT : NUMERIC
          break
        case 'm':
          options.minute = n === 2 ? TWODIGIT : NUMERIC
          break
        case 's':
        case 'S':
          options.second = n === 2 ? TWODIGIT : NUMERIC
          break
        case 'z':
        case 'Z':
        case 'v':
        case 'V':
          options.timeZoneName = n === 1 ? SHORT : LONG
          break
      }
    }
    return Object.keys(options).length ? options : undefined
  }
}


/***/ }),

/***/ "./node_modules/format-message-interpret/index.js":
/*!********************************************************!*\
  !*** ./node_modules/format-message-interpret/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @flow

var formats = __webpack_require__(/*! format-message-formats */ "./node_modules/format-message-formats/index.js")
var lookupClosestLocale = __webpack_require__(/*! lookup-closest-locale */ "./node_modules/lookup-closest-locale/index.js")
var plurals = __webpack_require__(/*! ./plurals */ "./node_modules/format-message-interpret/plurals.js")

/*::
import type {
  AST,
  SubMessages
} from '../format-message-parse'
type Locale = string
type Locales = Locale | Locale[]
type Placeholder = any[] // https://github.com/facebook/flow/issues/4050
export type Type = (Placeholder, Locales) => (any, ?Object) => any
export type Types = { [string]: Type }
*/

exports = module.exports = function interpret (
  ast/*: AST */,
  locale/*:: ?: Locales */,
  types/*:: ?: Types */
)/*: (args?: Object) => string */ {
  return interpretAST(ast, null, locale || 'en', types || {}, true)
}

exports.toParts = function toParts (
  ast/*: AST */,
  locale/*:: ?: Locales */,
  types/*:: ?: Types */
)/*: (args?: Object) => any[] */ {
  return interpretAST(ast, null, locale || 'en', types || {}, false)
}

function interpretAST (
  elements/*: any[] */,
  parent/*: ?Placeholder */,
  locale/*: Locales */,
  types/*: Types */,
  join/*: boolean */
)/*: Function */ {
  var parts = elements.map(function (element) {
    return interpretElement(element, parent, locale, types, join)
  })

  if (!join) {
    return function format (args) {
      return parts.reduce(function (parts, part) {
        return parts.concat(part(args))
      }, [])
    }
  }

  if (parts.length === 1) return parts[0]
  return function format (args) {
    var message = ''
    for (var e = 0; e < parts.length; ++e) {
      message += parts[e](args)
    }
    return message
  }
}

function interpretElement (
  element/*: Placeholder */,
  parent/*: ?Placeholder */,
  locale/*: Locales */,
  types/*: Types */,
  join/*: boolean */
)/*: Function */ {
  if (typeof element === 'string') {
    var value/*: string */ = element
    return function format () { return value }
  }

  var id = element[0]
  var type = element[1]

  if (parent && element[0] === '#') {
    id = parent[0]
    var offset = parent[2]
    var formatter = (types.number || defaults.number)([ id, 'number' ], locale)
    return function format (args) {
      return formatter(getArg(id, args) - offset, args)
    }
  }

  // pre-process children
  var children
  if (type === 'plural' || type === 'selectordinal') {
    children = {}
    Object.keys(element[3]).forEach(function (key) {
      children[key] = interpretAST(element[3][key], element, locale, types, join)
    })
    element = [ element[0], element[1], element[2], children ]
  } else if (element[2] && typeof element[2] === 'object') {
    children = {}
    Object.keys(element[2]).forEach(function (key) {
      children[key] = interpretAST(element[2][key], element, locale, types, join)
    })
    element = [ element[0], element[1], children ]
  }

  var getFrmt = type && (types[type] || defaults[type])
  if (getFrmt) {
    var frmt = getFrmt(element, locale)
    return function format (args) {
      return frmt(getArg(id, args), args)
    }
  }

  return join
    ? function format (args) { return String(getArg(id, args)) }
    : function format (args) { return getArg(id, args) }
}

function getArg (id/*: string */, args/*: ?Object */)/*: any */ {
  if (args && (id in args)) return args[id]
  var parts = id.split('.')
  var a = args
  for (var i = 0, ii = parts.length; a && i < ii; ++i) {
    a = a[parts[i]]
  }
  return a
}

function interpretNumber (element/*: Placeholder */, locales/*: Locales */) {
  var style = element[2]
  var options = formats.number[style] || formats.parseNumberPattern(style) || formats.number.default
  return new Intl.NumberFormat(locales, options).format
}

function interpretDuration (element/*: Placeholder */, locales/*: Locales */) {
  var style = element[2]
  var options = formats.duration[style] || formats.duration.default
  var fs = new Intl.NumberFormat(locales, options.seconds).format
  var fm = new Intl.NumberFormat(locales, options.minutes).format
  var fh = new Intl.NumberFormat(locales, options.hours).format
  var sep = /^fi$|^fi-|^da/.test(String(locales)) ? '.' : ':'

  return function (s, args) {
    s = +s
    if (!isFinite(s)) return fs(s)
    var h = ~~(s / 60 / 60) // ~~ acts much like Math.trunc
    var m = ~~(s / 60 % 60)
    var dur = (h ? (fh(Math.abs(h)) + sep) : '') +
      fm(Math.abs(m)) + sep + fs(Math.abs(s % 60))
    return s < 0 ? fh(-1).replace(fh(1), dur) : dur
  }
}

function interpretDateTime (element/*: Placeholder */, locales/*: Locales */) {
  var type = element[1]
  var style = element[2]
  var options = formats[type][style] || formats.parseDatePattern(style) || formats[type].default
  return new Intl.DateTimeFormat(locales, options).format
}

function interpretPlural (element/*: Placeholder */, locales/*: Locales */) {
  var type = element[1]
  var pluralType = type === 'selectordinal' ? 'ordinal' : 'cardinal'
  var offset = element[2]
  var children = element[3]
  var pluralRules
  if (Intl.PluralRules && Intl.PluralRules.supportedLocalesOf(locales).length > 0) {
    pluralRules = new Intl.PluralRules(locales, { type: pluralType })
  } else {
    var locale = lookupClosestLocale(locales, plurals)
    var select = (locale && plurals[locale][pluralType]) || returnOther
    pluralRules = { select: select }
  }

  return function (value, args) {
    var clause =
      children['=' + +value] ||
      children[pluralRules.select(value - offset)] ||
      children.other
    return clause(args)
  }
}

function returnOther (/*:: n:number */) { return 'other' }

function interpretSelect (element/*: Placeholder */, locales/*: Locales */) {
  var children = element[2]
  return function (value, args) {
    var clause = children[value] || children.other
    return clause(args)
  }
}

var defaults/*: Types */ = {
  number: interpretNumber,
  ordinal: interpretNumber, // TODO: support rbnf
  spellout: interpretNumber, // TODO: support rbnf
  duration: interpretDuration,
  date: interpretDateTime,
  time: interpretDateTime,
  plural: interpretPlural,
  selectordinal: interpretPlural,
  select: interpretSelect
}
exports.types = defaults


/***/ }),

/***/ "./node_modules/format-message-interpret/plurals.js":
/*!**********************************************************!*\
  !*** ./node_modules/format-message-interpret/plurals.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @flow


/*:: export type Rule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' */
var zero = 'zero', one = 'one', two = 'two', few = 'few', many = 'many', other = 'other'
var f = [
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return 0 <= n && n <= 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var n = +s
    return i === 0 || n === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 0 ? zero
      : n === 1 ? one
      : n === 2 ? two
      : 3 <= n % 100 && n % 100 <= 10 ? few
      : 11 <= n % 100 && n % 100 <= 99 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return i === 1 && v === 0 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n % 10 === 1 && n % 100 !== 11 ? one
      : (2 <= n % 10 && n % 10 <= 4) && (n % 100 < 12 || 14 < n % 100) ? few
      : n % 10 === 0 || (5 <= n % 10 && n % 10 <= 9) || (11 <= n % 100 && n % 100 <= 14) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n % 10 === 1 && (n % 100 !== 11 && n % 100 !== 71 && n % 100 !== 91) ? one
      : n % 10 === 2 && (n % 100 !== 12 && n % 100 !== 72 && n % 100 !== 92) ? two
      : ((3 <= n % 10 && n % 10 <= 4) || n % 10 === 9) && ((n % 100 < 10 || 19 < n % 100) && (n % 100 < 70 || 79 < n % 100) && (n % 100 < 90 || 99 < n % 100)) ? few
      : n !== 0 && n % 1000000 === 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var f = +(s + '.').split('.')[1]
    return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one
      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) || (2 <= f % 10 && f % 10 <= 4) && (f % 100 < 12 || 14 < f % 100) ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return i === 1 && v === 0 ? one
      : (2 <= i && i <= 4) && v === 0 ? few
      : v !== 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 0 ? zero
      : n === 1 ? one
      : n === 2 ? two
      : n === 3 ? few
      : n === 6 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var t = +('' + s).replace(/^[^.]*.?|0+$/g, '')
    var n = +s
    return n === 1 || t !== 0 && (i === 0 || i === 1) ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var f = +(s + '.').split('.')[1]
    return v === 0 && i % 100 === 1 || f % 100 === 1 ? one
      : v === 0 && i % 100 === 2 || f % 100 === 2 ? two
      : v === 0 && (3 <= i % 100 && i % 100 <= 4) || (3 <= f % 100 && f % 100 <= 4) ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    return i === 0 || i === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var f = +(s + '.').split('.')[1]
    return v === 0 && (i === 1 || i === 2 || i === 3) || v === 0 && (i % 10 !== 4 && i % 10 !== 6 && i % 10 !== 9) || v !== 0 && (f % 10 !== 4 && f % 10 !== 6 && f % 10 !== 9) ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n === 2 ? two
      : 3 <= n && n <= 6 ? few
      : 7 <= n && n <= 10 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 || n === 11 ? one
      : n === 2 || n === 12 ? two
      : ((3 <= n && n <= 10) || (13 <= n && n <= 19)) ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return v === 0 && i % 10 === 1 ? one
      : v === 0 && i % 10 === 2 ? two
      : v === 0 && (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? few
      : v !== 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var n = +s
    return i === 1 && v === 0 ? one
      : i === 2 && v === 0 ? two
      : v === 0 && (n < 0 || 10 < n) && n % 10 === 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var t = +('' + s).replace(/^[^.]*.?|0+$/g, '')
    return t === 0 && i % 10 === 1 && i % 100 !== 11 || t !== 0 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n === 2 ? two
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 0 ? zero
      : n === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var n = +s
    return n === 0 ? zero
      : (i === 0 || i === 1) && n !== 0 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var f = +(s + '.').split('.')[1]
    var n = +s
    return n % 10 === 1 && (n % 100 < 11 || 19 < n % 100) ? one
      : (2 <= n % 10 && n % 10 <= 9) && (n % 100 < 11 || 19 < n % 100) ? few
      : f !== 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var v = (s + '.').split('.')[1].length
    var f = +(s + '.').split('.')[1]
    var n = +s
    return n % 10 === 0 || (11 <= n % 100 && n % 100 <= 19) || v === 2 && (11 <= f % 100 && f % 100 <= 19) ? zero
      : n % 10 === 1 && n % 100 !== 11 || v === 2 && f % 10 === 1 && f % 100 !== 11 || v !== 2 && f % 10 === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var f = +(s + '.').split('.')[1]
    return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var n = +s
    return i === 1 && v === 0 ? one
      : v !== 0 || n === 0 || n !== 1 && (1 <= n % 100 && n % 100 <= 19) ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n === 0 || (2 <= n % 100 && n % 100 <= 10) ? few
      : 11 <= n % 100 && n % 100 <= 19 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return i === 1 && v === 0 ? one
      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) ? few
      : v === 0 && i !== 1 && (0 <= i % 10 && i % 10 <= 1) || v === 0 && (5 <= i % 10 && i % 10 <= 9) || v === 0 && (12 <= i % 100 && i % 100 <= 14) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    return 0 <= i && i <= 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return v === 0 && i % 10 === 1 && i % 100 !== 11 ? one
      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) ? few
      : v === 0 && i % 10 === 0 || v === 0 && (5 <= i % 10 && i % 10 <= 9) || v === 0 && (11 <= i % 100 && i % 100 <= 14) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var n = +s
    return i === 0 || n === 1 ? one
      : 2 <= n && n <= 10 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var f = +(s + '.').split('.')[1]
    var n = +s
    return (n === 0 || n === 1) || i === 0 && f === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return v === 0 && i % 100 === 1 ? one
      : v === 0 && i % 100 === 2 ? two
      : v === 0 && (3 <= i % 100 && i % 100 <= 4) || v !== 0 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return (0 <= n && n <= 1) || (11 <= n && n <= 99) ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 || n === 5 || n === 7 || n === 8 || n === 9 || n === 10 ? one
      : n === 2 || n === 3 ? two
      : n === 4 ? few
      : n === 6 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    return (i % 10 === 1 || i % 10 === 2 || i % 10 === 5 || i % 10 === 7 || i % 10 === 8) || (i % 100 === 20 || i % 100 === 50 || i % 100 === 70 || i % 100 === 80) ? one
      : (i % 10 === 3 || i % 10 === 4) || (i % 1000 === 100 || i % 1000 === 200 || i % 1000 === 300 || i % 1000 === 400 || i % 1000 === 500 || i % 1000 === 600 || i % 1000 === 700 || i % 1000 === 800 || i % 1000 === 900) ? few
      : i === 0 || i % 10 === 6 || (i % 100 === 40 || i % 100 === 60 || i % 100 === 90) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return (n % 10 === 2 || n % 10 === 3) && (n % 100 !== 12 && n % 100 !== 13) ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 || n === 3 ? one
      : n === 2 ? two
      : n === 4 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 0 || n === 7 || n === 8 || n === 9 ? zero
      : n === 1 ? one
      : n === 2 ? two
      : n === 3 || n === 4 ? few
      : n === 5 || n === 6 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n % 10 === 1 && n % 100 !== 11 ? one
      : n % 10 === 2 && n % 100 !== 12 ? two
      : n % 10 === 3 && n % 100 !== 13 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 || n === 11 ? one
      : n === 2 || n === 12 ? two
      : n === 3 || n === 13 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n === 2 || n === 3 ? two
      : n === 4 ? few
      : n === 6 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 || n === 5 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 11 || n === 8 || n === 80 || n === 800 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    return i === 1 ? one
      : i === 0 || ((2 <= i % 100 && i % 100 <= 20) || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n % 10 === 6 || n % 10 === 9 || n % 10 === 0 && n !== 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    return i % 10 === 1 && i % 100 !== 11 ? one
      : i % 10 === 2 && i % 100 !== 12 ? two
      : (i % 10 === 7 || i % 10 === 8) && (i % 100 !== 17 && i % 100 !== 18) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n === 2 || n === 3 ? two
      : n === 4 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return 1 <= n && n <= 4 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return (n === 1 || n === 5 || (7 <= n && n <= 9)) ? one
      : n === 2 || n === 3 ? two
      : n === 4 ? few
      : n === 6 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n % 10 === 4 && n % 100 !== 14 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return (n % 10 === 1 || n % 10 === 2) && (n % 100 !== 11 && n % 100 !== 12) ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return (n % 10 === 6 || n % 10 === 9) || n === 10 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n % 10 === 3 && n % 100 !== 13 ? few
      : other
  }
]

module.exports = {
  af: { cardinal: f[0] },
  ak: { cardinal: f[1] },
  am: { cardinal: f[2] },
  ar: { cardinal: f[3] },
  ars: { cardinal: f[3] },
  as: { cardinal: f[2], ordinal: f[34] },
  asa: { cardinal: f[0] },
  ast: { cardinal: f[4] },
  az: { cardinal: f[0], ordinal: f[35] },
  be: { cardinal: f[5], ordinal: f[36] },
  bem: { cardinal: f[0] },
  bez: { cardinal: f[0] },
  bg: { cardinal: f[0] },
  bh: { cardinal: f[1] },
  bn: { cardinal: f[2], ordinal: f[34] },
  br: { cardinal: f[6] },
  brx: { cardinal: f[0] },
  bs: { cardinal: f[7] },
  ca: { cardinal: f[4], ordinal: f[37] },
  ce: { cardinal: f[0] },
  cgg: { cardinal: f[0] },
  chr: { cardinal: f[0] },
  ckb: { cardinal: f[0] },
  cs: { cardinal: f[8] },
  cy: { cardinal: f[9], ordinal: f[38] },
  da: { cardinal: f[10] },
  de: { cardinal: f[4] },
  dsb: { cardinal: f[11] },
  dv: { cardinal: f[0] },
  ee: { cardinal: f[0] },
  el: { cardinal: f[0] },
  en: { cardinal: f[4], ordinal: f[39] },
  eo: { cardinal: f[0] },
  es: { cardinal: f[0] },
  et: { cardinal: f[4] },
  eu: { cardinal: f[0] },
  fa: { cardinal: f[2] },
  ff: { cardinal: f[12] },
  fi: { cardinal: f[4] },
  fil: { cardinal: f[13], ordinal: f[0] },
  fo: { cardinal: f[0] },
  fr: { cardinal: f[12], ordinal: f[0] },
  fur: { cardinal: f[0] },
  fy: { cardinal: f[4] },
  ga: { cardinal: f[14], ordinal: f[0] },
  gd: { cardinal: f[15], ordinal: f[40] },
  gl: { cardinal: f[4] },
  gsw: { cardinal: f[0] },
  gu: { cardinal: f[2], ordinal: f[41] },
  guw: { cardinal: f[1] },
  gv: { cardinal: f[16] },
  ha: { cardinal: f[0] },
  haw: { cardinal: f[0] },
  he: { cardinal: f[17] },
  hi: { cardinal: f[2], ordinal: f[41] },
  hr: { cardinal: f[7] },
  hsb: { cardinal: f[11] },
  hu: { cardinal: f[0], ordinal: f[42] },
  hy: { cardinal: f[12], ordinal: f[0] },
  ia: { cardinal: f[4] },
  io: { cardinal: f[4] },
  is: { cardinal: f[18] },
  it: { cardinal: f[4], ordinal: f[43] },
  iu: { cardinal: f[19] },
  iw: { cardinal: f[17] },
  jgo: { cardinal: f[0] },
  ji: { cardinal: f[4] },
  jmc: { cardinal: f[0] },
  ka: { cardinal: f[0], ordinal: f[44] },
  kab: { cardinal: f[12] },
  kaj: { cardinal: f[0] },
  kcg: { cardinal: f[0] },
  kk: { cardinal: f[0], ordinal: f[45] },
  kkj: { cardinal: f[0] },
  kl: { cardinal: f[0] },
  kn: { cardinal: f[2] },
  ks: { cardinal: f[0] },
  ksb: { cardinal: f[0] },
  ksh: { cardinal: f[20] },
  ku: { cardinal: f[0] },
  kw: { cardinal: f[19] },
  ky: { cardinal: f[0] },
  lag: { cardinal: f[21] },
  lb: { cardinal: f[0] },
  lg: { cardinal: f[0] },
  ln: { cardinal: f[1] },
  lt: { cardinal: f[22] },
  lv: { cardinal: f[23] },
  mas: { cardinal: f[0] },
  mg: { cardinal: f[1] },
  mgo: { cardinal: f[0] },
  mk: { cardinal: f[24], ordinal: f[46] },
  ml: { cardinal: f[0] },
  mn: { cardinal: f[0] },
  mo: { cardinal: f[25], ordinal: f[0] },
  mr: { cardinal: f[2], ordinal: f[47] },
  mt: { cardinal: f[26] },
  nah: { cardinal: f[0] },
  naq: { cardinal: f[19] },
  nb: { cardinal: f[0] },
  nd: { cardinal: f[0] },
  ne: { cardinal: f[0], ordinal: f[48] },
  nl: { cardinal: f[4] },
  nn: { cardinal: f[0] },
  nnh: { cardinal: f[0] },
  no: { cardinal: f[0] },
  nr: { cardinal: f[0] },
  nso: { cardinal: f[1] },
  ny: { cardinal: f[0] },
  nyn: { cardinal: f[0] },
  om: { cardinal: f[0] },
  or: { cardinal: f[0], ordinal: f[49] },
  os: { cardinal: f[0] },
  pa: { cardinal: f[1] },
  pap: { cardinal: f[0] },
  pl: { cardinal: f[27] },
  prg: { cardinal: f[23] },
  ps: { cardinal: f[0] },
  pt: { cardinal: f[28] },
  'pt-PT': { cardinal: f[4] },
  rm: { cardinal: f[0] },
  ro: { cardinal: f[25], ordinal: f[0] },
  rof: { cardinal: f[0] },
  ru: { cardinal: f[29] },
  rwk: { cardinal: f[0] },
  saq: { cardinal: f[0] },
  sc: { cardinal: f[4], ordinal: f[43] },
  scn: { cardinal: f[4], ordinal: f[43] },
  sd: { cardinal: f[0] },
  sdh: { cardinal: f[0] },
  se: { cardinal: f[19] },
  seh: { cardinal: f[0] },
  sh: { cardinal: f[7] },
  shi: { cardinal: f[30] },
  si: { cardinal: f[31] },
  sk: { cardinal: f[8] },
  sl: { cardinal: f[32] },
  sma: { cardinal: f[19] },
  smi: { cardinal: f[19] },
  smj: { cardinal: f[19] },
  smn: { cardinal: f[19] },
  sms: { cardinal: f[19] },
  sn: { cardinal: f[0] },
  so: { cardinal: f[0] },
  sq: { cardinal: f[0], ordinal: f[50] },
  sr: { cardinal: f[7] },
  ss: { cardinal: f[0] },
  ssy: { cardinal: f[0] },
  st: { cardinal: f[0] },
  sv: { cardinal: f[4], ordinal: f[51] },
  sw: { cardinal: f[4] },
  syr: { cardinal: f[0] },
  ta: { cardinal: f[0] },
  te: { cardinal: f[0] },
  teo: { cardinal: f[0] },
  ti: { cardinal: f[1] },
  tig: { cardinal: f[0] },
  tk: { cardinal: f[0], ordinal: f[52] },
  tl: { cardinal: f[13], ordinal: f[0] },
  tn: { cardinal: f[0] },
  tr: { cardinal: f[0] },
  ts: { cardinal: f[0] },
  tzm: { cardinal: f[33] },
  ug: { cardinal: f[0] },
  uk: { cardinal: f[29], ordinal: f[53] },
  ur: { cardinal: f[4] },
  uz: { cardinal: f[0] },
  ve: { cardinal: f[0] },
  vo: { cardinal: f[0] },
  vun: { cardinal: f[0] },
  wa: { cardinal: f[1] },
  wae: { cardinal: f[0] },
  xh: { cardinal: f[0] },
  xog: { cardinal: f[0] },
  yi: { cardinal: f[4] },
  zu: { cardinal: f[2] },
  lo: { ordinal: f[0] },
  ms: { ordinal: f[0] },
  vi: { ordinal: f[0] }
}


/***/ }),

/***/ "./node_modules/format-message-parse/index.js":
/*!****************************************************!*\
  !*** ./node_modules/format-message-parse/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @flow


/*::
export type AST = Element[]
export type Element = string | Placeholder
export type Placeholder = Plural | Styled | Typed | Simple
export type Plural = [ string, 'plural' | 'selectordinal', number, SubMessages ]
export type Styled = [ string, string, string | SubMessages ]
export type Typed = [ string, string ]
export type Simple = [ string ]
export type SubMessages = { [string]: AST }
export type Token = [ TokenType, string ]
export type TokenType = 'text' | 'space' | 'id' | 'type' | 'style' | 'offset' | 'number' | 'selector' | 'syntax'
type Context = {|
  pattern: string,
  index: number,
  tagsType: ?string,
  tokens: ?Token[]
|}
*/

var ARG_OPN = '{'
var ARG_CLS = '}'
var ARG_SEP = ','
var NUM_ARG = '#'
var TAG_OPN = '<'
var TAG_CLS = '>'
var TAG_END = '</'
var TAG_SELF_CLS = '/>'
var ESC = '\''
var OFFSET = 'offset:'
var simpleTypes = [
  'number',
  'date',
  'time',
  'ordinal',
  'duration',
  'spellout'
]
var submTypes = [
  'plural',
  'select',
  'selectordinal'
]

/**
 * parse
 *
 * Turns this:
 *  `You have { numBananas, plural,
 *       =0 {no bananas}
 *      one {a banana}
 *    other {# bananas}
 *  } for sale`
 *
 * into this:
 *  [ "You have ", [ "numBananas", "plural", 0, {
 *       "=0": [ "no bananas" ],
 *      "one": [ "a banana" ],
 *    "other": [ [ '#' ], " bananas" ]
 *  } ], " for sale." ]
 *
 * tokens:
 *  [
 *    [ "text", "You have " ],
 *    [ "syntax", "{" ],
 *    [ "space", " " ],
 *    [ "id", "numBananas" ],
 *    [ "syntax", ", " ],
 *    [ "space", " " ],
 *    [ "type", "plural" ],
 *    [ "syntax", "," ],
 *    [ "space", "\n     " ],
 *    [ "selector", "=0" ],
 *    [ "space", " " ],
 *    [ "syntax", "{" ],
 *    [ "text", "no bananas" ],
 *    [ "syntax", "}" ],
 *    [ "space", "\n    " ],
 *    [ "selector", "one" ],
 *    [ "space", " " ],
 *    [ "syntax", "{" ],
 *    [ "text", "a banana" ],
 *    [ "syntax", "}" ],
 *    [ "space", "\n  " ],
 *    [ "selector", "other" ],
 *    [ "space", " " ],
 *    [ "syntax", "{" ],
 *    [ "syntax", "#" ],
 *    [ "text", " bananas" ],
 *    [ "syntax", "}" ],
 *    [ "space", "\n" ],
 *    [ "syntax", "}" ],
 *    [ "text", " for sale." ]
 *  ]
 **/
exports = module.exports = function parse (
  pattern/*: string */,
  options/*:: ?: { tagsType?: string, tokens?: Token[] } */
)/*: AST */ {
  return parseAST({
    pattern: String(pattern),
    index: 0,
    tagsType: (options && options.tagsType) || null,
    tokens: (options && options.tokens) || null
  }, '')
}

function parseAST (current/*: Context */, parentType/*: string */)/*: AST */ {
  var pattern = current.pattern
  var length = pattern.length
  var elements/*: AST */ = []
  var start = current.index
  var text = parseText(current, parentType)
  if (text) elements.push(text)
  if (text && current.tokens) current.tokens.push([ 'text', pattern.slice(start, current.index) ])
  while (current.index < length) {
    if (pattern[current.index] === ARG_CLS) {
      if (!parentType) throw expected(current)
      break
    }
    if (parentType && current.tagsType && pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) break
    elements.push(parsePlaceholder(current))
    start = current.index
    text = parseText(current, parentType)
    if (text) elements.push(text)
    if (text && current.tokens) current.tokens.push([ 'text', pattern.slice(start, current.index) ])
  }
  return elements
}

function parseText (current/*: Context */, parentType/*: string */)/*: string */ {
  var pattern = current.pattern
  var length = pattern.length
  var isHashSpecial = (parentType === 'plural' || parentType === 'selectordinal')
  var isAngleSpecial = !!current.tagsType
  var isArgStyle = (parentType === '{style}')
  var text = ''
  while (current.index < length) {
    var char = pattern[current.index]
    if (
      char === ARG_OPN || char === ARG_CLS ||
      (isHashSpecial && char === NUM_ARG) ||
      (isAngleSpecial && char === TAG_OPN) ||
      (isArgStyle && isWhitespace(char.charCodeAt(0)))
    ) {
      break
    } else if (char === ESC) {
      char = pattern[++current.index]
      if (char === ESC) { // double is always 1 '
        text += char
        ++current.index
      } else if (
        // only when necessary
        char === ARG_OPN || char === ARG_CLS ||
        (isHashSpecial && char === NUM_ARG) ||
        (isAngleSpecial && char === TAG_OPN) ||
        isArgStyle
      ) {
        text += char
        while (++current.index < length) {
          char = pattern[current.index]
          if (char === ESC && pattern[current.index + 1] === ESC) { // double is always 1 '
            text += ESC
            ++current.index
          } else if (char === ESC) { // end of quoted
            ++current.index
            break
          } else {
            text += char
          }
        }
      } else { // lone ' is just a '
        text += ESC
        // already incremented
      }
    } else {
      text += char
      ++current.index
    }
  }
  return text
}

function isWhitespace (code/*: number */)/*: boolean */ {
  return (
    (code >= 0x09 && code <= 0x0D) ||
    code === 0x20 || code === 0x85 || code === 0xA0 || code === 0x180E ||
    (code >= 0x2000 && code <= 0x200D) ||
    code === 0x2028 || code === 0x2029 || code === 0x202F || code === 0x205F ||
    code === 0x2060 || code === 0x3000 || code === 0xFEFF
  )
}

function skipWhitespace (current/*: Context */)/*: void */ {
  var pattern = current.pattern
  var length = pattern.length
  var start = current.index
  while (current.index < length && isWhitespace(pattern.charCodeAt(current.index))) {
    ++current.index
  }
  if (start < current.index && current.tokens) {
    current.tokens.push([ 'space', current.pattern.slice(start, current.index) ])
  }
}

function parsePlaceholder (current/*: Context */)/*: Placeholder */ {
  var pattern = current.pattern
  if (pattern[current.index] === NUM_ARG) {
    if (current.tokens) current.tokens.push([ 'syntax', NUM_ARG ])
    ++current.index // move passed #
    return [ NUM_ARG ]
  }

  var tag = parseTag(current)
  if (tag) return tag

  /* istanbul ignore if should be unreachable if parseAST and parseText are right */
  if (pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN)
  if (current.tokens) current.tokens.push([ 'syntax', ARG_OPN ])
  ++current.index // move passed {
  skipWhitespace(current)

  var id = parseId(current)
  if (!id) throw expected(current, 'placeholder id')
  if (current.tokens) current.tokens.push([ 'id', id ])
  skipWhitespace(current)

  var char = pattern[current.index]
  if (char === ARG_CLS) { // end placeholder
    if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])
    ++current.index // move passed }
    return [ id ]
  }

  if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', ARG_SEP ])
  ++current.index // move passed ,
  skipWhitespace(current)

  var type = parseId(current)
  if (!type) throw expected(current, 'placeholder type')
  if (current.tokens) current.tokens.push([ 'type', type ])
  skipWhitespace(current)
  char = pattern[current.index]
  if (char === ARG_CLS) { // end placeholder
    if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])
    if (type === 'plural' || type === 'selectordinal' || type === 'select') {
      throw expected(current, type + ' sub-messages')
    }
    ++current.index // move passed }
    return [ id, type ]
  }

  if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', ARG_SEP ])
  ++current.index // move passed ,
  skipWhitespace(current)

  var arg
  if (type === 'plural' || type === 'selectordinal') {
    var offset = parsePluralOffset(current)
    skipWhitespace(current)
    arg = [ id, type, offset, parseSubMessages(current, type) ]
  } else if (type === 'select') {
    arg = [ id, type, parseSubMessages(current, type) ]
  } else if (simpleTypes.indexOf(type) >= 0) {
    arg = [ id, type, parseSimpleFormat(current) ]
  } else { // custom placeholder type
    var index = current.index
    var format/*: string | SubMessages */ = parseSimpleFormat(current)
    skipWhitespace(current)
    if (pattern[current.index] === ARG_OPN) {
      current.index = index // rewind, since should have been submessages
      format = parseSubMessages(current, type)
    }
    arg = [ id, type, format ]
  }

  skipWhitespace(current)
  if (pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])
  ++current.index // move passed }
  return arg
}

function parseTag (current/*: Context */)/*: ?Placeholder */ {
  var tagsType = current.tagsType
  if (!tagsType || current.pattern[current.index] !== TAG_OPN) return

  if (current.pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) {
    throw expected(current, null, 'closing tag without matching opening tag')
  }
  if (current.tokens) current.tokens.push([ 'syntax', TAG_OPN ])
  ++current.index // move passed <

  var id = parseId(current, true)
  if (!id) throw expected(current, 'placeholder id')
  if (current.tokens) current.tokens.push([ 'id', id ])
  skipWhitespace(current)

  if (current.pattern.slice(current.index, current.index + TAG_SELF_CLS.length) === TAG_SELF_CLS) {
    if (current.tokens) current.tokens.push([ 'syntax', TAG_SELF_CLS ])
    current.index += TAG_SELF_CLS.length
    return [ id, tagsType ]
  }
  if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', TAG_CLS ])
  ++current.index // move passed >

  var children = parseAST(current, tagsType)

  var end = current.index
  if (current.pattern.slice(current.index, current.index + TAG_END.length) !== TAG_END) throw expected(current, TAG_END + id + TAG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', TAG_END ])
  current.index += TAG_END.length
  var closeId = parseId(current, true)
  if (closeId && current.tokens) current.tokens.push([ 'id', closeId ])
  if (id !== closeId) {
    current.index = end // rewind for better error message
    throw expected(current, TAG_END + id + TAG_CLS, TAG_END + closeId + TAG_CLS)
  }
  skipWhitespace(current)
  if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', TAG_CLS ])
  ++current.index // move passed >

  return [ id, tagsType, { children: children } ]
}

function parseId (current/*: Context */, isTag/*:: ?: boolean */)/*: string */ {
  var pattern = current.pattern
  var length = pattern.length
  var id = ''
  while (current.index < length) {
    var char = pattern[current.index]
    if (
      char === ARG_OPN || char === ARG_CLS || char === ARG_SEP ||
      char === NUM_ARG || char === ESC || isWhitespace(char.charCodeAt(0)) ||
      (isTag && (char === TAG_OPN || char === TAG_CLS || char === '/'))
    ) break
    id += char
    ++current.index
  }
  return id
}

function parseSimpleFormat (current/*: Context */)/*: string */ {
  var start = current.index
  var style = parseText(current, '{style}')
  if (!style) throw expected(current, 'placeholder style name')
  if (current.tokens) current.tokens.push([ 'style', current.pattern.slice(start, current.index) ])
  return style
}

function parsePluralOffset (current/*: Context */)/*: number */ {
  var pattern = current.pattern
  var length = pattern.length
  var offset = 0
  if (pattern.slice(current.index, current.index + OFFSET.length) === OFFSET) {
    if (current.tokens) current.tokens.push([ 'offset', 'offset' ], [ 'syntax', ':' ])
    current.index += OFFSET.length // move passed offset:
    skipWhitespace(current)
    var start = current.index
    while (current.index < length && isDigit(pattern.charCodeAt(current.index))) {
      ++current.index
    }
    if (start === current.index) throw expected(current, 'offset number')
    if (current.tokens) current.tokens.push([ 'number', pattern.slice(start, current.index) ])
    offset = +pattern.slice(start, current.index)
  }
  return offset
}

function isDigit (code/*: number */)/*: boolean */ {
  return (code >= 0x30 && code <= 0x39)
}

function parseSubMessages (current/*: Context */, parentType/*: string */)/*: SubMessages */ {
  var pattern = current.pattern
  var length = pattern.length
  var options/*: SubMessages */ = {}
  while (current.index < length && pattern[current.index] !== ARG_CLS) {
    var selector = parseId(current)
    if (!selector) throw expected(current, 'sub-message selector')
    if (current.tokens) current.tokens.push([ 'selector', selector ])
    skipWhitespace(current)
    options[selector] = parseSubMessage(current, parentType)
    skipWhitespace(current)
  }
  if (!options.other && submTypes.indexOf(parentType) >= 0) {
    throw expected(current, null, null, '"other" sub-message must be specified in ' + parentType)
  }
  return options
}

function parseSubMessage (current/*: Context */, parentType/*: string */)/*: AST */ {
  if (current.pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN + ' to start sub-message')
  if (current.tokens) current.tokens.push([ 'syntax', ARG_OPN ])
  ++current.index // move passed {
  var message = parseAST(current, parentType)
  if (current.pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS + ' to end sub-message')
  if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])
  ++current.index // move passed }
  return message
}

function expected (current/*: Context */, expected/*:: ?: ?string */, found/*:: ?: ?string */, message/*:: ?: string */) {
  var pattern = current.pattern
  var lines = pattern.slice(0, current.index).split(/\r?\n/)
  var offset = current.index
  var line = lines.length
  var column = lines.slice(-1)[0].length
  found = found || (
    (current.index >= pattern.length) ? 'end of message pattern'
      : (parseId(current) || pattern[current.index])
  )
  if (!message) message = errorMessage(expected, found)
  message += ' in ' + pattern.replace(/\r?\n/g, '\n')
  return new SyntaxError(message, expected, found, offset, line, column)
}

function errorMessage (expected/*: ?string */, found/* string */) {
  if (!expected) return 'Unexpected ' + found + ' found'
  return 'Expected ' + expected + ' but found ' + found
}

/**
 * SyntaxError
 *  Holds information about bad syntax found in a message pattern
 **/
function SyntaxError (message/*: string */, expected/*: ?string */, found/*: ?string */, offset/*: number */, line/*: number */, column/*: number */) {
  Error.call(this, message)
  this.name = 'SyntaxError'
  this.message = message
  this.expected = expected
  this.found = found
  this.offset = offset
  this.line = line
  this.column = column
}
SyntaxError.prototype = Object.create(Error.prototype)
exports.SyntaxError = SyntaxError


/***/ }),

/***/ "./node_modules/format-message/index.js":
/*!**********************************************!*\
  !*** ./node_modules/format-message/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @flow

var parse = __webpack_require__(/*! format-message-parse */ "./node_modules/format-message-parse/index.js")
var interpret = __webpack_require__(/*! format-message-interpret */ "./node_modules/format-message-interpret/index.js")
var plurals = __webpack_require__(/*! format-message-interpret/plurals */ "./node_modules/format-message-interpret/plurals.js")
var lookupClosestLocale = __webpack_require__(/*! lookup-closest-locale */ "./node_modules/lookup-closest-locale/index.js")
var origFormats = __webpack_require__(/*! format-message-formats */ "./node_modules/format-message-formats/index.js")

/*::
import type { Types } from 'format-message-interpret'
type Locale = string
type Locales = Locale | Locale[]
type Message = string | {|
  id?: string,
  default: string,
  description?: string
|}
type Translations = { [string]: ?{ [string]: string | Translation } }
type Translation = {
  message: string,
  format?: (args?: Object) => string,
  toParts?: (args?: Object) => any[],
}
type Replacement = ?string | (string, string, locales?: Locales) => ?string
type GenerateId = (string) => string
type MissingTranslation = 'ignore' | 'warning' | 'error'
type FormatObject = { [string]: * }
type Options = {
  locale?: Locales,
  translations?: ?Translations,
  generateId?: GenerateId,
  missingReplacement?: Replacement,
  missingTranslation?: MissingTranslation,
  formats?: {
    number?: FormatObject,
    date?: FormatObject,
    time?: FormatObject
  },
  types?: Types
}
type Setup = {|
  locale: Locales,
  translations: Translations,
  generateId: GenerateId,
  missingReplacement: Replacement,
  missingTranslation: MissingTranslation,
  formats: {
    number: FormatObject,
    date: FormatObject,
    time: FormatObject
  },
  types: Types
|}
type FormatMessage = {
  (msg: Message, args?: Object, locales?: Locales): string,
  rich (msg: Message, args?: Object, locales?: Locales): any[],
  setup (opt?: Options): Setup,
  number (value: number, style?: string, locales?: Locales): string,
  date (value: number | Date, style?: string, locales?: Locales): string,
  time (value: number | Date, style?: string, locales?: Locales): string,
  select (value: any, options: Object): any,
  custom (placeholder: any[], locales: Locales, value: any, args: Object): any,
  plural (value: number, offset: any, options: any, locale: any): any,
  selectordinal (value: number, offset: any, options: any, locale: any): any,
  namespace (): FormatMessage
}
*/

function assign/*:: <T: Object> */ (target/*: T */, source/*: Object */) {
  Object.keys(source).forEach(function (key) { target[key] = source[key] })
  return target
}

function namespace ()/*: FormatMessage */ {
  var formats = assign({}, origFormats)
  var currentLocales/*: Locales */ = 'en'
  var translations/*: Translations */ = {}
  var generateId/*: GenerateId */ = function (pattern) { return pattern }
  var missingReplacement/*: Replacement */ = null
  var missingTranslation/*: MissingTranslation */ = 'warning'
  var types/*: Types */ = {}

  function formatMessage (msg/*: Message */, args/*:: ?: Object */, locales/*:: ?: Locales */) {
    var pattern = typeof msg === 'string' ? msg : msg.default
    var id = (typeof msg === 'object' && msg.id) || generateId(pattern)
    var translated = translate(pattern, id, locales || currentLocales)
    var format = translated.format || (
      translated.format = interpret(parse(translated.message), locales || currentLocales, types)
    )
    return format(args)
  }

  formatMessage.rich = function rich (msg/*: Message */, args/*:: ?: Object */, locales/*:: ?: Locales */) {
    var pattern = typeof msg === 'string' ? msg : msg.default
    var id = (typeof msg === 'object' && msg.id) || generateId(pattern)
    var translated = translate(pattern, id, locales || currentLocales)
    var format = translated.toParts || (
      translated.toParts = interpret.toParts(parse(translated.message, { tagsType: tagsType }), locales || currentLocales, types)
    )
    return format(args)
  }

  var tagsType = '<>'
  function richType (node/*: any[] */, locales/*: Locales */) {
    var style = node[2]
    return function (fn, args) {
      var props = typeof style === 'object' ? mapObject(style, args) : style
      return typeof fn === 'function' ? fn(props) : fn
    }
  }
  types[tagsType] = richType

  function mapObject (object/* { [string]: (args?: Object) => any } */, args/*: ?Object */) {
    return Object.keys(object).reduce(function (mapped, key) {
      mapped[key] = object[key](args)
      return mapped
    }, {})
  }

  function translate (pattern/*: string */, id/*: string */, locales/*: Locales */)/*: Translation */ {
    var locale = lookupClosestLocale(locales, translations) || 'en'
    var messages = translations[locale] || (translations[locale] = {})
    var translated = messages[id]
    if (typeof translated === 'string') {
      translated = messages[id] = { message: translated }
    }
    if (!translated) {
      var message = 'Translation for "' + id + '" in "' + locale + '" is missing'
      if (missingTranslation === 'warning') {
        /* istanbul ignore else */
        if (typeof console !== 'undefined') console.warn(message)
      } else if (missingTranslation !== 'ignore') { // 'error'
        throw new Error(message)
      }
      var replacement = typeof missingReplacement === 'function'
        ? missingReplacement(pattern, id, locale) || pattern
        : missingReplacement || pattern
      translated = messages[id] = { message: replacement }
    }
    return translated
  }

  formatMessage.setup = function setup (opt/*:: ?: Options */) {
    opt = opt || {}
    if (opt.locale) currentLocales = opt.locale
    if ('translations' in opt) translations = opt.translations || {}
    if (opt.generateId) generateId = opt.generateId
    if ('missingReplacement' in opt) missingReplacement = opt.missingReplacement
    if (opt.missingTranslation) missingTranslation = opt.missingTranslation
    if (opt.formats) {
      if (opt.formats.number) assign(formats.number, opt.formats.number)
      if (opt.formats.date) assign(formats.date, opt.formats.date)
      if (opt.formats.time) assign(formats.time, opt.formats.time)
    }
    if (opt.types) {
      types = opt.types
      types[tagsType] = richType
    }
    return {
      locale: currentLocales,
      translations: translations,
      generateId: generateId,
      missingReplacement: missingReplacement,
      missingTranslation: missingTranslation,
      formats: formats,
      types: types
    }
  }

  formatMessage.number = function (value/*: number */, style/*:: ?: string */, locales/*:: ?: Locales */) {
    var options = (style && formats.number[style]) ||
      formats.parseNumberPattern(style) ||
      formats.number.default
    return new Intl.NumberFormat(locales || currentLocales, options).format(value)
  }

  formatMessage.date = function (value/*:: ?: number | Date */, style/*:: ?: string */, locales/*:: ?: Locales */) {
    var options = (style && formats.date[style]) ||
      formats.parseDatePattern(style) ||
      formats.date.default
    return new Intl.DateTimeFormat(locales || currentLocales, options).format(value)
  }

  formatMessage.time = function (value/*:: ?: number | Date */, style/*:: ?: string */, locales/*:: ?: Locales */) {
    var options = (style && formats.time[style]) ||
      formats.parseDatePattern(style) ||
      formats.time.default
    return new Intl.DateTimeFormat(locales || currentLocales, options).format(value)
  }

  formatMessage.select = function (value/*: any */, options/*: Object */) {
    return options[value] || options.other
  }

  formatMessage.custom = function (placeholder/*: any[] */, locales/*: Locales */, value/*: any */, args/*: Object */) {
    if (!(placeholder[1] in types)) return value
    return types[placeholder[1]](placeholder, locales)(value, args)
  }

  formatMessage.plural = plural.bind(null, 'cardinal')
  formatMessage.selectordinal = plural.bind(null, 'ordinal')
  function plural (
    pluralType/*: 'cardinal' | 'ordinal' */,
    value/*: number */,
    offset/*: any */,
    options/*: any */,
    locale/*: any */
  ) {
    if (typeof offset === 'object' && typeof options !== 'object') { // offset is optional
      locale = options
      options = offset
      offset = 0
    }
    var closest = lookupClosestLocale(locale || currentLocales, plurals)
    var plural = (closest && plurals[closest][pluralType]) || returnOther
    return options['=' + +value] || options[plural(value - offset)] || options.other
  }
  function returnOther (/*:: n:number */) { return 'other' }

  formatMessage.namespace = namespace

  return formatMessage
}

module.exports = exports = namespace()


/***/ }),

/***/ "./node_modules/global/window.js":
/*!***************************************!*\
  !*** ./node_modules/global/window.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/htmlparser2/lib/CollectingHandler.js":
/*!***********************************************************!*\
  !*** ./node_modules/htmlparser2/lib/CollectingHandler.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = CollectingHandler;

function CollectingHandler(cbs){
	this._cbs = cbs || {};
	this.events = [];
}

var EVENTS = __webpack_require__(/*! ./ */ "./node_modules/htmlparser2/lib/index.js").EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(){
			this.events.push([name]);
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(a){
			this.events.push([name, a]);
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(a, b){
			this.events.push([name, a, b]);
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});

CollectingHandler.prototype.onreset = function(){
	this.events = [];
	if(this._cbs.onreset) this._cbs.onreset();
};

CollectingHandler.prototype.restart = function(){
	if(this._cbs.onreset) this._cbs.onreset();

	for(var i = 0, len = this.events.length; i < len; i++){
		if(this._cbs[this.events[i][0]]){

			var num = this.events[i].length;

			if(num === 1){
				this._cbs[this.events[i][0]]();
			} else if(num === 2){
				this._cbs[this.events[i][0]](this.events[i][1]);
			} else {
				this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
			}
		}
	}
};


/***/ }),

/***/ "./node_modules/htmlparser2/lib/FeedHandler.js":
/*!*****************************************************!*\
  !*** ./node_modules/htmlparser2/lib/FeedHandler.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var index = __webpack_require__(/*! ./index.js */ "./node_modules/htmlparser2/lib/index.js");
var DomHandler = index.DomHandler;
var DomUtils = index.DomUtils;

//TODO: make this a streamable handler
function FeedHandler(callback, options){
	this.init(callback, options);
}

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(FeedHandler, DomHandler);

FeedHandler.prototype.init = DomHandler;

function getElements(what, where){
	return DomUtils.getElementsByTagName(what, where, true);
}
function getOneElement(what, where){
	return DomUtils.getElementsByTagName(what, where, true, 1)[0];
}
function fetch(what, where, recurse){
	return DomUtils.getText(
		DomUtils.getElementsByTagName(what, where, recurse, 1)
	).trim();
}

function addConditionally(obj, prop, what, where, recurse){
	var tmp = fetch(what, where, recurse);
	if(tmp) obj[prop] = tmp;
}

var isValidFeed = function(value){
	return value === "rss" || value === "feed" || value === "rdf:RDF";
};

FeedHandler.prototype.onend = function(){
	var feed = {},
	    feedRoot = getOneElement(isValidFeed, this.dom),
	    tmp, childs;

	if(feedRoot){
		if(feedRoot.name === "feed"){
			childs = feedRoot.children;

			feed.type = "atom";
			addConditionally(feed, "id", "id", childs);
			addConditionally(feed, "title", "title", childs);
			if((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
			addConditionally(feed, "description", "subtitle", childs);
			if((tmp = fetch("updated", childs))) feed.updated = new Date(tmp);
			addConditionally(feed, "author", "email", childs, true);

			feed.items = getElements("entry", childs).map(function(item){
				var entry = {}, tmp;

				item = item.children;

				addConditionally(entry, "id", "id", item);
				addConditionally(entry, "title", "title", item);
				if((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
				if((tmp = fetch("summary", item) || fetch("content", item))) entry.description = tmp;
				if((tmp = fetch("updated", item))) entry.pubDate = new Date(tmp);
				return entry;
			});
		} else {
			childs = getOneElement("channel", feedRoot.children).children;

			feed.type = feedRoot.name.substr(0, 3);
			feed.id = "";
			addConditionally(feed, "title", "title", childs);
			addConditionally(feed, "link", "link", childs);
			addConditionally(feed, "description", "description", childs);
			if((tmp = fetch("lastBuildDate", childs))) feed.updated = new Date(tmp);
			addConditionally(feed, "author", "managingEditor", childs, true);

			feed.items = getElements("item", feedRoot.children).map(function(item){
				var entry = {}, tmp;

				item = item.children;

				addConditionally(entry, "id", "guid", item);
				addConditionally(entry, "title", "title", item);
				addConditionally(entry, "link", "link", item);
				addConditionally(entry, "description", "description", item);
				if((tmp = fetch("pubDate", item))) entry.pubDate = new Date(tmp);
				return entry;
			});
		}
	}
	this.dom = feed;
	DomHandler.prototype._handleCallback.call(
		this, feedRoot ? null : Error("couldn't find root of feed")
	);
};

module.exports = FeedHandler;


/***/ }),

/***/ "./node_modules/htmlparser2/lib/Parser.js":
/*!************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Parser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Tokenizer = __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/htmlparser2/lib/Tokenizer.js");

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var openImpliesClose = {
	tr      : { tr:true, th:true, td:true },
	th      : { th:true },
	td      : { thead:true, th:true, td:true },
	body    : { head:true, link:true, script:true },
	li      : { li:true },
	p       : { p:true },
	h1      : { p:true },
	h2      : { p:true },
	h3      : { p:true },
	h4      : { p:true },
	h5      : { p:true },
	h6      : { p:true },
	select  : formTags,
	input   : formTags,
	output  : formTags,
	button  : formTags,
	datalist: formTags,
	textarea: formTags,
	option  : { option:true },
	optgroup: { optgroup:true }
};

var voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,
};

var foreignContextElements = {
	__proto__: null,
	math: true,
	svg: true
}
var htmlIntegrationElements = {
	__proto__: null,
	mi: true,
	mo: true,
	mn: true,
	ms: true,
	mtext: true,
	"annotation-xml": true,
	foreignObject: true,
	desc: true,
	title: true
}

var re_nameEnd = /\s|\//;

function Parser(cbs, options){
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];
	this._foreignContext = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
		!!this._options.lowerCaseTags :
		!this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
		!!this._options.lowerCaseAttributeNames :
		!this._options.xmlMode;

	if(this._options.Tokenizer) {
		Tokenizer = this._options.Tokenizer;
	}
	this._tokenizer = new Tokenizer(this._options, this);

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
}

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Parser, __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

Parser.prototype._updatePosition = function(initialOffset){
	if(this.endIndex === null){
		if(this._tokenizer._sectionStart <= initialOffset){
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	}
	else this.startIndex = this.endIndex + 1;
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
Parser.prototype.ontext = function(data){
	this._updatePosition(1);
	this.endIndex--;

	if(this._cbs.ontext) this._cbs.ontext(data);
};

Parser.prototype.onopentagname = function(name){
	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	this._tagname = name;

	if(!this._options.xmlMode && name in openImpliesClose) {
		for(
			var el;
			(el = this._stack[this._stack.length - 1]) in openImpliesClose[name];
			this.onclosetag(el)
		);
	}

	if(this._options.xmlMode || !(name in voidElements)){
		this._stack.push(name);
		if(name in foreignContextElements) this._foreignContext.push(true);
		else if(name in htmlIntegrationElements) this._foreignContext.push(false);
	}

	if(this._cbs.onopentagname) this._cbs.onopentagname(name);
	if(this._cbs.onopentag) this._attribs = {};
};

Parser.prototype.onopentagend = function(){
	this._updatePosition(1);

	if(this._attribs){
		if(this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
		this._attribs = null;
	}

	if(!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements){
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

Parser.prototype.onclosetag = function(name){
	this._updatePosition(1);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	if(this._stack.length && (!(name in voidElements) || this._options.xmlMode)){
		var pos = this._stack.lastIndexOf(name);
		if(pos !== -1){
			if(this._cbs.onclosetag){
				pos = this._stack.length - pos;
				while(pos--) this._cbs.onclosetag(this._stack.pop());
			}
			else this._stack.length = pos;
		} else if(name === "p" && !this._options.xmlMode){
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	} else if(!this._options.xmlMode && (name === "br" || name === "p")){
		this.onopentagname(name);
		this._closeCurrentTag();
	}
};

Parser.prototype.onselfclosingtag = function(){
	if(this._options.xmlMode || this._options.recognizeSelfClosing
		|| this._foreignContext[this._foreignContext.length - 1]){
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

Parser.prototype._closeCurrentTag = function(){
	var name = this._tagname;

	this.onopentagend();

	//self-closing tags will be on the top of the stack
	//(cheaper check than in onclosetag)
	if(this._stack[this._stack.length - 1] === name){
		if(this._cbs.onclosetag){
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
		if((name in foreignContextElements) || (name in htmlIntegrationElements)){
			this._foreignContext.pop();
		}
	}
};

Parser.prototype.onattribname = function(name){
	if(this._lowerCaseAttributeNames){
		name = name.toLowerCase();
	}
	this._attribname = name;
};

Parser.prototype.onattribdata = function(value){
	this._attribvalue += value;
};

Parser.prototype.onattribend = function(){
	if(this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
	if(
		this._attribs &&
		!Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)
	){
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

Parser.prototype._getInstructionName = function(value){
	var idx = value.search(re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	return name;
};

Parser.prototype.ondeclaration = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

Parser.prototype.onprocessinginstruction = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

Parser.prototype.oncomment = function(value){
	this._updatePosition(4);

	if(this._cbs.oncomment) this._cbs.oncomment(value);
	if(this._cbs.oncommentend) this._cbs.oncommentend();
};

Parser.prototype.oncdata = function(value){
	this._updatePosition(1);

	if(this._options.xmlMode || this._options.recognizeCDATA){
		if(this._cbs.oncdatastart) this._cbs.oncdatastart();
		if(this._cbs.ontext) this._cbs.ontext(value);
		if(this._cbs.oncdataend) this._cbs.oncdataend();
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

Parser.prototype.onerror = function(err){
	if(this._cbs.onerror) this._cbs.onerror(err);
};

Parser.prototype.onend = function(){
	if(this._cbs.onclosetag){
		for(
			var i = this._stack.length;
			i > 0;
			this._cbs.onclosetag(this._stack[--i])
		);
	}
	if(this._cbs.onend) this._cbs.onend();
};


//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset = function(){
	if(this._cbs.onreset) this._cbs.onreset();
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete = function(data){
	this.reset();
	this.end(data);
};

Parser.prototype.write = function(chunk){
	this._tokenizer.write(chunk);
};

Parser.prototype.end = function(chunk){
	this._tokenizer.end(chunk);
};

Parser.prototype.pause = function(){
	this._tokenizer.pause();
};

Parser.prototype.resume = function(){
	this._tokenizer.resume();
};

//alias for backwards compat
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;

module.exports = Parser;


/***/ }),

/***/ "./node_modules/htmlparser2/lib/ProxyHandler.js":
/*!******************************************************!*\
  !*** ./node_modules/htmlparser2/lib/ProxyHandler.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = ProxyHandler;

function ProxyHandler(cbs){
	this._cbs = cbs || {};
}

var EVENTS = __webpack_require__(/*! ./ */ "./node_modules/htmlparser2/lib/index.js").EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(){
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a){
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a, b){
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});

/***/ }),

/***/ "./node_modules/htmlparser2/lib/Stream.js":
/*!************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Stream.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Stream;

var Parser = __webpack_require__(/*! ./WritableStream.js */ "./node_modules/htmlparser2/lib/WritableStream.js");

function Stream(options){
	Parser.call(this, new Cbs(this), options);
}

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Stream, Parser);

Stream.prototype.readable = true;

function Cbs(scope){
	this.scope = scope;
}

var EVENTS = __webpack_require__(/*! ../ */ "./node_modules/htmlparser2/lib/index.js").EVENTS;

Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		Cbs.prototype["on" + name] = function(){
			this.scope.emit(name);
		};
	} else if(EVENTS[name] === 1){
		Cbs.prototype["on" + name] = function(a){
			this.scope.emit(name, a);
		};
	} else if(EVENTS[name] === 2){
		Cbs.prototype["on" + name] = function(a, b){
			this.scope.emit(name, a, b);
		};
	} else {
		throw Error("wrong number of arguments!");
	}
});

/***/ }),

/***/ "./node_modules/htmlparser2/lib/Tokenizer.js":
/*!***************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Tokenizer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Tokenizer;

var decodeCodePoint = __webpack_require__(/*! entities/lib/decode_codepoint.js */ "./node_modules/entities/lib/decode_codepoint.js");
var entityMap = __webpack_require__(/*! entities/maps/entities.json */ "./node_modules/entities/maps/entities.json");
var legacyMap = __webpack_require__(/*! entities/maps/legacy.json */ "./node_modules/entities/maps/legacy.json");
var xmlMap    = __webpack_require__(/*! entities/maps/xml.json */ "./node_modules/entities/maps/xml.json");

var i = 0;

var TEXT                      = i++;
var BEFORE_TAG_NAME           = i++; //after <
var IN_TAG_NAME               = i++;
var IN_SELF_CLOSING_TAG       = i++;
var BEFORE_CLOSING_TAG_NAME   = i++;
var IN_CLOSING_TAG_NAME       = i++;
var AFTER_CLOSING_TAG_NAME    = i++;

//attributes
var BEFORE_ATTRIBUTE_NAME     = i++;
var IN_ATTRIBUTE_NAME         = i++;
var AFTER_ATTRIBUTE_NAME      = i++;
var BEFORE_ATTRIBUTE_VALUE    = i++;
var IN_ATTRIBUTE_VALUE_DQ     = i++; // "
var IN_ATTRIBUTE_VALUE_SQ     = i++; // '
var IN_ATTRIBUTE_VALUE_NQ     = i++;

//declarations
var BEFORE_DECLARATION        = i++; // !
var IN_DECLARATION            = i++;

//processing instructions
var IN_PROCESSING_INSTRUCTION = i++; // ?

//comments
var BEFORE_COMMENT            = i++;
var IN_COMMENT                = i++;
var AFTER_COMMENT_1           = i++;
var AFTER_COMMENT_2           = i++;

//cdata
var BEFORE_CDATA_1            = i++; // [
var BEFORE_CDATA_2            = i++; // C
var BEFORE_CDATA_3            = i++; // D
var BEFORE_CDATA_4            = i++; // A
var BEFORE_CDATA_5            = i++; // T
var BEFORE_CDATA_6            = i++; // A
var IN_CDATA                  = i++; // [
var AFTER_CDATA_1             = i++; // ]
var AFTER_CDATA_2             = i++; // ]

//special tags
var BEFORE_SPECIAL            = i++; //S
var BEFORE_SPECIAL_END        = i++;   //S

var BEFORE_SCRIPT_1           = i++; //C
var BEFORE_SCRIPT_2           = i++; //R
var BEFORE_SCRIPT_3           = i++; //I
var BEFORE_SCRIPT_4           = i++; //P
var BEFORE_SCRIPT_5           = i++; //T
var AFTER_SCRIPT_1            = i++; //C
var AFTER_SCRIPT_2            = i++; //R
var AFTER_SCRIPT_3            = i++; //I
var AFTER_SCRIPT_4            = i++; //P
var AFTER_SCRIPT_5            = i++; //T

var BEFORE_STYLE_1            = i++; //T
var BEFORE_STYLE_2            = i++; //Y
var BEFORE_STYLE_3            = i++; //L
var BEFORE_STYLE_4            = i++; //E
var AFTER_STYLE_1             = i++; //T
var AFTER_STYLE_2             = i++; //Y
var AFTER_STYLE_3             = i++; //L
var AFTER_STYLE_4             = i++; //E

var BEFORE_ENTITY             = i++; //&
var BEFORE_NUMERIC_ENTITY     = i++; //#
var IN_NAMED_ENTITY           = i++;
var IN_NUMERIC_ENTITY         = i++;
var IN_HEX_ENTITY             = i++; //X

var j = 0;

var SPECIAL_NONE              = j++;
var SPECIAL_SCRIPT            = j++;
var SPECIAL_STYLE             = j++;

function whitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function ifElseState(upper, SUCCESS, FAILURE){
	var lower = upper.toLowerCase();

	if(upper === lower){
		return function(c){
			if(c === lower){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	} else {
		return function(c){
			if(c === lower || c === upper){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	}
}

function consumeSpecialNameChar(upper, NEXT_STATE){
	var lower = upper.toLowerCase();

	return function(c){
		if(c === lower || c === upper){
			this._state = NEXT_STATE;
		} else {
			this._state = IN_TAG_NAME;
			this._index--; //consume the token again
		}
	};
}

function Tokenizer(options, cbs){
	this._state = TEXT;
	this._buffer = "";
	this._sectionStart = 0;
	this._index = 0;
	this._bufferOffset = 0; //chars removed from _buffer
	this._baseState = TEXT;
	this._special = SPECIAL_NONE;
	this._cbs = cbs;
	this._running = true;
	this._ended = false;
	this._xmlMode = !!(options && options.xmlMode);
	this._decodeEntities = !!(options && options.decodeEntities);
}

Tokenizer.prototype._stateText = function(c){
	if(c === "<"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._state = BEFORE_TAG_NAME;
		this._sectionStart = this._index;
	} else if(this._decodeEntities && this._special === SPECIAL_NONE && c === "&"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._baseState = TEXT;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeTagName = function(c){
	if(c === "/"){
		this._state = BEFORE_CLOSING_TAG_NAME;
	} else if(c === "<"){
		this._cbs.ontext(this._getSection());
		this._sectionStart = this._index;
	} else if(c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
		this._state = TEXT;
	} else if(c === "!"){
		this._state = BEFORE_DECLARATION;
		this._sectionStart = this._index + 1;
	} else if(c === "?"){
		this._state = IN_PROCESSING_INSTRUCTION;
		this._sectionStart = this._index + 1;
	} else {
		this._state = (!this._xmlMode && (c === "s" || c === "S")) ?
			BEFORE_SPECIAL : IN_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInTagName = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._emitToken("onopentagname");
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateBeforeCloseingTagName = function(c){
	if(whitespace(c));
	else if(c === ">"){
		this._state = TEXT;
	} else if(this._special !== SPECIAL_NONE){
		if(c === "s" || c === "S"){
			this._state = BEFORE_SPECIAL_END;
		} else {
			this._state = TEXT;
			this._index--;
		}
	} else {
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInCloseingTagName = function(c){
	if(c === ">" || whitespace(c)){
		this._emitToken("onclosetag");
		this._state = AFTER_CLOSING_TAG_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterCloseingTagName = function(c){
	//skip everything until ">"
	if(c === ">"){
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeAttributeName = function(c){
	if(c === ">"){
		this._cbs.onopentagend();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c === "/"){
		this._state = IN_SELF_CLOSING_TAG;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInSelfClosingTag = function(c){
	if(c === ">"){
		this._cbs.onselfclosingtag();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateInAttributeName = function(c){
	if(c === "=" || c === "/" || c === ">" || whitespace(c)){
		this._cbs.onattribname(this._getSection());
		this._sectionStart = -1;
		this._state = AFTER_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterAttributeName = function(c){
	if(c === "="){
		this._state = BEFORE_ATTRIBUTE_VALUE;
	} else if(c === "/" || c === ">"){
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(!whitespace(c)){
		this._cbs.onattribend();
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeAttributeValue = function(c){
	if(c === "\""){
		this._state = IN_ATTRIBUTE_VALUE_DQ;
		this._sectionStart = this._index + 1;
	} else if(c === "'"){
		this._state = IN_ATTRIBUTE_VALUE_SQ;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_VALUE_NQ;
		this._sectionStart = this._index;
		this._index--; //reconsume token
	}
};

Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c){
	if(c === "\""){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c){
	if(c === "'"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c){
	if(whitespace(c) || c === ">"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeDeclaration = function(c){
	this._state = c === "[" ? BEFORE_CDATA_1 :
		c === "-" ? BEFORE_COMMENT :
			IN_DECLARATION;
};

Tokenizer.prototype._stateInDeclaration = function(c){
	if(c === ">"){
		this._cbs.ondeclaration(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateInProcessingInstruction = function(c){
	if(c === ">"){
		this._cbs.onprocessinginstruction(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeComment = function(c){
	if(c === "-"){
		this._state = IN_COMMENT;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
	}
};

Tokenizer.prototype._stateInComment = function(c){
	if(c === "-") this._state = AFTER_COMMENT_1;
};

Tokenizer.prototype._stateAfterComment1 = function(c){
	if(c === "-"){
		this._state = AFTER_COMMENT_2;
	} else {
		this._state = IN_COMMENT;
	}
};

Tokenizer.prototype._stateAfterComment2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "-"){
		this._state = IN_COMMENT;
	}
	// else: stay in AFTER_COMMENT_2 (`--->`)
};

Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);

Tokenizer.prototype._stateBeforeCdata6 = function(c){
	if(c === "["){
		this._state = IN_CDATA;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
		this._index--;
	}
};

Tokenizer.prototype._stateInCdata = function(c){
	if(c === "]") this._state = AFTER_CDATA_1;
};

Tokenizer.prototype._stateAfterCdata1 = function(c){
	if(c === "]") this._state = AFTER_CDATA_2;
	else this._state = IN_CDATA;
};

Tokenizer.prototype._stateAfterCdata2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "]") {
		this._state = IN_CDATA;
	}
	//else: stay in AFTER_CDATA_2 (`]]]>`)
};

Tokenizer.prototype._stateBeforeSpecial = function(c){
	if(c === "c" || c === "C"){
		this._state = BEFORE_SCRIPT_1;
	} else if(c === "t" || c === "T"){
		this._state = BEFORE_STYLE_1;
	} else {
		this._state = IN_TAG_NAME;
		this._index--; //consume the token again
	}
};

Tokenizer.prototype._stateBeforeSpecialEnd = function(c){
	if(this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")){
		this._state = AFTER_SCRIPT_1;
	} else if(this._special === SPECIAL_STYLE && (c === "t" || c === "T")){
		this._state = AFTER_STYLE_1;
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);

Tokenizer.prototype._stateBeforeScript5 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_SCRIPT;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);

Tokenizer.prototype._stateAfterScript5 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 6;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);

Tokenizer.prototype._stateBeforeStyle4 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_STYLE;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);

Tokenizer.prototype._stateAfterStyle4 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 5;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
Tokenizer.prototype._parseNamedEntityStrict = function(){
	//offset = 1
	if(this._sectionStart + 1 < this._index){
		var entity = this._buffer.substring(this._sectionStart + 1, this._index),
		    map = this._xmlMode ? xmlMap : entityMap;

		if(map.hasOwnProperty(entity)){
			this._emitPartial(map[entity]);
			this._sectionStart = this._index + 1;
		}
	}
};


//parses legacy entities (without trailing semicolon)
Tokenizer.prototype._parseLegacyEntity = function(){
	var start = this._sectionStart + 1,
	    limit = this._index - start;

	if(limit > 6) limit = 6; //the max length of legacy entities is 6

	while(limit >= 2){ //the min length of legacy entities is 2
		var entity = this._buffer.substr(start, limit);

		if(legacyMap.hasOwnProperty(entity)){
			this._emitPartial(legacyMap[entity]);
			this._sectionStart += limit + 1;
			return;
		} else {
			limit--;
		}
	}
};

Tokenizer.prototype._stateInNamedEntity = function(c){
	if(c === ";"){
		this._parseNamedEntityStrict();
		if(this._sectionStart + 1 < this._index && !this._xmlMode){
			this._parseLegacyEntity();
		}
		this._state = this._baseState;
	} else if((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")){
		if(this._xmlMode);
		else if(this._sectionStart + 1 === this._index);
		else if(this._baseState !== TEXT){
			if(c !== "="){
				this._parseNamedEntityStrict();
			}
		} else {
			this._parseLegacyEntity();
		}

		this._state = this._baseState;
		this._index--;
	}
};

Tokenizer.prototype._decodeNumericEntity = function(offset, base){
	var sectionStart = this._sectionStart + offset;

	if(sectionStart !== this._index){
		//parse entity
		var entity = this._buffer.substring(sectionStart, this._index);
		var parsed = parseInt(entity, base);

		this._emitPartial(decodeCodePoint(parsed));
		this._sectionStart = this._index;
	} else {
		this._sectionStart--;
	}

	this._state = this._baseState;
};

Tokenizer.prototype._stateInNumericEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(2, 10);
		this._sectionStart++;
	} else if(c < "0" || c > "9"){
		if(!this._xmlMode){
			this._decodeNumericEntity(2, 10);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._stateInHexEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(3, 16);
		this._sectionStart++;
	} else if((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")){
		if(!this._xmlMode){
			this._decodeNumericEntity(3, 16);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._cleanup = function (){
	if(this._sectionStart < 0){
		this._buffer = "";
		this._bufferOffset += this._index;
		this._index = 0;
	} else if(this._running){
		if(this._state === TEXT){
			if(this._sectionStart !== this._index){
				this._cbs.ontext(this._buffer.substr(this._sectionStart));
			}
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else if(this._sectionStart === this._index){
			//the section just started
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else {
			//remove everything unnecessary
			this._buffer = this._buffer.substr(this._sectionStart);
			this._index -= this._sectionStart;
			this._bufferOffset += this._sectionStart;
		}

		this._sectionStart = 0;
	}
};

//TODO make events conditional
Tokenizer.prototype.write = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".write() after done!"));

	this._buffer += chunk;
	this._parse();
};

Tokenizer.prototype._parse = function(){
	while(this._index < this._buffer.length && this._running){
		var c = this._buffer.charAt(this._index);
		if(this._state === TEXT) {
			this._stateText(c);
		} else if(this._state === BEFORE_TAG_NAME){
			this._stateBeforeTagName(c);
		} else if(this._state === IN_TAG_NAME) {
			this._stateInTagName(c);
		} else if(this._state === BEFORE_CLOSING_TAG_NAME){
			this._stateBeforeCloseingTagName(c);
		} else if(this._state === IN_CLOSING_TAG_NAME){
			this._stateInCloseingTagName(c);
		} else if(this._state === AFTER_CLOSING_TAG_NAME){
			this._stateAfterCloseingTagName(c);
		} else if(this._state === IN_SELF_CLOSING_TAG){
			this._stateInSelfClosingTag(c);
		}

		/*
		*	attributes
		*/
		else if(this._state === BEFORE_ATTRIBUTE_NAME){
			this._stateBeforeAttributeName(c);
		} else if(this._state === IN_ATTRIBUTE_NAME){
			this._stateInAttributeName(c);
		} else if(this._state === AFTER_ATTRIBUTE_NAME){
			this._stateAfterAttributeName(c);
		} else if(this._state === BEFORE_ATTRIBUTE_VALUE){
			this._stateBeforeAttributeValue(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_DQ){
			this._stateInAttributeValueDoubleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_SQ){
			this._stateInAttributeValueSingleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_NQ){
			this._stateInAttributeValueNoQuotes(c);
		}

		/*
		*	declarations
		*/
		else if(this._state === BEFORE_DECLARATION){
			this._stateBeforeDeclaration(c);
		} else if(this._state === IN_DECLARATION){
			this._stateInDeclaration(c);
		}

		/*
		*	processing instructions
		*/
		else if(this._state === IN_PROCESSING_INSTRUCTION){
			this._stateInProcessingInstruction(c);
		}

		/*
		*	comments
		*/
		else if(this._state === BEFORE_COMMENT){
			this._stateBeforeComment(c);
		} else if(this._state === IN_COMMENT){
			this._stateInComment(c);
		} else if(this._state === AFTER_COMMENT_1){
			this._stateAfterComment1(c);
		} else if(this._state === AFTER_COMMENT_2){
			this._stateAfterComment2(c);
		}

		/*
		*	cdata
		*/
		else if(this._state === BEFORE_CDATA_1){
			this._stateBeforeCdata1(c);
		} else if(this._state === BEFORE_CDATA_2){
			this._stateBeforeCdata2(c);
		} else if(this._state === BEFORE_CDATA_3){
			this._stateBeforeCdata3(c);
		} else if(this._state === BEFORE_CDATA_4){
			this._stateBeforeCdata4(c);
		} else if(this._state === BEFORE_CDATA_5){
			this._stateBeforeCdata5(c);
		} else if(this._state === BEFORE_CDATA_6){
			this._stateBeforeCdata6(c);
		} else if(this._state === IN_CDATA){
			this._stateInCdata(c);
		} else if(this._state === AFTER_CDATA_1){
			this._stateAfterCdata1(c);
		} else if(this._state === AFTER_CDATA_2){
			this._stateAfterCdata2(c);
		}

		/*
		* special tags
		*/
		else if(this._state === BEFORE_SPECIAL){
			this._stateBeforeSpecial(c);
		} else if(this._state === BEFORE_SPECIAL_END){
			this._stateBeforeSpecialEnd(c);
		}

		/*
		* script
		*/
		else if(this._state === BEFORE_SCRIPT_1){
			this._stateBeforeScript1(c);
		} else if(this._state === BEFORE_SCRIPT_2){
			this._stateBeforeScript2(c);
		} else if(this._state === BEFORE_SCRIPT_3){
			this._stateBeforeScript3(c);
		} else if(this._state === BEFORE_SCRIPT_4){
			this._stateBeforeScript4(c);
		} else if(this._state === BEFORE_SCRIPT_5){
			this._stateBeforeScript5(c);
		}

		else if(this._state === AFTER_SCRIPT_1){
			this._stateAfterScript1(c);
		} else if(this._state === AFTER_SCRIPT_2){
			this._stateAfterScript2(c);
		} else if(this._state === AFTER_SCRIPT_3){
			this._stateAfterScript3(c);
		} else if(this._state === AFTER_SCRIPT_4){
			this._stateAfterScript4(c);
		} else if(this._state === AFTER_SCRIPT_5){
			this._stateAfterScript5(c);
		}

		/*
		* style
		*/
		else if(this._state === BEFORE_STYLE_1){
			this._stateBeforeStyle1(c);
		} else if(this._state === BEFORE_STYLE_2){
			this._stateBeforeStyle2(c);
		} else if(this._state === BEFORE_STYLE_3){
			this._stateBeforeStyle3(c);
		} else if(this._state === BEFORE_STYLE_4){
			this._stateBeforeStyle4(c);
		}

		else if(this._state === AFTER_STYLE_1){
			this._stateAfterStyle1(c);
		} else if(this._state === AFTER_STYLE_2){
			this._stateAfterStyle2(c);
		} else if(this._state === AFTER_STYLE_3){
			this._stateAfterStyle3(c);
		} else if(this._state === AFTER_STYLE_4){
			this._stateAfterStyle4(c);
		}

		/*
		* entities
		*/
		else if(this._state === BEFORE_ENTITY){
			this._stateBeforeEntity(c);
		} else if(this._state === BEFORE_NUMERIC_ENTITY){
			this._stateBeforeNumericEntity(c);
		} else if(this._state === IN_NAMED_ENTITY){
			this._stateInNamedEntity(c);
		} else if(this._state === IN_NUMERIC_ENTITY){
			this._stateInNumericEntity(c);
		} else if(this._state === IN_HEX_ENTITY){
			this._stateInHexEntity(c);
		}

		else {
			this._cbs.onerror(Error("unknown _state"), this._state);
		}

		this._index++;
	}

	this._cleanup();
};

Tokenizer.prototype.pause = function(){
	this._running = false;
};
Tokenizer.prototype.resume = function(){
	this._running = true;

	if(this._index < this._buffer.length){
		this._parse();
	}
	if(this._ended){
		this._finish();
	}
};

Tokenizer.prototype.end = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".end() after done!"));
	if(chunk) this.write(chunk);

	this._ended = true;

	if(this._running) this._finish();
};

Tokenizer.prototype._finish = function(){
	//if there is remaining data, emit it in a reasonable way
	if(this._sectionStart < this._index){
		this._handleTrailingData();
	}

	this._cbs.onend();
};

Tokenizer.prototype._handleTrailingData = function(){
	var data = this._buffer.substr(this._sectionStart);

	if(this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2){
		this._cbs.oncdata(data);
	} else if(this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2){
		this._cbs.oncomment(data);
	} else if(this._state === IN_NAMED_ENTITY && !this._xmlMode){
		this._parseLegacyEntity();
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_NUMERIC_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(2, 10);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_HEX_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(3, 16);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(
		this._state !== IN_TAG_NAME &&
		this._state !== BEFORE_ATTRIBUTE_NAME &&
		this._state !== BEFORE_ATTRIBUTE_VALUE &&
		this._state !== AFTER_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_VALUE_SQ &&
		this._state !== IN_ATTRIBUTE_VALUE_DQ &&
		this._state !== IN_ATTRIBUTE_VALUE_NQ &&
		this._state !== IN_CLOSING_TAG_NAME
	){
		this._cbs.ontext(data);
	}
	//else, ignore remaining data
	//TODO add a way to remove current tag
};

Tokenizer.prototype.reset = function(){
	Tokenizer.call(this, {xmlMode: this._xmlMode, decodeEntities: this._decodeEntities}, this._cbs);
};

Tokenizer.prototype.getAbsoluteIndex = function(){
	return this._bufferOffset + this._index;
};

Tokenizer.prototype._getSection = function(){
	return this._buffer.substring(this._sectionStart, this._index);
};

Tokenizer.prototype._emitToken = function(name){
	this._cbs[name](this._getSection());
	this._sectionStart = -1;
};

Tokenizer.prototype._emitPartial = function(value){
	if(this._baseState !== TEXT){
		this._cbs.onattribdata(value); //TODO implement the new event
	} else {
		this._cbs.ontext(value);
	}
};


/***/ }),

/***/ "./node_modules/htmlparser2/lib/WritableStream.js":
/*!********************************************************!*\
  !*** ./node_modules/htmlparser2/lib/WritableStream.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Stream;

var Parser = __webpack_require__(/*! ./Parser.js */ "./node_modules/htmlparser2/lib/Parser.js");
var WritableStream = __webpack_require__(/*! readable-stream */ 0).Writable;
var StringDecoder = __webpack_require__(/*! string_decoder */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

function Stream(cbs, options){
	var parser = this._parser = new Parser(cbs, options);
	var decoder = this._decoder = new StringDecoder();

	WritableStream.call(this, {decodeStrings: false});

	this.once("finish", function(){
		parser.end(decoder.end());
	});
}

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Stream, WritableStream);

WritableStream.prototype._write = function(chunk, encoding, cb){
	if(chunk instanceof Buffer) chunk = this._decoder.write(chunk);
	this._parser.write(chunk);
	cb();
};


/***/ }),

/***/ "./node_modules/htmlparser2/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/htmlparser2/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Parser = __webpack_require__(/*! ./Parser.js */ "./node_modules/htmlparser2/lib/Parser.js");
var DomHandler = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/index.js");

function defineProp(name, value){
	delete module.exports[name];
	module.exports[name] = value;
	return value;
}

module.exports = {
	Parser: Parser,
	Tokenizer: __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/htmlparser2/lib/Tokenizer.js"),
	ElementType: __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/index.js"),
	DomHandler: DomHandler,
	get FeedHandler(){
		return defineProp("FeedHandler", __webpack_require__(/*! ./FeedHandler.js */ "./node_modules/htmlparser2/lib/FeedHandler.js"));
	},
	get Stream(){
		return defineProp("Stream", __webpack_require__(/*! ./Stream.js */ "./node_modules/htmlparser2/lib/Stream.js"));
	},
	get WritableStream(){
		return defineProp("WritableStream", __webpack_require__(/*! ./WritableStream.js */ "./node_modules/htmlparser2/lib/WritableStream.js"));
	},
	get ProxyHandler(){
		return defineProp("ProxyHandler", __webpack_require__(/*! ./ProxyHandler.js */ "./node_modules/htmlparser2/lib/ProxyHandler.js"));
	},
	get DomUtils(){
		return defineProp("DomUtils", __webpack_require__(/*! domutils */ "./node_modules/domutils/index.js"));
	},
	get CollectingHandler(){
		return defineProp("CollectingHandler", __webpack_require__(/*! ./CollectingHandler.js */ "./node_modules/htmlparser2/lib/CollectingHandler.js"));
	},
	// For legacy support
	DefaultHandler: DomHandler,
	get RssHandler(){
		return defineProp("RssHandler", this.FeedHandler);
	},
	//helper methods
	parseDOM: function(data, options){
		var handler = new DomHandler(options);
		new Parser(handler, options).end(data);
		return handler.dom;
	},
	parseFeed: function(feed, options){
		var handler = new module.exports.FeedHandler(options);
		new Parser(handler, options).end(feed);
		return handler.dom;
	},
	createDomStream: function(cb, options, elementCb){
		var handler = new DomHandler(cb, options, elementCb);
		return new Parser(handler, options);
	},
	// List of all events that the parser emits
	EVENTS: { /* Format: eventname: number of arguments */
		attribute: 2,
		cdatastart: 0,
		cdataend: 0,
		text: 1,
		processinginstruction: 2,
		comment: 1,
		commentend: 0,
		closetag: 1,
		opentag: 2,
		opentagname: 1,
		error: 1,
		end: 0
	}
};


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/immutable/dist/immutable.js":
/*!**************************************************!*\
  !*** ./node_modules/immutable/dist/immutable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 *  Copyright (c) 2014-2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

  function createClass(ctor, superClass) {
    if (superClass) {
      ctor.prototype = Object.create(superClass.prototype);
    }
    ctor.prototype.constructor = ctor;
  }

  function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }


  createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }


  createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }


  createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }



  function isIterable(maybeIterable) {
    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  }

  function isKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  }

  function isIndexed(maybeIndexed) {
    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  function isOrdered(maybeOrdered) {
    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  }

  Iterable.isIterable = isIterable;
  Iterable.isKeyed = isKeyed;
  Iterable.isIndexed = isIndexed;
  Iterable.isAssociative = isAssociative;
  Iterable.isOrdered = isOrdered;

  Iterable.Keyed = KeyedIterable;
  Iterable.Indexed = IndexedIterable;
  Iterable.Set = SetIterable;


  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  // Used for setting prototype methods that IE8 chokes on.
  var DELETE = 'delete';

  // Constants describing the size of trie nodes.
  var SHIFT = 5; // Resulted in best performance after ______?
  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1;

  // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.
  var NOT_SET = {};

  // Boolean references, Rough equivalent of `bool &`.
  var CHANGE_LENGTH = { value: false };
  var DID_ALTER = { value: false };

  function MakeRef(ref) {
    ref.value = false;
    return ref;
  }

  function SetRef(ref) {
    ref && (ref.value = true);
  }

  // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.
  function OwnerID() {}

  // http://jsperf.com/copy-array-inline
  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }
    return newArr;
  }

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^321.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }
      index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (begin === 0 || (size !== undefined && begin <= -size)) &&
      (end === undefined || (size !== undefined && end >= size));
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    return index === undefined ?
      defaultIndex :
      index < 0 ?
        Math.max(0, size + index) :
        size === undefined ?
          index :
          Math.min(size, index);
  }

  /* global Symbol */

  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;

  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


  function Iterator(next) {
      this.next = next;
    }

    Iterator.prototype.toString = function() {
      return '[Iterator]';
    };


  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect =
  Iterator.prototype.toSource = function () { return this.toString(); }
  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };


  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
      value: value, done: false
    });
    return iteratorResult;
  }

  function iteratorDone() {
    return { value: undefined, done: true };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn = iterable && (
      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]
    );
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isArrayLike(value) {
    return value && typeof value.length === 'number';
  }

  createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() :
        isIterable(value) ? value.toSeq() : seqFromValue(value);
    }

    Seq.of = function(/*...values*/) {
      return Seq(arguments);
    };

    Seq.prototype.toSeq = function() {
      return this;
    };

    Seq.prototype.toString = function() {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, true);
    };



  createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ?
        emptySequence().toKeyedSeq() :
        isIterable(value) ?
          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
          keyedSeqFromValue(value);
    }

    KeyedSeq.prototype.toKeyedSeq = function() {
      return this;
    };



  createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }

    IndexedSeq.of = function(/*...values*/) {
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function() {
      return this;
    };

    IndexedSeq.prototype.toString = function() {
      return this.__toString('Seq [', ']');
    };

    IndexedSeq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };

    IndexedSeq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, false);
    };



  createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (
        value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value
      ).toSetSeq();
    }

    SetSeq.of = function(/*...values*/) {
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function() {
      return this;
    };



  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;

  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

  Seq.prototype[IS_SEQ_SENTINEL] = true;



  createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    ArraySeq.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function(fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ArraySeq.prototype.__iterator = function(type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(function() 
        {return ii > maxIndex ?
          iteratorDone() :
          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
      );
    };



  createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    ObjectSeq.prototype.get = function(key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };

    ObjectSeq.prototype.__iterate = function(fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ObjectSeq.prototype.__iterator = function(type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, key, object[key]);
      });
    };

  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }

    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };



  createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }

    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };

    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function()  {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };




  // # pragma Helper functions

  function isSeq(maybeSeq) {
    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  }

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq =
      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
      typeof value === 'object' ? new ObjectSeq(value) :
      undefined;
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of [k, v] entries, '+
        'or keyed object: ' + value
      );
    }
    return seq;
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values: ' + value
      );
    }
    return seq;
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value) ||
      (typeof value === 'object' && new ObjectSeq(value));
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values, or keyed object: ' + value
      );
    }
    return seq;
  }

  function maybeIndexedSeqFromValue(value) {
    return (
      isArrayLike(value) ? new ArraySeq(value) :
      isIterator(value) ? new IteratorSeq(value) :
      hasIterator(value) ? new IterableSeq(value) :
      undefined
    );
  }

  function seqIterate(seq, fn, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var entry = cache[reverse ? maxIndex - ii : ii];
        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
          return ii + 1;
        }
      }
      return ii;
    }
    return seq.__iterateUncached(fn, reverse);
  }

  function seqIterator(seq, type, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var entry = cache[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
      });
    }
    return seq.__iteratorUncached(type, reverse);
  }

  function fromJS(json, converter) {
    return converter ?
      fromJSWith(converter, json, '', {'': json}) :
      fromJSDefault(json);
  }

  function fromJSWith(converter, json, key, parentJSON) {
    if (Array.isArray(json)) {
      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    if (isPlainObj(json)) {
      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    return json;
  }

  function fromJSDefault(json) {
    if (Array.isArray(json)) {
      return IndexedSeq(json).map(fromJSDefault).toList();
    }
    if (isPlainObj(json)) {
      return KeyedSeq(json).map(fromJSDefault).toMap();
    }
    return json;
  }

  function isPlainObj(value) {
    return value && (value.constructor === Object || value.constructor === undefined);
  }

  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if the it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections implement `equals` and `hashCode`.
   *
   */
  function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
    if (typeof valueA.valueOf === 'function' &&
        typeof valueB.valueOf === 'function') {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
    }
    if (typeof valueA.equals === 'function' &&
        typeof valueB.equals === 'function' &&
        valueA.equals(valueB)) {
      return true;
    }
    return false;
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (
      !isIterable(b) ||
      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
      isKeyed(a) !== isKeyed(b) ||
      isIndexed(a) !== isIndexed(b) ||
      isOrdered(a) !== isOrdered(b)
    ) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return b.every(function(v, k)  {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done;
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;
    var bSize = b.__iterate(function(v, k)  {
      if (notAssociative ? !a.has(v) :
          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  createClass(Repeat, IndexedSeq);

    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    Repeat.prototype.toString = function() {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function(searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this :
        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };

    Repeat.prototype.reverse = function() {
      return this;
    };

    Repeat.prototype.indexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function(fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
      var ii = 0;
      return new Iterator(function() 
        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
      );
    };

    Repeat.prototype.equals = function(other) {
      return other instanceof Repeat ?
        is(this._value, other._value) :
        deepEqual(other);
    };


  var EMPTY_REPEAT;

  function invariant(condition, error) {
    if (!condition) throw new Error(error);
  }

  createClass(Range, IndexedSeq);

    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    Range.prototype.toString = function() {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' +
        this._start + '...' + this._end +
        (this._step !== 1 ? ' by ' + this._step : '') +
      ' ]';
    };

    Range.prototype.get = function(index, notSetValue) {
      return this.has(index) ?
        this._start + wrapIndex(this, index) * this._step :
        notSetValue;
    };

    Range.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 &&
        possibleIndex < this.size &&
        possibleIndex === Math.floor(possibleIndex);
    };

    Range.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };

    Range.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function(fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };

    Range.prototype.__iterator = function(type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function()  {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };

    Range.prototype.equals = function(other) {
      return other instanceof Range ?
        this._start === other._start &&
        this._end === other._end &&
        this._step === other._step :
        deepEqual(this, other);
    };


  var EMPTY_RANGE;

  createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }


  createClass(KeyedCollection, Collection);function KeyedCollection() {}

  createClass(IndexedCollection, Collection);function IndexedCollection() {}

  createClass(SetCollection, Collection);function SetCollection() {}


  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;

  var imul =
    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
    Math.imul :
    function imul(a, b) {
      a = a | 0; // int
      b = b | 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
    };

  // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.
  function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }
    if (typeof o.valueOf === 'function') {
      o = o.valueOf();
      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }
    if (o === true) {
      return 1;
    }
    var type = typeof o;
    if (type === 'number') {
      if (o !== o || o === Infinity) {
        return 0;
      }
      var h = o | 0;
      if (h !== o) {
        h ^= o * 0xFFFFFFFF;
      }
      while (o > 0xFFFFFFFF) {
        o /= 0xFFFFFFFF;
        h ^= o;
      }
      return smi(h);
    }
    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
    }
    if (typeof o.hashCode === 'function') {
      return o.hashCode();
    }
    if (type === 'object') {
      return hashJSObj(o);
    }
    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }
    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hash = stringHashCache[string];
    if (hash === undefined) {
      hash = hashString(string);
      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }
      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hash;
    }
    return hash;
  }

  // http://jsperf.com/hashing-strings
  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hash = 0;
    for (var ii = 0; ii < string.length; ii++) {
      hash = 31 * hash + string.charCodeAt(ii) | 0;
    }
    return smi(hash);
  }

  function hashJSObj(obj) {
    var hash;
    if (usingWeakMap) {
      hash = weakMap.get(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = obj[UID_HASH_KEY];
    if (hash !== undefined) {
      return hash;
    }

    if (!canDefineProperty) {
      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }

      hash = getIENodeHash(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = ++objHashUID;
    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hash);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': hash
      });
    } else if (obj.propertyIsEnumerable !== undefined &&
               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function() {
        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
      };
      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hash;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hash;
  }

  // Get references to ES5 object methods.
  var isExtensible = Object.isExtensible;

  // True if Object.defineProperty works as expected. IE8 fails this test.
  var canDefineProperty = (function() {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  }());

  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.
  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1: // Element
          return node.uniqueID;
        case 9: // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  }

  // If possible, use a WeakMap.
  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;
  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;

  var UID_HASH_KEY = '__immutablehash__';
  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  function assertNotInfinite(size) {
    invariant(
      size !== Infinity,
      'Cannot perform this action with an infinite size.'
    );
  }

  createClass(Map, KeyedCollection);

    // @pragma Construction

    function Map(value) {
      return value === null || value === undefined ? emptyMap() :
        isMap(value) && !isOrdered(value) ? value :
        emptyMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
      return emptyMap().withMutations(function(map ) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };

    Map.prototype.toString = function() {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function(k, notSetValue) {
      return this._root ?
        this._root.get(0, undefined, k, notSetValue) :
        notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function(k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function()  {return v});
    };

    Map.prototype.remove = function(k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function()  {return NOT_SET});
    };

    Map.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ?
        k(this) :
        this.updateIn([k], notSetValue, updater);
    };

    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(
        this,
        forceIterator(keyPath),
        notSetValue,
        updater
      );
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };

    Map.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.merge = function(/*...iters*/) {
      return mergeIntoMapWith(this, undefined, arguments);
    };

    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };

    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.merge === 'function' ?
          m.merge.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };

    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };

    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.mergeDeep === 'function' ?
          m.mergeDeep.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.sort = function(comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    // @pragma Mutability

    Map.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };

    Map.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };

    Map.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };

    Map.prototype.wasAltered = function() {
      return this.__altered;
    };

    Map.prototype.__iterator = function(type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry ) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };


  function isMap(maybeMap) {
    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  }

  Map.isMap = isMap;

  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SENTINEL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeIn = MapPrototype.deleteIn;


  // #pragma Trie Nodes



    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }

    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && entries.length === 1) {
        return; // undefined
      }

      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new ArrayMapNode(ownerID, newEntries);
    };




    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }

    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue :
        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
    };

    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;

      if (!exists && value === NOT_SET) {
        return this;
      }

      var idx = popCount(bitmap & (bit - 1));
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

      if (newNode === node) {
        return this;
      }

      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }

      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }

      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ?
        setIn(nodes, idx, newNode, isEditable) :
        spliceOut(nodes, idx, isEditable) :
        spliceIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }

      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };




    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }

    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };

    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];

      if (removed && !node) {
        return this;
      }

      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }

      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }

      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };




    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }

    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }

      var removed = value === NOT_SET;

      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };




    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }

    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };

    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }

      SetRef(didAlter);

      if (removed) {
        SetRef(didChangeSize);
        return; // undefined
      }

      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }

      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };



  // #pragma Iterators

  ArrayMapNode.prototype.iterate =
  HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;
    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  }

  BitmapIndexedNode.prototype.iterate =
  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  }

  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  }

  createClass(MapIterator, Iterator);

    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    MapIterator.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };


  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;
  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }
      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef(CHANGE_LENGTH);
      var didAlter = MakeRef(DID_ALTER);
      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
      if (!didAlter.value) {
        return map;
      }
      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }
    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  }

  function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

    var newNode;
    var nodes = idx1 === idx2 ?
      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];
      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function mergeIntoMapWith(map, merger, iterables) {
    var iters = [];
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = KeyedIterable(value);
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    return mergeIntoCollectionWith(map, merger, iters);
  }

  function deepMerger(existing, value, key) {
    return existing && existing.mergeDeep && isIterable(value) ?
      existing.mergeDeep(value) :
      is(existing, value) ? existing : value;
  }

  function deepMergerWith(merger) {
    return function(existing, value, key)  {
      if (existing && existing.mergeDeepWith && isIterable(value)) {
        return existing.mergeDeepWith(merger, value);
      }
      var nextValue = merger(existing, value, key);
      return is(existing, nextValue) ? existing : nextValue;
    };
  }

  function mergeIntoCollectionWith(collection, merger, iters) {
    iters = iters.filter(function(x ) {return x.size !== 0});
    if (iters.length === 0) {
      return collection;
    }
    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
      return collection.constructor(iters[0]);
    }
    return collection.withMutations(function(collection ) {
      var mergeIntoMap = merger ?
        function(value, key)  {
          collection.update(key, NOT_SET, function(existing )
            {return existing === NOT_SET ? value : merger(existing, value, key)}
          );
        } :
        function(value, key)  {
          collection.set(key, value);
        }
      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoMap);
      }
    });
  }

  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
    var isNotSet = existing === NOT_SET;
    var step = keyPathIter.next();
    if (step.done) {
      var existingValue = isNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }
    invariant(
      isNotSet || (existing && existing.set),
      'invalid keyPath'
    );
    var key = step.value;
    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
    var nextUpdated = updateInDeepMap(
      nextExisting,
      keyPathIter,
      notSetValue,
      updater
    );
    return nextUpdated === nextExisting ? existing :
      nextUpdated === NOT_SET ? existing.remove(key) :
      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  }

  function popCount(x) {
    x = x - ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x7f;
  }

  function setIn(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }
    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }
      newArray[ii] = array[ii + after];
    }
    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  createClass(List, IndexedCollection);

    // @pragma Construction

    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function(list ) {
        list.setSize(size);
        iter.forEach(function(v, i)  {return list.set(i, v)});
      });
    }

    List.of = function(/*...values*/) {
      return this(arguments);
    };

    List.prototype.toString = function() {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function(index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function(index) {
      return !this.has(index) ? this :
        index === 0 ? this.shift() :
        index === this.size - 1 ? this.pop() :
        this.splice(index, 1);
    };

    List.prototype.insert = function(index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function(/*...values*/) {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list ) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function() {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function(/*...values*/) {
      var values = arguments;
      return this.withMutations(function(list ) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function() {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.merge = function(/*...iters*/) {
      return mergeIntoListWith(this, undefined, arguments);
    };

    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };

    List.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoListWith(this, deepMerger, arguments);
    };

    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };

    List.prototype.setSize = function(size) {
      return setListBounds(this, 0, size);
    };

    // @pragma Iteration

    List.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };

    List.prototype.__iterator = function(type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function()  {
        var value = values();
        return value === DONE ?
          iteratorDone() :
          iteratorValue(type, index++, value);
      });
    };

    List.prototype.__iterate = function(fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };


  function isList(maybeList) {
    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  }

  List.isList = isList;

  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SENTINEL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.setIn = MapPrototype.setIn;
  ListPrototype.deleteIn =
  ListPrototype.removeIn = MapPrototype.removeIn;
  ListPrototype.update = MapPrototype.update;
  ListPrototype.updateIn = MapPrototype.updateIn;
  ListPrototype.mergeIn = MapPrototype.mergeIn;
  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  ListPrototype.withMutations = MapPrototype.withMutations;
  ListPrototype.asMutable = MapPrototype.asMutable;
  ListPrototype.asImmutable = MapPrototype.asImmutable;
  ListPrototype.wasAltered = MapPrototype.wasAltered;



    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }

    // TODO: seems like these methods are very similar

    VNode.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level :  false || this.array.length === 0) {
        return this;
      }
      var originIndex = (index >>> level) & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };

    VNode.prototype.removeAfter = function(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = ((index - 1) >>> level) & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }

      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }

      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };



  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;

    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0 ?
        iterateLeaf(node, offset) :
        iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : (left - offset) >> level;
      var to = ((right - offset) >> level) + 1;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        do {
          if (values) {
            var value = values();
            if (value !== DONE) {
              return value;
            }
            values = null;
          }
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(
            array && array[idx], level - SHIFT, offset + (idx << level)
          );
        } while (true);
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;
  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function(list ) {
        index < 0 ?
          setListBounds(list, index).set(0, value) :
          setListBounds(list, 0, index + 1).set(index, value)
      });
    }

    index += list._origin;

    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef(DID_ALTER);
    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
      if (newLowerNode === lowerNode) {
        return node;
      }
      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    SetRef(didAlter);

    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }
    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
      var node = list._root;
      var level = list._level;
      while (node && level > 0) {
        node = node.array[(rawIndex >>> level) & MASK];
        level -= SHIFT;
      }
      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      end = end | 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    }

    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root;

    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);

    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
      newLevel += SHIFT;
    }

    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset ?
      listNodeFor(list, newCapacity - 1) :
      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

    // Merge Tail into tree.
    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;
      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = (oldTailOffset >>> level) & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }
      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }

    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }

    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0;

      // Identify the new top root node of the subtree of the old root.
      while (newRoot) {
        var beginIndex = (newOrigin >>> newLevel) & MASK;
        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
          break;
        }
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      }

      // Trim the new sides of the new root.
      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }
      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
      }
      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function mergeIntoListWith(list, merger, iterables) {
    var iters = [];
    var maxSize = 0;
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = IndexedIterable(value);
      if (iter.size > maxSize) {
        maxSize = iter.size;
      }
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    if (maxSize > list.size) {
      list = list.setSize(maxSize);
    }
    return mergeIntoCollectionWith(list, merger, iters);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
  }

  createClass(OrderedMap, Map);

    // @pragma Construction

    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() :
        isOrderedMap(value) ? value :
        emptyOrderedMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    OrderedMap.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedMap.prototype.toString = function() {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function(k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function(k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };

    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._list.__iterate(
        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
        reverse
      );
    };

    OrderedMap.prototype.__iterator = function(type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };


  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  OrderedMap.isOrderedMap = isOrderedMap;

  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;
  function emptyOrderedMap() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) { // removed
      if (!has) {
        return omap;
      }
      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else {
      if (has) {
        if (v === list.get(i)[1]) {
          return omap;
        }
        newMap = map;
        newList = list.set(i, [k, v]);
      } else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
      }
    }
    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }
    return makeOrderedMap(newMap, newList);
  }

  createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    ToKeyedSequence.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function(key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var ii;
      return this._iter.__iterate(
        this._useKeys ?
          function(v, k)  {return fn(v, k, this$0)} :
          ((ii = reverse ? resolveSize(this) : 0),
            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
        reverse
      );
    };

    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };

  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToIndexedSequence.prototype.includes = function(value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
    };

    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, iterations++, step.value, step)
      });
    };



  createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToSetSequence.prototype.has = function(key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
    };

    ToSetSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, step.value, step.value, step);
      });
    };



  createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    FromEntriesSequence.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(entry ) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(
            indexedIterable ? entry.get(1) : entry[1],
            indexedIterable ? entry.get(0) : entry[0],
            this$0
          );
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(
              type,
              indexedIterable ? entry.get(0) : entry[0],
              indexedIterable ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };


  ToIndexedSequence.prototype.cacheResult =
  ToKeyedSequence.prototype.cacheResult =
  ToSetSequence.prototype.cacheResult =
  FromEntriesSequence.prototype.cacheResult =
    cacheResultThrough;


  function flipFactory(iterable) {
    var flipSequence = makeSequence(iterable);
    flipSequence._iter = iterable;
    flipSequence.size = iterable.size;
    flipSequence.flip = function()  {return iterable};
    flipSequence.reverse = function () {
      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
      reversedSequence.flip = function()  {return iterable.reverse()};
      return reversedSequence;
    };
    flipSequence.has = function(key ) {return iterable.includes(key)};
    flipSequence.includes = function(key ) {return iterable.has(key)};
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
    }
    flipSequence.__iteratorUncached = function(type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = iterable.__iterator(type, reverse);
        return new Iterator(function()  {
          var step = iterator.next();
          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }
          return step;
        });
      }
      return iterable.__iterator(
        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
        reverse
      );
    }
    return flipSequence;
  }


  function mapFactory(iterable, mapper, context) {
    var mappedSequence = makeSequence(iterable);
    mappedSequence.size = iterable.size;
    mappedSequence.has = function(key ) {return iterable.has(key)};
    mappedSequence.get = function(key, notSetValue)  {
      var v = iterable.get(key, NOT_SET);
      return v === NOT_SET ?
        notSetValue :
        mapper.call(context, v, key, iterable);
    };
    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(
        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
        reverse
      );
    }
    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        return iteratorValue(
          type,
          key,
          mapper.call(context, entry[1], key, iterable),
          step
        );
      });
    }
    return mappedSequence;
  }


  function reverseFactory(iterable, useKeys) {
    var reversedSequence = makeSequence(iterable);
    reversedSequence._iter = iterable;
    reversedSequence.size = iterable.size;
    reversedSequence.reverse = function()  {return iterable};
    if (iterable.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(iterable);
        flipSequence.reverse = function()  {return iterable.flip()};
        return flipSequence;
      };
    }
    reversedSequence.get = function(key, notSetValue) 
      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
    reversedSequence.has = function(key )
      {return iterable.has(useKeys ? key : -1 - key)};
    reversedSequence.includes = function(value ) {return iterable.includes(value)};
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
    };
    reversedSequence.__iterator =
      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
    return reversedSequence;
  }


  function filterFactory(iterable, predicate, context, useKeys) {
    var filterSequence = makeSequence(iterable);
    if (useKeys) {
      filterSequence.has = function(key ) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
      };
      filterSequence.get = function(key, notSetValue)  {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
          v : notSetValue;
      };
    }
    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      }, reverse);
      return iterations;
    };
    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          var value = entry[1];
          if (predicate.call(context, value, key, iterable)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    }
    return filterSequence;
  }


  function countByFactory(iterable, grouper, context) {
    var groups = Map().asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        0,
        function(a ) {return a + 1}
      );
    });
    return groups.asImmutable();
  }


  function groupByFactory(iterable, grouper, context) {
    var isKeyedIter = isKeyed(iterable);
    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
      );
    });
    var coerce = iterableClass(iterable);
    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
  }


  function sliceFactory(iterable, begin, end, useKeys) {
    var originalSize = iterable.size;

    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      if (end === Infinity) {
        end = originalSize;
      } else {
        end = end | 0;
      }
    }

    if (wholeSlice(begin, end, originalSize)) {
      return iterable;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);

    // begin or end will be NaN if they were provided as negative numbers and
    // this iterable's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
    }

    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(iterable);

    // If iterable.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize ?
          iterable.get(index + resolvedBegin, notSetValue) :
          notSetValue;
      }
    }

    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (sliceSize === 0) {
        return 0;
      }
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k)  {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
                 iterations !== sliceSize;
        }
      });
      return iterations;
    };

    sliceSeq.__iteratorUncached = function(type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      // Don't bother instantiating parent iterator if taking 0.
      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
      var skipped = 0;
      var iterations = 0;
      return new Iterator(function()  {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }
        if (++iterations > sliceSize) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (useKeys || type === ITERATE_VALUES) {
          return step;
        } else if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        } else {
          return iteratorValue(type, iterations - 1, step.value[1], step);
        }
      });
    }

    return sliceSeq;
  }


  function takeWhileFactory(iterable, predicate, context) {
    var takeSequence = makeSequence(iterable);
    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      iterable.__iterate(function(v, k, c) 
        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
      );
      return iterations;
    };
    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterating = true;
      return new Iterator(function()  {
        if (!iterating) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var k = entry[0];
        var v = entry[1];
        if (!predicate.call(context, v, k, this$0)) {
          iterating = false;
          return iteratorDone();
        }
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return takeSequence;
  }


  function skipWhileFactory(iterable, predicate, context, useKeys) {
    var skipSequence = makeSequence(iterable);
    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      });
      return iterations;
    };
    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var skipping = true;
      var iterations = 0;
      return new Iterator(function()  {
        var step, k, v;
        do {
          step = iterator.next();
          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            } else if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            } else {
              return iteratorValue(type, iterations++, step.value[1], step);
            }
          }
          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$0));
        } while (skipping);
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return skipSequence;
  }


  function concatFactory(iterable, values) {
    var isKeyedIterable = isKeyed(iterable);
    var iters = [iterable].concat(values).map(function(v ) {
      if (!isIterable(v)) {
        v = isKeyedIterable ?
          keyedSeqFromValue(v) :
          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedIterable) {
        v = KeyedIterable(v);
      }
      return v;
    }).filter(function(v ) {return v.size !== 0});

    if (iters.length === 0) {
      return iterable;
    }

    if (iters.length === 1) {
      var singleton = iters[0];
      if (singleton === iterable ||
          isKeyedIterable && isKeyed(singleton) ||
          isIndexed(iterable) && isIndexed(singleton)) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);
    if (isKeyedIterable) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(iterable)) {
      concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(
      function(sum, seq)  {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      },
      0
    );
    return concatSeq;
  }


  function flattenFactory(iterable, depth, useKeys) {
    var flatSequence = makeSequence(iterable);
    flatSequence.__iterateUncached = function(fn, reverse) {
      var iterations = 0;
      var stopped = false;
      function flatDeep(iter, currentDepth) {var this$0 = this;
        iter.__iterate(function(v, k)  {
          if ((!depth || currentDepth < depth) && isIterable(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
            stopped = true;
          }
          return !stopped;
        }, reverse);
      }
      flatDeep(iterable, 0);
      return iterations;
    }
    flatSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(type, reverse);
      var stack = [];
      var iterations = 0;
      return new Iterator(function()  {
        while (iterator) {
          var step = iterator.next();
          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }
          var v = step.value;
          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }
          if ((!depth || stack.length < depth) && isIterable(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }
        return iteratorDone();
      });
    }
    return flatSequence;
  }


  function flatMapFactory(iterable, mapper, context) {
    var coerce = iterableClass(iterable);
    return iterable.toSeq().map(
      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
    ).flatten(true);
  }


  function interposeFactory(iterable, separator) {
    var interposedSequence = makeSequence(iterable);
    interposedSequence.size = iterable.size && iterable.size * 2 -1;
    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k) 
        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
        fn(v, iterations++, this$0) !== false},
        reverse
      );
      return iterations;
    };
    interposedSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      var step;
      return new Iterator(function()  {
        if (!step || iterations % 2) {
          step = iterator.next();
          if (step.done) {
            return step;
          }
        }
        return iterations % 2 ?
          iteratorValue(type, iterations++, separator) :
          iteratorValue(type, iterations++, step.value, step);
      });
    };
    return interposedSequence;
  }


  function sortFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    var isKeyedIterable = isKeyed(iterable);
    var index = 0;
    var entries = iterable.toSeq().map(
      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
    ).toArray();
    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
      isKeyedIterable ?
      function(v, i)  { entries[i].length = 2; } :
      function(v, i)  { entries[i] = v[1]; }
    );
    return isKeyedIterable ? KeyedSeq(entries) :
      isIndexed(iterable) ? IndexedSeq(entries) :
      SetSeq(entries);
  }


  function maxFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    if (mapper) {
      var entry = iterable.toSeq()
        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
      return entry && entry[0];
    } else {
      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
    }
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
  }


  function zipWithFactory(keyIter, zipper, iters) {
    var zipSequence = makeSequence(keyIter);
    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function(fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    zipSequence.__iteratorUncached = function(type, reverse) {
      var iterators = iters.map(function(i )
        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
      );
      var iterations = 0;
      var isDone = false;
      return new Iterator(function()  {
        var steps;
        if (!isDone) {
          steps = iterators.map(function(i ) {return i.next()});
          isDone = steps.some(function(s ) {return s.done});
        }
        if (isDone) {
          return iteratorDone();
        }
        return iteratorValue(
          type,
          iterations++,
          zipper.apply(null, steps.map(function(s ) {return s.value}))
        );
      });
    };
    return zipSequence
  }


  // #pragma Helper Functions

  function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function resolveSize(iter) {
    assertNotInfinite(iter.size);
    return ensureSize(iter);
  }

  function iterableClass(iterable) {
    return isKeyed(iterable) ? KeyedIterable :
      isIndexed(iterable) ? IndexedIterable :
      SetIterable;
  }

  function makeSequence(iterable) {
    return Object.create(
      (
        isKeyed(iterable) ? KeyedSeq :
        isIndexed(iterable) ? IndexedSeq :
        SetSeq
      ).prototype
    );
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  }

  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  function forceIterator(keyPath) {
    var iter = getIterator(keyPath);
    if (!iter) {
      // Array might not be iterable in this environment, so we need a fallback
      // to our wrapped type.
      if (!isArrayLike(keyPath)) {
        throw new TypeError('Expected iterable or array-like: ' + keyPath);
      }
      iter = getIterator(Iterable(keyPath));
    }
    return iter;
  }

  createClass(Record, KeyedCollection);

    function Record(defaultValues, name) {
      var hasInitialized;

      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map(values);
      };

      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;

      return RecordType;
    }

    Record.prototype.toString = function() {
      return this.__toString(recordName(this) + ' {', '}');
    };

    // @pragma Access

    Record.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };

    Record.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };

    // @pragma Modification

    Record.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };

    Record.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      if (this._map && !this._map.has(k)) {
        var defaultVal = this._defaultValues[k];
        if (v === defaultVal) {
          return this;
        }
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
    };

    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
    };

    Record.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };


  var RecordPrototype = Record.prototype;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn =
  RecordPrototype.removeIn = MapPrototype.removeIn;
  RecordPrototype.merge = MapPrototype.merge;
  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  RecordPrototype.setIn = MapPrototype.setIn;
  RecordPrototype.update = MapPrototype.update;
  RecordPrototype.updateIn = MapPrototype.updateIn;
  RecordPrototype.withMutations = MapPrototype.withMutations;
  RecordPrototype.asMutable = MapPrototype.asMutable;
  RecordPrototype.asImmutable = MapPrototype.asImmutable;


  function makeRecord(likeRecord, map, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._map = map;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function setProps(prototype, names) {
    try {
      names.forEach(setProp.bind(undefined, prototype));
    } catch (error) {
      // Object.defineProperty failed. Probably IE8.
    }
  }

  function setProp(prototype, name) {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  }

  createClass(Set, SetCollection);

    // @pragma Construction

    function Set(value) {
      return value === null || value === undefined ? emptySet() :
        isSet(value) && !isOrdered(value) ? value :
        emptySet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    Set.of = function(/*...values*/) {
      return this(arguments);
    };

    Set.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    Set.prototype.toString = function() {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function(value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function(value) {
      return updateSet(this, this._map.set(value, true));
    };

    Set.prototype.remove = function(value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function() {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x ) {return x.size !== 0});
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set ) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
        }
      });
    };

    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (!iters.every(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (iters.some(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };

    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };

    Set.prototype.sort = function(comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
    };

    Set.prototype.__iterator = function(type, reverse) {
      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };


  function isSet(maybeSet) {
    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  }

  Set.isSet = isSet;

  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SENTINEL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.mergeDeep = SetPrototype.merge;
  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  SetPrototype.withMutations = MapPrototype.withMutations;
  SetPrototype.asMutable = MapPrototype.asMutable;
  SetPrototype.asImmutable = MapPrototype.asImmutable;

  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }
    return newMap === set._map ? set :
      newMap.size === 0 ? set.__empty() :
      set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;
  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  createClass(OrderedSet, Set);

    // @pragma Construction

    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() :
        isOrderedSet(value) ? value :
        emptyOrderedSet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    OrderedSet.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedSet.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    OrderedSet.prototype.toString = function() {
      return this.__toString('OrderedSet {', '}');
    };


  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  OrderedSet.isOrderedSet = isOrderedSet;

  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;
  function emptyOrderedSet() {
    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  }

  createClass(Stack, IndexedCollection);

    // @pragma Construction

    function Stack(value) {
      return value === null || value === undefined ? emptyStack() :
        isStack(value) ? value :
        emptyStack().unshiftAll(value);
    }

    Stack.of = function(/*...values*/) {
      return this(arguments);
    };

    Stack.prototype.toString = function() {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function() {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function(/*...values*/) {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value ) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function() {
      return this.slice(1);
    };

    Stack.prototype.unshift = function(/*...values*/) {
      return this.push.apply(this, arguments);
    };

    Stack.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };

    Stack.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };

    Stack.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function(fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function(type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function()  {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };


  function isStack(maybeStack) {
    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  }

  Stack.isStack = isStack;

  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SENTINEL] = true;
  StackPrototype.withMutations = MapPrototype.withMutations;
  StackPrototype.asMutable = MapPrototype.asMutable;
  StackPrototype.asImmutable = MapPrototype.asImmutable;
  StackPrototype.wasAltered = MapPrototype.wasAltered;


  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;
  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }

  /**
   * Contributes additional methods to a constructor
   */
  function mixin(ctor, methods) {
    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  Iterable.Iterator = Iterator;

  mixin(Iterable, {

    // ### Conversion to other types

    toArray: function() {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);
      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
      return array;
    },

    toIndexedSeq: function() {
      return new ToIndexedSequence(this);
    },

    toJS: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
      ).__toJS();
    },

    toJSON: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
      ).__toJS();
    },

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, true);
    },

    toMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },

    toObject: function() {
      assertNotInfinite(this.size);
      var object = {};
      this.__iterate(function(v, k)  { object[k] = v; });
      return object;
    },

    toOrderedMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },

    toOrderedSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },

    toSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },

    toSetSeq: function() {
      return new ToSetSequence(this);
    },

    toSeq: function() {
      return isIndexed(this) ? this.toIndexedSeq() :
        isKeyed(this) ? this.toKeyedSeq() :
        this.toSetSeq();
    },

    toStack: function() {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },

    toList: function() {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },


    // ### Common JavaScript methods and properties

    toString: function() {
      return '[Iterable]';
    },

    __toString: function(head, tail) {
      if (this.size === 0) {
        return head + tail;
      }
      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    concat: function() {var values = SLICE$0.call(arguments, 0);
      return reify(this, concatFactory(this, values));
    },

    includes: function(searchValue) {
      return this.some(function(value ) {return is(value, searchValue)});
    },

    entries: function() {
      return this.__iterator(ITERATE_ENTRIES);
    },

    every: function(predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;
      this.__iterate(function(v, k, c)  {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });
      return returnValue;
    },

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },

    find: function(predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },

    forEach: function(sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },

    join: function(separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;
      this.__iterate(function(v ) {
        isFirst ? (isFirst = false) : (joined += separator);
        joined += v !== null && v !== undefined ? v.toString() : '';
      });
      return joined;
    },

    keys: function() {
      return this.__iterator(ITERATE_KEYS);
    },

    map: function(mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },

    reduce: function(reducer, initialReduction, context) {
      assertNotInfinite(this.size);
      var reduction;
      var useFirst;
      if (arguments.length < 2) {
        useFirst = true;
      } else {
        reduction = initialReduction;
      }
      this.__iterate(function(v, k, c)  {
        if (useFirst) {
          useFirst = false;
          reduction = v;
        } else {
          reduction = reducer.call(context, reduction, v, k, c);
        }
      });
      return reduction;
    },

    reduceRight: function(reducer, initialReduction, context) {
      var reversed = this.toKeyedSeq().reverse();
      return reversed.reduce.apply(reversed, arguments);
    },

    reverse: function() {
      return reify(this, reverseFactory(this, true));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },

    some: function(predicate, context) {
      return !this.every(not(predicate), context);
    },

    sort: function(comparator) {
      return reify(this, sortFactory(this, comparator));
    },

    values: function() {
      return this.__iterator(ITERATE_VALUES);
    },


    // ### More sequential methods

    butLast: function() {
      return this.slice(0, -1);
    },

    isEmpty: function() {
      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
    },

    count: function(predicate, context) {
      return ensureSize(
        predicate ? this.toSeq().filter(predicate, context) : this
      );
    },

    countBy: function(grouper, context) {
      return countByFactory(this, grouper, context);
    },

    equals: function(other) {
      return deepEqual(this, other);
    },

    entrySeq: function() {
      var iterable = this;
      if (iterable._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(iterable._cache);
      }
      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
      return entriesSequence;
    },

    filterNot: function(predicate, context) {
      return this.filter(not(predicate), context);
    },

    findEntry: function(predicate, context, notSetValue) {
      var found = notSetValue;
      this.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });
      return found;
    },

    findKey: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },

    findLast: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },

    findLastEntry: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
    },

    findLastKey: function(predicate, context) {
      return this.toKeyedSeq().reverse().findKey(predicate, context);
    },

    first: function() {
      return this.find(returnTrue);
    },

    flatMap: function(mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, true));
    },

    fromEntrySeq: function() {
      return new FromEntriesSequence(this);
    },

    get: function(searchKey, notSetValue) {
      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
    },

    getIn: function(searchKeyPath, notSetValue) {
      var nested = this;
      // Note: in an ES6 environment, we would prefer:
      // for (var key of searchKeyPath) {
      var iter = forceIterator(searchKeyPath);
      var step;
      while (!(step = iter.next()).done) {
        var key = step.value;
        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
        if (nested === NOT_SET) {
          return notSetValue;
        }
      }
      return nested;
    },

    groupBy: function(grouper, context) {
      return groupByFactory(this, grouper, context);
    },

    has: function(searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },

    hasIn: function(searchKeyPath) {
      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
    },

    isSubset: function(iter) {
      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
      return this.every(function(value ) {return iter.includes(value)});
    },

    isSuperset: function(iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
      return iter.isSubset(this);
    },

    keyOf: function(searchValue) {
      return this.findKey(function(value ) {return is(value, searchValue)});
    },

    keySeq: function() {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },

    last: function() {
      return this.toSeq().reverse().first();
    },

    lastKeyOf: function(searchValue) {
      return this.toKeyedSeq().reverse().keyOf(searchValue);
    },

    max: function(comparator) {
      return maxFactory(this, comparator);
    },

    maxBy: function(mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },

    min: function(comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },

    minBy: function(mapper, comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },

    rest: function() {
      return this.slice(1);
    },

    skip: function(amount) {
      return this.slice(Math.max(0, amount));
    },

    skipLast: function(amount) {
      return reify(this, this.toSeq().reverse().skip(amount).reverse());
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },

    skipUntil: function(predicate, context) {
      return this.skipWhile(not(predicate), context);
    },

    sortBy: function(mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },

    take: function(amount) {
      return this.slice(0, Math.max(0, amount));
    },

    takeLast: function(amount) {
      return reify(this, this.toSeq().reverse().take(amount).reverse());
    },

    takeWhile: function(predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },

    takeUntil: function(predicate, context) {
      return this.takeWhile(not(predicate), context);
    },

    valueSeq: function() {
      return this.toIndexedSeq();
    },


    // ### Hashable Object

    hashCode: function() {
      return this.__hash || (this.__hash = hashIterable(this));
    }


    // ### Internal

    // abstract __iterate(fn, reverse)

    // abstract __iterator(type, reverse)
  });

  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  var IterablePrototype = Iterable.prototype;
  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  IterablePrototype.__toJS = IterablePrototype.toArray;
  IterablePrototype.__toStringMapper = quoteString;
  IterablePrototype.inspect =
  IterablePrototype.toSource = function() { return this.toString(); };
  IterablePrototype.chain = IterablePrototype.flatMap;
  IterablePrototype.contains = IterablePrototype.includes;

  mixin(KeyedIterable, {

    // ### More sequential methods

    flip: function() {
      return reify(this, flipFactory(this));
    },

    mapEntries: function(mapper, context) {var this$0 = this;
      var iterations = 0;
      return reify(this,
        this.toSeq().map(
          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
        ).fromEntrySeq()
      );
    },

    mapKeys: function(mapper, context) {var this$0 = this;
      return reify(this,
        this.toSeq().flip().map(
          function(k, v)  {return mapper.call(context, k, v, this$0)}
        ).flip()
      );
    }

  });

  var KeyedIterablePrototype = KeyedIterable.prototype;
  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



  mixin(IndexedIterable, {

    // ### Conversion to other types

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, false);
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },

    findIndex: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    indexOf: function(searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    lastIndexOf: function(searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    reverse: function() {
      return reify(this, reverseFactory(this, false));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },

    splice: function(index, removeNum /*, ...values*/) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum | 0, 0);
      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
        return this;
      }
      // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.
      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(
        this,
        numArgs === 1 ?
          spliced :
          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
      );
    },


    // ### More collection methods

    findLastIndex: function(predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    first: function() {
      return this.get(0);
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, false));
    },

    get: function(index, notSetValue) {
      index = wrapIndex(this, index);
      return (index < 0 || (this.size === Infinity ||
          (this.size !== undefined && index > this.size))) ?
        notSetValue :
        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
    },

    has: function(index) {
      index = wrapIndex(this, index);
      return index >= 0 && (this.size !== undefined ?
        this.size === Infinity || index < this.size :
        this.indexOf(index) !== -1
      );
    },

    interpose: function(separator) {
      return reify(this, interposeFactory(this, separator));
    },

    interleave: function(/*...iterables*/) {
      var iterables = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
      var interleaved = zipped.flatten(true);
      if (zipped.size) {
        interleaved.size = zipped.size * iterables.length;
      }
      return reify(this, interleaved);
    },

    keySeq: function() {
      return Range(0, this.size);
    },

    last: function() {
      return this.get(-1);
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },

    zip: function(/*, ...iterables */) {
      var iterables = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, iterables));
    },

    zipWith: function(zipper/*, ...iterables */) {
      var iterables = arrCopy(arguments);
      iterables[0] = this;
      return reify(this, zipWithFactory(this, zipper, iterables));
    }

  });

  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



  mixin(SetIterable, {

    // ### ES6 Collection methods (ES6 Array and Map)

    get: function(value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },

    includes: function(value) {
      return this.has(value);
    },


    // ### More sequential methods

    keySeq: function() {
      return this.valueSeq();
    }

  });

  SetIterable.prototype.has = IterablePrototype.includes;
  SetIterable.prototype.contains = SetIterable.prototype.includes;


  // Mixin subclasses

  mixin(KeyedSeq, KeyedIterable.prototype);
  mixin(IndexedSeq, IndexedIterable.prototype);
  mixin(SetSeq, SetIterable.prototype);

  mixin(KeyedCollection, KeyedIterable.prototype);
  mixin(IndexedCollection, IndexedIterable.prototype);
  mixin(SetCollection, SetIterable.prototype);


  // #pragma Helper functions

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    }
  }

  function neg(predicate) {
    return function() {
      return -predicate.apply(this, arguments);
    }
  }

  function quoteString(value) {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashIterable(iterable) {
    if (iterable.size === Infinity) {
      return 0;
    }
    var ordered = isOrdered(iterable);
    var keyed = isKeyed(iterable);
    var h = ordered ? 1 : 0;
    var size = iterable.__iterate(
      keyed ?
        ordered ?
          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
        ordered ?
          function(v ) { h = 31 * h + hash(v) | 0; } :
          function(v ) { h = h + hash(v) | 0; }
    );
    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xCC9E2D51);
    h = imul(h << 15 | h >>> -15, 0x1B873593);
    h = imul(h << 13 | h >>> -13, 5);
    h = (h + 0xE6546B64 | 0) ^ size;
    h = imul(h ^ h >>> 16, 0x85EBCA6B);
    h = imul(h ^ h >>> 13, 0xC2B2AE35);
    h = smi(h ^ h >>> 16);
    return h;
  }

  function hashMerge(a, b) {
    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  }

  var Immutable = {

    Iterable: Iterable,

    Seq: Seq,
    Collection: Collection,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,

    Record: Record,
    Range: Range,
    Repeat: Repeat,

    is: is,
    fromJS: fromJS

  };

  return Immutable;

}));

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/is-function/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-function/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  if (!fn) {
    return false
  }
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/jszip/dist/jszip.min.js":
/*!**********************************************!*\
  !*** ./node_modules/jszip/dist/jszip.min.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, global, setImmediate) {var require;var require;/*!

JSZip v3.5.0 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

!function(t){if(true)module.exports=t();else {}}(function(){return function s(a,o,h){function u(r,t){if(!o[r]){if(!a[r]){var e="function"==typeof require&&require;if(!t&&e)return require(r,!0);if(l)return l(r,!0);var i=new Error("Cannot find module '"+r+"'");throw i.code="MODULE_NOT_FOUND",i}var n=o[r]={exports:{}};a[r][0].call(n.exports,function(t){var e=a[r][1][t];return u(e||t)},n,n.exports,s,a,o,h)}return o[r].exports}for(var l="function"==typeof require&&require,t=0;t<h.length;t++)u(h[t]);return u}({1:[function(t,e,r){"use strict";var c=t("./utils"),d=t("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(t){for(var e,r,i,n,s,a,o,h=[],u=0,l=t.length,f=l,d="string"!==c.getTypeOf(t);u<t.length;)f=l-u,i=d?(e=t[u++],r=u<l?t[u++]:0,u<l?t[u++]:0):(e=t.charCodeAt(u++),r=u<l?t.charCodeAt(u++):0,u<l?t.charCodeAt(u++):0),n=e>>2,s=(3&e)<<4|r>>4,a=1<f?(15&r)<<2|i>>6:64,o=2<f?63&i:64,h.push(p.charAt(n)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(t){var e,r,i,n,s,a,o=0,h=0,u="data:";if(t.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(t=t.replace(/[^A-Za-z0-9\+\/\=]/g,"")).length/4;if(t.charAt(t.length-1)===p.charAt(64)&&f--,t.charAt(t.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=d.uint8array?new Uint8Array(0|f):new Array(0|f);o<t.length;)e=p.indexOf(t.charAt(o++))<<2|(n=p.indexOf(t.charAt(o++)))>>4,r=(15&n)<<4|(s=p.indexOf(t.charAt(o++)))>>2,i=(3&s)<<6|(a=p.indexOf(t.charAt(o++))),l[h++]=e,64!==s&&(l[h++]=r),64!==a&&(l[h++]=i);return l}},{"./support":30,"./utils":32}],2:[function(t,e,r){"use strict";var i=t("./external"),n=t("./stream/DataWorker"),s=t("./stream/DataLengthProbe"),a=t("./stream/Crc32Probe");s=t("./stream/DataLengthProbe");function o(t,e,r,i,n){this.compressedSize=t,this.uncompressedSize=e,this.crc32=r,this.compression=i,this.compressedContent=n}o.prototype={getContentWorker:function(){var t=new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new s("data_length")),e=this;return t.on("end",function(){if(this.streamInfo.data_length!==e.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),t},getCompressedWorker:function(){return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(t,e,r){return t.pipe(new a).pipe(new s("uncompressedSize")).pipe(e.compressWorker(r)).pipe(new s("compressedSize")).withStreamInfo("compression",e)},e.exports=o},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(t,e,r){"use strict";var i=t("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(t){return new i("STORE compression")},uncompressWorker:function(){return new i("STORE decompression")}},r.DEFLATE=t("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(t,e,r){"use strict";var i=t("./utils");var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e){return void 0!==t&&t.length?"string"!==i.getTypeOf(t)?function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}(0|e,t,t.length,0):function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e.charCodeAt(a))];return-1^t}(0|e,t,t.length,0):0}},{"./utils":32}],5:[function(t,e,r){"use strict";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(t,e,r){"use strict";var i=null;i="undefined"!=typeof Promise?Promise:t("lie"),e.exports={Promise:i}},{lie:37}],7:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,n=t("pako"),s=t("./utils"),a=t("./stream/GenericWorker"),o=i?"uint8array":"array";function h(t,e){a.call(this,"FlateWorker/"+t),this._pako=null,this._pakoAction=t,this._pakoOptions=e,this.meta={}}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(t){this.meta=t.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,t.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new n[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},r.compressWorker=function(t){return new h("Deflate",t)},r.uncompressWorker=function(){return new h("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(t,e,r){"use strict";function A(t,e){var r,i="";for(r=0;r<e;r++)i+=String.fromCharCode(255&t),t>>>=8;return i}function i(t,e,r,i,n,s){var a,o,h=t.file,u=t.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),d=I.transformTo("string",O.utf8encode(h.name)),c=h.comment,p=I.transformTo("string",s(c)),m=I.transformTo("string",O.utf8encode(c)),_=d.length!==h.name.length,g=m.length!==c.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};e&&!r||(x.crc32=t.crc32,x.compressedSize=t.compressedSize,x.uncompressedSize=t.uncompressedSize);var S=0;e&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===n?(C=798,z|=function(t,e){var r=t;return t||(r=e?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(t){return 63&(t||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+d,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(i,4)+f+b+p}}var I=t("../utils"),n=t("../stream/GenericWorker"),O=t("../utf8"),B=t("../crc32"),R=t("../signature");function s(t,e,r,i){n.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=e,this.zipPlatform=r,this.encodeFileName=i,this.streamFiles=t,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,n),s.prototype.push=function(t){var e=t.meta.percent||0,r=this.entriesCount,i=this._sources.length;this.accumulate?this.contentBuffer.push(t):(this.bytesWritten+=t.data.length,n.prototype.push.call(this,{data:t.data,meta:{currentFile:this.currentFile,percent:r?(e+100*(r-i-1))/r:100}}))},s.prototype.openedSource=function(t){this.currentSourceOffset=this.bytesWritten,this.currentFile=t.file.name;var e=this.streamFiles&&!t.file.dir;if(e){var r=i(t,e,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(t){this.accumulate=!1;var e=this.streamFiles&&!t.file.dir,r=i(t,e,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),e)this.push({data:function(t){return R.DATA_DESCRIPTOR+A(t.crc32,4)+A(t.compressedSize,4)+A(t.uncompressedSize,4)}(t),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var t=this.bytesWritten,e=0;e<this.dirRecords.length;e++)this.push({data:this.dirRecords[e],meta:{percent:100}});var r=this.bytesWritten-t,i=function(t,e,r,i,n){var s=I.transformTo("string",n(i));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(t,2)+A(t,2)+A(e,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,t,this.zipComment,this.encodeFileName);this.push({data:i,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(t){this._sources.push(t);var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.closedSource(e.previous.streamInfo),e._sources.length?e.prepareNextSource():e.end()}),t.on("error",function(t){e.error(t)}),this},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(t){var e=this._sources;if(!n.prototype.error.call(this,t))return!1;for(var r=0;r<e.length;r++)try{e[r].error(t)}catch(t){}return!0},s.prototype.lock=function(){n.prototype.lock.call(this);for(var t=this._sources,e=0;e<t.length;e++)t[e].lock()},e.exports=s},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(t,e,r){"use strict";var u=t("../compressions"),i=t("./ZipFileWorker");r.generateWorker=function(t,a,e){var o=new i(a.streamFiles,e,a.platform,a.encodeFileName),h=0;try{t.forEach(function(t,e){h++;var r=function(t,e){var r=t||e,i=u[r];if(!i)throw new Error(r+" is not a valid compression method !");return i}(e.options.compression,a.compression),i=e.options.compressionOptions||a.compressionOptions||{},n=e.dir,s=e.date;e._compressWorker(r,i).withStreamInfo("file",{name:t,dir:n,date:s,comment:e.comment||"",unixPermissions:e.unixPermissions,dosPermissions:e.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(t){o.error(t)}return o}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(t,e,r){"use strict";function i(){if(!(this instanceof i))return new i;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var t=new i;for(var e in this)"function"!=typeof this[e]&&(t[e]=this[e]);return t}}(i.prototype=t("./object")).loadAsync=t("./load"),i.support=t("./support"),i.defaults=t("./defaults"),i.version="3.5.0",i.loadAsync=function(t,e){return(new i).loadAsync(t,e)},i.external=t("./external"),e.exports=i},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(t,e,r){"use strict";var i=t("./utils"),n=t("./external"),o=t("./utf8"),h=(i=t("./utils"),t("./zipEntries")),s=t("./stream/Crc32Probe"),u=t("./nodejsUtils");function l(i){return new n.Promise(function(t,e){var r=i.decompressed.getContentWorker().pipe(new s);r.on("error",function(t){e(t)}).on("end",function(){r.streamInfo.crc32!==i.decompressed.crc32?e(new Error("Corrupted zip : CRC32 mismatch")):t()}).resume()})}e.exports=function(t,s){var a=this;return s=i.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),u.isNode&&u.isStream(t)?n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):i.prepareContent("the loaded zip file",t,!0,s.optimizedBinaryString,s.base64).then(function(t){var e=new h(s);return e.load(t),e}).then(function(t){var e=[n.Promise.resolve(t)],r=t.files;if(s.checkCRC32)for(var i=0;i<r.length;i++)e.push(l(r[i]));return n.Promise.all(e)}).then(function(t){for(var e=t.shift(),r=e.files,i=0;i<r.length;i++){var n=r[i];a.file(n.fileNameStr,n.decompressed,{binary:!0,optimizedBinaryString:!0,date:n.date,dir:n.dir,comment:n.fileCommentStr.length?n.fileCommentStr:null,unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions,createFolders:s.createFolders})}return e.zipComment.length&&(a.comment=e.zipComment),a})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../stream/GenericWorker");function s(t,e){n.call(this,"Nodejs stream input adapter for "+t),this._upstreamEnded=!1,this._bindStream(e)}i.inherits(s,n),s.prototype._bindStream=function(t){var e=this;(this._stream=t).pause(),t.on("data",function(t){e.push({data:t,meta:{percent:0}})}).on("error",function(t){e.isPaused?this.generatedError=t:e.error(t)}).on("end",function(){e.isPaused?e._upstreamEnded=!0:e.end()})},s.prototype.pause=function(){return!!n.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},e.exports=s},{"../stream/GenericWorker":28,"../utils":32}],13:[function(t,e,r){"use strict";var n=t("readable-stream").Readable;function i(t,e,r){n.call(this,e),this._helper=t;var i=this;t.on("data",function(t,e){i.push(t)||i._helper.pause(),r&&r(e)}).on("error",function(t){i.emit("error",t)}).on("end",function(){i.push(null)})}t("../utils").inherits(i,n),i.prototype._read=function(){this._helper.resume()},e.exports=i},{"../utils":32,"readable-stream":16}],14:[function(t,e,r){"use strict";e.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(t,e){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(t,e);if("number"==typeof t)throw new Error('The "data" argument must not be a number');return new Buffer(t,e)},allocBuffer:function(t){if(Buffer.alloc)return Buffer.alloc(t);var e=new Buffer(t);return e.fill(0),e},isBuffer:function(t){return Buffer.isBuffer(t)},isStream:function(t){return t&&"function"==typeof t.on&&"function"==typeof t.pause&&"function"==typeof t.resume}}},{}],15:[function(t,e,r){"use strict";function s(t,e,r){var i,n=u.getTypeOf(e),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(t=g(t)),s.createFolders&&(i=_(t))&&b.call(this,i,!0);var a="string"===n&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(e instanceof d&&0===e.uncompressedSize||s.dir||!e||0===e.length)&&(s.base64=!1,s.binary=!0,e="",s.compression="STORE",n="string");var o=null;o=e instanceof d||e instanceof l?e:p.isNode&&p.isStream(e)?new m(t,e):u.prepareContent(t,e,s.binary,s.optimizedBinaryString,s.base64);var h=new c(t,o,s);this.files[t]=h}var n=t("./utf8"),u=t("./utils"),l=t("./stream/GenericWorker"),a=t("./stream/StreamHelper"),f=t("./defaults"),d=t("./compressedObject"),c=t("./zipObject"),o=t("./generate"),p=t("./nodejsUtils"),m=t("./nodejs/NodejsStreamInputAdapter"),_=function(t){"/"===t.slice(-1)&&(t=t.substring(0,t.length-1));var e=t.lastIndexOf("/");return 0<e?t.substring(0,e):""},g=function(t){return"/"!==t.slice(-1)&&(t+="/"),t},b=function(t,e){return e=void 0!==e?e:f.createFolders,t=g(t),this.files[t]||s.call(this,t,null,{dir:!0,createFolders:e}),this.files[t]};function h(t){return"[object RegExp]"===Object.prototype.toString.call(t)}var i={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(t){var e,r,i;for(e in this.files)this.files.hasOwnProperty(e)&&(i=this.files[e],(r=e.slice(this.root.length,e.length))&&e.slice(0,this.root.length)===this.root&&t(r,i))},filter:function(r){var i=[];return this.forEach(function(t,e){r(t,e)&&i.push(e)}),i},file:function(t,e,r){if(1!==arguments.length)return t=this.root+t,s.call(this,t,e,r),this;if(h(t)){var i=t;return this.filter(function(t,e){return!e.dir&&i.test(t)})}var n=this.files[this.root+t];return n&&!n.dir?n:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(t,e){return e.dir&&r.test(t)});var t=this.root+r,e=b.call(this,t),i=this.clone();return i.root=e.name,i},remove:function(r){r=this.root+r;var t=this.files[r];if(t||("/"!==r.slice(-1)&&(r+="/"),t=this.files[r]),t&&!t.dir)delete this.files[r];else for(var e=this.filter(function(t,e){return e.name.slice(0,r.length)===r}),i=0;i<e.length;i++)delete this.files[e[i].name];return this},generate:function(t){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(t){var e,r={};try{if((r=u.extend(t||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:n.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var i=r.comment||this.comment||"";e=o.generateWorker(this,r,i)}catch(t){(e=new l("error")).error(t)}return new a(e,r.type||"string",r.mimeType)},generateAsync:function(t,e){return this.generateInternalStream(t).accumulate(e)},generateNodeStream:function(t,e){return(t=t||{}).type||(t.type="nodebuffer"),this.generateInternalStream(t).toNodejsStream(e)}};e.exports=i},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(t,e,r){e.exports=t("stream")},{stream:void 0}],17:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t);for(var e=0;e<this.data.length;e++)t[e]=255&t[e]}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data[this.zero+t]},n.prototype.lastIndexOfSignature=function(t){for(var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===e&&this.data[s+1]===r&&this.data[s+2]===i&&this.data[s+3]===n)return s-this.zero;return-1},n.prototype.readAndCheckSignature=function(t){var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.readData(4);return e===s[0]&&r===s[1]&&i===s[2]&&n===s[3]},n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return[];var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],18:[function(t,e,r){"use strict";var i=t("../utils");function n(t){this.data=t,this.length=t.length,this.index=0,this.zero=0}n.prototype={checkOffset:function(t){this.checkIndex(this.index+t)},checkIndex:function(t){if(this.length<this.zero+t||t<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+t+"). Corrupted zip ?")},setIndex:function(t){this.checkIndex(t),this.index=t},skip:function(t){this.setIndex(this.index+t)},byteAt:function(t){},readInt:function(t){var e,r=0;for(this.checkOffset(t),e=this.index+t-1;e>=this.index;e--)r=(r<<8)+this.byteAt(e);return this.index+=t,r},readString:function(t){return i.transformTo("string",this.readData(t))},readData:function(t){},lastIndexOfSignature:function(t){},readAndCheckSignature:function(t){},readDate:function(){var t=this.readInt(4);return new Date(Date.UTC(1980+(t>>25&127),(t>>21&15)-1,t>>16&31,t>>11&31,t>>5&63,(31&t)<<1))}},e.exports=n},{"../utils":32}],19:[function(t,e,r){"use strict";var i=t("./Uint8ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data.charCodeAt(this.zero+t)},n.prototype.lastIndexOfSignature=function(t){return this.data.lastIndexOf(t)-this.zero},n.prototype.readAndCheckSignature=function(t){return t===this.readData(4)},n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],21:[function(t,e,r){"use strict";var i=t("./ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return new Uint8Array(0);var e=this.data.subarray(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./ArrayReader":17}],22:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../support"),s=t("./ArrayReader"),a=t("./StringReader"),o=t("./NodeBufferReader"),h=t("./Uint8ArrayReader");e.exports=function(t){var e=i.getTypeOf(t);return i.checkSupport(e),"string"!==e||n.uint8array?"nodebuffer"===e?new o(t):n.uint8array?new h(i.transformTo("uint8array",t)):new s(i.transformTo("array",t)):new a(t)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(t,e,r){"use strict";r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b"},{}],24:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../utils");function s(t){i.call(this,"ConvertWorker to "+t),this.destType=t}n.inherits(s,i),s.prototype.processChunk=function(t){this.push({data:n.transformTo(this.destType,t.data),meta:t.meta})},e.exports=s},{"../utils":32,"./GenericWorker":28}],25:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../crc32");function s(){i.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}t("../utils").inherits(s,i),s.prototype.processChunk=function(t){this.streamInfo.crc32=n(t.data,this.streamInfo.crc32||0),this.push(t)},e.exports=s},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataLengthProbe for "+t),this.propName=t,this.withStreamInfo(t,0)}i.inherits(s,n),s.prototype.processChunk=function(t){if(t){var e=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=e+t.data.length}n.prototype.processChunk.call(this,t)},e.exports=s},{"../utils":32,"./GenericWorker":28}],27:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataWorker");var e=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,t.then(function(t){e.dataIsReady=!0,e.data=t,e.max=t&&t.length||0,e.type=i.getTypeOf(t),e.isPaused||e._tickAndRepeat()},function(t){e.error(t)})}i.inherits(s,n),s.prototype.cleanUp=function(){n.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,i.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(i.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var t=null,e=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":t=this.data.substring(this.index,e);break;case"uint8array":t=this.data.subarray(this.index,e);break;case"array":case"nodebuffer":t=this.data.slice(this.index,e)}return this.index=e,this.push({data:t,meta:{percent:this.max?this.index/this.max*100:0}})},e.exports=s},{"../utils":32,"./GenericWorker":28}],28:[function(t,e,r){"use strict";function i(t){this.name=t||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}i.prototype={push:function(t){this.emit("data",t)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(t){this.emit("error",t)}return!0},error:function(t){return!this.isFinished&&(this.isPaused?this.generatedError=t:(this.isFinished=!0,this.emit("error",t),this.previous&&this.previous.error(t),this.cleanUp()),!0)},on:function(t,e){return this._listeners[t].push(e),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(t,e){if(this._listeners[t])for(var r=0;r<this._listeners[t].length;r++)this._listeners[t][r].call(this,e)},pipe:function(t){return t.registerPrevious(this)},registerPrevious:function(t){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=t.streamInfo,this.mergeStreamInfo(),this.previous=t;var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.end()}),t.on("error",function(t){e.error(t)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var t=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),t=!0),this.previous&&this.previous.resume(),!t},flush:function(){},processChunk:function(t){this.push(t)},withStreamInfo:function(t,e){return this.extraStreamInfo[t]=e,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var t in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(t)&&(this.streamInfo[t]=this.extraStreamInfo[t])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var t="Worker "+this.name;return this.previous?this.previous+" -> "+t:t}},e.exports=i},{}],29:[function(t,e,r){"use strict";var h=t("../utils"),n=t("./ConvertWorker"),s=t("./GenericWorker"),u=t("../base64"),i=t("../support"),a=t("../external"),o=null;if(i.nodestream)try{o=t("../nodejs/NodejsStreamOutputAdapter")}catch(t){}function l(t,o){return new a.Promise(function(e,r){var i=[],n=t._internalType,s=t._outputType,a=t._mimeType;t.on("data",function(t,e){i.push(t),o&&o(e)}).on("error",function(t){i=[],r(t)}).on("end",function(){try{var t=function(t,e,r){switch(t){case"blob":return h.newBlob(h.transformTo("arraybuffer",e),r);case"base64":return u.encode(e);default:return h.transformTo(t,e)}}(s,function(t,e){var r,i=0,n=null,s=0;for(r=0;r<e.length;r++)s+=e[r].length;switch(t){case"string":return e.join("");case"array":return Array.prototype.concat.apply([],e);case"uint8array":for(n=new Uint8Array(s),r=0;r<e.length;r++)n.set(e[r],i),i+=e[r].length;return n;case"nodebuffer":return Buffer.concat(e);default:throw new Error("concat : unsupported type '"+t+"'")}}(n,i),a);e(t)}catch(t){r(t)}i=[]}).resume()})}function f(t,e,r){var i=e;switch(e){case"blob":case"arraybuffer":i="uint8array";break;case"base64":i="string"}try{this._internalType=i,this._outputType=e,this._mimeType=r,h.checkSupport(i),this._worker=t.pipe(new n(i)),t.lock()}catch(t){this._worker=new s("error"),this._worker.error(t)}}f.prototype={accumulate:function(t){return l(this,t)},on:function(t,e){var r=this;return"data"===t?this._worker.on(t,function(t){e.call(r,t.data,t.meta)}):this._worker.on(t,function(){h.delay(e,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(t){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},t)}},e.exports=f},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(t,e,r){"use strict";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else{var i=new ArrayBuffer(0);try{r.blob=0===new Blob([i],{type:"application/zip"}).size}catch(t){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);n.append(i),r.blob=0===n.getBlob("application/zip").size}catch(t){r.blob=!1}}}try{r.nodestream=!!t("readable-stream").Readable}catch(t){r.nodestream=!1}},{"readable-stream":16}],31:[function(t,e,s){"use strict";for(var o=t("./utils"),h=t("./support"),r=t("./nodejsUtils"),i=t("./stream/GenericWorker"),u=new Array(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;u[254]=u[254]=1;function a(){i.call(this,"utf-8 decode"),this.leftOver=null}function l(){i.call(this,"utf-8 encode")}s.utf8encode=function(t){return h.nodebuffer?r.newBufferFrom(t,"utf-8"):function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=h.uint8array?new Uint8Array(o):new Array(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e}(t)},s.utf8decode=function(t){return h.nodebuffer?o.transformTo("nodebuffer",t).toString("utf-8"):function(t){var e,r,i,n,s=t.length,a=new Array(2*s);for(e=r=0;e<s;)if((i=t[e++])<128)a[r++]=i;else if(4<(n=u[i]))a[r++]=65533,e+=n-1;else{for(i&=2===n?31:3===n?15:7;1<n&&e<s;)i=i<<6|63&t[e++],n--;1<n?a[r++]=65533:i<65536?a[r++]=i:(i-=65536,a[r++]=55296|i>>10&1023,a[r++]=56320|1023&i)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(t=o.transformTo(h.uint8array?"uint8array":"array",t))},o.inherits(a,i),a.prototype.processChunk=function(t){var e=o.transformTo(h.uint8array?"uint8array":"array",t.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=e;(e=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),e.set(r,this.leftOver.length)}else e=this.leftOver.concat(e);this.leftOver=null}var i=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}(e),n=e;i!==e.length&&(h.uint8array?(n=e.subarray(0,i),this.leftOver=e.subarray(i,e.length)):(n=e.slice(0,i),this.leftOver=e.slice(i,e.length))),this.push({data:s.utf8decode(n),meta:t.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,i),l.prototype.processChunk=function(t){this.push({data:s.utf8encode(t.data),meta:t.meta})},s.Utf8EncodeWorker=l},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(t,e,a){"use strict";var o=t("./support"),h=t("./base64"),r=t("./nodejsUtils"),i=t("set-immediate-shim"),u=t("./external");function n(t){return t}function l(t,e){for(var r=0;r<t.length;++r)e[r]=255&t.charCodeAt(r);return e}a.newBlob=function(e,r){a.checkSupport("blob");try{return new Blob([e],{type:r})}catch(t){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return i.append(e),i.getBlob(r)}catch(t){throw new Error("Bug : can't construct the Blob.")}}};var s={stringifyByChunk:function(t,e,r){var i=[],n=0,s=t.length;if(s<=r)return String.fromCharCode.apply(null,t);for(;n<s;)"array"===e||"nodebuffer"===e?i.push(String.fromCharCode.apply(null,t.slice(n,Math.min(n+r,s)))):i.push(String.fromCharCode.apply(null,t.subarray(n,Math.min(n+r,s)))),n+=r;return i.join("")},stringifyByChar:function(t){for(var e="",r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(t){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(t){return!1}}()}};function f(t){var e=65536,r=a.getTypeOf(t),i=!0;if("uint8array"===r?i=s.applyCanBeUsed.uint8array:"nodebuffer"===r&&(i=s.applyCanBeUsed.nodebuffer),i)for(;1<e;)try{return s.stringifyByChunk(t,r,e)}catch(t){e=Math.floor(e/2)}return s.stringifyByChar(t)}function d(t,e){for(var r=0;r<t.length;r++)e[r]=t[r];return e}a.applyFromCharCode=f;var c={};c.string={string:n,array:function(t){return l(t,new Array(t.length))},arraybuffer:function(t){return c.string.uint8array(t).buffer},uint8array:function(t){return l(t,new Uint8Array(t.length))},nodebuffer:function(t){return l(t,r.allocBuffer(t.length))}},c.array={string:f,array:n,arraybuffer:function(t){return new Uint8Array(t).buffer},uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(t)}},c.arraybuffer={string:function(t){return f(new Uint8Array(t))},array:function(t){return d(new Uint8Array(t),new Array(t.byteLength))},arraybuffer:n,uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(new Uint8Array(t))}},c.uint8array={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return t.buffer},uint8array:n,nodebuffer:function(t){return r.newBufferFrom(t)}},c.nodebuffer={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return c.nodebuffer.uint8array(t).buffer},uint8array:function(t){return d(t,new Uint8Array(t.length))},nodebuffer:n},a.transformTo=function(t,e){if(e=e||"",!t)return e;a.checkSupport(t);var r=a.getTypeOf(e);return c[r][t](e)},a.getTypeOf=function(t){return"string"==typeof t?"string":"[object Array]"===Object.prototype.toString.call(t)?"array":o.nodebuffer&&r.isBuffer(t)?"nodebuffer":o.uint8array&&t instanceof Uint8Array?"uint8array":o.arraybuffer&&t instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(t){if(!o[t.toLowerCase()])throw new Error(t+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(t){var e,r,i="";for(r=0;r<(t||"").length;r++)i+="\\x"+((e=t.charCodeAt(r))<16?"0":"")+e.toString(16).toUpperCase();return i},a.delay=function(t,e,r){i(function(){t.apply(r||null,e||[])})},a.inherits=function(t,e){function r(){}r.prototype=e.prototype,t.prototype=new r},a.extend=function(){var t,e,r={};for(t=0;t<arguments.length;t++)for(e in arguments[t])arguments[t].hasOwnProperty(e)&&void 0===r[e]&&(r[e]=arguments[t][e]);return r},a.prepareContent=function(r,t,i,n,s){return u.Promise.resolve(t).then(function(i){return o.blob&&(i instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(i)))&&"undefined"!=typeof FileReader?new u.Promise(function(e,r){var t=new FileReader;t.onload=function(t){e(t.target.result)},t.onerror=function(t){r(t.target.error)},t.readAsArrayBuffer(i)}):i}).then(function(t){var e=a.getTypeOf(t);return e?("arraybuffer"===e?t=a.transformTo("uint8array",t):"string"===e&&(s?t=h.decode(t):i&&!0!==n&&(t=function(t){return l(t,o.uint8array?new Uint8Array(t.length):new Array(t.length))}(t))),t):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),n=t("./utils"),s=t("./signature"),a=t("./zipEntry"),o=(t("./utf8"),t("./support"));function h(t){this.files=[],this.loadOptions=t}h.prototype={checkSignature:function(t){if(!this.reader.readAndCheckSignature(t)){this.reader.index-=4;var e=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+n.pretty(e)+", expected "+n.pretty(t)+")")}},isSignature:function(t,e){var r=this.reader.index;this.reader.setIndex(t);var i=this.reader.readString(4)===e;return this.reader.setIndex(r),i},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var t=this.reader.readData(this.zipCommentLength),e=o.uint8array?"uint8array":"array",r=n.transformTo(e,t);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var t,e,r,i=this.zip64EndOfCentralSize-44;0<i;)t=this.reader.readInt(2),e=this.reader.readInt(4),r=this.reader.readData(e),this.zip64ExtensibleData[t]={id:t,length:e,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var t,e;for(t=0;t<this.files.length;t++)e=this.files[t],this.reader.setIndex(e.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),e.readLocalPart(this.reader),e.handleUTF8(),e.processAttributes()},readCentralDir:function(){var t;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(t=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(t);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var t=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(t<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(t);var e=t;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===n.MAX_VALUE_16BITS||this.diskWithCentralDirStart===n.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===n.MAX_VALUE_16BITS||this.centralDirRecords===n.MAX_VALUE_16BITS||this.centralDirSize===n.MAX_VALUE_32BITS||this.centralDirOffset===n.MAX_VALUE_32BITS){if(this.zip64=!0,(t=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(t),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var i=e-r;if(0<i)this.isSignature(e,s.CENTRAL_FILE_HEADER)||(this.reader.zero=i);else if(i<0)throw new Error("Corrupted zip: missing "+Math.abs(i)+" bytes.")},prepareReader:function(t){this.reader=i(t)},load:function(t){this.prepareReader(t),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},e.exports=h},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),s=t("./utils"),n=t("./compressedObject"),a=t("./crc32"),o=t("./utf8"),h=t("./compressions"),u=t("./support");function l(t,e){this.options=t,this.loadOptions=e}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(t){var e,r;if(t.skip(22),this.fileNameLength=t.readInt(2),r=t.readInt(2),this.fileName=t.readData(this.fileNameLength),t.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(e=function(t){for(var e in h)if(h.hasOwnProperty(e)&&h[e].magic===t)return h[e];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new n(this.compressedSize,this.uncompressedSize,this.crc32,e,t.readData(this.compressedSize))},readCentralPart:function(t){this.versionMadeBy=t.readInt(2),t.skip(2),this.bitFlag=t.readInt(2),this.compressionMethod=t.readString(2),this.date=t.readDate(),this.crc32=t.readInt(4),this.compressedSize=t.readInt(4),this.uncompressedSize=t.readInt(4);var e=t.readInt(2);if(this.extraFieldsLength=t.readInt(2),this.fileCommentLength=t.readInt(2),this.diskNumberStart=t.readInt(2),this.internalFileAttributes=t.readInt(2),this.externalFileAttributes=t.readInt(4),this.localHeaderOffset=t.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");t.skip(e),this.readExtraFields(t),this.parseZIP64ExtraField(t),this.fileComment=t.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var t=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==t&&(this.dosPermissions=63&this.externalFileAttributes),3==t&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(t){if(this.extraFields[1]){var e=i(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(t){var e,r,i,n=t.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});t.index+4<n;)e=t.readInt(2),r=t.readInt(2),i=t.readData(r),this.extraFields[e]={id:e,length:r,value:i};t.setIndex(n)},handleUTF8:function(){var t=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var e=this.findExtraFieldUnicodePath();if(null!==e)this.fileNameStr=e;else{var r=s.transformTo(t,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var i=this.findExtraFieldUnicodeComment();if(null!==i)this.fileCommentStr=i;else{var n=s.transformTo(t,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(n)}}},findExtraFieldUnicodePath:function(){var t=this.extraFields[28789];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileName)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null},findExtraFieldUnicodeComment:function(){var t=this.extraFields[25461];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileComment)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null}},e.exports=l},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(t,e,r){"use strict";function i(t,e,r){this.name=t,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=e,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=t("./stream/StreamHelper"),n=t("./stream/DataWorker"),a=t("./utf8"),o=t("./compressedObject"),h=t("./stream/GenericWorker");i.prototype={internalStream:function(t){var e=null,r="string";try{if(!t)throw new Error("No output type specified.");var i="string"===(r=t.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),e=this._decompressWorker();var n=!this._dataBinary;n&&!i&&(e=e.pipe(new a.Utf8EncodeWorker)),!n&&i&&(e=e.pipe(new a.Utf8DecodeWorker))}catch(t){(e=new h("error")).error(t)}return new s(e,r,"")},async:function(t,e){return this.internalStream(t).accumulate(e)},nodeStream:function(t,e){return this.internalStream(t||"nodebuffer").toNodejsStream(e)},_compressWorker:function(t,e){if(this._data instanceof o&&this._data.compression.magic===t.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,t,e)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new n(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)i.prototype[u[f]]=l;e.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(t,l,e){(function(e){"use strict";var r,i,t=e.MutationObserver||e.WebKitMutationObserver;if(t){var n=0,s=new t(u),a=e.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=n=++n%2}}else if(e.setImmediate||void 0===e.MessageChannel)r="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){u(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(u,0)};else{var o=new e.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var t,e;i=!0;for(var r=h.length;r;){for(e=h,h=[],t=-1;++t<r;)e[t]();r=h.length}i=!1}l.exports=function(t){1!==h.push(t)||i||r()}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],37:[function(t,e,r){"use strict";var n=t("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],i=["PENDING"];function o(t){if("function"!=typeof t)throw new TypeError("resolver must be a function");this.state=i,this.queue=[],this.outcome=void 0,t!==u&&c(this,t)}function h(t,e,r){this.promise=t,"function"==typeof e&&(this.onFulfilled=e,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(e,r,i){n(function(){var t;try{t=r(i)}catch(t){return l.reject(e,t)}t===e?l.reject(e,new TypeError("Cannot resolve promise with itself")):l.resolve(e,t)})}function d(t){var e=t&&t.then;if(t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof e)return function(){e.apply(t,arguments)}}function c(e,t){var r=!1;function i(t){r||(r=!0,l.reject(e,t))}function n(t){r||(r=!0,l.resolve(e,t))}var s=p(function(){t(n,i)});"error"===s.status&&i(s.value)}function p(t,e){var r={};try{r.value=t(e),r.status="success"}catch(t){r.status="error",r.value=t}return r}(e.exports=o).prototype.finally=function(e){if("function"!=typeof e)return this;var r=this.constructor;return this.then(function(t){return r.resolve(e()).then(function(){return t})},function(t){return r.resolve(e()).then(function(){throw t})})},o.prototype.catch=function(t){return this.then(null,t)},o.prototype.then=function(t,e){if("function"!=typeof t&&this.state===a||"function"!=typeof e&&this.state===s)return this;var r=new this.constructor(u);this.state!==i?f(r,this.state===a?t:e,this.outcome):this.queue.push(new h(r,t,e));return r},h.prototype.callFulfilled=function(t){l.resolve(this.promise,t)},h.prototype.otherCallFulfilled=function(t){f(this.promise,this.onFulfilled,t)},h.prototype.callRejected=function(t){l.reject(this.promise,t)},h.prototype.otherCallRejected=function(t){f(this.promise,this.onRejected,t)},l.resolve=function(t,e){var r=p(d,e);if("error"===r.status)return l.reject(t,r.value);var i=r.value;if(i)c(t,i);else{t.state=a,t.outcome=e;for(var n=-1,s=t.queue.length;++n<s;)t.queue[n].callFulfilled(e)}return t},l.reject=function(t,e){t.state=s,t.outcome=e;for(var r=-1,i=t.queue.length;++r<i;)t.queue[r].callRejected(e);return t},o.resolve=function(t){if(t instanceof this)return t;return l.resolve(new this(u),t)},o.reject=function(t){var e=new this(u);return l.reject(e,t)},o.all=function(t){var r=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var i=t.length,n=!1;if(!i)return this.resolve([]);var s=new Array(i),a=0,e=-1,o=new this(u);for(;++e<i;)h(t[e],e);return o;function h(t,e){r.resolve(t).then(function(t){s[e]=t,++a!==i||n||(n=!0,l.resolve(o,s))},function(t){n||(n=!0,l.reject(o,t))})}},o.race=function(t){var e=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var r=t.length,i=!1;if(!r)return this.resolve([]);var n=-1,s=new this(u);for(;++n<r;)a=t[n],e.resolve(a).then(function(t){i||(i=!0,l.resolve(s,t))},function(t){i||(i=!0,l.reject(s,t))});var a;return s}},{immediate:36}],38:[function(t,e,r){"use strict";var i={};(0,t("./lib/utils/common").assign)(i,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),e.exports=i},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(t,e,r){"use strict";var a=t("./zlib/deflate"),o=t("./utils/common"),h=t("./utils/strings"),n=t("./zlib/messages"),s=t("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,d=0,c=8;function p(t){if(!(this instanceof p))return new p(t);this.options=o.assign({level:f,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:""},t||{});var e=this.options;e.raw&&0<e.windowBits?e.windowBits=-e.windowBits:e.gzip&&0<e.windowBits&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==l)throw new Error(n[r]);if(e.header&&a.deflateSetHeader(this.strm,e.header),e.dictionary){var i;if(i="string"==typeof e.dictionary?h.string2buf(e.dictionary):"[object ArrayBuffer]"===u.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(r=a.deflateSetDictionary(this.strm,i))!==l)throw new Error(n[r]);this._dict_set=!0}}function i(t,e){var r=new p(e);if(r.push(t,!0),r.err)throw r.msg||n[r.err];return r.result}p.prototype.push=function(t,e){var r,i,n=this.strm,s=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:!0===e?4:0,"string"==typeof t?n.input=h.string2buf(t):"[object ArrayBuffer]"===u.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new o.Buf8(s),n.next_out=0,n.avail_out=s),1!==(r=a.deflate(n,i))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==n.avail_out&&(0!==n.avail_in||4!==i&&2!==i)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(n.output,n.next_out))):this.onData(o.shrinkBuf(n.output,n.next_out)))}while((0<n.avail_in||0===n.avail_out)&&1!==r);return 4===i?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==i||(this.onEnd(l),!(n.avail_out=0))},p.prototype.onData=function(t){this.chunks.push(t)},p.prototype.onEnd=function(t){t===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Deflate=p,r.deflate=i,r.deflateRaw=function(t,e){return(e=e||{}).raw=!0,i(t,e)},r.gzip=function(t,e){return(e=e||{}).gzip=!0,i(t,e)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(t,e,r){"use strict";var d=t("./zlib/inflate"),c=t("./utils/common"),p=t("./utils/strings"),m=t("./zlib/constants"),i=t("./zlib/messages"),n=t("./zlib/zstream"),s=t("./zlib/gzheader"),_=Object.prototype.toString;function a(t){if(!(this instanceof a))return new a(t);this.options=c.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&0<=e.windowBits&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(0<=e.windowBits&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),15<e.windowBits&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new n,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,e.windowBits);if(r!==m.Z_OK)throw new Error(i[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(t,e){var r=new a(e);if(r.push(t,!0),r.err)throw r.msg||i[r.err];return r.result}a.prototype.push=function(t,e){var r,i,n,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;i=e===~~e?e:!0===e?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof t?h.input=p.binstring2buf(t):"[object ArrayBuffer]"===_.call(t)?h.input=new Uint8Array(t):h.input=t,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new c.Buf8(u),h.next_out=0,h.avail_out=u),(r=d.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||i!==m.Z_FINISH&&i!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(n=p.utf8border(h.output,h.next_out),s=h.next_out-n,a=p.buf2string(h.output,n),h.next_out=s,h.avail_out=u-s,s&&c.arraySet(h.output,h.output,n,s,0),this.onData(a)):this.onData(c.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(i=m.Z_FINISH),i===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):i!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(t){this.chunks.push(t)},a.prototype.onEnd=function(t){t===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(t,e){return(e=e||{}).raw=!0,o(t,e)},r.ungzip=o},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var i in r)r.hasOwnProperty(i)&&(t[i]=r[i])}}return t},r.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){var e,r,i,n,s,a;for(e=i=0,r=t.length;e<r;e++)i+=t[e].length;for(a=new Uint8Array(i),e=n=0,r=t.length;e<r;e++)s=t[e],a.set(s,n),n+=s.length;return a}},s={arraySet:function(t,e,r,i,n){for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){return[].concat.apply([],t)}};r.setTyped=function(t){t?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,n)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(i)},{}],42:[function(t,e,r){"use strict";var h=t("./common"),n=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){n=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var u=new h.Buf8(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function l(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&n))return String.fromCharCode.apply(null,h.shrinkBuf(t,e));for(var r="",i=0;i<e;i++)r+=String.fromCharCode(t[i]);return r}u[254]=u[254]=1,r.string2buf=function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=new h.Buf8(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e},r.buf2binstring=function(t){return l(t,t.length)},r.binstring2buf=function(t){for(var e=new h.Buf8(t.length),r=0,i=e.length;r<i;r++)e[r]=t.charCodeAt(r);return e},r.buf2string=function(t,e){var r,i,n,s,a=e||t.length,o=new Array(2*a);for(r=i=0;r<a;)if((n=t[r++])<128)o[i++]=n;else if(4<(s=u[n]))o[i++]=65533,r+=s-1;else{for(n&=2===s?31:3===s?15:7;1<s&&r<a;)n=n<<6|63&t[r++],s--;1<s?o[i++]=65533:n<65536?o[i++]=n:(n-=65536,o[i++]=55296|n>>10&1023,o[i++]=56320|1023&n)}return l(o,i)},r.utf8border=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}},{"./common":41}],43:[function(t,e,r){"use strict";e.exports=function(t,e,r,i){for(var n=65535&t|0,s=t>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(n=n+e[i++]|0)|0,--a;);n%=65521,s%=65521}return n|s<<16|0}},{}],44:[function(t,e,r){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,e,r){"use strict";var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}},{}],46:[function(t,e,r){"use strict";var h,d=t("../utils/common"),u=t("./trees"),c=t("./adler32"),p=t("./crc32"),i=t("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,n=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(t,e){return t.msg=i[e],e}function T(t){return(t<<1)-(4<t?9:0)}function D(t){for(var e=t.length;0<=--e;)t[e]=0}function F(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(d.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function N(t,e){u._tr_flush_block(t,0<=t.block_start?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,F(t.strm)}function U(t,e){t.pending_buf[t.pending++]=e}function P(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function L(t,e){var r,i,n=t.max_chain_length,s=t.strstart,a=t.prev_length,o=t.nice_match,h=t.strstart>t.w_size-z?t.strstart-(t.w_size-z):0,u=t.window,l=t.w_mask,f=t.prev,d=t.strstart+S,c=u[s+a-1],p=u[s+a];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(u[(r=e)+a]===p&&u[r+a-1]===c&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<d);if(i=S-(d-s),s=d-S,a<i){if(t.match_start=e,o<=(a=i))break;c=u[s+a-1],p=u[s+a]}}}while((e=f[e&l])>h&&0!=--n);return a<=t.lookahead?a:t.lookahead}function j(t){var e,r,i,n,s,a,o,h,u,l,f=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=f+(f-z)){for(d.arraySet(t.window,t.window,f,f,0),t.match_start-=f,t.strstart-=f,t.block_start-=f,e=r=t.hash_size;i=t.head[--e],t.head[e]=f<=i?i-f:0,--r;);for(e=r=f;i=t.prev[--e],t.prev[e]=f<=i?i-f:0,--r;);n+=f}if(0===t.strm.avail_in)break;if(a=t.strm,o=t.window,h=t.strstart+t.lookahead,u=n,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,d.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=c(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),t.lookahead+=r,t.lookahead+t.insert>=x)for(s=t.strstart-t.insert,t.ins_h=t.window[s],t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+x-1])&t.hash_mask,t.prev[s&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=s,s++,t.insert--,!(t.lookahead+t.insert<x)););}while(t.lookahead<z&&0!==t.strm.avail_in)}function Z(t,e){for(var r,i;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r)),t.match_length>=x)if(i=u._tr_tally(t,t.strstart-t.match_start,t.match_length-x),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=x){for(t.match_length--;t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart,0!=--t.match_length;);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function W(t,e){for(var r,i,n;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=x-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r),t.match_length<=5&&(1===t.strategy||t.match_length===x&&4096<t.strstart-t.match_start)&&(t.match_length=x-1)),t.prev_length>=x&&t.match_length<=t.prev_length){for(n=t.strstart+t.lookahead-x,i=u._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-x),t.lookahead-=t.prev_length-1,t.prev_length-=2;++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!=--t.prev_length;);if(t.match_available=0,t.match_length=x-1,t.strstart++,i&&(N(t,!1),0===t.strm.avail_out))return A}else if(t.match_available){if((i=u._tr_tally(t,0,t.window[t.strstart-1]))&&N(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return A}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=u._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function M(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*w),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(k+1),this.heap=new d.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=n,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?C:E,t.adler=2===e.wrap?0:1,e.last_flush=l,u._tr_init(e),m):R(t,_)}function K(t){var e=G(t);return e===m&&function(t){t.window_size=2*t.w_size,D(t.head),t.max_lazy_match=h[t.level].max_lazy,t.good_match=h[t.level].good_length,t.nice_match=h[t.level].nice_length,t.max_chain_length=h[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=x-1,t.match_available=0,t.ins_h=0}(t.state),e}function Y(t,e,r,i,n,s){if(!t)return _;var a=1;if(e===g&&(e=6),i<0?(a=0,i=-i):15<i&&(a=2,i-=16),n<1||y<n||r!==v||i<8||15<i||e<0||9<e||s<0||b<s)return R(t,_);8===i&&(i=9);var o=new H;return(t.state=o).strm=t,o.wrap=a,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=e,o.strategy=s,o.method=r,K(t)}h=[new M(0,0,0,0,function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(j(t),0===t.lookahead&&e===l)return A;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,N(t,!1),0===t.strm.avail_out))return A;if(t.strstart-t.block_start>=t.w_size-z&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):(t.strstart>t.block_start&&(N(t,!1),t.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(t,e){return Y(t,e,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?_:(t.state.gzhead=e,m):_},r.deflate=function(t,e){var r,i,n,s;if(!t||!t.state||5<e||e<0)return t?R(t,_):_;if(i=t.state,!t.output||!t.input&&0!==t.avail_in||666===i.status&&e!==f)return R(t,0===t.avail_out?-5:_);if(i.strm=t,r=i.last_flush,i.last_flush=e,i.status===C)if(2===i.wrap)t.adler=0,U(i,31),U(i,139),U(i,8),i.gzhead?(U(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),U(i,255&i.gzhead.time),U(i,i.gzhead.time>>8&255),U(i,i.gzhead.time>>16&255),U(i,i.gzhead.time>>24&255),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(U(i,255&i.gzhead.extra.length),U(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(t.adler=p(t.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=69):(U(i,0),U(i,0),U(i,0),U(i,0),U(i,0),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,3),i.status=E);else{var a=v+(i.w_bits-8<<4)<<8;a|=(2<=i.strategy||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(a|=32),a+=31-a%31,i.status=E,P(i,a),0!==i.strstart&&(P(i,t.adler>>>16),P(i,65535&t.adler)),t.adler=1}if(69===i.status)if(i.gzhead.extra){for(n=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending!==i.pending_buf_size));)U(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=73)}else i.status=73;if(73===i.status)if(i.gzhead.name){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.gzindex=0,i.status=91)}else i.status=91;if(91===i.status)if(i.gzhead.comment){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.status=103)}else i.status=103;if(103===i.status&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&F(t),i.pending+2<=i.pending_buf_size&&(U(i,255&t.adler),U(i,t.adler>>8&255),t.adler=0,i.status=E)):i.status=E),0!==i.pending){if(F(t),0===t.avail_out)return i.last_flush=-1,m}else if(0===t.avail_in&&T(e)<=T(r)&&e!==f)return R(t,-5);if(666===i.status&&0!==t.avail_in)return R(t,-5);if(0!==t.avail_in||0!==i.lookahead||e!==l&&666!==i.status){var o=2===i.strategy?function(t,e){for(var r;;){if(0===t.lookahead&&(j(t),0===t.lookahead)){if(e===l)return A;break}if(t.match_length=0,r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):3===i.strategy?function(t,e){for(var r,i,n,s,a=t.window;;){if(t.lookahead<=S){if(j(t),t.lookahead<=S&&e===l)return A;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=x&&0<t.strstart&&(i=a[n=t.strstart-1])===a[++n]&&i===a[++n]&&i===a[++n]){s=t.strstart+S;do{}while(i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&n<s);t.match_length=S-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=x?(r=u._tr_tally(t,1,t.match_length-x),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):h[i.level].func(i,e);if(o!==O&&o!==B||(i.status=666),o===A||o===O)return 0===t.avail_out&&(i.last_flush=-1),m;if(o===I&&(1===e?u._tr_align(i):5!==e&&(u._tr_stored_block(i,0,0,!1),3===e&&(D(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),F(t),0===t.avail_out))return i.last_flush=-1,m}return e!==f?m:i.wrap<=0?1:(2===i.wrap?(U(i,255&t.adler),U(i,t.adler>>8&255),U(i,t.adler>>16&255),U(i,t.adler>>24&255),U(i,255&t.total_in),U(i,t.total_in>>8&255),U(i,t.total_in>>16&255),U(i,t.total_in>>24&255)):(P(i,t.adler>>>16),P(i,65535&t.adler)),F(t),0<i.wrap&&(i.wrap=-i.wrap),0!==i.pending?m:1)},r.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==C&&69!==e&&73!==e&&91!==e&&103!==e&&e!==E&&666!==e?R(t,_):(t.state=null,e===E?R(t,-3):m):_},r.deflateSetDictionary=function(t,e){var r,i,n,s,a,o,h,u,l=e.length;if(!t||!t.state)return _;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(t.adler=c(t.adler,e,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new d.Buf8(r.w_size),d.arraySet(u,e,l-r.w_size,r.w_size,0),e=u,l=r.w_size),a=t.avail_in,o=t.next_in,h=t.input,t.avail_in=l,t.next_in=0,t.input=e,j(r);r.lookahead>=x;){for(i=r.strstart,n=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+x-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++,--n;);r.strstart=i,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,t.next_in=o,t.input=h,t.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(t,e,r){"use strict";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(t,e,r){"use strict";e.exports=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C;r=t.state,i=t.next_in,z=t.input,n=i+(t.avail_in-5),s=t.next_out,C=t.output,a=s-(e-t.avail_out),o=s+(t.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;t:do{p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=m[c&g];e:for(;;){if(c>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(c&(1<<y)-1)];continue e}if(32&y){r.mode=12;break t}t.msg="invalid literal/length code",r.mode=30;break t}w=65535&v,(y&=15)&&(p<y&&(c+=z[i++]<<p,p+=8),w+=c&(1<<y)-1,c>>>=y,p-=y),p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=_[c&b];r:for(;;){if(c>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(c&(1<<y)-1)];continue r}t.msg="invalid distance code",r.mode=30;break t}if(k=65535&v,p<(y&=15)&&(c+=z[i++]<<p,(p+=8)<y&&(c+=z[i++]<<p,p+=8)),h<(k+=c&(1<<y)-1)){t.msg="invalid distance too far back",r.mode=30;break t}if(c>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){t.msg="invalid distance too far back",r.mode=30;break t}if(S=d,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=d[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=d[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(i<n&&s<o);i-=w=p>>3,c&=(1<<(p-=w<<3))-1,t.next_in=i,t.next_out=s,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(t,e,r){"use strict";var I=t("../utils/common"),O=t("./adler32"),B=t("./crc32"),R=t("./inffast"),T=t("./inftrees"),D=1,F=2,N=0,U=-2,P=1,i=852,n=592;function L(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=P,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new I.Buf32(i),e.distcode=e.distdyn=new I.Buf32(n),e.sane=1,e.back=-1,N):U}function o(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,a(t)):U}function h(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||15<e)?U:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,o(t))):U}function u(t,e){var r,i;return t?(i=new s,(t.state=i).window=null,(r=h(t,e))!==N&&(t.state=null),r):U}var l,f,d=!0;function j(t){if(d){var e;for(l=new I.Buf32(512),f=new I.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(T(D,t.lens,0,288,l,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;T(F,t.lens,0,32,f,0,t.work,{bits:5}),d=!1}t.lencode=l,t.lenbits=9,t.distcode=f,t.distbits=5}function Z(t,e,r,i){var n,s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),i>=s.wsize?(I.arraySet(s.window,e,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(i<(n=s.wsize-s.wnext)&&(n=i),I.arraySet(s.window,e,r-i,n,s.wnext),(i-=n)?(I.arraySet(s.window,e,r-i,i,0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(t){return u(t,15)},r.inflateInit2=u,r.inflate=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return U;12===(r=t.state).mode&&(r.mode=13),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,f=o,d=h,x=N;t:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){t.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){t.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){t.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,t.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){t.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){t.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,i,s,c,k)),512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,r.length-=c),r.length))break t;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(65535&r.check)){t.msg="header crc mismatch",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}t.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,2;t.adler=r.check=1,r.mode=12;case 12:if(5===e||6===e)break t;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==e)break;u>>>=2,l-=2;break t;case 2:r.mode=17;break;case 3:t.msg="invalid block type",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){t.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===e)break t;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),h<c&&(c=h),0===c)break t;I.arraySet(n,i,s,c,a),o-=c,s+=c,h-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){t.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){t.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+c>r.nlen+r.ndist){t.msg="invalid bit length repeat",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){t.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){t.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===e)break t;case 20:r.mode=21;case 21:if(6<=o&&258<=h){t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,R(t,d),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){t.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){t.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break t;if(c=d-h,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){t.msg="invalid distance too far back",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=n,p=a-r.offset,c=r.length;for(h<c&&(c=h),h-=c,r.length-=c;n[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break t;n[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break t;o--,u|=i[s++]<<l,l+=8}if(d-=h,t.total_out+=d,r.total+=d,d&&(t.adler=r.check=r.flags?B(r.check,n,d,a-d):O(r.check,n,d,a-d)),d=h,(r.flags?u:L(u))!==r.check){t.msg="incorrect data check",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(4294967295&r.total)){t.msg="incorrect length check",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break t;case 30:x=-3;break t;case 31:return-4;case 32:default:return U}return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,(r.wsize||d!==t.avail_out&&r.mode<30&&(r.mode<27||4!==e))&&Z(t,t.output,t.next_out,d-t.avail_out)?(r.mode=31,-4):(f-=t.avail_in,d-=t.avail_out,t.total_in+=f,t.total_out+=d,r.total+=d,r.wrap&&d&&(t.adler=r.check=r.flags?B(r.check,n,d,t.next_out-d):O(r.check,n,d,t.next_out-d)),t.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===d||4===e)&&x===N&&(x=-5),x)},r.inflateEnd=function(t){if(!t||!t.state)return U;var e=t.state;return e.window&&(e.window=null),t.state=null,N},r.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?U:((r.head=e).done=!1,N):U},r.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,e,i,0)!==r.check?-3:Z(t,e,i,i)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(t,e,r){"use strict";var D=t("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,r,i,n,s,a,o){var h,u,l,f,d,c,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<i;v++)O[e[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===t||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<i;v++)0!==e[r+v]&&(a[B[e[r+v]]++]=v);if(c=0===t?(A=R=a,19):1===t?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,d=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===t&&852<C||2===t&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<c?(m=0,a[v]):a[v]>c?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;n[d+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=e[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),d+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===t&&852<C||2===t&&592<C)return 1;n[l=E&f]=k<<24|x<<16|d-s|0}}return 0!==E&&(n[d+E]=b-S<<24|64<<16|0),o.bits=k,0}},{"../utils/common":41}],51:[function(t,e,r){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(t,e,r){"use strict";var n=t("../utils/common"),o=0,h=1;function i(t){for(var e=t.length;0<=--e;)t[e]=0}var s=0,a=29,u=256,l=u+1+a,f=30,d=19,_=2*l+1,g=15,c=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));i(z);var C=new Array(2*f);i(C);var E=new Array(512);i(E);var A=new Array(256);i(A);var I=new Array(a);i(I);var O,B,R,T=new Array(f);function D(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function F(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function N(t){return t<256?E[t]:E[256+(t>>>7)]}function U(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function P(t,e,r){t.bi_valid>c-r?(t.bi_buf|=e<<t.bi_valid&65535,U(t,t.bi_buf),t.bi_buf=e>>c-t.bi_valid,t.bi_valid+=r-c):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function L(t,e,r){P(t,r[2*e],r[2*e+1])}function j(t,e){for(var r=0;r|=1&t,t>>>=1,r<<=1,0<--e;);return r>>>1}function Z(t,e,r){var i,n,s=new Array(g+1),a=0;for(i=1;i<=g;i++)s[i]=a=a+r[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=j(s[o]++,o))}}function W(t){var e;for(e=0;e<l;e++)t.dyn_ltree[2*e]=0;for(e=0;e<f;e++)t.dyn_dtree[2*e]=0;for(e=0;e<d;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*m]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function M(t){8<t.bi_valid?U(t,t.bi_buf):0<t.bi_valid&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function H(t,e,r,i){var n=2*e,s=2*r;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[r]}function G(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&H(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!H(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function K(t,e,r){var i,n,s,a,o=0;if(0!==t.last_lit)for(;i=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],n=t.pending_buf[t.l_buf+o],o++,0===i?L(t,n,e):(L(t,(s=A[n])+u+1,e),0!==(a=w[s])&&P(t,n-=I[s],a),L(t,s=N(--i),r),0!==(a=k[s])&&P(t,i-=T[s],a)),o<t.last_lit;);L(t,m,e)}function Y(t,e){var r,i,n,s=e.dyn_tree,a=e.stat_desc.static_tree,o=e.stat_desc.has_stree,h=e.stat_desc.elems,u=-1;for(t.heap_len=0,t.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(t.heap[++t.heap_len]=u=r,t.depth[r]=0):s[2*r+1]=0;for(;t.heap_len<2;)s[2*(n=t.heap[++t.heap_len]=u<2?++u:0)]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=a[2*n+1]);for(e.max_code=u,r=t.heap_len>>1;1<=r;r--)G(t,s,r);for(n=h;r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],G(t,s,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,s[2*n]=s[2*r]+s[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,s[2*r+1]=s[2*i+1]=n,t.heap[1]=n++,G(t,s,1),2<=t.heap_len;);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,s,a,o,h=e.dyn_tree,u=e.max_code,l=e.stat_desc.static_tree,f=e.stat_desc.has_stree,d=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,m=0;for(s=0;s<=g;s++)t.bl_count[s]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<_;r++)p<(s=h[2*h[2*(i=t.heap[r])+1]+1]+1)&&(s=p,m++),h[2*i+1]=s,u<i||(t.bl_count[s]++,a=0,c<=i&&(a=d[i-c]),o=h[2*i],t.opt_len+=o*(s+a),f&&(t.static_len+=o*(l[2*i+1]+a)));if(0!==m){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(i=t.bl_count[s];0!==i;)u<(n=t.heap[--r])||(h[2*n+1]!==s&&(t.opt_len+=(s-h[2*n+1])*h[2*n],h[2*n+1]=s),i--)}}(t,e),Z(s,u,t.bl_count)}function X(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=a,a=e[2*(i+1)+1],++o<h&&n===a||(o<u?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[2*b]++):o<=10?t.bl_tree[2*v]++:t.bl_tree[2*y]++,s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4))}function V(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),i=0;i<=r;i++)if(n=a,a=e[2*(i+1)+1],!(++o<h&&n===a)){if(o<u)for(;L(t,n,t.bl_tree),0!=--o;);else 0!==n?(n!==s&&(L(t,n,t.bl_tree),o--),L(t,b,t.bl_tree),P(t,o-3,2)):o<=10?(L(t,v,t.bl_tree),P(t,o-3,3)):(L(t,y,t.bl_tree),P(t,o-11,7));s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4)}}i(T);var q=!1;function J(t,e,r,i){P(t,(s<<1)+(i?1:0),3),function(t,e,r,i){M(t),i&&(U(t,r),U(t,~r)),n.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r,!0)}r._tr_init=function(t){q||(function(){var t,e,r,i,n,s=new Array(g+1);for(i=r=0;i<a-1;i++)for(I[i]=r,t=0;t<1<<w[i];t++)A[r++]=i;for(A[r-1]=i,i=n=0;i<16;i++)for(T[i]=n,t=0;t<1<<k[i];t++)E[n++]=i;for(n>>=7;i<f;i++)for(T[i]=n<<7,t=0;t<1<<k[i]-7;t++)E[256+n++]=i;for(e=0;e<=g;e++)s[e]=0;for(t=0;t<=143;)z[2*t+1]=8,t++,s[8]++;for(;t<=255;)z[2*t+1]=9,t++,s[9]++;for(;t<=279;)z[2*t+1]=7,t++,s[7]++;for(;t<=287;)z[2*t+1]=8,t++,s[8]++;for(Z(z,l+1,s),t=0;t<f;t++)C[2*t+1]=5,C[2*t]=j(t,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,d,p)}(),q=!0),t.l_desc=new F(t.dyn_ltree,O),t.d_desc=new F(t.dyn_dtree,B),t.bl_desc=new F(t.bl_tree,R),t.bi_buf=0,t.bi_valid=0,W(t)},r._tr_stored_block=J,r._tr_flush_block=function(t,e,r,i){var n,s,a=0;0<t.level?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return o;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return h;for(e=32;e<u;e++)if(0!==t.dyn_ltree[2*e])return h;return o}(t)),Y(t,t.l_desc),Y(t,t.d_desc),a=function(t){var e;for(X(t,t.dyn_ltree,t.l_desc.max_code),X(t,t.dyn_dtree,t.d_desc.max_code),Y(t,t.bl_desc),e=d-1;3<=e&&0===t.bl_tree[2*S[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),n=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=n&&(n=s)):n=s=r+5,r+4<=n&&-1!==e?J(t,e,r,i):4===t.strategy||s===n?(P(t,2+(i?1:0),3),K(t,z,C)):(P(t,4+(i?1:0),3),function(t,e,r,i){var n;for(P(t,e-257,5),P(t,r-1,5),P(t,i-4,4),n=0;n<i;n++)P(t,t.bl_tree[2*S[n]+1],3);V(t,t.dyn_ltree,e-1),V(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,a+1),K(t,t.dyn_ltree,t.dyn_dtree)),W(t),i&&M(t)},r._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(A[r]+u+1)]++,t.dyn_dtree[2*N(e)]++),t.last_lit===t.lit_bufsize-1},r._tr_align=function(t){P(t,2,3),L(t,m,z),function(t){16===t.bi_valid?(U(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},{"../utils/common":41}],53:[function(t,e,r){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,e,r){"use strict";e.exports="function"==typeof setImmediate?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)}},{}]},{},[10])(10)});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/lookup-closest-locale/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/lookup-closest-locale/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// @flow
// "lookup" algorithm http://tools.ietf.org/html/rfc4647#section-3.4
// assumes normalized language tags, and matches in a case sensitive manner
module.exports = function lookupClosestLocale (locale/*: string | string[] | void */, available/*: { [string]: any } */)/*: ?string */ {
  if (typeof locale === 'string' && available[locale]) return locale
  var locales = [].concat(locale || [])
  for (var l = 0, ll = locales.length; l < ll; ++l) {
    var current = locales[l].split('-')
    while (current.length) {
      var candidate = current.join('-')
      if (available[candidate]) return candidate
      current.pop()
    }
  }
}


/***/ }),

/***/ "./node_modules/nets/index.js":
/*!************************************!*\
  !*** ./node_modules/nets/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer) {var req = __webpack_require__(/*! request */ "./node_modules/xhr/index.js")

module.exports = Nets

function Nets (opts, cb) {
  if (typeof opts === 'string') opts = { uri: opts }

  // in node, if encoding === null then response will be a Buffer. we want this to be the default
  if (!opts.hasOwnProperty('encoding')) opts.encoding = null

  // in browser, we should by default convert the arraybuffer into a Buffer
  if (process.browser && !opts.hasOwnProperty('json') && opts.encoding === null) {
    opts.responseType = 'arraybuffer'
    var originalCb = cb
    cb = bufferify
  }

  function bufferify (err, resp, body) {
    if (body) body = new Buffer(new Uint8Array(body))
    originalCb(err, resp, body)
  }

  return req(opts, cb)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js"), __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/parse-headers/parse-headers.js":
/*!*****************************************************!*\
  !*** ./node_modules/parse-headers/parse-headers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var trim = function(string) {
  return string.replace(/^\s+|\s+$/g, '');
}
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  var headersArr = trim(headers).split('\n')

  for (var i = 0; i < headersArr.length; i++) {
    var row = headersArr[i]
    var index = row.indexOf(':')
    , key = trim(row.slice(0, index)).toLowerCase()
    , value = trim(row.slice(index + 1))

    if (typeof(result[key]) === 'undefined') {
      result[key] = value
    } else if (isArray(result[key])) {
      result[key].push(value)
    } else {
      result[key] = [ result[key], value ]
    }
  }

  return result
}


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/scratch-translate-extension-languages/languages.json":
/*!***************************************************************************!*\
  !*** ./node_modules/scratch-translate-extension-languages/languages.json ***!
  \***************************************************************************/
/*! exports provided: menuMap, nameMap, scratchToGoogleMap, previouslySupported, spokenLanguages, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"menuMap\":{\"cs\":[{\"code\":\"am\",\"name\":\"amhartina\"},{\"code\":\"en\",\"name\":\"anglitina\"},{\"code\":\"ar\",\"name\":\"arabtina\"},{\"code\":\"az\",\"name\":\"zerbjdntina\"},{\"code\":\"eu\",\"name\":\"baskitina\"},{\"code\":\"bg\",\"name\":\"bulhartina\"},{\"code\":\"cs\",\"name\":\"etina\"},{\"code\":\"zh-tw\",\"name\":\"ntina (tradin)\"},{\"code\":\"zh-cn\",\"name\":\"ntina (zjednoduen)\"},{\"code\":\"da\",\"name\":\"dntina\"},{\"code\":\"et\",\"name\":\"estontina\"},{\"code\":\"fi\",\"name\":\"fintina\"},{\"code\":\"fr\",\"name\":\"francouztina\"},{\"code\":\"gl\",\"name\":\"galicijtina\"},{\"code\":\"he\",\"name\":\"hebrejtina\"},{\"code\":\"nl\",\"name\":\"holandtina\"},{\"code\":\"hr\",\"name\":\"chorvattina\"},{\"code\":\"id\",\"name\":\"indontina\"},{\"code\":\"ga\",\"name\":\"irtina\"},{\"code\":\"is\",\"name\":\"islandtina\"},{\"code\":\"it\",\"name\":\"italtina\"},{\"code\":\"ja\",\"name\":\"japontina\"},{\"code\":\"ca\",\"name\":\"katalntina\"},{\"code\":\"ko\",\"name\":\"korejtina\"},{\"code\":\"lt\",\"name\":\"litevtina\"},{\"code\":\"lv\",\"name\":\"lotytina\"},{\"code\":\"hu\",\"name\":\"maartina\"},{\"code\":\"mi\",\"name\":\"maortina\"},{\"code\":\"de\",\"name\":\"nmina\"},{\"code\":\"nb\",\"name\":\"nortina\"},{\"code\":\"fa\",\"name\":\"pertina\"},{\"code\":\"pl\",\"name\":\"poltina\"},{\"code\":\"pt\",\"name\":\"portugaltina\"},{\"code\":\"ro\",\"name\":\"rumuntina\"},{\"code\":\"ru\",\"name\":\"rutina\"},{\"code\":\"el\",\"name\":\"etina\"},{\"code\":\"gd\",\"name\":\"skotsk gaeltina\"},{\"code\":\"sk\",\"name\":\"sloventina\"},{\"code\":\"sl\",\"name\":\"slovintina\"},{\"code\":\"sr\",\"name\":\"srbtina\"},{\"code\":\"es\",\"name\":\"panltina\"},{\"code\":\"sv\",\"name\":\"vdtina\"},{\"code\":\"th\",\"name\":\"thajtina\"},{\"code\":\"tr\",\"name\":\"turetina\"},{\"code\":\"uk\",\"name\":\"ukrajintina\"},{\"code\":\"cy\",\"name\":\"veltina\"},{\"code\":\"vi\",\"name\":\"vietnamtina\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"da\":[{\"code\":\"am\",\"name\":\"Amharisk\"},{\"code\":\"ar\",\"name\":\"Arabisk\"},{\"code\":\"az\",\"name\":\"Aserbajdsjansk\"},{\"code\":\"eu\",\"name\":\"Baskisk\"},{\"code\":\"bg\",\"name\":\"Bulgarsk\"},{\"code\":\"da\",\"name\":\"Dansk\"},{\"code\":\"en\",\"name\":\"Engelsk\"},{\"code\":\"et\",\"name\":\"Estisk\"},{\"code\":\"fi\",\"name\":\"Finsk\"},{\"code\":\"fr\",\"name\":\"Fransk\"},{\"code\":\"gl\",\"name\":\"Galicisk\"},{\"code\":\"el\",\"name\":\"Grsk\"},{\"code\":\"he\",\"name\":\"Hebraisk\"},{\"code\":\"nl\",\"name\":\"Hollandsk\"},{\"code\":\"id\",\"name\":\"Indonesisk\"},{\"code\":\"ga\",\"name\":\"Irsk\"},{\"code\":\"is\",\"name\":\"Islandsk\"},{\"code\":\"it\",\"name\":\"Italiensk\"},{\"code\":\"ja\",\"name\":\"Japansk\"},{\"code\":\"ca\",\"name\":\"Katalansk\"},{\"code\":\"zh-cn\",\"name\":\"Kinesisk (forenklet)\"},{\"code\":\"zh-tw\",\"name\":\"Kinesisk (traditionelt)\"},{\"code\":\"ko\",\"name\":\"Koreansk\"},{\"code\":\"hr\",\"name\":\"Kroatisk\"},{\"code\":\"lv\",\"name\":\"Lettisk\"},{\"code\":\"lt\",\"name\":\"Litauisk\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norsk\"},{\"code\":\"fa\",\"name\":\"Persisk\"},{\"code\":\"pl\",\"name\":\"Polsk\"},{\"code\":\"pt\",\"name\":\"Portugisisk\"},{\"code\":\"ro\",\"name\":\"Rumnsk\"},{\"code\":\"ru\",\"name\":\"Russisk\"},{\"code\":\"sr\",\"name\":\"Serbisk\"},{\"code\":\"gd\",\"name\":\"Skotsk glisk\"},{\"code\":\"sk\",\"name\":\"Slovakisk\"},{\"code\":\"sl\",\"name\":\"Slovensk\"},{\"code\":\"es\",\"name\":\"Spansk\"},{\"code\":\"sv\",\"name\":\"Svensk\"},{\"code\":\"th\",\"name\":\"Thailandsk\"},{\"code\":\"cs\",\"name\":\"Tjekkisk\"},{\"code\":\"tr\",\"name\":\"Tyrkisk\"},{\"code\":\"de\",\"name\":\"Tysk\"},{\"code\":\"uk\",\"name\":\"Ukrainsk\"},{\"code\":\"hu\",\"name\":\"Ungarsk\"},{\"code\":\"vi\",\"name\":\"Vietnamesisk\"},{\"code\":\"cy\",\"name\":\"Walisisk\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"gl\":[{\"code\":\"az\",\"name\":\"acerbaixano\"},{\"code\":\"de\",\"name\":\"alemn\"},{\"code\":\"am\",\"name\":\"amrico\"},{\"code\":\"ar\",\"name\":\"rabe\"},{\"code\":\"bg\",\"name\":\"blgaro\"},{\"code\":\"ca\",\"name\":\"cataln\"},{\"code\":\"cs\",\"name\":\"checo\"},{\"code\":\"zh-cn\",\"name\":\"chins (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"chins (tradicional)\"},{\"code\":\"ko\",\"name\":\"coreano\"},{\"code\":\"hr\",\"name\":\"croata\"},{\"code\":\"da\",\"name\":\"dinamarqus\"},{\"code\":\"sk\",\"name\":\"eslovaco\"},{\"code\":\"sl\",\"name\":\"esloveno\"},{\"code\":\"es\",\"name\":\"espaol\"},{\"code\":\"et\",\"name\":\"estoniano\"},{\"code\":\"eu\",\"name\":\"uscaro\"},{\"code\":\"fi\",\"name\":\"fins\"},{\"code\":\"fr\",\"name\":\"francs\"},{\"code\":\"gd\",\"name\":\"galico escocs\"},{\"code\":\"gl\",\"name\":\"galego\"},{\"code\":\"cy\",\"name\":\"gals\"},{\"code\":\"el\",\"name\":\"grego\"},{\"code\":\"he\",\"name\":\"hebreo\"},{\"code\":\"hu\",\"name\":\"hngaro\"},{\"code\":\"id\",\"name\":\"indonesio\"},{\"code\":\"en\",\"name\":\"ingls\"},{\"code\":\"ga\",\"name\":\"irlands\"},{\"code\":\"is\",\"name\":\"islands\"},{\"code\":\"it\",\"name\":\"italiano\"},{\"code\":\"lv\",\"name\":\"letn\"},{\"code\":\"lt\",\"name\":\"lituano\"},{\"code\":\"mi\",\"name\":\"maor\"},{\"code\":\"nl\",\"name\":\"neerlands\"},{\"code\":\"nb\",\"name\":\"noruegus\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polaco\"},{\"code\":\"pt\",\"name\":\"portugus\"},{\"code\":\"ro\",\"name\":\"romans\"},{\"code\":\"ru\",\"name\":\"ruso\"},{\"code\":\"sr\",\"name\":\"serbio\"},{\"code\":\"sv\",\"name\":\"sueco\"},{\"code\":\"th\",\"name\":\"tailands\"},{\"code\":\"tr\",\"name\":\"turco\"},{\"code\":\"uk\",\"name\":\"ucrano\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"ja\",\"name\":\"xapons\"},{\"code\":\"zu\",\"name\":\"zul\"}],\"sl\":[{\"code\":\"am\",\"name\":\"amharina\"},{\"code\":\"en\",\"name\":\"angleina\"},{\"code\":\"ar\",\"name\":\"arabina\"},{\"code\":\"az\",\"name\":\"azerbajdanina\"},{\"code\":\"eu\",\"name\":\"baskovina\"},{\"code\":\"bg\",\"name\":\"bolgarina\"},{\"code\":\"cs\",\"name\":\"eina\"},{\"code\":\"da\",\"name\":\"danina\"},{\"code\":\"et\",\"name\":\"estonina\"},{\"code\":\"fi\",\"name\":\"finina\"},{\"code\":\"fr\",\"name\":\"francoina\"},{\"code\":\"gl\",\"name\":\"galicijina\"},{\"code\":\"el\",\"name\":\"grina\"},{\"code\":\"he\",\"name\":\"hebrejina\"},{\"code\":\"hr\",\"name\":\"hrvaina\"},{\"code\":\"id\",\"name\":\"indonezijina\"},{\"code\":\"ga\",\"name\":\"irina\"},{\"code\":\"is\",\"name\":\"islandina\"},{\"code\":\"it\",\"name\":\"italijanina\"},{\"code\":\"ja\",\"name\":\"japonina\"},{\"code\":\"ca\",\"name\":\"katalonina\"},{\"code\":\"zh-cn\",\"name\":\"kitajina (poenostavljena)\"},{\"code\":\"zh-tw\",\"name\":\"kitajina (tradicionalna)\"},{\"code\":\"ko\",\"name\":\"korejina\"},{\"code\":\"lv\",\"name\":\"latvijina\"},{\"code\":\"lt\",\"name\":\"litovina\"},{\"code\":\"hu\",\"name\":\"madarina\"},{\"code\":\"mi\",\"name\":\"maorina\"},{\"code\":\"de\",\"name\":\"nemina\"},{\"code\":\"nl\",\"name\":\"nizozemina\"},{\"code\":\"nb\",\"name\":\"norveina\"},{\"code\":\"fa\",\"name\":\"perzijina\"},{\"code\":\"pl\",\"name\":\"poljina\"},{\"code\":\"pt\",\"name\":\"portugalina\"},{\"code\":\"ro\",\"name\":\"romunina\"},{\"code\":\"ru\",\"name\":\"ruina\"},{\"code\":\"sk\",\"name\":\"slovaina\"},{\"code\":\"sl\",\"name\":\"slovenina\"},{\"code\":\"sr\",\"name\":\"srbina\"},{\"code\":\"gd\",\"name\":\"kotska gelina\"},{\"code\":\"es\",\"name\":\"panina\"},{\"code\":\"sv\",\"name\":\"vedina\"},{\"code\":\"th\",\"name\":\"tajina\"},{\"code\":\"tr\",\"name\":\"turina\"},{\"code\":\"uk\",\"name\":\"ukrajinina\"},{\"code\":\"cy\",\"name\":\"valianina\"},{\"code\":\"vi\",\"name\":\"vietnamina\"},{\"code\":\"zu\",\"name\":\"zulujina\"}],\"fr\":[{\"code\":\"de\",\"name\":\"Allemand\"},{\"code\":\"am\",\"name\":\"Amharique\"},{\"code\":\"en\",\"name\":\"Anglais\"},{\"code\":\"ar\",\"name\":\"Arabe\"},{\"code\":\"az\",\"name\":\"Azri\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"bg\",\"name\":\"Bulgare\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"zh-cn\",\"name\":\"Chinois (simplifi)\"},{\"code\":\"zh-tw\",\"name\":\"Chinois (traditionnel)\"},{\"code\":\"ko\",\"name\":\"Coren\"},{\"code\":\"hr\",\"name\":\"Croate\"},{\"code\":\"da\",\"name\":\"Danois\"},{\"code\":\"es\",\"name\":\"Espagnol\"},{\"code\":\"et\",\"name\":\"Estonien\"},{\"code\":\"fi\",\"name\":\"Finnois\"},{\"code\":\"fr\",\"name\":\"Franais\"},{\"code\":\"gd\",\"name\":\"Galique (cosse)\"},{\"code\":\"gl\",\"name\":\"Galicien\"},{\"code\":\"cy\",\"name\":\"Gallois\"},{\"code\":\"el\",\"name\":\"Grec\"},{\"code\":\"he\",\"name\":\"Hbreu\"},{\"code\":\"hu\",\"name\":\"Hongrois\"},{\"code\":\"id\",\"name\":\"Indonsien\"},{\"code\":\"ga\",\"name\":\"Irlandais\"},{\"code\":\"is\",\"name\":\"Islandais\"},{\"code\":\"it\",\"name\":\"Italien\"},{\"code\":\"ja\",\"name\":\"Japonais\"},{\"code\":\"lv\",\"name\":\"Letton\"},{\"code\":\"lt\",\"name\":\"Lituanien\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Nerlandais\"},{\"code\":\"nb\",\"name\":\"Norvgien\"},{\"code\":\"fa\",\"name\":\"Persan\"},{\"code\":\"pl\",\"name\":\"Polonais\"},{\"code\":\"pt\",\"name\":\"Portugais\"},{\"code\":\"ro\",\"name\":\"Roumain\"},{\"code\":\"ru\",\"name\":\"Russe\"},{\"code\":\"sr\",\"name\":\"Serbe\"},{\"code\":\"sk\",\"name\":\"Slovaque\"},{\"code\":\"sl\",\"name\":\"Slovne\"},{\"code\":\"sv\",\"name\":\"Sudois\"},{\"code\":\"cs\",\"name\":\"Tchque\"},{\"code\":\"th\",\"name\":\"Tha\"},{\"code\":\"tr\",\"name\":\"Turc\"},{\"code\":\"uk\",\"name\":\"Ukrainien\"},{\"code\":\"vi\",\"name\":\"Vietnamien\"},{\"code\":\"zu\",\"name\":\"Zoulou\"}],\"hu\":[{\"code\":\"am\",\"name\":\"amhara\"},{\"code\":\"en\",\"name\":\"angol\"},{\"code\":\"ar\",\"name\":\"arab\"},{\"code\":\"az\",\"name\":\"azeri\"},{\"code\":\"eu\",\"name\":\"baszk\"},{\"code\":\"bg\",\"name\":\"bolgr\"},{\"code\":\"cs\",\"name\":\"cseh\"},{\"code\":\"da\",\"name\":\"dn\"},{\"code\":\"et\",\"name\":\"szt\"},{\"code\":\"fi\",\"name\":\"finn\"},{\"code\":\"fr\",\"name\":\"francia\"},{\"code\":\"gl\",\"name\":\"galciai\"},{\"code\":\"el\",\"name\":\"grg\"},{\"code\":\"he\",\"name\":\"hber\"},{\"code\":\"nl\",\"name\":\"holland\"},{\"code\":\"hr\",\"name\":\"horvt\"},{\"code\":\"id\",\"name\":\"indonz\"},{\"code\":\"ga\",\"name\":\"r\"},{\"code\":\"is\",\"name\":\"izlandi\"},{\"code\":\"ja\",\"name\":\"japn\"},{\"code\":\"ca\",\"name\":\"kataln\"},{\"code\":\"zh-cn\",\"name\":\"knai (egyszerstett)\"},{\"code\":\"zh-tw\",\"name\":\"knai (hagyomnyos)\"},{\"code\":\"ko\",\"name\":\"koreai\"},{\"code\":\"pl\",\"name\":\"lengyel\"},{\"code\":\"lv\",\"name\":\"lett\"},{\"code\":\"lt\",\"name\":\"litvn\"},{\"code\":\"hu\",\"name\":\"magyar\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"de\",\"name\":\"nmet\"},{\"code\":\"nb\",\"name\":\"norvg\"},{\"code\":\"it\",\"name\":\"olasz\"},{\"code\":\"ru\",\"name\":\"orosz\"},{\"code\":\"fa\",\"name\":\"perzsa\"},{\"code\":\"pt\",\"name\":\"portugl\"},{\"code\":\"ro\",\"name\":\"romn\"},{\"code\":\"gd\",\"name\":\"skt-gael\"},{\"code\":\"es\",\"name\":\"spanyol\"},{\"code\":\"sv\",\"name\":\"svd\"},{\"code\":\"sr\",\"name\":\"szerb\"},{\"code\":\"sk\",\"name\":\"szlovk\"},{\"code\":\"sl\",\"name\":\"szlovn\"},{\"code\":\"th\",\"name\":\"thai\"},{\"code\":\"tr\",\"name\":\"trk\"},{\"code\":\"uk\",\"name\":\"ukrn\"},{\"code\":\"vi\",\"name\":\"vietnami\"},{\"code\":\"cy\",\"name\":\"walesi\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"uk\":[{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" ()\"},{\"code\":\"ja\",\"name\":\"\"}],\"zh-tw\":[{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\"()\"},{\"code\":\"zh-cn\",\"name\":\"()\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\"\"}],\"pt\":[{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arabic\"},{\"code\":\"az\",\"name\":\"Azerbaijani\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"bg\",\"name\":\"Bulgarian\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"zh-cn\",\"name\":\"Chinese (Simplified)\"},{\"code\":\"zh-tw\",\"name\":\"Chinese (Traditional)\"},{\"code\":\"hr\",\"name\":\"Croatian\"},{\"code\":\"cs\",\"name\":\"Czech\"},{\"code\":\"da\",\"name\":\"Danish\"},{\"code\":\"nl\",\"name\":\"Dutch\"},{\"code\":\"en\",\"name\":\"English\"},{\"code\":\"et\",\"name\":\"Estonian\"},{\"code\":\"fi\",\"name\":\"Finnish\"},{\"code\":\"fr\",\"name\":\"French\"},{\"code\":\"gl\",\"name\":\"Galician\"},{\"code\":\"de\",\"name\":\"German\"},{\"code\":\"el\",\"name\":\"Greek\"},{\"code\":\"he\",\"name\":\"Hebrew\"},{\"code\":\"hu\",\"name\":\"Hungarian\"},{\"code\":\"is\",\"name\":\"Icelandic\"},{\"code\":\"id\",\"name\":\"Indonesian\"},{\"code\":\"ga\",\"name\":\"Irish\"},{\"code\":\"it\",\"name\":\"Italian\"},{\"code\":\"ja\",\"name\":\"Japanese\"},{\"code\":\"ko\",\"name\":\"Korean\"},{\"code\":\"lv\",\"name\":\"Latvian\"},{\"code\":\"lt\",\"name\":\"Lithuanian\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norwegian\"},{\"code\":\"fa\",\"name\":\"Persian\"},{\"code\":\"pl\",\"name\":\"Polish\"},{\"code\":\"pt\",\"name\":\"Portuguese\"},{\"code\":\"ro\",\"name\":\"Romanian\"},{\"code\":\"ru\",\"name\":\"Russian\"},{\"code\":\"gd\",\"name\":\"Scots Gaelic\"},{\"code\":\"sr\",\"name\":\"Serbian\"},{\"code\":\"sk\",\"name\":\"Slovak\"},{\"code\":\"sl\",\"name\":\"Slovenian\"},{\"code\":\"es\",\"name\":\"Spanish\"},{\"code\":\"sv\",\"name\":\"Swedish\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"tr\",\"name\":\"Turkish\"},{\"code\":\"uk\",\"name\":\"Ukrainian\"},{\"code\":\"vi\",\"name\":\"Vietnamese\"},{\"code\":\"cy\",\"name\":\"Welsh\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"pt-br\":[{\"code\":\"de\",\"name\":\"Alemo\"},{\"code\":\"am\",\"name\":\"Amrico\"},{\"code\":\"ar\",\"name\":\"rabe\"},{\"code\":\"az\",\"name\":\"Azerbaijano\"},{\"code\":\"eu\",\"name\":\"Basco\"},{\"code\":\"bg\",\"name\":\"Blgaro\"},{\"code\":\"ca\",\"name\":\"Catalo\"},{\"code\":\"zh-cn\",\"name\":\"Chins (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"Chins (tradicional)\"},{\"code\":\"ko\",\"name\":\"Coreano\"},{\"code\":\"hr\",\"name\":\"Croata\"},{\"code\":\"da\",\"name\":\"Dinamarqus\"},{\"code\":\"sk\",\"name\":\"Eslovaco\"},{\"code\":\"sl\",\"name\":\"Esloveno\"},{\"code\":\"es\",\"name\":\"Espanhol\"},{\"code\":\"et\",\"name\":\"Estoniano\"},{\"code\":\"fi\",\"name\":\"Finlands\"},{\"code\":\"fr\",\"name\":\"Francs\"},{\"code\":\"gd\",\"name\":\"Galico escocs\"},{\"code\":\"gl\",\"name\":\"Galego\"},{\"code\":\"cy\",\"name\":\"Gals\"},{\"code\":\"el\",\"name\":\"Grego\"},{\"code\":\"he\",\"name\":\"Hebraico\"},{\"code\":\"nl\",\"name\":\"Holands\"},{\"code\":\"hu\",\"name\":\"Hngaro\"},{\"code\":\"id\",\"name\":\"Indonsio\"},{\"code\":\"en\",\"name\":\"Ingls\"},{\"code\":\"ga\",\"name\":\"Irlands\"},{\"code\":\"is\",\"name\":\"Islands\"},{\"code\":\"it\",\"name\":\"Italiano\"},{\"code\":\"ja\",\"name\":\"Japons\"},{\"code\":\"lv\",\"name\":\"Leto\"},{\"code\":\"lt\",\"name\":\"Lituano\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Noruegus\"},{\"code\":\"fa\",\"name\":\"Persa\"},{\"code\":\"pl\",\"name\":\"Polons\"},{\"code\":\"pt\",\"name\":\"Portugus\"},{\"code\":\"ro\",\"name\":\"Romeno\"},{\"code\":\"ru\",\"name\":\"Russo\"},{\"code\":\"sr\",\"name\":\"Srvio\"},{\"code\":\"sv\",\"name\":\"Sueco\"},{\"code\":\"th\",\"name\":\"Tailands\"},{\"code\":\"cs\",\"name\":\"Tcheco\"},{\"code\":\"tr\",\"name\":\"Turco\"},{\"code\":\"uk\",\"name\":\"Ucraniano\"},{\"code\":\"vi\",\"name\":\"Vietnamita\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"tr\":[{\"code\":\"de\",\"name\":\"Almanca\"},{\"code\":\"ar\",\"name\":\"Arapa\"},{\"code\":\"az\",\"name\":\"Azerice\"},{\"code\":\"eu\",\"name\":\"Baska\"},{\"code\":\"bg\",\"name\":\"Bulgarca\"},{\"code\":\"cs\",\"name\":\"eke\"},{\"code\":\"zh-cn\",\"name\":\"ince (Basitletirilmi)\"},{\"code\":\"zh-tw\",\"name\":\"ince (Geleneksel)\"},{\"code\":\"da\",\"name\":\"Danca\"},{\"code\":\"id\",\"name\":\"Endonezya Dili\"},{\"code\":\"et\",\"name\":\"Estonyaca\"},{\"code\":\"fa\",\"name\":\"Farsa\"},{\"code\":\"nl\",\"name\":\"Felemenke\"},{\"code\":\"fi\",\"name\":\"Fince\"},{\"code\":\"fr\",\"name\":\"Franszca\"},{\"code\":\"cy\",\"name\":\"Galce\"},{\"code\":\"gl\",\"name\":\"Galiyaca\"},{\"code\":\"am\",\"name\":\"Habee\"},{\"code\":\"hr\",\"name\":\"Hrvata\"},{\"code\":\"he\",\"name\":\"branice\"},{\"code\":\"en\",\"name\":\"ngilizce\"},{\"code\":\"ga\",\"name\":\"rlandaca\"},{\"code\":\"es\",\"name\":\"spanyolca\"},{\"code\":\"sv\",\"name\":\"svee\"},{\"code\":\"it\",\"name\":\"talyanca\"},{\"code\":\"is\",\"name\":\"zlandaca\"},{\"code\":\"ja\",\"name\":\"Japonca\"},{\"code\":\"ca\",\"name\":\"Katalanca\"},{\"code\":\"ko\",\"name\":\"Korece\"},{\"code\":\"gd\",\"name\":\"Kuzey sko Dili\"},{\"code\":\"pl\",\"name\":\"Lehe\"},{\"code\":\"lv\",\"name\":\"Letonca\"},{\"code\":\"lt\",\"name\":\"Litvanca\"},{\"code\":\"hu\",\"name\":\"Macarca\"},{\"code\":\"mi\",\"name\":\"Maori Dili\"},{\"code\":\"nb\",\"name\":\"Norvee\"},{\"code\":\"pt\",\"name\":\"Portekizce\"},{\"code\":\"ro\",\"name\":\"Romence\"},{\"code\":\"ru\",\"name\":\"Rusa\"},{\"code\":\"sr\",\"name\":\"Srpa\"},{\"code\":\"sk\",\"name\":\"Slovaka\"},{\"code\":\"sl\",\"name\":\"Slovence\"},{\"code\":\"th\",\"name\":\"Tay Dili\"},{\"code\":\"tr\",\"name\":\"Trke\"},{\"code\":\"uk\",\"name\":\"Ukraynaca\"},{\"code\":\"vi\",\"name\":\"Vietnamca\"},{\"code\":\"el\",\"name\":\"Yunanca\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"ga\":[{\"code\":\"am\",\"name\":\"Amrais\"},{\"code\":\"ar\",\"name\":\"Araibis\"},{\"code\":\"az\",\"name\":\"Asarbaiseinis\"},{\"code\":\"eu\",\"name\":\"Bascais\"},{\"code\":\"en\",\"name\":\"Barla\"},{\"code\":\"cy\",\"name\":\"Breatnais\"},{\"code\":\"bg\",\"name\":\"Bulgiris\"},{\"code\":\"ca\",\"name\":\"Catalinis\"},{\"code\":\"ko\",\"name\":\"Ciris\"},{\"code\":\"hr\",\"name\":\"Critis\"},{\"code\":\"da\",\"name\":\"Danmhairgis\"},{\"code\":\"he\",\"name\":\"Eabhrais\"},{\"code\":\"et\",\"name\":\"Eastinis\"},{\"code\":\"fi\",\"name\":\"Fionlainnis\"},{\"code\":\"fr\",\"name\":\"Fraincis\"},{\"code\":\"ga\",\"name\":\"Gaeilge\"},{\"code\":\"gd\",\"name\":\"Gaeilge na hAlban\"},{\"code\":\"gl\",\"name\":\"Gailsis\"},{\"code\":\"de\",\"name\":\"Gearminis\"},{\"code\":\"el\",\"name\":\"Grigis\"},{\"code\":\"id\",\"name\":\"Indinisis\"},{\"code\":\"it\",\"name\":\"Iodilis\"},{\"code\":\"nb\",\"name\":\"Ioruais\"},{\"code\":\"is\",\"name\":\"oslainnis\"},{\"code\":\"lv\",\"name\":\"Laitvis\"},{\"code\":\"lt\",\"name\":\"Liotuinis\"},{\"code\":\"mi\",\"name\":\"Maorais\"},{\"code\":\"nl\",\"name\":\"Ollainnis\"},{\"code\":\"fa\",\"name\":\"Peirsis\"},{\"code\":\"pl\",\"name\":\"Polainnis\"},{\"code\":\"pt\",\"name\":\"Portaingilis\"},{\"code\":\"ro\",\"name\":\"Rminis\"},{\"code\":\"ru\",\"name\":\"Risis\"},{\"code\":\"ja\",\"name\":\"Seapinis\"},{\"code\":\"cs\",\"name\":\"Seicis\"},{\"code\":\"sr\",\"name\":\"Seirbis\"},{\"code\":\"zh-cn\",\"name\":\"Snis (Simplithe)\"},{\"code\":\"zh-tw\",\"name\":\"Snis (Traidisinta)\"},{\"code\":\"sl\",\"name\":\"Slivinis\"},{\"code\":\"sk\",\"name\":\"Slvaicis\"},{\"code\":\"es\",\"name\":\"Spinnis\"},{\"code\":\"sv\",\"name\":\"Sualainnis\"},{\"code\":\"zu\",\"name\":\"Slis\"},{\"code\":\"th\",\"name\":\"Talainnis\"},{\"code\":\"tr\",\"name\":\"Tuircis\"},{\"code\":\"uk\",\"name\":\"crinis\"},{\"code\":\"hu\",\"name\":\"Ungiris\"},{\"code\":\"vi\",\"name\":\"Vtneaimis\"}],\"th\":[{\"code\":\"el\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"}],\"ja\":[{\"code\":\"is\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\"()\"},{\"code\":\"zh-tw\",\"name\":\"()\"},{\"code\":\"ja\",\"name\":\"\"}],\"ja-hira\":[{\"code\":\"is\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\"()\"},{\"code\":\"zh-tw\",\"name\":\"()\"},{\"code\":\"ja\",\"name\":\"\"}],\"nl\":[{\"code\":\"am\",\"name\":\"Amharisch\"},{\"code\":\"ar\",\"name\":\"Arabisch\"},{\"code\":\"az\",\"name\":\"Azerbeidzjaans\"},{\"code\":\"eu\",\"name\":\"Baskisch\"},{\"code\":\"bg\",\"name\":\"Bulgaars\"},{\"code\":\"ca\",\"name\":\"Catalaans\"},{\"code\":\"zh-tw\",\"name\":\"Chinees (traditioneel)\"},{\"code\":\"zh-cn\",\"name\":\"Chinees (vereenvoudigd)\"},{\"code\":\"da\",\"name\":\"Deens\"},{\"code\":\"de\",\"name\":\"Duits\"},{\"code\":\"en\",\"name\":\"Engels\"},{\"code\":\"et\",\"name\":\"Ests\"},{\"code\":\"fi\",\"name\":\"Fins\"},{\"code\":\"fr\",\"name\":\"Frans\"},{\"code\":\"gl\",\"name\":\"Galicisch\"},{\"code\":\"el\",\"name\":\"Grieks\"},{\"code\":\"he\",\"name\":\"Hebreeuws\"},{\"code\":\"hu\",\"name\":\"Hongaars\"},{\"code\":\"ga\",\"name\":\"Iers\"},{\"code\":\"is\",\"name\":\"IJslands\"},{\"code\":\"id\",\"name\":\"Indonesisch\"},{\"code\":\"it\",\"name\":\"Italiaans\"},{\"code\":\"ja\",\"name\":\"Japans\"},{\"code\":\"ko\",\"name\":\"Koreaans\"},{\"code\":\"hr\",\"name\":\"Kroatisch\"},{\"code\":\"lv\",\"name\":\"Lets\"},{\"code\":\"lt\",\"name\":\"Litouws\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Nederlands\"},{\"code\":\"nb\",\"name\":\"Noors\"},{\"code\":\"uk\",\"name\":\"Oekraens\"},{\"code\":\"fa\",\"name\":\"Perzisch\"},{\"code\":\"pl\",\"name\":\"Pools\"},{\"code\":\"pt\",\"name\":\"Portugees\"},{\"code\":\"ro\",\"name\":\"Roemeens\"},{\"code\":\"ru\",\"name\":\"Russisch\"},{\"code\":\"gd\",\"name\":\"Schots Keltisch\"},{\"code\":\"sr\",\"name\":\"Servisch\"},{\"code\":\"sk\",\"name\":\"Slovaaks\"},{\"code\":\"sl\",\"name\":\"Sloveens\"},{\"code\":\"es\",\"name\":\"Spaans\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"cs\",\"name\":\"Tsjechisch\"},{\"code\":\"tr\",\"name\":\"Turks\"},{\"code\":\"vi\",\"name\":\"Vietnamees\"},{\"code\":\"cy\",\"name\":\"Wels\"},{\"code\":\"zu\",\"name\":\"Zoeloe\"},{\"code\":\"sv\",\"name\":\"Zweeds\"}],\"gd\":[{\"code\":\"am\",\"name\":\"Amtharais\"},{\"code\":\"ar\",\"name\":\"Arabais\"},{\"code\":\"az\",\"name\":\"Asarbaidenais\"},{\"code\":\"eu\",\"name\":\"Basgais\"},{\"code\":\"en\",\"name\":\"Beurla\"},{\"code\":\"vi\",\"name\":\"Bhiet-Namais\"},{\"code\":\"bg\",\"name\":\"Bulgarais\"},{\"code\":\"th\",\"name\":\"Cnan nan Tidh\"},{\"code\":\"ca\",\"name\":\"Catalanais\"},{\"code\":\"ko\",\"name\":\"Coiranais\"},{\"code\":\"hr\",\"name\":\"Crthaisis\"},{\"code\":\"cy\",\"name\":\"Cuimris\"},{\"code\":\"da\",\"name\":\"Danmhairgis\"},{\"code\":\"nl\",\"name\":\"Duitsis\"},{\"code\":\"he\",\"name\":\"Eabhra\"},{\"code\":\"it\",\"name\":\"Eadailtis\"},{\"code\":\"et\",\"name\":\"Eastoinis\"},{\"code\":\"fi\",\"name\":\"Fionnlannais\"},{\"code\":\"fr\",\"name\":\"Fraingis\"},{\"code\":\"ga\",\"name\":\"Gaeilge\"},{\"code\":\"gd\",\"name\":\"Gidhlig\"},{\"code\":\"gl\",\"name\":\"Gailsis\"},{\"code\":\"de\",\"name\":\"Gearmailtis\"},{\"code\":\"el\",\"name\":\"Grigis\"},{\"code\":\"id\",\"name\":\"Innd-Innsis\"},{\"code\":\"is\",\"name\":\"Innis-Tlis\"},{\"code\":\"lv\",\"name\":\"Laitbheis\"},{\"code\":\"lt\",\"name\":\"Liotuainis\"},{\"code\":\"mi\",\"name\":\"Mori\"},{\"code\":\"nb\",\"name\":\"Nirribhis\"},{\"code\":\"fa\",\"name\":\"Peirsis\"},{\"code\":\"pl\",\"name\":\"Plainnis\"},{\"code\":\"pt\",\"name\":\"Portagailis\"},{\"code\":\"ro\",\"name\":\"Rominis\"},{\"code\":\"ru\",\"name\":\"Ruisis\"},{\"code\":\"cs\",\"name\":\"Seacais\"},{\"code\":\"ja\",\"name\":\"Seapanais\"},{\"code\":\"sr\",\"name\":\"Sirbis\"},{\"code\":\"zh-tw\",\"name\":\"Sonais (seann-nsach)\"},{\"code\":\"zh-cn\",\"name\":\"Sonais (smplichte)\"},{\"code\":\"sk\",\"name\":\"Slbhacais\"},{\"code\":\"sl\",\"name\":\"Slbhainis\"},{\"code\":\"es\",\"name\":\"Spinntis\"},{\"code\":\"sv\",\"name\":\"Suainis\"},{\"code\":\"tr\",\"name\":\"Turcais\"},{\"code\":\"uk\",\"name\":\"Ucrinis\"},{\"code\":\"hu\",\"name\":\"Ungairis\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"nb\":[{\"code\":\"am\",\"name\":\"amharisk\"},{\"code\":\"ar\",\"name\":\"arabisk\"},{\"code\":\"az\",\"name\":\"aserbajdsjansk\"},{\"code\":\"eu\",\"name\":\"baskisk\"},{\"code\":\"bg\",\"name\":\"bulgarsk\"},{\"code\":\"da\",\"name\":\"dansk\"},{\"code\":\"en\",\"name\":\"engelsk\"},{\"code\":\"et\",\"name\":\"estisk\"},{\"code\":\"fa\",\"name\":\"farsi\"},{\"code\":\"fi\",\"name\":\"finsk\"},{\"code\":\"fr\",\"name\":\"fransk\"},{\"code\":\"gl\",\"name\":\"galisisk\"},{\"code\":\"el\",\"name\":\"gresk\"},{\"code\":\"he\",\"name\":\"hebraisk\"},{\"code\":\"id\",\"name\":\"indonesisk\"},{\"code\":\"ga\",\"name\":\"irsk\"},{\"code\":\"is\",\"name\":\"islandsk\"},{\"code\":\"it\",\"name\":\"italiensk\"},{\"code\":\"ja\",\"name\":\"japansk\"},{\"code\":\"ca\",\"name\":\"katalansk\"},{\"code\":\"zh-cn\",\"name\":\"kinesisk (forenklet)\"},{\"code\":\"zh-tw\",\"name\":\"kinesisk (tradisjonell)\"},{\"code\":\"ko\",\"name\":\"koreansk\"},{\"code\":\"hr\",\"name\":\"kroatisk\"},{\"code\":\"lv\",\"name\":\"latvisk\"},{\"code\":\"lt\",\"name\":\"litauisk\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"nederlandsk\"},{\"code\":\"nb\",\"name\":\"norsk\"},{\"code\":\"pl\",\"name\":\"polsk\"},{\"code\":\"pt\",\"name\":\"portugisisk\"},{\"code\":\"ro\",\"name\":\"rumensk\"},{\"code\":\"ru\",\"name\":\"russisk\"},{\"code\":\"sr\",\"name\":\"serbisk\"},{\"code\":\"gd\",\"name\":\"skotsk glisk\"},{\"code\":\"sk\",\"name\":\"slovakisk\"},{\"code\":\"sl\",\"name\":\"slovensk\"},{\"code\":\"es\",\"name\":\"spansk\"},{\"code\":\"sv\",\"name\":\"svensk\"},{\"code\":\"th\",\"name\":\"thai\"},{\"code\":\"cs\",\"name\":\"tsjekkisk\"},{\"code\":\"tr\",\"name\":\"tyrkisk\"},{\"code\":\"de\",\"name\":\"tysk\"},{\"code\":\"uk\",\"name\":\"ukrainsk\"},{\"code\":\"hu\",\"name\":\"ungarsk\"},{\"code\":\"vi\",\"name\":\"vietnamesisk\"},{\"code\":\"cy\",\"name\":\"walisisk\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"de\":[{\"code\":\"am\",\"name\":\"Amharisch\"},{\"code\":\"ar\",\"name\":\"Arabisch\"},{\"code\":\"az\",\"name\":\"Aserbaidschanisch\"},{\"code\":\"eu\",\"name\":\"Baskisch\"},{\"code\":\"bg\",\"name\":\"Bulgarisch\"},{\"code\":\"zh-tw\",\"name\":\"Chinesisch (traditionell)\"},{\"code\":\"zh-cn\",\"name\":\"Chinesisch (vereinfacht)\"},{\"code\":\"da\",\"name\":\"Dnisch\"},{\"code\":\"de\",\"name\":\"Deutsch\"},{\"code\":\"en\",\"name\":\"Englisch\"},{\"code\":\"et\",\"name\":\"Estnisch\"},{\"code\":\"fi\",\"name\":\"Finnisch\"},{\"code\":\"fr\",\"name\":\"Franzsisch\"},{\"code\":\"gl\",\"name\":\"Galizisch\"},{\"code\":\"el\",\"name\":\"Griechisch\"},{\"code\":\"he\",\"name\":\"Hebrisch\"},{\"code\":\"id\",\"name\":\"Indonesisch\"},{\"code\":\"ga\",\"name\":\"Irisch\"},{\"code\":\"is\",\"name\":\"Islndisch\"},{\"code\":\"it\",\"name\":\"Italienisch\"},{\"code\":\"ja\",\"name\":\"Japanisch\"},{\"code\":\"ca\",\"name\":\"Katalanisch\"},{\"code\":\"ko\",\"name\":\"Koreanisch\"},{\"code\":\"hr\",\"name\":\"Kroatisch\"},{\"code\":\"lv\",\"name\":\"Lettisch\"},{\"code\":\"lt\",\"name\":\"Litauisch\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Niederlndisch\"},{\"code\":\"nb\",\"name\":\"Norwegisch\"},{\"code\":\"fa\",\"name\":\"Persisch\"},{\"code\":\"pl\",\"name\":\"Polnisch\"},{\"code\":\"pt\",\"name\":\"Portugiesisch\"},{\"code\":\"ro\",\"name\":\"Rumnisch\"},{\"code\":\"ru\",\"name\":\"Russisch\"},{\"code\":\"gd\",\"name\":\"Schottisch-Glisch\"},{\"code\":\"sv\",\"name\":\"Schwedisch\"},{\"code\":\"sr\",\"name\":\"Serbisch\"},{\"code\":\"sk\",\"name\":\"Slowakisch\"},{\"code\":\"sl\",\"name\":\"Slowenisch\"},{\"code\":\"es\",\"name\":\"Spanisch\"},{\"code\":\"th\",\"name\":\"Thailndisch\"},{\"code\":\"cs\",\"name\":\"Tschechisch\"},{\"code\":\"tr\",\"name\":\"Trkisch\"},{\"code\":\"uk\",\"name\":\"Ukrainisch\"},{\"code\":\"hu\",\"name\":\"Ungarisch\"},{\"code\":\"vi\",\"name\":\"Vietnamesisch\"},{\"code\":\"cy\",\"name\":\"Walisisch\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"he\":[{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"'\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"}],\"sk\":[{\"code\":\"am\",\"name\":\"amharina\"},{\"code\":\"en\",\"name\":\"anglitina\"},{\"code\":\"ar\",\"name\":\"arabina\"},{\"code\":\"az\",\"name\":\"azerbajdanina\"},{\"code\":\"eu\",\"name\":\"baskitina\"},{\"code\":\"bg\",\"name\":\"bulharina\"},{\"code\":\"cs\",\"name\":\"etina\"},{\"code\":\"zh-tw\",\"name\":\"ntina (tradin)\"},{\"code\":\"zh-cn\",\"name\":\"ntina (zjednoduen)\"},{\"code\":\"da\",\"name\":\"dnina\"},{\"code\":\"et\",\"name\":\"estnina\"},{\"code\":\"fi\",\"name\":\"fnina\"},{\"code\":\"fr\",\"name\":\"francztina\"},{\"code\":\"gl\",\"name\":\"galcijina\"},{\"code\":\"el\",\"name\":\"grtina\"},{\"code\":\"he\",\"name\":\"hebrejina\"},{\"code\":\"nl\",\"name\":\"holandina\"},{\"code\":\"hr\",\"name\":\"chorvtina\"},{\"code\":\"id\",\"name\":\"indonztina\"},{\"code\":\"ga\",\"name\":\"rina\"},{\"code\":\"is\",\"name\":\"islandina\"},{\"code\":\"ja\",\"name\":\"japonina\"},{\"code\":\"ca\",\"name\":\"katalnina\"},{\"code\":\"ko\",\"name\":\"krejina\"},{\"code\":\"lt\",\"name\":\"litovina\"},{\"code\":\"lv\",\"name\":\"lotytina\"},{\"code\":\"hu\",\"name\":\"maarina\"},{\"code\":\"mi\",\"name\":\"maorijina\"},{\"code\":\"de\",\"name\":\"nemina\"},{\"code\":\"nb\",\"name\":\"nrina\"},{\"code\":\"fa\",\"name\":\"perztina\"},{\"code\":\"pl\",\"name\":\"potina\"},{\"code\":\"pt\",\"name\":\"portugalina\"},{\"code\":\"ro\",\"name\":\"rumunina\"},{\"code\":\"ru\",\"name\":\"rutina\"},{\"code\":\"sk\",\"name\":\"slovenina\"},{\"code\":\"sl\",\"name\":\"slovinina\"},{\"code\":\"sr\",\"name\":\"srbina\"},{\"code\":\"gd\",\"name\":\"ktska gaelina\"},{\"code\":\"es\",\"name\":\"panielina\"},{\"code\":\"sv\",\"name\":\"vdina\"},{\"code\":\"it\",\"name\":\"talianina\"},{\"code\":\"th\",\"name\":\"thajina\"},{\"code\":\"tr\",\"name\":\"turetina\"},{\"code\":\"uk\",\"name\":\"ukrajinina\"},{\"code\":\"vi\",\"name\":\"vietnamina\"},{\"code\":\"cy\",\"name\":\"waletina\"},{\"code\":\"zu\",\"name\":\"zulutina\"}],\"zu\":[{\"code\":\"am\",\"name\":\"isi-Amharic\"},{\"code\":\"ar\",\"name\":\"isi-Arabic\"},{\"code\":\"az\",\"name\":\"Isi-Azerbaijani\"},{\"code\":\"eu\",\"name\":\"isi-Basque\"},{\"code\":\"bg\",\"name\":\"isi-Bulgarian\"},{\"code\":\"ca\",\"name\":\"isi-Catalan\"},{\"code\":\"zh-cn\",\"name\":\"isi-Chinese (Simplified)\"},{\"code\":\"zh-tw\",\"name\":\"isi-Chinese (Traditional)\"},{\"code\":\"hr\",\"name\":\"isi-Croatian\"},{\"code\":\"cs\",\"name\":\"isi-Czech\"},{\"code\":\"da\",\"name\":\"isi-Danish\"},{\"code\":\"nl\",\"name\":\"isi-Dutch\"},{\"code\":\"en\",\"name\":\"isi-English\"},{\"code\":\"et\",\"name\":\"isi-Estonian\"},{\"code\":\"fi\",\"name\":\"isi-Finnish\"},{\"code\":\"fr\",\"name\":\"isi-French\"},{\"code\":\"gl\",\"name\":\"isi-Galician\"},{\"code\":\"de\",\"name\":\"isi-German\"},{\"code\":\"el\",\"name\":\"isi-Greek\"},{\"code\":\"hu\",\"name\":\"isi-Hangarian\"},{\"code\":\"he\",\"name\":\"isi-Hebrew\"},{\"code\":\"is\",\"name\":\"isi-Icelandic\"},{\"code\":\"id\",\"name\":\"isi-Indonesian\"},{\"code\":\"ga\",\"name\":\"isi-Irish\"},{\"code\":\"it\",\"name\":\"isi-Italian\"},{\"code\":\"ja\",\"name\":\"isi-Japanese\"},{\"code\":\"ko\",\"name\":\"isi-Korean\"},{\"code\":\"lv\",\"name\":\"isi-Latvian\"},{\"code\":\"lt\",\"name\":\"isi-Lithuanian\"},{\"code\":\"mi\",\"name\":\"isi-Maori\"},{\"code\":\"nb\",\"name\":\"isi-Norwegian\"},{\"code\":\"fa\",\"name\":\"isi-Persian\"},{\"code\":\"pl\",\"name\":\"isi-Polish\"},{\"code\":\"pt\",\"name\":\"isi-Portuguese\"},{\"code\":\"ro\",\"name\":\"isi-Romanian\"},{\"code\":\"ru\",\"name\":\"isi-Russian\"},{\"code\":\"gd\",\"name\":\"isi-Scots Gaelic\"},{\"code\":\"sr\",\"name\":\"isi-Serbian\"},{\"code\":\"sk\",\"name\":\"isi-Slovak\"},{\"code\":\"sl\",\"name\":\"isi-Slovenian\"},{\"code\":\"es\",\"name\":\"isi-Spanish\"},{\"code\":\"sv\",\"name\":\"isi-Swedish\"},{\"code\":\"th\",\"name\":\"isi-Thai\"},{\"code\":\"tr\",\"name\":\"isi-Turkish\"},{\"code\":\"uk\",\"name\":\"isi-Ukrainian\"},{\"code\":\"vi\",\"name\":\"isi-Vietnamese\"},{\"code\":\"cy\",\"name\":\"isi-Welsh\"},{\"code\":\"zu\",\"name\":\"isiZulu\"}],\"ru\":[{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" ()\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"}],\"pl\":[{\"code\":\"am\",\"name\":\"amharski\"},{\"code\":\"en\",\"name\":\"angielski\"},{\"code\":\"ar\",\"name\":\"arabski\"},{\"code\":\"az\",\"name\":\"azerski\"},{\"code\":\"eu\",\"name\":\"baskijski\"},{\"code\":\"bg\",\"name\":\"bugarski\"},{\"code\":\"zh-tw\",\"name\":\"chiski (tradycyjny)\"},{\"code\":\"zh-cn\",\"name\":\"chiski (uproszczony)\"},{\"code\":\"hr\",\"name\":\"chorwacki\"},{\"code\":\"cs\",\"name\":\"czeski\"},{\"code\":\"da\",\"name\":\"duski\"},{\"code\":\"et\",\"name\":\"estoski\"},{\"code\":\"fi\",\"name\":\"fiski\"},{\"code\":\"fr\",\"name\":\"francuski\"},{\"code\":\"gl\",\"name\":\"galicyjski\"},{\"code\":\"el\",\"name\":\"grecki\"},{\"code\":\"he\",\"name\":\"hebrajski\"},{\"code\":\"es\",\"name\":\"hiszpaski\"},{\"code\":\"id\",\"name\":\"indonezyjski\"},{\"code\":\"ga\",\"name\":\"irlandzki\"},{\"code\":\"is\",\"name\":\"islandzki\"},{\"code\":\"ja\",\"name\":\"japoski\"},{\"code\":\"ca\",\"name\":\"kataloski\"},{\"code\":\"ko\",\"name\":\"koreaski\"},{\"code\":\"lt\",\"name\":\"litewski\"},{\"code\":\"lv\",\"name\":\"otewski\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"niderlandzki\"},{\"code\":\"de\",\"name\":\"niemiecki\"},{\"code\":\"nb\",\"name\":\"norweski\"},{\"code\":\"fa\",\"name\":\"perski\"},{\"code\":\"pl\",\"name\":\"polski\"},{\"code\":\"pt\",\"name\":\"portugalski\"},{\"code\":\"ru\",\"name\":\"rosyjski\"},{\"code\":\"ro\",\"name\":\"rumuski\"},{\"code\":\"sr\",\"name\":\"serbski\"},{\"code\":\"sk\",\"name\":\"sowacki\"},{\"code\":\"sl\",\"name\":\"soweski\"},{\"code\":\"gd\",\"name\":\"szkocki gaelicki\"},{\"code\":\"sv\",\"name\":\"szwedzki\"},{\"code\":\"th\",\"name\":\"tajski\"},{\"code\":\"tr\",\"name\":\"turecki\"},{\"code\":\"uk\",\"name\":\"ukraiski\"},{\"code\":\"cy\",\"name\":\"walijski\"},{\"code\":\"hu\",\"name\":\"wgierski\"},{\"code\":\"vi\",\"name\":\"wietnamski\"},{\"code\":\"it\",\"name\":\"woski\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"am\":[{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\"   ()\"},{\"code\":\"zh-tw\",\"name\":\"  ()\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"}],\"az\":[{\"code\":\"de\",\"name\":\"Alman\"},{\"code\":\"am\",\"name\":\"Amarikc\"},{\"code\":\"az\",\"name\":\"Azrbaycan dili\"},{\"code\":\"eu\",\"name\":\"Bask\"},{\"code\":\"bg\",\"name\":\"Bolqar\"},{\"code\":\"cs\",\"name\":\"ex\"},{\"code\":\"zh-tw\",\"name\":\"in (n'nvi)\"},{\"code\":\"zh-cn\",\"name\":\"in (Sadldirilmi)\"},{\"code\":\"da\",\"name\":\"Danimarka\"},{\"code\":\"et\",\"name\":\"Eston\"},{\"code\":\"ar\",\"name\":\"rb\"},{\"code\":\"fa\",\"name\":\"Fars Dili\"},{\"code\":\"fi\",\"name\":\"Fin\"},{\"code\":\"fr\",\"name\":\"Fransz\"},{\"code\":\"nl\",\"name\":\"Holland\"},{\"code\":\"hr\",\"name\":\"Xorvat\"},{\"code\":\"es\",\"name\":\"Ispan\"},{\"code\":\"id\",\"name\":\"ndoneziya\"},{\"code\":\"en\",\"name\":\"ngilis\"},{\"code\":\"ga\",\"name\":\"rland\"},{\"code\":\"is\",\"name\":\"sland\"},{\"code\":\"sv\",\"name\":\"sve\"},{\"code\":\"it\",\"name\":\"talyan\"},{\"code\":\"he\",\"name\":\"vrit\"},{\"code\":\"ca\",\"name\":\"Katalan\"},{\"code\":\"ko\",\"name\":\"Koreya\"},{\"code\":\"gl\",\"name\":\"Qalisian\"},{\"code\":\"lv\",\"name\":\"Lat\"},{\"code\":\"lt\",\"name\":\"Litva\"},{\"code\":\"hu\",\"name\":\"Macar\"},{\"code\":\"mi\",\"name\":\"Maoric\"},{\"code\":\"nb\",\"name\":\"Norve\"},{\"code\":\"pl\",\"name\":\"Polyak\"},{\"code\":\"pt\",\"name\":\"Portuqal\"},{\"code\":\"ro\",\"name\":\"Rumn\"},{\"code\":\"ru\",\"name\":\"Rus\"},{\"code\":\"sr\",\"name\":\"Serb\"},{\"code\":\"sk\",\"name\":\"Slovak\"},{\"code\":\"sl\",\"name\":\"Sloven\"},{\"code\":\"gd\",\"name\":\"otland (Kelt)\"},{\"code\":\"th\",\"name\":\"Tayca\"},{\"code\":\"tr\",\"name\":\"Trk\"},{\"code\":\"cy\",\"name\":\"Uels\"},{\"code\":\"uk\",\"name\":\"Ukrayna\"},{\"code\":\"vi\",\"name\":\"Vyetnam\"},{\"code\":\"ja\",\"name\":\"Yapon\"},{\"code\":\"el\",\"name\":\"Yunan\"},{\"code\":\"zu\",\"name\":\"Zulu dili\"}],\"hr\":[{\"code\":\"am\",\"name\":\"amharik\"},{\"code\":\"ar\",\"name\":\"arapski\"},{\"code\":\"az\",\"name\":\"azerbajdanski\"},{\"code\":\"eu\",\"name\":\"baskijski\"},{\"code\":\"bg\",\"name\":\"bugarski\"},{\"code\":\"cs\",\"name\":\"eki\"},{\"code\":\"da\",\"name\":\"danski\"},{\"code\":\"en\",\"name\":\"engleski\"},{\"code\":\"et\",\"name\":\"estonski\"},{\"code\":\"fi\",\"name\":\"finski\"},{\"code\":\"fr\",\"name\":\"francuski\"},{\"code\":\"gl\",\"name\":\"galski\"},{\"code\":\"el\",\"name\":\"grki\"},{\"code\":\"he\",\"name\":\"hebrejski\"},{\"code\":\"hr\",\"name\":\"hrvatski\"},{\"code\":\"id\",\"name\":\"indonezijski\"},{\"code\":\"ga\",\"name\":\"irski\"},{\"code\":\"is\",\"name\":\"islandski\"},{\"code\":\"ja\",\"name\":\"japanski\"},{\"code\":\"ca\",\"name\":\"katalonski\"},{\"code\":\"zh-cn\",\"name\":\"kineski (pojednost.)\"},{\"code\":\"zh-tw\",\"name\":\"kineski (tradicionalni)\"},{\"code\":\"ko\",\"name\":\"korejski\"},{\"code\":\"lv\",\"name\":\"latvijski/letonski\"},{\"code\":\"lt\",\"name\":\"litvanski\"},{\"code\":\"hu\",\"name\":\"maarski\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"nizozemski\"},{\"code\":\"nb\",\"name\":\"norveki\"},{\"code\":\"de\",\"name\":\"njemaki\"},{\"code\":\"fa\",\"name\":\"perzijski\"},{\"code\":\"pl\",\"name\":\"poljski\"},{\"code\":\"pt\",\"name\":\"portugalski\"},{\"code\":\"ro\",\"name\":\"rumunjski\"},{\"code\":\"ru\",\"name\":\"ruski\"},{\"code\":\"sk\",\"name\":\"slovaki\"},{\"code\":\"sl\",\"name\":\"slovenski\"},{\"code\":\"sr\",\"name\":\"srpski\"},{\"code\":\"gd\",\"name\":\"kotski keltski\"},{\"code\":\"es\",\"name\":\"panjolski\"},{\"code\":\"sv\",\"name\":\"vedski\"},{\"code\":\"th\",\"name\":\"tajlandski\"},{\"code\":\"it\",\"name\":\"talijanski\"},{\"code\":\"tr\",\"name\":\"turski\"},{\"code\":\"uk\",\"name\":\"ukrajinski\"},{\"code\":\"cy\",\"name\":\"velki\"},{\"code\":\"vi\",\"name\":\"vijetnamski\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"fa\":[{\"code\":\"az\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\" \"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"}],\"mi\":[{\"code\":\"az\",\"name\":\"Ahepaitani\"},{\"code\":\"ga\",\"name\":\"Airihi\"},{\"code\":\"am\",\"name\":\"Amariki\"},{\"code\":\"ar\",\"name\":\"Arapi\"},{\"code\":\"et\",\"name\":\"Etnia\"},{\"code\":\"zh-tw\",\"name\":\"Haina (Onamata)\"},{\"code\":\"zh-cn\",\"name\":\"Hainamana (Kua whakammtia)\"},{\"code\":\"hu\",\"name\":\"Hanekeria\"},{\"code\":\"ja\",\"name\":\"Hapanihi\"},{\"code\":\"sr\",\"name\":\"Herepia\"},{\"code\":\"fi\",\"name\":\"Hinerangi\"},{\"code\":\"he\",\"name\":\"Hiperu\"},{\"code\":\"sk\",\"name\":\"Horowkia\"},{\"code\":\"sl\",\"name\":\"Horowinia\"},{\"code\":\"sv\",\"name\":\"Huitene\"},{\"code\":\"zu\",\"name\":\"Huru\"},{\"code\":\"en\",\"name\":\"Ingarihi\"},{\"code\":\"id\",\"name\":\"Initonhia\"},{\"code\":\"it\",\"name\":\"Itriana\"},{\"code\":\"gl\",\"name\":\"Karihia\"},{\"code\":\"ca\",\"name\":\"Katarna\"},{\"code\":\"el\",\"name\":\"Kiriki\"},{\"code\":\"ko\",\"name\":\"Kreana\"},{\"code\":\"hr\",\"name\":\"Korotiana\"},{\"code\":\"tr\",\"name\":\"Korukoru\"},{\"code\":\"mi\",\"name\":\"Mori\"},{\"code\":\"nb\",\"name\":\"Nwei\"},{\"code\":\"eu\",\"name\":\"Pkihi\"},{\"code\":\"es\",\"name\":\"Pniora\"},{\"code\":\"fa\",\"name\":\"Perhia\"},{\"code\":\"pl\",\"name\":\"Prana\"},{\"code\":\"pt\",\"name\":\"Potukhi\"},{\"code\":\"bg\",\"name\":\"Purukriana\"},{\"code\":\"lv\",\"name\":\"Rwhiana\"},{\"code\":\"lt\",\"name\":\"Ritunia\"},{\"code\":\"ro\",\"name\":\"Romnia\"},{\"code\":\"ru\",\"name\":\"Rhia\"},{\"code\":\"th\",\"name\":\"Tai\"},{\"code\":\"nl\",\"name\":\"Tati\"},{\"code\":\"da\",\"name\":\"Tenemka\"},{\"code\":\"de\",\"name\":\"Tiamana\"},{\"code\":\"cs\",\"name\":\"Tieke\"},{\"code\":\"is\",\"name\":\"Tiorangi\"},{\"code\":\"gd\",\"name\":\"Tuauri Kotarangi\"},{\"code\":\"uk\",\"name\":\"kareiana\"},{\"code\":\"cy\",\"name\":\"Wra\"},{\"code\":\"vi\",\"name\":\"Whitinmu\"},{\"code\":\"fr\",\"name\":\"Ww\"}],\"el\":[{\"code\":\"en\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"}],\"is\":[{\"code\":\"am\",\"name\":\"amharsku\"},{\"code\":\"ar\",\"name\":\"arabska\"},{\"code\":\"az\",\"name\":\"aserska\"},{\"code\":\"eu\",\"name\":\"baskneska\"},{\"code\":\"bg\",\"name\":\"blgarska\"},{\"code\":\"da\",\"name\":\"danska\"},{\"code\":\"et\",\"name\":\"eistneska\"},{\"code\":\"en\",\"name\":\"enska\"},{\"code\":\"fi\",\"name\":\"finnska\"},{\"code\":\"fr\",\"name\":\"franska\"},{\"code\":\"gl\",\"name\":\"galisska\"},{\"code\":\"el\",\"name\":\"grska\"},{\"code\":\"he\",\"name\":\"hebreska\"},{\"code\":\"nl\",\"name\":\"hollenska\"},{\"code\":\"id\",\"name\":\"indnesska\"},{\"code\":\"ga\",\"name\":\"rska\"},{\"code\":\"is\",\"name\":\"slenska\"},{\"code\":\"it\",\"name\":\"talska\"},{\"code\":\"ja\",\"name\":\"japanska\"},{\"code\":\"ca\",\"name\":\"katalnska\"},{\"code\":\"zh-cn\",\"name\":\"knverska (einfldu)\"},{\"code\":\"zh-tw\",\"name\":\"knverska (hefbundin)\"},{\"code\":\"ko\",\"name\":\"kreska\"},{\"code\":\"hr\",\"name\":\"kratska\"},{\"code\":\"lv\",\"name\":\"lettneska\"},{\"code\":\"lt\",\"name\":\"lithska\"},{\"code\":\"mi\",\"name\":\"maorska\"},{\"code\":\"nb\",\"name\":\"norska\"},{\"code\":\"fa\",\"name\":\"persneska\"},{\"code\":\"pt\",\"name\":\"portgalska\"},{\"code\":\"pl\",\"name\":\"plska\"},{\"code\":\"ro\",\"name\":\"rmenska\"},{\"code\":\"ru\",\"name\":\"rssneska\"},{\"code\":\"sr\",\"name\":\"serbneska\"},{\"code\":\"gd\",\"name\":\"skosk-gelska\"},{\"code\":\"sk\",\"name\":\"slvakska\"},{\"code\":\"sl\",\"name\":\"slvenska\"},{\"code\":\"es\",\"name\":\"spnska\"},{\"code\":\"zu\",\"name\":\"sl\"},{\"code\":\"sv\",\"name\":\"snska\"},{\"code\":\"th\",\"name\":\"talenska\"},{\"code\":\"cs\",\"name\":\"tkkneska\"},{\"code\":\"tr\",\"name\":\"tyrkneska\"},{\"code\":\"hu\",\"name\":\"ungverska\"},{\"code\":\"uk\",\"name\":\"kranska\"},{\"code\":\"cy\",\"name\":\"velska\"},{\"code\":\"vi\",\"name\":\"vetnamska\"},{\"code\":\"de\",\"name\":\"ska\"}],\"fi\":[{\"code\":\"am\",\"name\":\"amhara\"},{\"code\":\"ar\",\"name\":\"arabia\"},{\"code\":\"az\",\"name\":\"azeri\"},{\"code\":\"eu\",\"name\":\"baski\"},{\"code\":\"bg\",\"name\":\"bulgaria\"},{\"code\":\"en\",\"name\":\"englanti\"},{\"code\":\"es\",\"name\":\"espanja\"},{\"code\":\"gl\",\"name\":\"galicia\"},{\"code\":\"he\",\"name\":\"heprea\"},{\"code\":\"nl\",\"name\":\"hollanti\"},{\"code\":\"ga\",\"name\":\"iiri\"},{\"code\":\"id\",\"name\":\"indonesia\"},{\"code\":\"is\",\"name\":\"islanti\"},{\"code\":\"it\",\"name\":\"italia\"},{\"code\":\"ja\",\"name\":\"japani\"},{\"code\":\"ca\",\"name\":\"katalaani\"},{\"code\":\"zh-tw\",\"name\":\"kiina (perinteinen)\"},{\"code\":\"zh-cn\",\"name\":\"kiina (yksinkert.)\"},{\"code\":\"ko\",\"name\":\"korea\"},{\"code\":\"el\",\"name\":\"kreikka\"},{\"code\":\"hr\",\"name\":\"kroatia\"},{\"code\":\"cy\",\"name\":\"kymri\"},{\"code\":\"lv\",\"name\":\"latvia\"},{\"code\":\"lt\",\"name\":\"liettua\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nb\",\"name\":\"norja\"},{\"code\":\"fa\",\"name\":\"persia\"},{\"code\":\"pt\",\"name\":\"portugali\"},{\"code\":\"pl\",\"name\":\"puola\"},{\"code\":\"fr\",\"name\":\"ranska\"},{\"code\":\"ro\",\"name\":\"romania\"},{\"code\":\"sv\",\"name\":\"ruotsi\"},{\"code\":\"de\",\"name\":\"saksa\"},{\"code\":\"sr\",\"name\":\"serbia\"},{\"code\":\"gd\",\"name\":\"skottigaeli\"},{\"code\":\"sk\",\"name\":\"slovakia\"},{\"code\":\"sl\",\"name\":\"slovenia\"},{\"code\":\"fi\",\"name\":\"suomi\"},{\"code\":\"da\",\"name\":\"tanska\"},{\"code\":\"th\",\"name\":\"thai\"},{\"code\":\"cs\",\"name\":\"tsekki\"},{\"code\":\"tr\",\"name\":\"turkki\"},{\"code\":\"uk\",\"name\":\"ukraina\"},{\"code\":\"hu\",\"name\":\"unkari\"},{\"code\":\"ru\",\"name\":\"venj\"},{\"code\":\"vi\",\"name\":\"vietnam\"},{\"code\":\"et\",\"name\":\"viro\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"eu\":[{\"code\":\"de\",\"name\":\"alemana\"},{\"code\":\"am\",\"name\":\"amharera\"},{\"code\":\"ar\",\"name\":\"arabiera\"},{\"code\":\"az\",\"name\":\"azerbaijanera\"},{\"code\":\"bg\",\"name\":\"bulgariera\"},{\"code\":\"da\",\"name\":\"daniera\"},{\"code\":\"ro\",\"name\":\"errumaniera\"},{\"code\":\"ru\",\"name\":\"errusiera\"},{\"code\":\"gd\",\"name\":\"Eskoziako gaelera\"},{\"code\":\"sk\",\"name\":\"eslovakiera\"},{\"code\":\"sl\",\"name\":\"esloveniera\"},{\"code\":\"et\",\"name\":\"estoniera\"},{\"code\":\"eu\",\"name\":\"euskara\"},{\"code\":\"fr\",\"name\":\"frantsesa\"},{\"code\":\"cy\",\"name\":\"gaelera\"},{\"code\":\"gl\",\"name\":\"galiziera\"},{\"code\":\"es\",\"name\":\"gaztelania\"},{\"code\":\"el\",\"name\":\"greziera\"},{\"code\":\"he\",\"name\":\"hebreera\"},{\"code\":\"hu\",\"name\":\"hungariera\"},{\"code\":\"id\",\"name\":\"indonesiera\"},{\"code\":\"en\",\"name\":\"ingelesa\"},{\"code\":\"ga\",\"name\":\"irlandera\"},{\"code\":\"is\",\"name\":\"islandiera\"},{\"code\":\"it\",\"name\":\"italiera\"},{\"code\":\"ja\",\"name\":\"japoniera\"},{\"code\":\"ca\",\"name\":\"katalana\"},{\"code\":\"ko\",\"name\":\"koreera\"},{\"code\":\"hr\",\"name\":\"kroaziera\"},{\"code\":\"lv\",\"name\":\"letoniera\"},{\"code\":\"lt\",\"name\":\"lituaniera\"},{\"code\":\"mi\",\"name\":\"maoriera\"},{\"code\":\"nl\",\"name\":\"nederlandera\"},{\"code\":\"nb\",\"name\":\"norvegiera\"},{\"code\":\"fa\",\"name\":\"persiera\"},{\"code\":\"pl\",\"name\":\"poloniera\"},{\"code\":\"pt\",\"name\":\"portugesa\"},{\"code\":\"sr\",\"name\":\"serbiera\"},{\"code\":\"sv\",\"name\":\"suediera\"},{\"code\":\"fi\",\"name\":\"suomiera\"},{\"code\":\"th\",\"name\":\"thaiera\"},{\"code\":\"tr\",\"name\":\"turkiera\"},{\"code\":\"cs\",\"name\":\"txekiera\"},{\"code\":\"zh-cn\",\"name\":\"txinera (soildua)\"},{\"code\":\"zh-tw\",\"name\":\"txinera (tradizionala)\"},{\"code\":\"uk\",\"name\":\"ukrainera\"},{\"code\":\"vi\",\"name\":\"vietnamera\"},{\"code\":\"zu\",\"name\":\"zuluera\"}],\"ca\":[{\"code\":\"de\",\"name\":\"alemany\"},{\"code\":\"am\",\"name\":\"amhric\"},{\"code\":\"en\",\"name\":\"angls\"},{\"code\":\"ar\",\"name\":\"rab\"},{\"code\":\"az\",\"name\":\"zeri\"},{\"code\":\"eu\",\"name\":\"basc\"},{\"code\":\"bg\",\"name\":\"blgar\"},{\"code\":\"es\",\"name\":\"castell\"},{\"code\":\"ca\",\"name\":\"catal\"},{\"code\":\"ko\",\"name\":\"core\"},{\"code\":\"hr\",\"name\":\"croat\"},{\"code\":\"da\",\"name\":\"dans\"},{\"code\":\"sk\",\"name\":\"eslovac\"},{\"code\":\"sl\",\"name\":\"eslov\"},{\"code\":\"et\",\"name\":\"estoni\"},{\"code\":\"fi\",\"name\":\"fins\"},{\"code\":\"fr\",\"name\":\"francs\"},{\"code\":\"gd\",\"name\":\"galic escocs\"},{\"code\":\"gl\",\"name\":\"gallec\"},{\"code\":\"cy\",\"name\":\"galls\"},{\"code\":\"el\",\"name\":\"grec\"},{\"code\":\"he\",\"name\":\"hebreu\"},{\"code\":\"hu\",\"name\":\"hongars\"},{\"code\":\"id\",\"name\":\"indonesi\"},{\"code\":\"ga\",\"name\":\"irlands\"},{\"code\":\"is\",\"name\":\"islands\"},{\"code\":\"it\",\"name\":\"itali\"},{\"code\":\"ja\",\"name\":\"japons\"},{\"code\":\"lv\",\"name\":\"let\"},{\"code\":\"lt\",\"name\":\"litu\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"neerlands\"},{\"code\":\"nb\",\"name\":\"noruec\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polons\"},{\"code\":\"pt\",\"name\":\"portugus\"},{\"code\":\"ro\",\"name\":\"romans\"},{\"code\":\"ru\",\"name\":\"rus\"},{\"code\":\"sr\",\"name\":\"serbi\"},{\"code\":\"sv\",\"name\":\"suec\"},{\"code\":\"th\",\"name\":\"tai\"},{\"code\":\"tr\",\"name\":\"turc\"},{\"code\":\"cs\",\"name\":\"txec\"},{\"code\":\"uk\",\"name\":\"ucrans\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"zh-cn\",\"name\":\"xins (simplificat)\"},{\"code\":\"zh-tw\",\"name\":\"xins (tradicional)\"},{\"code\":\"zu\",\"name\":\"zul\"}],\"lv\":[{\"code\":\"am\",\"name\":\"amharu\"},{\"code\":\"en\",\"name\":\"angu\"},{\"code\":\"ar\",\"name\":\"arbu\"},{\"code\":\"az\",\"name\":\"azerbaidu\"},{\"code\":\"eu\",\"name\":\"basku\"},{\"code\":\"bg\",\"name\":\"bulgru\"},{\"code\":\"cs\",\"name\":\"ehu\"},{\"code\":\"da\",\"name\":\"du\"},{\"code\":\"he\",\"name\":\"ebreju (ivrits)\"},{\"code\":\"fr\",\"name\":\"franu\"},{\"code\":\"gl\",\"name\":\"galisieu\"},{\"code\":\"el\",\"name\":\"grieu\"},{\"code\":\"nl\",\"name\":\"holandieu\"},{\"code\":\"hr\",\"name\":\"horvtu\"},{\"code\":\"et\",\"name\":\"igauu\"},{\"code\":\"id\",\"name\":\"indonzieu\"},{\"code\":\"ga\",\"name\":\"ru\"},{\"code\":\"is\",\"name\":\"slandieu\"},{\"code\":\"it\",\"name\":\"itu\"},{\"code\":\"ja\",\"name\":\"japu\"},{\"code\":\"ca\",\"name\":\"katalu\"},{\"code\":\"ko\",\"name\":\"korejieu\"},{\"code\":\"ru\",\"name\":\"krievu\"},{\"code\":\"zh-tw\",\"name\":\"nieu (tradicionl)\"},{\"code\":\"zh-cn\",\"name\":\"nieu (vienkrot)\"},{\"code\":\"lv\",\"name\":\"latvieu\"},{\"code\":\"lt\",\"name\":\"lietuvieu\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nb\",\"name\":\"norvu\"},{\"code\":\"fa\",\"name\":\"persieu\"},{\"code\":\"pl\",\"name\":\"pou\"},{\"code\":\"pt\",\"name\":\"portugu\"},{\"code\":\"ro\",\"name\":\"rumu\"},{\"code\":\"sr\",\"name\":\"serbu\"},{\"code\":\"gd\",\"name\":\"skotu glu\"},{\"code\":\"sk\",\"name\":\"slovku\"},{\"code\":\"sl\",\"name\":\"slovu\"},{\"code\":\"fi\",\"name\":\"somu\"},{\"code\":\"es\",\"name\":\"spu\"},{\"code\":\"th\",\"name\":\"taju\"},{\"code\":\"tr\",\"name\":\"turku\"},{\"code\":\"uk\",\"name\":\"ukraiu\"},{\"code\":\"hu\",\"name\":\"ungru\"},{\"code\":\"de\",\"name\":\"vcu\"},{\"code\":\"cy\",\"name\":\"velsieu\"},{\"code\":\"vi\",\"name\":\"vjetnamieu\"},{\"code\":\"zu\",\"name\":\"zulu\"},{\"code\":\"sv\",\"name\":\"zviedru\"}],\"id\":[{\"code\":\"am\",\"name\":\"Amhara\"},{\"code\":\"ar\",\"name\":\"Arab\"},{\"code\":\"az\",\"name\":\"Azerbaijan\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"nl\",\"name\":\"Belanda\"},{\"code\":\"bg\",\"name\":\"Bulgaria\"},{\"code\":\"cs\",\"name\":\"Cek\"},{\"code\":\"zh-cn\",\"name\":\"China (Aks. Sederhana)\"},{\"code\":\"zh-tw\",\"name\":\"China (Aks. Tradisional)\"},{\"code\":\"da\",\"name\":\"Denmark\"},{\"code\":\"et\",\"name\":\"Estonia\"},{\"code\":\"fa\",\"name\":\"Farsi\"},{\"code\":\"fi\",\"name\":\"Finlandia\"},{\"code\":\"ga\",\"name\":\"Gaelig\"},{\"code\":\"gd\",\"name\":\"Gaelik Skotlandia\"},{\"code\":\"gl\",\"name\":\"Galisia\"},{\"code\":\"he\",\"name\":\"Ibrani\"},{\"code\":\"id\",\"name\":\"Indonesia\"},{\"code\":\"en\",\"name\":\"Inggris\"},{\"code\":\"is\",\"name\":\"Islan\"},{\"code\":\"it\",\"name\":\"Italia\"},{\"code\":\"ja\",\"name\":\"Jepang\"},{\"code\":\"de\",\"name\":\"Jerman\"},{\"code\":\"ca\",\"name\":\"Katala\"},{\"code\":\"ko\",\"name\":\"Korea\"},{\"code\":\"hr\",\"name\":\"Kroat\"},{\"code\":\"lv\",\"name\":\"Latvia\"},{\"code\":\"lt\",\"name\":\"Lituania\"},{\"code\":\"hu\",\"name\":\"Magyar\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norsk\"},{\"code\":\"pl\",\"name\":\"Polandia\"},{\"code\":\"pt\",\"name\":\"Portugis\"},{\"code\":\"fr\",\"name\":\"Prancis\"},{\"code\":\"ro\",\"name\":\"Rumania\"},{\"code\":\"ru\",\"name\":\"Rusia\"},{\"code\":\"sr\",\"name\":\"Serb\"},{\"code\":\"sk\",\"name\":\"Slovakia\"},{\"code\":\"sl\",\"name\":\"Slovenia\"},{\"code\":\"es\",\"name\":\"Spanyol\"},{\"code\":\"sv\",\"name\":\"Swensk\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"tr\",\"name\":\"Turki\"},{\"code\":\"uk\",\"name\":\"Ukraina\"},{\"code\":\"vi\",\"name\":\"Vietnam\"},{\"code\":\"cy\",\"name\":\"Wales\"},{\"code\":\"el\",\"name\":\"Yunani\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"es\":[{\"code\":\"de\",\"name\":\"alemn\"},{\"code\":\"am\",\"name\":\"amhrico\"},{\"code\":\"ar\",\"name\":\"rabe\"},{\"code\":\"az\",\"name\":\"azer\"},{\"code\":\"bg\",\"name\":\"blgaro\"},{\"code\":\"ca\",\"name\":\"cataln\"},{\"code\":\"cs\",\"name\":\"checo\"},{\"code\":\"zh-cn\",\"name\":\"chino (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"chino (tradicional)\"},{\"code\":\"ko\",\"name\":\"coreano\"},{\"code\":\"hr\",\"name\":\"croata\"},{\"code\":\"da\",\"name\":\"dans\"},{\"code\":\"sk\",\"name\":\"eslovaco\"},{\"code\":\"sl\",\"name\":\"esloveno\"},{\"code\":\"es\",\"name\":\"espaol\"},{\"code\":\"et\",\"name\":\"estonio\"},{\"code\":\"eu\",\"name\":\"euskera\"},{\"code\":\"fi\",\"name\":\"finlands\"},{\"code\":\"fr\",\"name\":\"francs\"},{\"code\":\"gd\",\"name\":\"galico escocs\"},{\"code\":\"cy\",\"name\":\"gals\"},{\"code\":\"gl\",\"name\":\"gallego\"},{\"code\":\"el\",\"name\":\"griego\"},{\"code\":\"he\",\"name\":\"hebreo\"},{\"code\":\"hu\",\"name\":\"hngaro\"},{\"code\":\"id\",\"name\":\"indonesio\"},{\"code\":\"en\",\"name\":\"ingls\"},{\"code\":\"ga\",\"name\":\"irlands\"},{\"code\":\"is\",\"name\":\"islands\"},{\"code\":\"it\",\"name\":\"italiano\"},{\"code\":\"ja\",\"name\":\"japons\"},{\"code\":\"lv\",\"name\":\"letn\"},{\"code\":\"lt\",\"name\":\"lituano\"},{\"code\":\"mi\",\"name\":\"maor\"},{\"code\":\"nl\",\"name\":\"neerlands\"},{\"code\":\"nb\",\"name\":\"noruego\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polaco\"},{\"code\":\"pt\",\"name\":\"portugus\"},{\"code\":\"ro\",\"name\":\"rumano\"},{\"code\":\"ru\",\"name\":\"ruso\"},{\"code\":\"sr\",\"name\":\"serbio\"},{\"code\":\"sv\",\"name\":\"sueco\"},{\"code\":\"th\",\"name\":\"tailands\"},{\"code\":\"tr\",\"name\":\"turco\"},{\"code\":\"uk\",\"name\":\"ucraniano\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"zu\",\"name\":\"zul\"}],\"es-419\":[{\"code\":\"de\",\"name\":\"alemn\"},{\"code\":\"am\",\"name\":\"amhrico\"},{\"code\":\"ar\",\"name\":\"rabe\"},{\"code\":\"az\",\"name\":\"azer\"},{\"code\":\"bg\",\"name\":\"blgaro\"},{\"code\":\"ca\",\"name\":\"cataln\"},{\"code\":\"cs\",\"name\":\"checo\"},{\"code\":\"zh-cn\",\"name\":\"chino (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"chino (tradicional)\"},{\"code\":\"ko\",\"name\":\"coreano\"},{\"code\":\"hr\",\"name\":\"croata\"},{\"code\":\"da\",\"name\":\"dans\"},{\"code\":\"sk\",\"name\":\"eslovaco\"},{\"code\":\"sl\",\"name\":\"esloveno\"},{\"code\":\"es\",\"name\":\"espaol\"},{\"code\":\"et\",\"name\":\"estonio\"},{\"code\":\"eu\",\"name\":\"euskera\"},{\"code\":\"fi\",\"name\":\"finlands\"},{\"code\":\"fr\",\"name\":\"francs\"},{\"code\":\"gd\",\"name\":\"galico escocs\"},{\"code\":\"cy\",\"name\":\"gals\"},{\"code\":\"gl\",\"name\":\"gallego\"},{\"code\":\"el\",\"name\":\"griego\"},{\"code\":\"he\",\"name\":\"hebreo\"},{\"code\":\"hu\",\"name\":\"hngaro\"},{\"code\":\"id\",\"name\":\"indonesio\"},{\"code\":\"en\",\"name\":\"ingls\"},{\"code\":\"ga\",\"name\":\"irlands\"},{\"code\":\"is\",\"name\":\"islands\"},{\"code\":\"it\",\"name\":\"italiano\"},{\"code\":\"ja\",\"name\":\"japons\"},{\"code\":\"lv\",\"name\":\"letn\"},{\"code\":\"lt\",\"name\":\"lituano\"},{\"code\":\"mi\",\"name\":\"maor\"},{\"code\":\"nl\",\"name\":\"neerlands\"},{\"code\":\"nb\",\"name\":\"noruego\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polaco\"},{\"code\":\"pt\",\"name\":\"portugus\"},{\"code\":\"ro\",\"name\":\"rumano\"},{\"code\":\"ru\",\"name\":\"ruso\"},{\"code\":\"sr\",\"name\":\"serbio\"},{\"code\":\"sv\",\"name\":\"sueco\"},{\"code\":\"th\",\"name\":\"tailands\"},{\"code\":\"tr\",\"name\":\"turco\"},{\"code\":\"uk\",\"name\":\"ucraniano\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"zu\",\"name\":\"zul\"}],\"et\":[{\"code\":\"am\",\"name\":\"amhaari\"},{\"code\":\"ar\",\"name\":\"araabia\"},{\"code\":\"az\",\"name\":\"aserbaidaani\"},{\"code\":\"eu\",\"name\":\"baski\"},{\"code\":\"bg\",\"name\":\"bulgaaria\"},{\"code\":\"et\",\"name\":\"eesti\"},{\"code\":\"gl\",\"name\":\"galeegi\"},{\"code\":\"he\",\"name\":\"heebrea\"},{\"code\":\"es\",\"name\":\"hispaania\"},{\"code\":\"nl\",\"name\":\"hollandi\"},{\"code\":\"hr\",\"name\":\"horvaadi\"},{\"code\":\"ga\",\"name\":\"iiri\"},{\"code\":\"id\",\"name\":\"indoneesia\"},{\"code\":\"en\",\"name\":\"inglise\"},{\"code\":\"is\",\"name\":\"islandi\"},{\"code\":\"it\",\"name\":\"itaalia\"},{\"code\":\"ja\",\"name\":\"jaapani\"},{\"code\":\"ca\",\"name\":\"katalaani\"},{\"code\":\"ko\",\"name\":\"korea\"},{\"code\":\"el\",\"name\":\"kreeka\"},{\"code\":\"lt\",\"name\":\"leedu\"},{\"code\":\"zh-cn\",\"name\":\"lihtsustatud hiina\"},{\"code\":\"lv\",\"name\":\"lti\"},{\"code\":\"mi\",\"name\":\"maoori\"},{\"code\":\"nb\",\"name\":\"norra\"},{\"code\":\"pl\",\"name\":\"poola\"},{\"code\":\"pt\",\"name\":\"portugali\"},{\"code\":\"fr\",\"name\":\"prantsuse\"},{\"code\":\"fa\",\"name\":\"prsia\"},{\"code\":\"sv\",\"name\":\"rootsi\"},{\"code\":\"ro\",\"name\":\"rumeenia\"},{\"code\":\"de\",\"name\":\"saksa\"},{\"code\":\"sr\",\"name\":\"serbia\"},{\"code\":\"sk\",\"name\":\"slovaki\"},{\"code\":\"sl\",\"name\":\"sloveeni\"},{\"code\":\"fi\",\"name\":\"soome\"},{\"code\":\"zu\",\"name\":\"suulu\"},{\"code\":\"gd\",\"name\":\"oti\"},{\"code\":\"da\",\"name\":\"taani\"},{\"code\":\"th\",\"name\":\"tai\"},{\"code\":\"zh-tw\",\"name\":\"traditsiooniline hiina\"},{\"code\":\"cs\",\"name\":\"tehhi\"},{\"code\":\"tr\",\"name\":\"trgi\"},{\"code\":\"cy\",\"name\":\"uelsi\"},{\"code\":\"uk\",\"name\":\"ukraina\"},{\"code\":\"hu\",\"name\":\"ungari\"},{\"code\":\"ru\",\"name\":\"vene\"},{\"code\":\"vi\",\"name\":\"vietnami\"}],\"cy\":[{\"code\":\"de\",\"name\":\"Almaeneg\"},{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arabeg\"},{\"code\":\"az\",\"name\":\"Aserbaijaneg\"},{\"code\":\"eu\",\"name\":\"Basgeg\"},{\"code\":\"bg\",\"name\":\"Bwlgaraidd\"},{\"code\":\"ca\",\"name\":\"Catalaneg\"},{\"code\":\"hr\",\"name\":\"Croateg\"},{\"code\":\"cy\",\"name\":\"Cymraeg\"},{\"code\":\"da\",\"name\":\"Daneg\"},{\"code\":\"it\",\"name\":\"Eidaleg\"},{\"code\":\"et\",\"name\":\"Estoneg\"},{\"code\":\"vi\",\"name\":\"Fietnameg\"},{\"code\":\"fi\",\"name\":\"Ffineg\"},{\"code\":\"nl\",\"name\":\"Fflemeg\"},{\"code\":\"fr\",\"name\":\"Ffrangeg\"},{\"code\":\"gd\",\"name\":\"Gaeleg yr Alban\"},{\"code\":\"gl\",\"name\":\"Galisaidd\"},{\"code\":\"el\",\"name\":\"Groeg\"},{\"code\":\"ga\",\"name\":\"Gwyddeleg\"},{\"code\":\"he\",\"name\":\"Hebraeg\"},{\"code\":\"hu\",\"name\":\"Hwngareg\"},{\"code\":\"ko\",\"name\":\"Iaith Corea\"},{\"code\":\"id\",\"name\":\"Indonesieg\"},{\"code\":\"is\",\"name\":\"Islandeg\"},{\"code\":\"uk\",\"name\":\"Iwcraineg\"},{\"code\":\"ja\",\"name\":\"Japaneg\"},{\"code\":\"lv\",\"name\":\"Latfieg\"},{\"code\":\"lt\",\"name\":\"Lithwaneg\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norwyeg\"},{\"code\":\"fa\",\"name\":\"Perseg\"},{\"code\":\"pt\",\"name\":\"Portiwgaleg\"},{\"code\":\"pl\",\"name\":\"Pwyleg\"},{\"code\":\"ro\",\"name\":\"Rwmaneg\"},{\"code\":\"ru\",\"name\":\"Rwsieg\"},{\"code\":\"en\",\"name\":\"Saesneg\"},{\"code\":\"es\",\"name\":\"Sbaeneg\"},{\"code\":\"sr\",\"name\":\"Serbeg\"},{\"code\":\"sk\",\"name\":\"Slofac\"},{\"code\":\"sl\",\"name\":\"Slofenia\"},{\"code\":\"sv\",\"name\":\"Swedeg\"},{\"code\":\"zu\",\"name\":\"Swlw\"},{\"code\":\"th\",\"name\":\"Tai\"},{\"code\":\"cs\",\"name\":\"Tsieceg\"},{\"code\":\"zh-tw\",\"name\":\"Tsieineeg (Traddodiadol)\"},{\"code\":\"zh-cn\",\"name\":\"Tsieineeg (Wedi symleiddio)\"},{\"code\":\"tr\",\"name\":\"Twrceg\"}],\"zh-cn\":[{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\"()\"},{\"code\":\"zh-cn\",\"name\":\"()\"}],\"bg\":[{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"ja\",\"name\":\"\"}],\"ar\":[{\"code\":\"is\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"}],\"en\":[{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arabic\"},{\"code\":\"az\",\"name\":\"Azerbaijani\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"bg\",\"name\":\"Bulgarian\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"zh-cn\",\"name\":\"Chinese (Simplified)\"},{\"code\":\"zh-tw\",\"name\":\"Chinese (Traditional)\"},{\"code\":\"hr\",\"name\":\"Croatian\"},{\"code\":\"cs\",\"name\":\"Czech\"},{\"code\":\"da\",\"name\":\"Danish\"},{\"code\":\"nl\",\"name\":\"Dutch\"},{\"code\":\"en\",\"name\":\"English\"},{\"code\":\"et\",\"name\":\"Estonian\"},{\"code\":\"fi\",\"name\":\"Finnish\"},{\"code\":\"fr\",\"name\":\"French\"},{\"code\":\"gl\",\"name\":\"Galician\"},{\"code\":\"de\",\"name\":\"German\"},{\"code\":\"el\",\"name\":\"Greek\"},{\"code\":\"he\",\"name\":\"Hebrew\"},{\"code\":\"hu\",\"name\":\"Hungarian\"},{\"code\":\"is\",\"name\":\"Icelandic\"},{\"code\":\"id\",\"name\":\"Indonesian\"},{\"code\":\"ga\",\"name\":\"Irish\"},{\"code\":\"it\",\"name\":\"Italian\"},{\"code\":\"ja\",\"name\":\"Japanese\"},{\"code\":\"ko\",\"name\":\"Korean\"},{\"code\":\"lv\",\"name\":\"Latvian\"},{\"code\":\"lt\",\"name\":\"Lithuanian\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norwegian\"},{\"code\":\"fa\",\"name\":\"Persian\"},{\"code\":\"pl\",\"name\":\"Polish\"},{\"code\":\"pt\",\"name\":\"Portuguese\"},{\"code\":\"ro\",\"name\":\"Romanian\"},{\"code\":\"ru\",\"name\":\"Russian\"},{\"code\":\"gd\",\"name\":\"Scots Gaelic\"},{\"code\":\"sr\",\"name\":\"Serbian\"},{\"code\":\"sk\",\"name\":\"Slovak\"},{\"code\":\"sl\",\"name\":\"Slovenian\"},{\"code\":\"es\",\"name\":\"Spanish\"},{\"code\":\"sv\",\"name\":\"Swedish\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"tr\",\"name\":\"Turkish\"},{\"code\":\"uk\",\"name\":\"Ukrainian\"},{\"code\":\"vi\",\"name\":\"Vietnamese\"},{\"code\":\"cy\",\"name\":\"Welsh\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"sr\":[{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"es\",\"name\":\"\"}],\"sv\":[{\"code\":\"am\",\"name\":\"amhariska\"},{\"code\":\"ar\",\"name\":\"arabiska\"},{\"code\":\"az\",\"name\":\"azerbajdzjanska\"},{\"code\":\"eu\",\"name\":\"baskiska\"},{\"code\":\"bg\",\"name\":\"bulgariska\"},{\"code\":\"da\",\"name\":\"danska\"},{\"code\":\"en\",\"name\":\"engelska\"},{\"code\":\"et\",\"name\":\"estniska\"},{\"code\":\"fi\",\"name\":\"finska\"},{\"code\":\"fr\",\"name\":\"franska\"},{\"code\":\"gd\",\"name\":\"gaeliska\"},{\"code\":\"gl\",\"name\":\"galiciska\"},{\"code\":\"el\",\"name\":\"grekiska\"},{\"code\":\"he\",\"name\":\"hebreiska\"},{\"code\":\"id\",\"name\":\"indonesiska\"},{\"code\":\"ga\",\"name\":\"irlndska\"},{\"code\":\"is\",\"name\":\"islndska\"},{\"code\":\"it\",\"name\":\"italienska\"},{\"code\":\"ja\",\"name\":\"japanska\"},{\"code\":\"ca\",\"name\":\"katalanska\"},{\"code\":\"zh-cn\",\"name\":\"kinesiska (frenklad)\"},{\"code\":\"zh-tw\",\"name\":\"kinesiska (traditionell)\"},{\"code\":\"ko\",\"name\":\"koreanska\"},{\"code\":\"hr\",\"name\":\"kroatiska\"},{\"code\":\"lv\",\"name\":\"lettiska\"},{\"code\":\"lt\",\"name\":\"litauiska\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"nederlndska\"},{\"code\":\"nb\",\"name\":\"norska\"},{\"code\":\"fa\",\"name\":\"persiska\"},{\"code\":\"pl\",\"name\":\"polska\"},{\"code\":\"pt\",\"name\":\"portugisiska\"},{\"code\":\"ro\",\"name\":\"rumnska\"},{\"code\":\"ru\",\"name\":\"ryska\"},{\"code\":\"sr\",\"name\":\"serbiska\"},{\"code\":\"sk\",\"name\":\"slovakiska\"},{\"code\":\"sl\",\"name\":\"slovenska\"},{\"code\":\"es\",\"name\":\"spanska\"},{\"code\":\"sv\",\"name\":\"svenska\"},{\"code\":\"th\",\"name\":\"thailndska\"},{\"code\":\"cs\",\"name\":\"tjeckiska\"},{\"code\":\"tr\",\"name\":\"turkiska\"},{\"code\":\"de\",\"name\":\"tyska\"},{\"code\":\"uk\",\"name\":\"ukrainska\"},{\"code\":\"hu\",\"name\":\"ungerska\"},{\"code\":\"vi\",\"name\":\"vietnamesiska\"},{\"code\":\"cy\",\"name\":\"walesiska\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"ro\":[{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arab\"},{\"code\":\"az\",\"name\":\"Azerbaidjan\"},{\"code\":\"eu\",\"name\":\"Basc\"},{\"code\":\"bg\",\"name\":\"Bulgar\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"cs\",\"name\":\"Ceh\"},{\"code\":\"zh-cn\",\"name\":\"Chinez (Simplificat)\"},{\"code\":\"zh-tw\",\"name\":\"Chinez (Tradiional)\"},{\"code\":\"ko\",\"name\":\"Coreean\"},{\"code\":\"hr\",\"name\":\"Croat\"},{\"code\":\"da\",\"name\":\"Danez\"},{\"code\":\"he\",\"name\":\"Ebraic\"},{\"code\":\"en\",\"name\":\"Englez\"},{\"code\":\"et\",\"name\":\"Eston\"},{\"code\":\"fi\",\"name\":\"Finlandez\"},{\"code\":\"fr\",\"name\":\"Francez\"},{\"code\":\"cy\",\"name\":\"Galez\"},{\"code\":\"gd\",\"name\":\"Galica scoian\"},{\"code\":\"gl\",\"name\":\"Galician\"},{\"code\":\"de\",\"name\":\"German\"},{\"code\":\"el\",\"name\":\"Greac\"},{\"code\":\"id\",\"name\":\"Indonezian\"},{\"code\":\"ga\",\"name\":\"Irlandez\"},{\"code\":\"is\",\"name\":\"Islandez\"},{\"code\":\"it\",\"name\":\"Italian\"},{\"code\":\"ja\",\"name\":\"Japonez\"},{\"code\":\"lv\",\"name\":\"Leton\"},{\"code\":\"lt\",\"name\":\"Lituanian\"},{\"code\":\"hu\",\"name\":\"Maghiar\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Neerlandez\"},{\"code\":\"nb\",\"name\":\"Norvegian\"},{\"code\":\"fa\",\"name\":\"Persan\"},{\"code\":\"pl\",\"name\":\"Polonez\"},{\"code\":\"pt\",\"name\":\"Portughez\"},{\"code\":\"ro\",\"name\":\"Romn\"},{\"code\":\"ru\",\"name\":\"Rus\"},{\"code\":\"sr\",\"name\":\"Srb\"},{\"code\":\"sk\",\"name\":\"Slovac\"},{\"code\":\"sl\",\"name\":\"Sloven\"},{\"code\":\"es\",\"name\":\"Spaniol\"},{\"code\":\"sv\",\"name\":\"Suedez\"},{\"code\":\"th\",\"name\":\"Thailandez\"},{\"code\":\"tr\",\"name\":\"Turc\"},{\"code\":\"uk\",\"name\":\"Ucrainean\"},{\"code\":\"vi\",\"name\":\"Vietnamez\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"lt\":[{\"code\":\"ga\",\"name\":\"airi\"},{\"code\":\"am\",\"name\":\"amhar\"},{\"code\":\"en\",\"name\":\"angl\"},{\"code\":\"ar\",\"name\":\"arab\"},{\"code\":\"az\",\"name\":\"Azerbaidaniei\"},{\"code\":\"eu\",\"name\":\"bask\"},{\"code\":\"bg\",\"name\":\"bulgar\"},{\"code\":\"cs\",\"name\":\"ek\"},{\"code\":\"da\",\"name\":\"dan\"},{\"code\":\"et\",\"name\":\"est\"},{\"code\":\"gl\",\"name\":\"galis\"},{\"code\":\"el\",\"name\":\"graik\"},{\"code\":\"he\",\"name\":\"hebraj\"},{\"code\":\"id\",\"name\":\"indoneziei\"},{\"code\":\"is\",\"name\":\"island\"},{\"code\":\"es\",\"name\":\"ispan\"},{\"code\":\"it\",\"name\":\"ital\"},{\"code\":\"ja\",\"name\":\"japon\"},{\"code\":\"ca\",\"name\":\"kataloniei\"},{\"code\":\"zh-cn\",\"name\":\"kin (supaprastinta)\"},{\"code\":\"zh-tw\",\"name\":\"kin (tradicin)\"},{\"code\":\"ko\",\"name\":\"korjiei\"},{\"code\":\"hr\",\"name\":\"kroat\"},{\"code\":\"lv\",\"name\":\"latvi\"},{\"code\":\"pl\",\"name\":\"lenk\"},{\"code\":\"lt\",\"name\":\"lietuvi\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nb\",\"name\":\"norveg\"},{\"code\":\"nl\",\"name\":\"oland\"},{\"code\":\"fa\",\"name\":\"pers\"},{\"code\":\"pt\",\"name\":\"portugal\"},{\"code\":\"fr\",\"name\":\"prancz\"},{\"code\":\"ro\",\"name\":\"rumun\"},{\"code\":\"ru\",\"name\":\"rus\"},{\"code\":\"sr\",\"name\":\"serb\"},{\"code\":\"sk\",\"name\":\"slovak\"},{\"code\":\"sl\",\"name\":\"slovn\"},{\"code\":\"fi\",\"name\":\"suomi\"},{\"code\":\"gd\",\"name\":\"kot (gl)\"},{\"code\":\"sv\",\"name\":\"ved\"},{\"code\":\"th\",\"name\":\"taj\"},{\"code\":\"tr\",\"name\":\"turk\"},{\"code\":\"uk\",\"name\":\"ukrainiei\"},{\"code\":\"cy\",\"name\":\"val\"},{\"code\":\"hu\",\"name\":\"vengr\"},{\"code\":\"vi\",\"name\":\"vietnamiei\"},{\"code\":\"de\",\"name\":\"vokiei\"},{\"code\":\"zu\",\"name\":\"zulus\"}],\"ko\":[{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\"()\"},{\"code\":\"zh-tw\",\"name\":\"()\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"}],\"it\":[{\"code\":\"am\",\"name\":\"Amarico\"},{\"code\":\"ar\",\"name\":\"Arabo\"},{\"code\":\"az\",\"name\":\"Azero\"},{\"code\":\"eu\",\"name\":\"Basco\"},{\"code\":\"bg\",\"name\":\"Bulgaro\"},{\"code\":\"ca\",\"name\":\"Catalano\"},{\"code\":\"cs\",\"name\":\"Ceco\"},{\"code\":\"zh-cn\",\"name\":\"Cinese (semplificato)\"},{\"code\":\"zh-tw\",\"name\":\"Cinese (tradizionale)\"},{\"code\":\"ko\",\"name\":\"Coreano\"},{\"code\":\"hr\",\"name\":\"Croato\"},{\"code\":\"da\",\"name\":\"Danese\"},{\"code\":\"he\",\"name\":\"Ebraico\"},{\"code\":\"et\",\"name\":\"Estone\"},{\"code\":\"fi\",\"name\":\"Finlandese\"},{\"code\":\"fr\",\"name\":\"Francese\"},{\"code\":\"gd\",\"name\":\"Gaelico scozzese\"},{\"code\":\"gl\",\"name\":\"Galiziano\"},{\"code\":\"cy\",\"name\":\"Gallese\"},{\"code\":\"ja\",\"name\":\"Giapponese\"},{\"code\":\"el\",\"name\":\"Greco\"},{\"code\":\"id\",\"name\":\"Indonesiano\"},{\"code\":\"en\",\"name\":\"Inglese\"},{\"code\":\"ga\",\"name\":\"Irlandese\"},{\"code\":\"is\",\"name\":\"Islandese\"},{\"code\":\"it\",\"name\":\"Italiano\"},{\"code\":\"lv\",\"name\":\"Lettone\"},{\"code\":\"lt\",\"name\":\"Lituano\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norvegese\"},{\"code\":\"nl\",\"name\":\"Olandese\"},{\"code\":\"fa\",\"name\":\"Persiano\"},{\"code\":\"pl\",\"name\":\"Polacco\"},{\"code\":\"pt\",\"name\":\"Portoghese\"},{\"code\":\"ro\",\"name\":\"Rumeno\"},{\"code\":\"ru\",\"name\":\"Russo\"},{\"code\":\"sr\",\"name\":\"Serbo\"},{\"code\":\"sk\",\"name\":\"Slovacco\"},{\"code\":\"sl\",\"name\":\"Sloveno\"},{\"code\":\"es\",\"name\":\"Spagnolo\"},{\"code\":\"sv\",\"name\":\"Svedese\"},{\"code\":\"th\",\"name\":\"Tailandese\"},{\"code\":\"de\",\"name\":\"Tedesco\"},{\"code\":\"tr\",\"name\":\"Turco\"},{\"code\":\"uk\",\"name\":\"Ucraino\"},{\"code\":\"hu\",\"name\":\"Ungherese\"},{\"code\":\"vi\",\"name\":\"Vietnamita\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"vi\":[{\"code\":\"ar\",\"name\":\"Ting  Rp\"},{\"code\":\"am\",\"name\":\"Ting Amharic\"},{\"code\":\"en\",\"name\":\"Ting Anh\"},{\"code\":\"az\",\"name\":\"Ting Azerbaijan\"},{\"code\":\"pl\",\"name\":\"Ting Ba Lan\"},{\"code\":\"fa\",\"name\":\"Ting Ba T\"},{\"code\":\"eu\",\"name\":\"Ting Basque\"},{\"code\":\"pt\",\"name\":\"Ting B o Nha\"},{\"code\":\"bg\",\"name\":\"Ting Bulgaria\"},{\"code\":\"ca\",\"name\":\"Ting Catalan\"},{\"code\":\"hr\",\"name\":\"Ting Croatia\"},{\"code\":\"he\",\"name\":\"Ting Do Thi\"},{\"code\":\"da\",\"name\":\"Ting an Mch\"},{\"code\":\"de\",\"name\":\"Ting c\"},{\"code\":\"et\",\"name\":\"Ting Estonia\"},{\"code\":\"gd\",\"name\":\"Ting Gael Scotland\"},{\"code\":\"gl\",\"name\":\"Ting Galicia\"},{\"code\":\"nl\",\"name\":\"Ting H Lan\"},{\"code\":\"ko\",\"name\":\"Ting Hn\"},{\"code\":\"hu\",\"name\":\"Ting Hungary\"},{\"code\":\"el\",\"name\":\"Ting Hy Lp\"},{\"code\":\"is\",\"name\":\"Ting Iceland\"},{\"code\":\"id\",\"name\":\"Ting Indonesia\"},{\"code\":\"ga\",\"name\":\"Ting Ireland\"},{\"code\":\"lv\",\"name\":\"Ting Latvia\"},{\"code\":\"lt\",\"name\":\"Ting Litva\"},{\"code\":\"mi\",\"name\":\"Ting Maori\"},{\"code\":\"nb\",\"name\":\"Ting Na Uy\"},{\"code\":\"ru\",\"name\":\"Ting Nga\"},{\"code\":\"ja\",\"name\":\"Ting Nht\"},{\"code\":\"fr\",\"name\":\"Ting Php\"},{\"code\":\"fi\",\"name\":\"Ting Phn Lan\"},{\"code\":\"ro\",\"name\":\"Ting Rumani\"},{\"code\":\"cs\",\"name\":\"Ting Sc\"},{\"code\":\"sr\",\"name\":\"Ting Serbia\"},{\"code\":\"sk\",\"name\":\"Ting Slovak\"},{\"code\":\"sl\",\"name\":\"Ting Slovenia\"},{\"code\":\"es\",\"name\":\"Ting Ty Ban Nha\"},{\"code\":\"th\",\"name\":\"Ting Thi\"},{\"code\":\"tr\",\"name\":\"Ting Th Nh K\"},{\"code\":\"sv\",\"name\":\"Ting Thy in\"},{\"code\":\"zh-cn\",\"name\":\"Ting Trung (Gian Th)\"},{\"code\":\"zh-tw\",\"name\":\"Ting Trung (Phn th)\"},{\"code\":\"uk\",\"name\":\"Ting Ukraina\"},{\"code\":\"vi\",\"name\":\"Ting Vit\"},{\"code\":\"cy\",\"name\":\"Ting X Wales\"},{\"code\":\"it\",\"name\":\"Ting \"},{\"code\":\"zu\",\"name\":\"Ting Zulu\"}]},\"nameMap\":{\"albntina\":\"sq\",\"amhartina\":\"am\",\"anglitina\":\"en\",\"arabtina\":\"ar\",\"armntina\":\"hy\",\"zerbjdntina\":\"az\",\"barmtina\":\"my\",\"baskitina\":\"eu\",\"blorutina\":\"be\",\"bulhartina\":\"bg\",\"etina\":\"cs\",\"ntina (tradin)\":\"zh-tw\",\"ntina (zjednoduen)\":\"zh-cn\",\"dntina\":\"da\",\"esperanto\":\"eo\",\"estontina\":\"et\",\"fintina\":\"fi\",\"francouztina\":\"fr\",\"galicijtina\":\"gl\",\"haitsk kreoltina\":\"ht\",\"hebrejtina\":\"he\",\"hindtina\":\"hi\",\"holandtina\":\"nl\",\"chorvattina\":\"hr\",\"indontina\":\"id\",\"irtina\":\"ga\",\"islandtina\":\"is\",\"italtina\":\"it\",\"japontina\":\"ja\",\"kannadtina\":\"kn\",\"katalntina\":\"ca\",\"korejtina\":\"ko\",\"kurdtina\":\"ku\",\"latina\":\"la\",\"litevtina\":\"lt\",\"lotytina\":\"lv\",\"maartina\":\"hu\",\"makedontina\":\"mk\",\"malajlamtina\":\"ml\",\"malajtina\":\"ms\",\"malttina\":\"mt\",\"maortina\":\"mi\",\"marttina\":\"mr\",\"mongoltina\":\"mn\",\"nmina\":\"de\",\"nortina\":\"nb\",\"pertina\":\"fa\",\"poltina\":\"pl\",\"portugaltina\":\"pt\",\"rumuntina\":\"ro\",\"rutina\":\"ru\",\"etina\":\"el\",\"skotsk gaeltina\":\"gd\",\"sloventina\":\"sk\",\"slovintina\":\"sl\",\"srbtina\":\"sr\",\"panltina\":\"es\",\"vdtina\":\"sv\",\"telutina\":\"te\",\"thajtina\":\"th\",\"turetina\":\"tr\",\"ukrajintina\":\"uk\",\"uzbetina\":\"uz\",\"veltina\":\"cy\",\"vietnamtina\":\"vi\",\"zulu\":\"zu\",\"albansk\":\"sq\",\"amharisk\":\"am\",\"arabisk\":\"ar\",\"armensk\":\"hy\",\"aserbajdsjansk\":\"az\",\"baskisk\":\"eu\",\"bulgarsk\":\"bg\",\"burmesisk\":\"my\",\"dansk\":\"da\",\"engelsk\":\"en\",\"estisk\":\"et\",\"finsk\":\"fi\",\"fransk\":\"fr\",\"galicisk\":\"gl\",\"grsk\":\"el\",\"haitisk kreolsk\":\"ht\",\"hebraisk\":\"he\",\"hindi\":\"hi\",\"hollandsk\":\"nl\",\"hviderussisk\":\"be\",\"indonesisk\":\"id\",\"irsk\":\"ga\",\"islandsk\":\"is\",\"italiensk\":\"it\",\"japansk\":\"ja\",\"kannada\":\"kn\",\"katalansk\":\"ca\",\"kinesisk (forenklet)\":\"zh-cn\",\"kinesisk (traditionelt)\":\"zh-tw\",\"koreansk\":\"ko\",\"kroatisk\":\"hr\",\"kurdisk\":\"ku\",\"latin\":\"la\",\"lettisk\":\"lv\",\"litauisk\":\"lt\",\"makedonsk\":\"mk\",\"malajisk\":\"ms\",\"malayalam\":\"ml\",\"maltesisk\":\"mt\",\"maori\":\"mi\",\"marathi\":\"mr\",\"mongolsk\":\"mn\",\"norsk\":\"nb\",\"persisk\":\"fa\",\"polsk\":\"pl\",\"portugisisk\":\"pt\",\"rumnsk\":\"ro\",\"russisk\":\"ru\",\"serbisk\":\"sr\",\"skotsk glisk\":\"gd\",\"slovakisk\":\"sk\",\"slovensk\":\"sl\",\"spansk\":\"es\",\"svensk\":\"sv\",\"telugu\":\"te\",\"thailandsk\":\"th\",\"tjekkisk\":\"cs\",\"tyrkisk\":\"tr\",\"tysk\":\"de\",\"ukrainsk\":\"uk\",\"ungarsk\":\"hu\",\"usbekisk\":\"uz\",\"vietnamesisk\":\"vi\",\"walisisk\":\"cy\",\"acerbaixano\":\"az\",\"albans\":\"sq\",\"alemn\":\"de\",\"amrico\":\"am\",\"rabe\":\"ar\",\"armenio\":\"hy\",\"bielorruso\":\"be\",\"birmano\":\"my\",\"blgaro\":\"bg\",\"canars\":\"kn\",\"cataln\":\"ca\",\"checo\":\"cs\",\"chins (simplificado)\":\"zh-cn\",\"chins (tradicional)\":\"zh-tw\",\"coreano\":\"ko\",\"crioulo haitiano\":\"ht\",\"croata\":\"hr\",\"curdo\":\"ku\",\"dinamarqus\":\"da\",\"eslovaco\":\"sk\",\"esloveno\":\"sl\",\"espaol\":\"es\",\"estoniano\":\"et\",\"uscaro\":\"eu\",\"fins\":\"fi\",\"francs\":\"fr\",\"galico escocs\":\"gd\",\"galego\":\"gl\",\"gals\":\"cy\",\"grego\":\"el\",\"hebreo\":\"he\",\"hngaro\":\"hu\",\"indonesio\":\"id\",\"ingls\":\"en\",\"irlands\":\"ga\",\"islands\":\"is\",\"italiano\":\"it\",\"latn\":\"la\",\"letn\":\"lv\",\"lituano\":\"lt\",\"macedonio\":\"mk\",\"malabar\":\"ml\",\"malaio\":\"ms\",\"malts\":\"mt\",\"maor\":\"mi\",\"mongol\":\"mn\",\"neerlands\":\"nl\",\"noruegus\":\"nb\",\"persa\":\"fa\",\"polaco\":\"pl\",\"portugus\":\"pt\",\"romans\":\"ro\",\"ruso\":\"ru\",\"serbio\":\"sr\",\"sueco\":\"sv\",\"tailands\":\"th\",\"telug\":\"te\",\"turco\":\"tr\",\"ucrano\":\"uk\",\"usbeco\":\"uz\",\"vietnamita\":\"vi\",\"xapons\":\"ja\",\"zul\":\"zu\",\"albanina\":\"sq\",\"amharina\":\"am\",\"angleina\":\"en\",\"arabina\":\"ar\",\"armenina\":\"hy\",\"azerbajdanina\":\"az\",\"baskovina\":\"eu\",\"beloruina\":\"be\",\"bolgarina\":\"bg\",\"burmanina\":\"my\",\"eina\":\"cs\",\"danina\":\"da\",\"estonina\":\"et\",\"finina\":\"fi\",\"francoina\":\"fr\",\"galicijina\":\"gl\",\"grina\":\"el\",\"haitijska kreolina\":\"ht\",\"hebrejina\":\"he\",\"hindijina\":\"hi\",\"hrvaina\":\"hr\",\"indonezijina\":\"id\",\"irina\":\"ga\",\"islandina\":\"is\",\"italijanina\":\"it\",\"japonina\":\"ja\",\"kanareina\":\"kn\",\"katalonina\":\"ca\",\"kitajina (poenostavljena)\":\"zh-cn\",\"kitajina (tradicionalna)\":\"zh-tw\",\"korejina\":\"ko\",\"kurdina\":\"ku\",\"latinina\":\"la\",\"latvijina\":\"lv\",\"litovina\":\"lt\",\"madarina\":\"hu\",\"makedonina\":\"mk\",\"malajalina\":\"ml\",\"malajina\":\"ms\",\"malteina\":\"mt\",\"maorina\":\"mi\",\"maratina\":\"mr\",\"mongolina\":\"mn\",\"nemina\":\"de\",\"nizozemina\":\"nl\",\"norveina\":\"nb\",\"perzijina\":\"fa\",\"poljina\":\"pl\",\"portugalina\":\"pt\",\"romunina\":\"ro\",\"ruina\":\"ru\",\"slovaina\":\"sk\",\"slovenina\":\"sl\",\"srbina\":\"sr\",\"kotska gelina\":\"gd\",\"panina\":\"es\",\"vedina\":\"sv\",\"tajina\":\"th\",\"teluina\":\"te\",\"turina\":\"tr\",\"ukrajinina\":\"uk\",\"uzbeina\":\"uz\",\"valianina\":\"cy\",\"vietnamina\":\"vi\",\"zulujina\":\"zu\",\"albanais\":\"sq\",\"allemand\":\"de\",\"amharique\":\"am\",\"anglais\":\"en\",\"arabe\":\"ar\",\"armnien\":\"hy\",\"azri\":\"az\",\"basque\":\"eu\",\"bilorusse\":\"be\",\"birman\":\"my\",\"bulgare\":\"bg\",\"catalan\":\"ca\",\"chinois (simplifi)\":\"zh-cn\",\"chinois (traditionnel)\":\"zh-tw\",\"coren\":\"ko\",\"crole hatien\":\"ht\",\"croate\":\"hr\",\"danois\":\"da\",\"espagnol\":\"es\",\"espranto\":\"eo\",\"estonien\":\"et\",\"finnois\":\"fi\",\"franais\":\"fr\",\"galique (cosse)\":\"gd\",\"galicien\":\"gl\",\"gallois\":\"cy\",\"grec\":\"el\",\"hbreu\":\"he\",\"hongrois\":\"hu\",\"indonsien\":\"id\",\"irlandais\":\"ga\",\"islandais\":\"is\",\"italien\":\"it\",\"japonais\":\"ja\",\"kurde\":\"ku\",\"letton\":\"lv\",\"lituanien\":\"lt\",\"macdonien\":\"mk\",\"malaisien\":\"ms\",\"maltais\":\"mt\",\"nerlandais\":\"nl\",\"norvgien\":\"nb\",\"ouzbek\":\"uz\",\"persan\":\"fa\",\"polonais\":\"pl\",\"portugais\":\"pt\",\"roumain\":\"ro\",\"russe\":\"ru\",\"serbe\":\"sr\",\"slovaque\":\"sk\",\"slovne\":\"sl\",\"sudois\":\"sv\",\"tchque\":\"cs\",\"tha\":\"th\",\"turc\":\"tr\",\"ukrainien\":\"uk\",\"vietnamien\":\"vi\",\"zoulou\":\"zu\",\"albn\":\"sq\",\"amhara\":\"am\",\"angol\":\"en\",\"arab\":\"ar\",\"azeri\":\"az\",\"baszk\":\"eu\",\"belorusz\":\"be\",\"bolgr\":\"bg\",\"burmai\":\"my\",\"cseh\":\"cs\",\"dn\":\"da\",\"eszperant\":\"eo\",\"szt\":\"et\",\"finn\":\"fi\",\"francia\":\"fr\",\"galciai\":\"gl\",\"grg\":\"el\",\"haiti kreol\":\"ht\",\"hber\":\"he\",\"holland\":\"nl\",\"horvt\":\"hr\",\"indonz\":\"id\",\"r\":\"ga\",\"izlandi\":\"is\",\"japn\":\"ja\",\"kataln\":\"ca\",\"knai (egyszerstett)\":\"zh-cn\",\"knai (hagyomnyos)\":\"zh-tw\",\"koreai\":\"ko\",\"kurd\":\"ku\",\"lengyel\":\"pl\",\"lett\":\"lv\",\"litvn\":\"lt\",\"macedn\":\"mk\",\"magyar\":\"hu\",\"malj\":\"ms\",\"malajlam\":\"ml\",\"mltai\":\"mt\",\"marthi\":\"mr\",\"nmet\":\"de\",\"norvg\":\"nb\",\"olasz\":\"it\",\"orosz\":\"ru\",\"rmny\":\"hy\",\"perzsa\":\"fa\",\"portugl\":\"pt\",\"romn\":\"ro\",\"skt-gael\":\"gd\",\"spanyol\":\"es\",\"svd\":\"sv\",\"szerb\":\"sr\",\"szlovk\":\"sk\",\"szlovn\":\"sl\",\"thai\":\"th\",\"trk\":\"tr\",\"ukrn\":\"uk\",\"zbg\":\"uz\",\"vietnami\":\"vi\",\"walesi\":\"cy\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"eu\",\"\":\"be\",\"\":\"my\",\"\":\"bg\",\"\":\"vi\",\"\":\"cy\",\"\":\"hy\",\" \":\"ht\",\"\":\"hi\",\"\":\"el\",\"\":\"gl\",\"\":\"da\",\"\":\"eo\",\"\":\"et\",\"\":\"zu\",\"\":\"he\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"kn\",\"\":\"ca\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ko\",\"\":\"ku\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"mk\",\"\":\"ms\",\"\":\"ml\",\"\":\"mt\",\"\":\"mi\",\"\":\"mr\",\"\":\"mn\",\"\":\"nl\",\"\":\"de\",\"\":\"nb\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"ru\",\"\":\"ro\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"th\",\"\":\"te\",\"\":\"tr\",\"\":\"hu\",\"\":\"uz\",\"\":\"uk\",\"\":\"fi\",\"\":\"fr\",\"\":\"hr\",\"\":\"cs\",\"\":\"sv\",\" ()\":\"gd\",\"\":\"ja\",\"\":\"tr\",\"()\":\"zh-tw\",\"()\":\"zh-cn\",\"\":\"da\",\"\":\"eu\",\"\":\"ja\",\"\":\"mi\",\"\":\"eo\",\"\":\"gl\",\"\":\"ca\",\"\":\"kn\",\"\":\"be\",\"\":\"lt\",\"\":\"is\",\"\":\"hu\",\"\":\"id\",\"\":\"hi\",\"\":\"es\",\"\":\"hr\",\"\":\"he\",\"\":\"el\",\"\":\"hy\",\"\":\"az\",\"\":\"la\",\"\":\"lv\",\"\":\"fr\",\"\":\"fa\",\"\":\"pl\",\"\":\"fi\",\"\":\"am\",\"\":\"ar\",\"\":\"sq\",\"\":\"ru\",\"\":\"bg\",\"\":\"zu\",\"\":\"cy\",\"\":\"en\",\"\":\"ku\",\"\":\"nb\",\"\":\"th\",\"\":\"te\",\"\":\"ht\",\"\":\"uk\",\"\":\"uz\",\"\":\"mt\",\"\":\"ms\",\"\":\"mk\",\"\":\"mr\",\"\":\"ml\",\"\":\"cs\",\"\":\"nl\",\"\":\"sk\",\"\":\"sl\",\"\":\"vi\",\"\":\"sr\",\"\":\"et\",\"\":\"ga\",\"\":\"sv\",\"\":\"it\",\"\":\"pt\",\"\":\"mn\",\"\":\"de\",\"\":\"my\",\"\":\"ko\",\"\":\"ro\",\"\":\"gd\",\"\":\"az\",\"\":\"am\",\"\":\"ar\",\"\":\"hy\",\"\":\"sq\",\"\":\"is\",\"\":\"ga\",\"\":\"en\",\"\":\"id\",\"\":\"it\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"kn\",\" ()\":\"ku\",\"\":\"ca\",\"\":\"ko\",\"\":\"hr\",\"\":\"gl\",\"\":\"el\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"ja\",\"\":\"de\",\"\":\"zu\",\"\":\"cs\",\"\":\"nl\",\"\":\"da\",\"\":\"tr\",\"\":\"te\",\"\":\"th\",\"\":\"nb\",\"\":\"pt\",\"\":\"pl\",\"\":\"fa\",\"\":\"fi\",\"\":\"fr\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"mn\",\"\":\"mr\",\"\":\"ms\",\"\":\"ml\",\"\":\"mi\",\"\":\"mt\",\"\":\"mk\",\" ()\":\"my\",\"\":\"uk\",\"\":\"ru\",\"\":\"ro\",\"\":\"lv\",\"\":\"lt\",\"\":\"la\",\"\":\"cy\",\"\":\"vi\",\"\":\"sr\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"hu\",\"\":\"hi\",\"\":\"he\",\" \":\"ht\",\"albanian\":\"sq\",\"amharic\":\"am\",\"arabic\":\"ar\",\"armenian\":\"hy\",\"azerbaijani\":\"az\",\"belarusian\":\"be\",\"bulgarian\":\"bg\",\"chinese (simplified)\":\"zh-cn\",\"chinese (traditional)\":\"zh-tw\",\"croatian\":\"hr\",\"czech\":\"cs\",\"danish\":\"da\",\"dutch\":\"nl\",\"english\":\"en\",\"estonian\":\"et\",\"finnish\":\"fi\",\"french\":\"fr\",\"galician\":\"gl\",\"german\":\"de\",\"greek\":\"el\",\"haitian creole\":\"ht\",\"hebrew\":\"he\",\"hungarian\":\"hu\",\"icelandic\":\"is\",\"indonesian\":\"id\",\"irish\":\"ga\",\"italian\":\"it\",\"japanese\":\"ja\",\"korean\":\"ko\",\"kurdish (kurmanji)\":\"ku\",\"latvian\":\"lv\",\"lithuanian\":\"lt\",\"macedonian\":\"mk\",\"malay\":\"ms\",\"maltese\":\"mt\",\"mongolian\":\"mn\",\"myanmar (burmese)\":\"my\",\"norwegian\":\"nb\",\"persian\":\"fa\",\"polish\":\"pl\",\"portuguese\":\"pt\",\"romanian\":\"ro\",\"russian\":\"ru\",\"scots gaelic\":\"gd\",\"serbian\":\"sr\",\"slovak\":\"sk\",\"slovenian\":\"sl\",\"spanish\":\"es\",\"swedish\":\"sv\",\"turkish\":\"tr\",\"ukrainian\":\"uk\",\"uzbek\":\"uz\",\"vietnamese\":\"vi\",\"welsh\":\"cy\",\"albans\":\"sq\",\"alemo\":\"de\",\"armnio\":\"hy\",\"azerbaijano\":\"az\",\"basco\":\"eu\",\"bielo-russo\":\"be\",\"birmans\":\"my\",\"canars\":\"kn\",\"catalo\":\"ca\",\"chins (simplificado)\":\"zh-cn\",\"chins (tradicional)\":\"zh-tw\",\"dinamarqus\":\"da\",\"espanhol\":\"es\",\"finlands\":\"fi\",\"francs\":\"fr\",\"galico escocs\":\"gd\",\"gals\":\"cy\",\"hebraico\":\"he\",\"holands\":\"nl\",\"indonsio\":\"id\",\"ingls\":\"en\",\"irlands\":\"ga\",\"islands\":\"is\",\"japons\":\"ja\",\"latim\":\"la\",\"leto\":\"lv\",\"macednio\":\"mk\",\"malaiala\":\"ml\",\"malts\":\"mt\",\"marata\":\"mr\",\"noruegus\":\"nb\",\"polons\":\"pl\",\"portugus\":\"pt\",\"romeno\":\"ro\",\"russo\":\"ru\",\"srvio\":\"sr\",\"tailands\":\"th\",\"tcheco\":\"cs\",\"telugo\":\"te\",\"ucraniano\":\"uk\",\"uzbeque\":\"uz\",\"almanca\":\"de\",\"arapa\":\"ar\",\"arnavuta\":\"sq\",\"azerice\":\"az\",\"baska\":\"eu\",\"belarusa\":\"be\",\"bulgarca\":\"bg\",\"burmaca\":\"my\",\"eke\":\"cs\",\"ince (basitletirilmi)\":\"zh-cn\",\"ince (geleneksel)\":\"zh-tw\",\"danca\":\"da\",\"endonezya dili\":\"id\",\"ermenice\":\"hy\",\"esperantoca\":\"eo\",\"estonyaca\":\"et\",\"farsa\":\"fa\",\"felemenke\":\"nl\",\"fince\":\"fi\",\"franszca\":\"fr\",\"galce\":\"cy\",\"galiyaca\":\"gl\",\"habee\":\"am\",\"haiti creole dili\":\"ht\",\"hrvata\":\"hr\",\"hinte\":\"hi\",\"ibranice\":\"he\",\"ingilizce\":\"en\",\"irlandaca\":\"ga\",\"ispanyolca\":\"es\",\"isvee\":\"sv\",\"italyanca\":\"it\",\"izlandaca\":\"is\",\"japonca\":\"ja\",\"katalanca\":\"ca\",\"korece\":\"ko\",\"kuzey isko dili\":\"gd\",\"krte\":\"ku\",\"latince\":\"la\",\"lehe\":\"pl\",\"letonca\":\"lv\",\"litvanca\":\"lt\",\"macarca\":\"hu\",\"makedonca\":\"mk\",\"malezya dili\":\"ms\",\"malta dili\":\"mt\",\"maori dili\":\"mi\",\"moolca\":\"mn\",\"norvee\":\"nb\",\"zbeke\":\"uz\",\"portekizce\":\"pt\",\"romence\":\"ro\",\"rusa\":\"ru\",\"srpa\":\"sr\",\"slovaka\":\"sk\",\"slovence\":\"sl\",\"tay dili\":\"th\",\"telugu dili\":\"te\",\"trke\":\"tr\",\"ukraynaca\":\"uk\",\"vietnamca\":\"vi\",\"yunanca\":\"el\",\"airminis\":\"hy\",\"albinis\":\"sq\",\"amrais\":\"am\",\"araibis\":\"ar\",\"asarbaiseinis\":\"az\",\"bascais\":\"eu\",\"bealarisis\":\"be\",\"barla\":\"en\",\"breatnais\":\"cy\",\"bulgiris\":\"bg\",\"cannadais\":\"kn\",\"catalinis\":\"ca\",\"coirdis (curmainsis)\":\"ku\",\"ciris\":\"ko\",\"cril ht\":\"ht\",\"critis\":\"hr\",\"danmhairgis\":\"da\",\"eabhrais\":\"he\",\"eastinis\":\"et\",\"fionlainnis\":\"fi\",\"fraincis\":\"fr\",\"gaeilge\":\"ga\",\"gaeilge na halban\":\"gd\",\"gailsis\":\"gl\",\"gearminis\":\"de\",\"grigis\":\"el\",\"hiondis\":\"hi\",\"indinisis\":\"id\",\"iodilis\":\"it\",\"ioruais\":\"nb\",\"oslainnis\":\"is\",\"laidin\":\"la\",\"laitvis\":\"lv\",\"liotuinis\":\"lt\",\"macadinis\":\"mk\",\"maenmar (burmais)\":\"my\",\"mailalaimis\":\"ml\",\"malaeis\":\"ms\",\"mltais\":\"mt\",\"maorais\":\"mi\",\"maraitis\":\"mr\",\"mongilis\":\"mn\",\"ollainnis\":\"nl\",\"peirsis\":\"fa\",\"polainnis\":\"pl\",\"portaingilis\":\"pt\",\"rminis\":\"ro\",\"risis\":\"ru\",\"seapinis\":\"ja\",\"seicis\":\"cs\",\"seirbis\":\"sr\",\"snis (simplithe)\":\"zh-cn\",\"snis (traidisinta)\":\"zh-tw\",\"slivinis\":\"sl\",\"slvaicis\":\"sk\",\"spinnis\":\"es\",\"sualainnis\":\"sv\",\"slis\":\"zu\",\"talainnis\":\"th\",\"teileagis\":\"te\",\"tuircis\":\"tr\",\"crinis\":\"uk\",\"isbiceastinis\":\"uz\",\"ungiris\":\"hu\",\"vtneaimis\":\"vi\",\"\":\"el\",\"\":\"kn\",\"\":\"gl\",\"\":\"gd\",\"\":\"ko\",\"\":\"ca\",\"\":\"ku\",\"\":\"hr\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"cs\",\"\":\"zu\",\"\":\"sr\",\"\":\"ja\",\"\":\"nl\",\"\":\"da\",\"\":\"tr\",\"\":\"te\",\"\":\"th\",\"\":\"nb\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"fa\",\"\":\"pt\",\"\":\"pl\",\"\":\"fr\",\"\":\"fi\",\"\":\"mn\",\"\":\"mt\",\"\":\"mk\",\"\":\"mr\",\"\":\"ml\",\"\":\"ms\",\"\":\"mi\",\" ()\":\"my\",\"\":\"uk\",\"\":\"de\",\"\":\"ru\",\"\":\"ro\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"cy\",\"\":\"vi\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"en\",\"\":\"am\",\"\":\"sq\",\"\":\"az\",\"\":\"hy\",\"\":\"ar\",\"\":\"it\",\"\":\"id\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"is\",\"\":\"ga\",\"\":\"hu\",\"\":\"hi\",\"\":\"he\",\"\":\"ht\",\"\":\"is\",\"\":\"ga\",\"\":\"az\",\"\":\"am\",\"\":\"ar\",\"\":\"sq\",\"\":\"hy\",\"\":\"it\",\"\":\"id\",\"\":\"cy\",\"\":\"uk\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"nl\",\"\":\"ca\",\"\":\"gl\",\"\":\"kn\",\"\":\"el\",\"\":\"ku\",\"\":\"hr\",\"\":\"sv\",\"\":\"zu\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sr\",\"\":\"th\",\"\":\"cs\",\"\":\"te\",\"\":\"da\",\"\":\"de\",\"\":\"tr\",\"\":\"nb\",\"\":\"ht\",\"\":\"eu\",\"\":\"hu\",\"\":\"hi\",\"\":\"fi\",\"\":\"fr\",\"\":\"bg\",\"\":\"vi\",\"\":\"he\",\"\":\"be\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"mi\",\"\":\"mk\",\"\":\"mr\",\"\":\"ml\",\"\":\"mt\",\"\":\"ms\",\"\":\"my\",\"\":\"mn\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"ro\",\"\":\"ru\",\"\":\"en\",\"\":\"ko\",\"()\":\"zh-cn\",\"()\":\"zh-tw\",\"\":\"ja\",\"albanees\":\"sq\",\"amharisch\":\"am\",\"arabisch\":\"ar\",\"armeens\":\"hy\",\"azerbeidzjaans\":\"az\",\"baskisch\":\"eu\",\"birmaans\":\"my\",\"bulgaars\":\"bg\",\"catalaans\":\"ca\",\"chinees (traditioneel)\":\"zh-tw\",\"chinees (vereenvoudigd)\":\"zh-cn\",\"deens\":\"da\",\"duits\":\"de\",\"engels\":\"en\",\"ests\":\"et\",\"fins\":\"fi\",\"frans\":\"fr\",\"galicisch\":\"gl\",\"grieks\":\"el\",\"hatiaans creools\":\"ht\",\"hebreeuws\":\"he\",\"hongaars\":\"hu\",\"iers\":\"ga\",\"ijslands\":\"is\",\"indonesisch\":\"id\",\"italiaans\":\"it\",\"japans\":\"ja\",\"koerdisch\":\"ku\",\"koreaans\":\"ko\",\"kroatisch\":\"hr\",\"latijn\":\"la\",\"lets\":\"lv\",\"litouws\":\"lt\",\"macedonisch\":\"mk\",\"maleis\":\"ms\",\"maltees\":\"mt\",\"mongools\":\"mn\",\"nederlands\":\"nl\",\"noors\":\"nb\",\"oekraens\":\"uk\",\"oezbeeks\":\"uz\",\"perzisch\":\"fa\",\"pools\":\"pl\",\"portugees\":\"pt\",\"roemeens\":\"ro\",\"russisch\":\"ru\",\"schots keltisch\":\"gd\",\"servisch\":\"sr\",\"slovaaks\":\"sk\",\"sloveens\":\"sl\",\"spaans\":\"es\",\"tsjechisch\":\"cs\",\"turks\":\"tr\",\"vietnamees\":\"vi\",\"wels\":\"cy\",\"wit-russisch\":\"be\",\"zoeloe\":\"zu\",\"zweeds\":\"sv\",\"airmeinis\":\"hy\",\"albinis\":\"sq\",\"amtharais\":\"am\",\"arabais\":\"ar\",\"asarbaidenais\":\"az\",\"basgais\":\"eu\",\"bealaruisis\":\"be\",\"beurla\":\"en\",\"bhiet-namais\":\"vi\",\"bulgarais\":\"bg\",\"cnan nan tidh\":\"th\",\"catalanais\":\"ca\",\"coiranais\":\"ko\",\"crtheol haidhti\":\"ht\",\"crthaisis\":\"hr\",\"cuimris\":\"cy\",\"crdais (kurmanji)\":\"ku\",\"duitsis\":\"nl\",\"eabhra\":\"he\",\"eadailtis\":\"it\",\"eastoinis\":\"et\",\"fionnlannais\":\"fi\",\"fraingis\":\"fr\",\"gidhlig\":\"gd\",\"gailsis\":\"gl\",\"gearmailtis\":\"de\",\"grigis\":\"el\",\"hindis\":\"hi\",\"innd-innsis\":\"id\",\"innis-tlis\":\"is\",\"laideann\":\"la\",\"laitbheis\":\"lv\",\"liotuainis\":\"lt\",\"malaidhis\":\"ms\",\"mori\":\"mi\",\"masadonais\":\"mk\",\"minmar (burmais)\":\"my\",\"mongolais\":\"mn\",\"nirribhis\":\"nb\",\"plainnis\":\"pl\",\"portagailis\":\"pt\",\"rominis\":\"ro\",\"ruisis\":\"ru\",\"seacais\":\"cs\",\"seapanais\":\"ja\",\"sirbis\":\"sr\",\"sonais (seann-nsach)\":\"zh-tw\",\"sonais (smplichte)\":\"zh-cn\",\"slbhacais\":\"sk\",\"slbhainis\":\"sl\",\"spinntis\":\"es\",\"suainis\":\"sv\",\"turcais\":\"tr\",\"ucrinis\":\"uk\",\"ungairis\":\"hu\",\"usbagais\":\"uz\",\"farsi\":\"fa\",\"galisisk\":\"gl\",\"gresk\":\"el\",\"hviterussisk\":\"be\",\"kinesisk (tradisjonell)\":\"zh-tw\",\"kreol (haiti)\":\"ht\",\"latvisk\":\"lv\",\"malayisk\":\"ms\",\"nederlandsk\":\"nl\",\"rumensk\":\"ro\",\"tsjekkisk\":\"cs\",\"albanisch\":\"sq\",\"armenisch\":\"hy\",\"aserbaidschanisch\":\"az\",\"birmanisch\":\"my\",\"bulgarisch\":\"bg\",\"chinesisch (traditionell)\":\"zh-tw\",\"chinesisch (vereinfacht)\":\"zh-cn\",\"dnisch\":\"da\",\"deutsch\":\"de\",\"englisch\":\"en\",\"estnisch\":\"et\",\"finnisch\":\"fi\",\"franzsisch\":\"fr\",\"galizisch\":\"gl\",\"griechisch\":\"el\",\"haitianisch\":\"ht\",\"hebrisch\":\"he\",\"irisch\":\"ga\",\"islndisch\":\"is\",\"italienisch\":\"it\",\"japanisch\":\"ja\",\"katalanisch\":\"ca\",\"koreanisch\":\"ko\",\"kurdisch (kurmandschi)\":\"ku\",\"lateinisch\":\"la\",\"lettisch\":\"lv\",\"litauisch\":\"lt\",\"malaysisch\":\"ms\",\"maltesisch\":\"mt\",\"mazedonisch\":\"mk\",\"mongolisch\":\"mn\",\"niederlndisch\":\"nl\",\"norwegisch\":\"nb\",\"persisch\":\"fa\",\"polnisch\":\"pl\",\"portugiesisch\":\"pt\",\"rumnisch\":\"ro\",\"schottisch-glisch\":\"gd\",\"schwedisch\":\"sv\",\"serbisch\":\"sr\",\"slowakisch\":\"sk\",\"slowenisch\":\"sl\",\"spanisch\":\"es\",\"thailndisch\":\"th\",\"tschechisch\":\"cs\",\"trkisch\":\"tr\",\"ukrainisch\":\"uk\",\"ungarisch\":\"hu\",\"usbekisch\":\"uz\",\"vietnamesisch\":\"vi\",\"walisisch\":\"cy\",\"weirussisch\":\"be\",\"\":\"kn\",\" ()\":\"ku\",\"\":\"ko\",\"\":\"ca\",\"\":\"hr\",\"\":\"cs\",\"\":\"el\",\"\":\"gl\",\"\":\"ja\",\"\":\"de\",\" \":\"gd\",\"\":\"es\",\"\":\"sl\",\"\":\"sk\",\"\":\"sr\",\"\":\"sv\",\"\":\"zu\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"tr\",\"\":\"te\",\"\":\"th\",\"\":\"nl\",\"\":\"da\",\"\":\"nb\",\"\":\"fa\",\"\":\"pt\",\"\":\"pl\",\"\":\"fr\",\"\":\"fi\",\"\":\"vi\",\"\":\"eu\",\"\":\"bg\",\"\":\"be\",\"\":\"ml\",\"\":\"ms\",\"\":\"mr\",\"\":\"mi\",\"\":\"mt\",\"\":\"mk\",\" ()\":\"my\",\"\":\"mn\",\"\":\"uk\",\"\":\"ru\",\"\":\"ro\",\"\":\"la\",\"\":\"lt\",\"\":\"lv\",\"\":\"cy\",\"\":\"he\",\" \":\"ht\",\"\":\"hi\",\"\":\"hu\",\"\":\"az\",\"\":\"hy\",\"\":\"ar\",\"\":\"it\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"is\",\"\":\"en\",\"\":\"id\",\"\":\"ga\",\"\":\"am\",\"\":\"sq\",\"\":\"uz\",\"\":\"uk\",\"\":\"az\",\"\":\"it\",\"\":\"id\",\"\":\"is\",\"\":\"ga\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"et\",\"\":\"eo\",\"\":\"hy\",\"\":\"eu\",\"\":\"bg\",\"\":\"my\",\"\":\"be\",\"\":\"gl\",\"\":\"de\",\"\":\"da\",\"\":\"nl\",\"\":\"hu\",\"\":\"hi\",\"\":\"cy\",\"\":\"vi\",\"\":\"zu\",\"\":\"tr\",\"\":\"te\",\"\":\"el\",\"\":\"ja\",\"\":\"ku\",\"\":\"lv\",\"\":\"la\",\"\":\"lt\",\"\":\"mi\",\"\":\"ml\",\"\":\"ms\",\"\":\"mr\",\"\":\"mn\",\"\":\"mt\",\"\":\"mk\",\"\":\"nb\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"sl\",\"\":\"sk\",\"\":\"es\",\" \":\"gd\",\"\":\"sr\",\"\":\"he\",\"\":\"ar\",\"\":\"pl\",\"\":\"pt\",\"\":\"fi\",\"\":\"fa\",\"'\":\"cs\",\"\":\"fr\",\"\":\"kn\",\"\":\"ko\",\"\":\"ca\",\"\":\"hr\",\" \":\"ht\",\"\":\"ro\",\"\":\"ru\",\"\":\"sv\",\"\":\"th\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"eu\",\"\":\"be\",\"\":\"bg\",\"\":\"my\",\"\":\"cy\",\"\":\"vi\",\"\":\"gl\",\"\":\"de\",\"\":\"el\",\"\":\"da\",\"\":\"hy\",\"\":\"et\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"it\",\"\":\"ja\",\"\":\"kn\",\"\":\"ca\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ko\",\"\":\"ku\",\"\":\"lv\",\"\":\"la\",\"\":\"lt\",\"\":\"mk\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mi\",\"\":\"mr\",\"\":\"mn\",\"\":\"nb\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"ro\",\"\":\"ru\",\"\":\"sk\",\"\":\"sl\",\"\":\"sr\",\"\":\"th\",\"\":\"te\",\"\":\"tr\",\"\":\"uz\",\"\":\"uk\",\"\":\"hu\",\"\":\"fi\",\"\":\"fr\",\" \":\"ht\",\"\":\"he\",\"\":\"hi\",\"\":\"nl\",\"\":\"hr\",\"\":\"cs\",\"\":\"sv\",\" \":\"gd\",\"\":\"es\",\"\":\"az\",\"\":\"am\",\"\":\"ar\",\"\":\"hy\",\"\":\"sq\",\"\":\"en\",\"\":\"id\",\"\":\"it\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"ga\",\"\":\"is\",\"\":\"kn\",\"\":\"ku\",\"\":\"ko\",\"\":\"ca\",\"\":\"hr\",\"\":\"gl\",\"\":\"el\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ja\",\"\":\"de\",\"\":\"zu\",\"\":\"cs\",\"\":\"tr\",\"\":\"nl\",\"\":\"da\",\"\":\"te\",\"\":\"th\",\"\":\"nb\",\"\":\"pt\",\"\":\"pl\",\"\":\"fa\",\"\":\"fi\",\"\":\"fr\",\"\":\"my\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"mn\",\"\":\"mr\",\"\":\"ms\",\"\":\"ml\",\"\":\"mt\",\"\":\"mi\",\"\":\"mk\",\"\":\"uk\",\"\":\"ru\",\"\":\"ro\",\"\":\"lt\",\"\":\"la\",\"\":\"lv\",\"\":\"vi\",\"\":\"cy\",\"\":\"sr\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"hu\",\" \":\"ht\",\"\":\"hi\",\"\":\"he\",\"\":\"am\",\"\":\"hy\",\"\":\"sq\",\"\":\"az\",\"\":\"ar\",\"\":\"id\",\"\":\"en\",\"\":\"it\",\"\":\"uk\",\"\":\"uz\",\"\":\"eo\",\"\":\"et\",\"\":\"is\",\"\":\"ga\",\"\":\"kn\",\"\":\"ca\",\"\":\"ku\",\"\":\"ko\",\"\":\"hr\",\"\":\"gl\",\"\":\"el\",\"\":\"cs\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"de\",\"\":\"ja\",\"\":\"tr\",\"\":\"nl\",\"\":\"da\",\"\":\"th\",\"\":\"te\",\"\":\"nb\",\"\":\"fa\",\"\":\"pt\",\"\":\"pl\",\"\":\"fi\",\"\":\"fr\",\"\":\"my\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"mn\",\"\":\"ml\",\"\":\"ms\",\"\":\"mr\",\"\":\"mk\",\"\":\"mt\",\"\":\"mi\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"vi\",\"\":\"cy\",\"\":\"zu\",\"\":\"sr\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"hu\",\"\":\"hi\",\"\":\"he\",\" \":\"ht\",\"\":\"ru\",\"\":\"ro\",\"albnina\":\"sq\",\"amharina\":\"am\",\"arabina\":\"ar\",\"armnina\":\"hy\",\"azerbajdanina\":\"az\",\"barmina\":\"my\",\"bielorutina\":\"be\",\"bulharina\":\"bg\",\"ntina (tradin)\":\"zh-tw\",\"dnina\":\"da\",\"estnina\":\"et\",\"fnina\":\"fi\",\"francztina\":\"fr\",\"galcijina\":\"gl\",\"grtina\":\"el\",\"haitsk kreolina\":\"ht\",\"hebrejina\":\"he\",\"hindina\":\"hi\",\"holandina\":\"nl\",\"chorvtina\":\"hr\",\"indonztina\":\"id\",\"rina\":\"ga\",\"islandina\":\"is\",\"japonina\":\"ja\",\"kannadina\":\"kn\",\"katalnina\":\"ca\",\"krejina\":\"ko\",\"kurdina\":\"ku\",\"latinina\":\"la\",\"litovina\":\"lt\",\"macednina\":\"mk\",\"maarina\":\"hu\",\"malajmina\":\"ml\",\"malajina\":\"ms\",\"maltina\":\"mt\",\"maorijina\":\"mi\",\"maratina\":\"mr\",\"mongolina\":\"mn\",\"nemina\":\"de\",\"nrina\":\"nb\",\"perztina\":\"fa\",\"potina\":\"pl\",\"portugalina\":\"pt\",\"rumunina\":\"ro\",\"slovenina\":\"sk\",\"slovinina\":\"sl\",\"srbina\":\"sr\",\"ktska gaelina\":\"gd\",\"panielina\":\"es\",\"vdina\":\"sv\",\"talianina\":\"it\",\"telugina\":\"te\",\"thajina\":\"th\",\"ukrajinina\":\"uk\",\"vietnamina\":\"vi\",\"waletina\":\"cy\",\"zulutina\":\"zu\",\"isi-albania\":\"sq\",\"isi-amharic\":\"am\",\"isi-arabic\":\"ar\",\"isi-armenian\":\"hy\",\"isi-azerbaijani\":\"az\",\"isi-basque\":\"eu\",\"isi-belarusian\":\"be\",\"isi-bulgarian\":\"bg\",\"isi-burmese\":\"my\",\"isi-catalan\":\"ca\",\"isi-chinese (simplified)\":\"zh-cn\",\"isi-chinese (traditional)\":\"zh-tw\",\"isi-croatian\":\"hr\",\"isi-czech\":\"cs\",\"isi-danish\":\"da\",\"isi-dutch\":\"nl\",\"isi-english\":\"en\",\"isi-esperanto\":\"eo\",\"isi-estonian\":\"et\",\"isi-finnish\":\"fi\",\"isi-french\":\"fr\",\"isi-galician\":\"gl\",\"isi-german\":\"de\",\"isi-greek\":\"el\",\"isi-haitian creole\":\"ht\",\"isi-hangarian\":\"hu\",\"isi-hebrew\":\"he\",\"isi-hindi\":\"hi\",\"isi-icelandic\":\"is\",\"isi-indonesian\":\"id\",\"isi-irish\":\"ga\",\"isi-italian\":\"it\",\"isi-japanese\":\"ja\",\"isi-kannada\":\"kn\",\"isi-korean\":\"ko\",\"isi-kurdish\":\"ku\",\"isi-latin\":\"la\",\"isi-latvian\":\"lv\",\"isi-lithuanian\":\"lt\",\"isi-macedonian\":\"mk\",\"isi-malay\":\"ms\",\"isi-malayalam\":\"ml\",\"isi-maltese\":\"mt\",\"isi-maori\":\"mi\",\"isi-marathi\":\"mr\",\"isi-mongolian\":\"mn\",\"isi-norwegian\":\"nb\",\"isi-persian\":\"fa\",\"isi-polish\":\"pl\",\"isi-portuguese\":\"pt\",\"isi-romanian\":\"ro\",\"isi-russian\":\"ru\",\"isi-scots gaelic\":\"gd\",\"isi-serbian\":\"sr\",\"isi-slovak\":\"sk\",\"isi-slovenian\":\"sl\",\"isi-spanish\":\"es\",\"isi-swedish\":\"sv\",\"isi-telugu\":\"te\",\"isi-thai\":\"th\",\"isi-turkish\":\"tr\",\"isi-ukrainian\":\"uk\",\"isi-uzbek\":\"uz\",\"isi-vietnamese\":\"vi\",\"isi-welsh\":\"cy\",\"isizulu\":\"zu\",\"albania\":\"sq\",\"armenia\":\"hy\",\"azerbaijan\":\"az\",\"belanda\":\"nl\",\"belarus\":\"be\",\"bulgaria\":\"bg\",\"cina (mudah)\":\"zh-cn\",\"cina (tradisional)\":\"zh-tw\",\"croatia\":\"hr\",\"denmark\":\"da\",\"estonia\":\"et\",\"finland\":\"fi\",\"gaelic scotland\":\"gd\",\"galicia\":\"gl\",\"hungary\":\"hu\",\"ibrani\":\"he\",\"iceland\":\"is\",\"indonesia\":\"id\",\"inggeris\":\"en\",\"ireland\":\"ga\",\"itali\":\"it\",\"jepun\":\"ja\",\"jerman\":\"de\",\"korea\":\"ko\",\"kreol haiti\":\"ht\",\"kurdistan\":\"ku\",\"latvia\":\"lv\",\"lithuania\":\"lt\",\"macedonia\":\"mk\",\"malta\":\"mt\",\"melayu\":\"ms\",\"mongolia\":\"mn\",\"myanmar\":\"my\",\"norway\":\"nb\",\"parsi\":\"fa\",\"perancis\":\"fr\",\"poland\":\"pl\",\"portugis\":\"pt\",\"romania\":\"ro\",\"rusia\":\"ru\",\"sepanyol\":\"es\",\"serbia\":\"sr\",\"slovenia\":\"sl\",\"sweden\":\"sv\",\"turki\":\"tr\",\"ukraine\":\"uk\",\"vietnam\":\"vi\",\"wales\":\"cy\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"hy\",\"\":\"eu\",\"\":\"be\",\"\":\"my\",\"\":\"bg\",\"\":\"cy\",\"\":\"hu\",\"\":\"vi\",\"\":\"gl\",\"\":\"el\",\"\":\"da\",\"\":\"he\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"ca\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"ko\",\" ()\":\"ht\",\"\":\"ku\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"mk\",\"\":\"ms\",\"\":\"mt\",\"\":\"mi\",\"\":\"mn\",\"\":\"de\",\"\":\"nl\",\"\":\"nb\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"ro\",\"\":\"ru\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"th\",\"\":\"tr\",\"\":\"uz\",\"\":\"uk\",\"\":\"fi\",\"\":\"fr\",\"\":\"hi\",\"\":\"hr\",\"\":\"cs\",\"\":\"sv\",\" ()\":\"gd\",\"\":\"eo\",\"\":\"et\",\"\":\"ja\",\"albaski\":\"sq\",\"amharski\":\"am\",\"angielski\":\"en\",\"arabski\":\"ar\",\"azerski\":\"az\",\"baskijski\":\"eu\",\"biaoruski\":\"be\",\"birmaski\":\"my\",\"bugarski\":\"bg\",\"chiski (tradycyjny)\":\"zh-tw\",\"chiski (uproszczony)\":\"zh-cn\",\"chorwacki\":\"hr\",\"czeski\":\"cs\",\"duski\":\"da\",\"estoski\":\"et\",\"fiski\":\"fi\",\"francuski\":\"fr\",\"galicyjski\":\"gl\",\"grecki\":\"el\",\"hebrajski\":\"he\",\"hiszpaski\":\"es\",\"indonezyjski\":\"id\",\"irlandzki\":\"ga\",\"islandzki\":\"is\",\"japoski\":\"ja\",\"kataloski\":\"ca\",\"koreaski\":\"ko\",\"kreolski (haiti)\":\"ht\",\"kurdyjski\":\"ku\",\"litewski\":\"lt\",\"aciski\":\"la\",\"otewski\":\"lv\",\"macedoski\":\"mk\",\"malajalam\":\"ml\",\"malajski\":\"ms\",\"maltaski\":\"mt\",\"mongolski\":\"mn\",\"niderlandzki\":\"nl\",\"niemiecki\":\"de\",\"norweski\":\"nb\",\"ormiaski\":\"hy\",\"perski\":\"fa\",\"polski\":\"pl\",\"portugalski\":\"pt\",\"rosyjski\":\"ru\",\"rumuski\":\"ro\",\"serbski\":\"sr\",\"sowacki\":\"sk\",\"soweski\":\"sl\",\"szkocki gaelicki\":\"gd\",\"szwedzki\":\"sv\",\"tajski\":\"th\",\"turecki\":\"tr\",\"ukraiski\":\"uk\",\"uzbecki\":\"uz\",\"walijski\":\"cy\",\"wgierski\":\"hu\",\"wietnamski\":\"vi\",\"woski\":\"it\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"hy\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"'\":\"vi\",\"\":\"cy\",\"\":\"hu\",\" \":\"ht\",\"\":\"nl\",\"\":\"gl\",\"\":\"el\",\"\":\"da\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"he\",\"\":\"ko\",\"\":\"ca\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\" ()\":\"ku\",\"\":\"lv\",\"\":\"la\",\"\":\"lt\",\"' ()\":\"my\",\"\":\"mi\",\"\":\"mk\",\"\":\"ms\",\"\":\"mt\",\"\":\"mn\",\"\":\"nb\",\"\":\"de\",\"\":\"pt\",\"\":\"fa\",\"\":\"pl\",\"\":\"ro\",\"\":\"ru\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"th\",\"\":\"tr\",\"\":\"te\",\"\":\"uz\",\"\":\"uk\",\"\":\"fi\",\"\":\"fr\",\"\":\"hr\",\"\":\"hi\",\"\":\"cs\",\" \":\"gd\",\"\":\"sv\",\"\":\"eo\",\"\":\"et\",\"\":\"ja\",\"amarikisht\":\"am\",\"anglisht\":\"en\",\"arabisht\":\"ar\",\"armenisht\":\"hy\",\"azerisht\":\"az\",\"baskisht\":\"eu\",\"birmanisht\":\"my\",\"bjellorusisht\":\"be\",\"bullgarisht\":\"bg\",\"ekisht\":\"cs\",\"danisht\":\"da\",\"estonisht\":\"et\",\"finlandisht\":\"fi\",\"frngjisht\":\"fr\",\"galicianisht\":\"gl\",\"galishte skoceze\":\"gd\",\"greqisht\":\"el\",\"gjermanisht\":\"de\",\"hebraisht\":\"he\",\"hindisht\":\"hi\",\"holandisht\":\"nl\",\"hungarisht\":\"hu\",\"indonezisht\":\"id\",\"irlandisht\":\"ga\",\"islandisht\":\"is\",\"italisht\":\"it\",\"japonisht\":\"ja\",\"kanada\":\"kn\",\"katalonisht\":\"ca\",\"kinezisht (e thjeshtuar)\":\"zh-cn\",\"kinezisht (tradicionale)\":\"zh-tw\",\"koreanisht\":\"ko\",\"kreolishte haitiane\":\"ht\",\"kroatisht\":\"hr\",\"latinisht\":\"la\",\"letonisht\":\"lv\",\"lituanisht\":\"lt\",\"malajalamisht\":\"ml\",\"malajzisht\":\"ms\",\"malteze\":\"mt\",\"maorisht\":\"mi\",\"maqedonisht\":\"mk\",\"maratisht\":\"mr\",\"mongolisht\":\"mn\",\"norvegjisht\":\"nb\",\"persisht\":\"fa\",\"polonisht\":\"pl\",\"portugalisht\":\"pt\",\"rumanisht\":\"ro\",\"rusisht\":\"ru\",\"serbisht\":\"sr\",\"sllovakisht\":\"sk\",\"sllovenisht\":\"sl\",\"spanjisht\":\"es\",\"suedisht\":\"sv\",\"shqip\":\"sq\",\"tajlandisht\":\"th\",\"telugisht\":\"te\",\"turqisht\":\"tr\",\"uellsisht\":\"cy\",\"ukrainisht\":\"uk\",\"uzbekisht\":\"uz\",\"vietnamisht\":\"vi\",\"\":\"hu\",\"\":\"hi\",\"\":\"lt\",\"\":\"la\",\"\":\"lv\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mr\",\"\":\"mi\",\"\":\"mk\",\"\":\"mn\",\"\":\"ru\",\"\":\"ro\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"es\",\"\":\"my\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"vi\",\"\":\"tr\",\"\":\"th\",\"\":\"te\",\"   ()\":\"zh-cn\",\"  ()\":\"zh-tw\",\"\":\"cs\",\"\":\"nb\",\"\":\"sq\",\"\":\"am\",\"\":\"hy\",\"\":\"az\",\"\":\"ga\",\"\":\"is\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"id\",\"\":\"en\",\"\":\"ku\",\"\":\"ca\",\"\":\"kn\",\"\":\"hr\",\"\":\"ko\",\"\":\"cy\",\"\":\"ar\",\"\":\"he\",\"\":\"zu\",\" \":\"ht\",\" \":\"gd\",\"\":\"uk\",\"\":\"nl\",\"\":\"da\",\"\":\"de\",\"\":\"ja\",\"\":\"gl\",\"\":\"el\",\"\":\"it\",\"\":\"fr\",\"\":\"fi\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"alban\":\"sq\",\"alman\":\"de\",\"amarikc\":\"am\",\"azrbaycan dili\":\"az\",\"bask\":\"eu\",\"belarusca\":\"be\",\"bolqar\":\"bg\",\"ex\":\"cs\",\"in (n'nvi)\":\"zh-tw\",\"in (sadldirilmi)\":\"zh-cn\",\"danimarka\":\"da\",\"ermni\":\"hy\",\"eston\":\"et\",\"rb\":\"ar\",\"fars dili\":\"fa\",\"fin\":\"fi\",\"fransz\":\"fr\",\"haiti kreol dili\":\"ht\",\"hind\":\"hi\",\"xorvat\":\"hr\",\"ispan\":\"es\",\"indoneziya\":\"id\",\"ingilis\":\"en\",\"irland\":\"ga\",\"island\":\"is\",\"isve\":\"sv\",\"italyan\":\"it\",\"ivrit\":\"he\",\"katalan\":\"ca\",\"koreya\":\"ko\",\"krd dili (kurmanci)\":\"ku\",\"qalisian\":\"gl\",\"latn\":\"la\",\"lat\":\"lv\",\"litva\":\"lt\",\"macar\":\"hu\",\"makedoniya\":\"mk\",\"maoric\":\"mi\",\"monqolca\":\"mn\",\"myanma (birma) dili\":\"my\",\"norve\":\"nb\",\"zbk\":\"uz\",\"polyak\":\"pl\",\"portuqal\":\"pt\",\"rumn\":\"ro\",\"rus\":\"ru\",\"serb\":\"sr\",\"sloven\":\"sl\",\"otland (kelt)\":\"gd\",\"tayca\":\"th\",\"teluqu\":\"te\",\"trk\":\"tr\",\"uels\":\"cy\",\"ukrayna\":\"uk\",\"vyetnam\":\"vi\",\"yapon\":\"ja\",\"yunan\":\"el\",\"zulu dili\":\"zu\",\"albani\":\"sq\",\"amari\":\"am\",\"armen\":\"hy\",\"aerbajani\":\"az\",\"belarussu\":\"be\",\"bulgaru\":\"bg\",\"ek\":\"cs\",\"ini (semplifikat)\":\"zh-cn\",\"ini (tradizzjonali)\":\"zh-tw\",\"creole haiti\":\"ht\",\"dani\":\"da\",\"ebrajk\":\"he\",\"estonjan\":\"et\",\"finlandi\":\"fi\",\"frani\":\"fr\",\"appuni\":\"ja\",\"ermani\":\"de\",\"gaelic tal-iskoii\":\"gd\",\"galizjan\":\"gl\",\"grieg\":\"el\",\"garbi\":\"ar\",\"indi\":\"hi\",\"indonejan\":\"id\",\"ingli\":\"en\",\"irlandi\":\"ga\",\"islandi\":\"is\",\"kroat\":\"hr\",\"kurd (kurmanji)\":\"ku\",\"latvjan\":\"lv\",\"litwen\":\"lt\",\"maedonjan\":\"mk\",\"malasjan\":\"ms\",\"malti\":\"mt\",\"marati\":\"mr\",\"mjanmar (burma)\":\"my\",\"mongoljan\":\"mn\",\"norvei\":\"nb\",\"olandi\":\"nl\",\"persjan\":\"fa\",\"pollakk\":\"pl\",\"portugi\":\"pt\",\"rumen\":\"ro\",\"russu\":\"ru\",\"slovakk\":\"sk\",\"spanjol\":\"es\",\"svedi\":\"sv\",\"tajlandi\":\"th\",\"taljan\":\"it\",\"tork\":\"tr\",\"ukren\":\"uk\",\"ungeri\":\"hu\",\"ubek\":\"uz\",\"vjetnami\":\"vi\",\"ulu\":\"zu\",\"albanski\":\"sq\",\"amharik\":\"am\",\"arapski\":\"ar\",\"armenijski\":\"hy\",\"azerbajdanski\":\"az\",\"bjeloruski\":\"be\",\"bugarski\":\"bg\",\"burmanski\":\"my\",\"eki\":\"cs\",\"danski\":\"da\",\"engleski\":\"en\",\"estonski\":\"et\",\"finski\":\"fi\",\"galski\":\"gl\",\"grki\":\"el\",\"haiansko-kreolski\":\"ht\",\"hebrejski\":\"he\",\"hindu\":\"hi\",\"hrvatski\":\"hr\",\"indonezijski\":\"id\",\"irski\":\"ga\",\"islandski\":\"is\",\"japanski\":\"ja\",\"katalonski\":\"ca\",\"kineski (pojednost.)\":\"zh-cn\",\"kineski (tradicionalni)\":\"zh-tw\",\"korejski\":\"ko\",\"kurdski\":\"ku\",\"latinski\":\"la\",\"latvijski/letonski\":\"lv\",\"litvanski\":\"lt\",\"maarski\":\"hu\",\"makedonski\":\"mk\",\"malezijski\":\"ms\",\"malteki\":\"mt\",\"nizozemski\":\"nl\",\"norveki\":\"nb\",\"njemaki\":\"de\",\"perzijski\":\"fa\",\"poljski\":\"pl\",\"rumunjski\":\"ro\",\"ruski\":\"ru\",\"slovaki\":\"sk\",\"slovenski\":\"sl\",\"srpski\":\"sr\",\"kotski keltski\":\"gd\",\"panjolski\":\"es\",\"vedski\":\"sv\",\"tajlandski\":\"th\",\"talijanski\":\"it\",\"turski\":\"tr\",\"ukrajinski\":\"uk\",\"uzbekistanski\":\"uz\",\"velki\":\"cy\",\"vijetnamski\":\"vi\",\"\":\"az\",\"\":\"sq\",\"\":\"de\",\"\":\"hy\",\"\":\"uz\",\"\":\"es\",\"\":\"eo\",\"\":\"et\",\"\":\"sk\",\"\":\"sl\",\"\":\"uk\",\"\":\"am\",\"\":\"id\",\"\":\"en\",\"\":\"it\",\"\":\"ga\",\"\":\"is\",\"\":\"eu\",\"\":\"my\",\"\":\"be\",\"\":\"bg\",\"\":\"pt\",\"\":\"th\",\" \":\"tr\",\"\":\"te\",\"\":\"cs\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"da\",\"\":\"ru\",\"\":\"ro\",\"\":\"zu\",\"\":\"ja\",\"\":\"sv\",\"\":\"sr\",\"\":\"he\",\"\":\"ar\",\"\":\"fa\",\"\":\"fr\",\"\":\"fi\",\"\":\"ca\",\"\":\"kn\",\" \":\"ht\",\"\":\"ku\",\"\":\"hr\",\"\":\"ko\",\"\":\"gl\",\" \":\"gd\",\"\":\"la\",\"\":\"lv\",\"\":\"pl\",\"\":\"lt\",\"\":\"mi\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"hu\",\"\":\"mr\",\"\":\"mn\",\"\":\"mk\",\"\":\"nb\",\"\":\"cy\",\"\":\"vi\",\"\":\"nl\",\"\":\"hi\",\"\":\"el\",\"ahepaitani\":\"az\",\"airihi\":\"ga\",\"amariki\":\"am\",\"amniana\":\"hy\",\"arapeinia\":\"sq\",\"arapi\":\"ar\",\"epernato\":\"eo\",\"etnia\":\"et\",\"haina (onamata)\":\"zh-tw\",\"hainamana (kua whakammtia)\":\"zh-cn\",\"hanekeria\":\"hu\",\"hapanihi\":\"ja\",\"herepia\":\"sr\",\"hinerangi\":\"fi\",\"hni\":\"hi\",\"hiperu\":\"he\",\"horowkia\":\"sk\",\"horowinia\":\"sl\",\"huitene\":\"sv\",\"huru\":\"zu\",\"ingarihi\":\"en\",\"initonhia\":\"id\",\"itriana\":\"it\",\"kanata\":\"kn\",\"karihia\":\"gl\",\"katarna\":\"ca\",\"kereore haiti\":\"ht\",\"kiriki\":\"el\",\"kreana\":\"ko\",\"korotiana\":\"hr\",\"korukoru\":\"tr\",\"krihi\":\"ku\",\"makernia\":\"mk\",\"mratihi\":\"mt\",\"marei\":\"ms\",\"mareiarama\":\"ml\",\"mongriana\":\"mn\",\"nwei\":\"nb\",\"pkihi\":\"eu\",\"pniora\":\"es\",\"pma (purumhi)\":\"my\",\"peraruhia\":\"be\",\"perhia\":\"fa\",\"prana\":\"pl\",\"potukhi\":\"pt\",\"purukriana\":\"bg\",\"rtini\":\"la\",\"rwhiana\":\"lv\",\"ritunia\":\"lt\",\"romnia\":\"ro\",\"rhia\":\"ru\",\"tai\":\"th\",\"tati\":\"nl\",\"tenemka\":\"da\",\"teruku\":\"te\",\"tiamana\":\"de\",\"tieke\":\"cs\",\"tiorangi\":\"is\",\"tuauri kotarangi\":\"gd\",\"uhipeke\":\"uz\",\"kareiana\":\"uk\",\"wra\":\"cy\",\"whitinmu\":\"vi\",\"ww\":\"fr\",\"\":\"en\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"ar\",\"\":\"hy\",\"\":\"eu\",\"\":\"vi\",\"\":\"my\",\"\":\"bg\",\" \":\"gd\",\"\":\"gl\",\"\":\"fr\",\"\":\"de\",\"\":\"da\",\"\":\"he\",\"\":\"el\",\"\":\"et\",\"\":\"eo\",\"\":\"zu\",\"\":\"ja\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"kn\",\"\":\"ca\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ko\",\"\":\"ku\",\" \":\"ht\",\"\":\"hr\",\"\":\"la\",\"\":\"lv\",\"\":\"be\",\"\":\"lt\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mi\",\"\":\"mr\",\"\":\"mn\",\"\":\"nb\",\"\":\"nl\",\"\":\"cy\",\"\":\"hu\",\"\":\"uz\",\"\":\"uk\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"ro\",\"\":\"ru\",\"\":\"sr\",\"\":\"mk\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"th\",\"\":\"te\",\"\":\"tr\",\"\":\"cs\",\"\":\"fi\",\"\":\"hi\",\"amxar\":\"am\",\"arman\":\"hy\",\"bolgar\":\"bg\",\"dat\":\"da\",\"fors\":\"fa\",\"fransuz\":\"fr\",\"gaiti-kreol\":\"ht\",\"galisiy\":\"gl\",\"golland\":\"nl\",\"grek\":\"el\",\"ibroniy\":\"he\",\"indonez\":\"id\",\"ingliz\":\"en\",\"irland\":\"ga\",\"island\":\"is\",\"italyan\":\"it\",\"koreys\":\"ko\",\"kurd (kurmonji)\":\"ku\",\"latish\":\"lv\",\"lotin\":\"la\",\"makedon\":\"mk\",\"maltiy\":\"mt\",\"maratxi\":\"mr\",\"mogul\":\"mn\",\"nemis\":\"de\",\"norveg\":\"nb\",\"ozarbayjon\":\"az\",\"portugal\":\"pt\",\"rumin\":\"ro\",\"tay\":\"th\",\"turk\":\"tr\",\"ukrain\":\"uk\",\"valliy\":\"cy\",\"venger\":\"hu\",\"xitoy (ananaviy)\":\"zh-tw\",\"xitoy (soddalashgan)\":\"zh-cn\",\"ozbek\":\"uz\",\"shotland-gel\":\"gd\",\"shved\":\"sv\",\"chex\":\"cs\",\"albanska\":\"sq\",\"amharsku\":\"am\",\"arabska\":\"ar\",\"armenska\":\"hy\",\"aserska\":\"az\",\"baskneska\":\"eu\",\"blgarska\":\"bg\",\"brmska\":\"my\",\"danska\":\"da\",\"eistneska\":\"et\",\"enska\":\"en\",\"esperant\":\"eo\",\"finnska\":\"fi\",\"franska\":\"fr\",\"galisska\":\"gl\",\"grska\":\"el\",\"hatskt krelaml\":\"ht\",\"hebreska\":\"he\",\"hind\":\"hi\",\"hollenska\":\"nl\",\"hvtrssneska\":\"be\",\"indnesska\":\"id\",\"rska\":\"ga\",\"slenska\":\"is\",\"talska\":\"it\",\"japanska\":\"ja\",\"katalnska\":\"ca\",\"knverska (einfldu)\":\"zh-cn\",\"knverska (hefbundin)\":\"zh-tw\",\"kreska\":\"ko\",\"kratska\":\"hr\",\"krdska\":\"ku\",\"latna\":\"la\",\"lettneska\":\"lv\",\"lithska\":\"lt\",\"makednska\":\"mk\",\"malajska\":\"ms\",\"maltneska\":\"mt\",\"maorska\":\"mi\",\"marat\":\"mr\",\"monglska\":\"mn\",\"norska\":\"nb\",\"persneska\":\"fa\",\"portgalska\":\"pt\",\"plska\":\"pl\",\"rmenska\":\"ro\",\"rssneska\":\"ru\",\"serbneska\":\"sr\",\"skosk-gelska\":\"gd\",\"slvakska\":\"sk\",\"slvenska\":\"sl\",\"spnska\":\"es\",\"sl\":\"zu\",\"snska\":\"sv\",\"talenska\":\"th\",\"tkkneska\":\"cs\",\"tyrkneska\":\"tr\",\"ungverska\":\"hu\",\"kranska\":\"uk\",\"sbekska\":\"uz\",\"velska\":\"cy\",\"vetnamska\":\"vi\",\"ska\":\"de\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"eu\",\"\":\"be\",\"\":\"my\",\"\":\"bg\",\"\":\"gl\",\"\":\"de\",\"\":\"da\",\"\":\"he\",\"\":\"zu\",\"\":\"eo\",\"\":\"et\",\"\":\"th\",\"\":\"tr\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"la\",\"\":\"lv\",\"\":\"pl\",\"\":\"lt\",\"\":\"hr\",\"\":\"kn\",\"\":\"ca\",\" \":\"gd\",\"\":\"ko\",\" ()\":\"ht\",\"\":\"hy\",\"\":\"hi\",\"\":\"nl\",\"\":\"el\",\"\":\"hu\",\"\":\"ja\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mk\",\"\":\"mi\",\"\":\"mr\",\"\":\"mn\",\"\":\"nb\",\"\":\"sv\",\"\":\"uz\",\"\":\"uk\",\"\":\"cs\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"fa\",\"\":\"pt\",\"\":\"ro\",\"\":\"ru\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"cy\",\"\":\"vi\",\"\":\"te\",\" ()\":\"ku\",\"\":\"fi\",\"\":\"fr\",\"arabia\":\"ar\",\"baski\":\"eu\",\"burma\":\"my\",\"englanti\":\"en\",\"espanja\":\"es\",\"haitinkreoli\":\"ht\",\"heprea\":\"he\",\"hollanti\":\"nl\",\"iiri\":\"ga\",\"islanti\":\"is\",\"italia\":\"it\",\"japani\":\"ja\",\"katalaani\":\"ca\",\"kiina (perinteinen)\":\"zh-tw\",\"kiina (yksinkert.)\":\"zh-cn\",\"kreikka\":\"el\",\"kroatia\":\"hr\",\"kurdi\":\"ku\",\"kymri\":\"cy\",\"liettua\":\"lt\",\"makedonia\":\"mk\",\"malaiji\":\"ms\",\"norja\":\"nb\",\"persia\":\"fa\",\"portugali\":\"pt\",\"puola\":\"pl\",\"ranska\":\"fr\",\"ruotsi\":\"sv\",\"saksa\":\"de\",\"skottigaeli\":\"gd\",\"slovakia\":\"sk\",\"suomi\":\"fi\",\"tanska\":\"da\",\"tsekki\":\"cs\",\"turkki\":\"tr\",\"ukraina\":\"uk\",\"unkari\":\"hu\",\"uzbekki\":\"uz\",\"valkovenj\":\"be\",\"venj\":\"ru\",\"viro\":\"et\",\"albaniera\":\"sq\",\"alemana\":\"de\",\"amharera\":\"am\",\"arabiera\":\"ar\",\"armeniera\":\"hy\",\"azerbaijanera\":\"az\",\"bielorrusiera\":\"be\",\"birmaniera\":\"my\",\"bulgariera\":\"bg\",\"daniera\":\"da\",\"errumaniera\":\"ro\",\"errusiera\":\"ru\",\"eskoziako gaelera\":\"gd\",\"eslovakiera\":\"sk\",\"esloveniera\":\"sl\",\"esperantoa\":\"eo\",\"estoniera\":\"et\",\"euskara\":\"eu\",\"frantsesa\":\"fr\",\"gaelera\":\"cy\",\"galiziera\":\"gl\",\"gaztelania\":\"es\",\"greziera\":\"el\",\"hebreera\":\"he\",\"hindia\":\"hi\",\"hungariera\":\"hu\",\"indonesiera\":\"id\",\"ingelesa\":\"en\",\"irlandera\":\"ga\",\"islandiera\":\"is\",\"italiera\":\"it\",\"japoniera\":\"ja\",\"katalana\":\"ca\",\"koreera\":\"ko\",\"kreolera (haiti)\":\"ht\",\"kroaziera\":\"hr\",\"kurduera\":\"ku\",\"letoniera\":\"lv\",\"lituaniera\":\"lt\",\"malabarera\":\"ml\",\"malaysiera\":\"ms\",\"maltera\":\"mt\",\"maoriera\":\"mi\",\"marathera\":\"mr\",\"mazedoniera\":\"mk\",\"mongoliera\":\"mn\",\"nederlandera\":\"nl\",\"norvegiera\":\"nb\",\"persiera\":\"fa\",\"poloniera\":\"pl\",\"portugesa\":\"pt\",\"serbiera\":\"sr\",\"suediera\":\"sv\",\"suomiera\":\"fi\",\"telugua\":\"te\",\"thaiera\":\"th\",\"turkiera\":\"tr\",\"txekiera\":\"cs\",\"txinera (soildua)\":\"zh-cn\",\"txinera (tradizionala)\":\"zh-tw\",\"ukrainera\":\"uk\",\"uzbekera\":\"uz\",\"vietnamera\":\"vi\",\"zuluera\":\"zu\",\"albans\":\"sq\",\"alemany\":\"de\",\"amhric\":\"am\",\"angls\":\"en\",\"rab\":\"ar\",\"armeni\":\"hy\",\"zeri\":\"az\",\"basc\":\"eu\",\"bielors\":\"be\",\"birm\":\"my\",\"blgar\":\"bg\",\"castell\":\"es\",\"catal\":\"ca\",\"core\":\"ko\",\"crioll d'hait\":\"ht\",\"croat\":\"hr\",\"dans\":\"da\",\"eslovac\":\"sk\",\"eslov\":\"sl\",\"estoni\":\"et\",\"fins\":\"fi\",\"francs\":\"fr\",\"galic escocs\":\"gd\",\"gallec\":\"gl\",\"galls\":\"cy\",\"hebreu\":\"he\",\"hongars\":\"hu\",\"indonesi\":\"id\",\"irlands\":\"ga\",\"islands\":\"is\",\"itali\":\"it\",\"japons\":\"ja\",\"let\":\"lv\",\"litu\":\"lt\",\"llat\":\"la\",\"macednic\":\"mk\",\"malai\":\"ms\",\"malailam\":\"ml\",\"malts\":\"mt\",\"neerlands\":\"nl\",\"noruec\":\"nb\",\"polons\":\"pl\",\"portugus\":\"pt\",\"romans\":\"ro\",\"serbi\":\"sr\",\"suec\":\"sv\",\"txec\":\"cs\",\"ucrans\":\"uk\",\"xins (simplificat)\":\"zh-cn\",\"xins (tradicional)\":\"zh-tw\",\"albu\":\"sq\",\"amharu\":\"am\",\"angu\":\"en\",\"arbu\":\"ar\",\"armu\":\"hy\",\"azerbaidu\":\"az\",\"baltkrievu\":\"be\",\"basku\":\"eu\",\"birmieu\":\"my\",\"bulgru\":\"bg\",\"ehu\":\"cs\",\"du\":\"da\",\"ebreju (ivrits)\":\"he\",\"franu\":\"fr\",\"galisieu\":\"gl\",\"grieu\":\"el\",\"holandieu\":\"nl\",\"horvtu\":\"hr\",\"igauu\":\"et\",\"indonzieu\":\"id\",\"ru\":\"ga\",\"slandieu\":\"is\",\"itu\":\"it\",\"japu\":\"ja\",\"katalu\":\"ca\",\"korejieu\":\"ko\",\"kreolu (haiti)\":\"ht\",\"krievu\":\"ru\",\"kurdu\":\"ku\",\"nieu (tradicionl)\":\"zh-tw\",\"nieu (vienkrot)\":\"zh-cn\",\"latu\":\"la\",\"latvieu\":\"lv\",\"lietuvieu\":\"lt\",\"maedonieu\":\"mk\",\"malajalamieu\":\"ml\",\"malajieu\":\"ms\",\"maltieu\":\"mt\",\"maratu\":\"mr\",\"mongou\":\"mn\",\"norvu\":\"nb\",\"persieu\":\"fa\",\"pou\":\"pl\",\"portugu\":\"pt\",\"rumu\":\"ro\",\"serbu\":\"sr\",\"skotu glu\":\"gd\",\"slovku\":\"sk\",\"slovu\":\"sl\",\"somu\":\"fi\",\"spu\":\"es\",\"taju\":\"th\",\"turku\":\"tr\",\"ukraiu\":\"uk\",\"ungru\":\"hu\",\"uzbeku\":\"uz\",\"vcu\":\"de\",\"velsieu\":\"cy\",\"vjetnamieu\":\"vi\",\"zviedru\":\"sv\",\"belarussia\":\"be\",\"cek\":\"cs\",\"china (aks. sederhana)\":\"zh-cn\",\"china (aks. tradisional)\":\"zh-tw\",\"finlandia\":\"fi\",\"gaelig\":\"ga\",\"gaelik skotlandia\":\"gd\",\"galisia\":\"gl\",\"inggris\":\"en\",\"islan\":\"is\",\"jepang\":\"ja\",\"katala\":\"ca\",\"lituania\":\"lt\",\"polandia\":\"pl\",\"prancis\":\"fr\",\"rumania\":\"ro\",\"swensk\":\"sv\",\"yunani\":\"el\",\"\":\"az\",\"\":\"hy\",\"\":\"sq\",\"\":\"en\",\"\":\"am\",\"\":\"ar\",\"\":\"id\",\"\":\"it\",\"\":\"uz\",\"\":\"eo\",\"\":\"et\",\"\":\"ga\",\" \":\"is\",\"\":\"kn\",\"\":\"ku\",\"\":\"ko\",\"\":\"ca\",\"\":\"hr\",\"\":\"gl\",\"\":\"el\",\"\":\"cs\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ja\",\"\":\"de\",\"\":\"zu\",\"\":\"tr\",\"\":\"nl\",\"\":\"da\",\"\":\"te\",\"\":\"th\",\"\":\"nb\",\"\":\"fa\",\"\":\"pt\",\"\":\"pl\",\"\":\"fi\",\"\":\"fr\",\"\":\"my\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"mn\",\"\":\"mi\",\"\":\"mr\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mk\",\"\":\"uk\",\"\":\"ru\",\"\":\"ro\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"vi\",\"\":\"cy\",\"\":\"sr\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"hu\",\"\":\"hi\",\"\":\"he\",\" \":\"ht\",\"amhrico\":\"am\",\"azer\":\"az\",\"chino (simplificado)\":\"zh-cn\",\"chino (tradicional)\":\"zh-tw\",\"criollo haitiano\":\"ht\",\"dans\":\"da\",\"estonio\":\"et\",\"euskera\":\"eu\",\"finlands\":\"fi\",\"gallego\":\"gl\",\"griego\":\"el\",\"japons\":\"ja\",\"kurdo\":\"ku\",\"malayo\":\"ms\",\"noruego\":\"nb\",\"rumano\":\"ro\",\"uzbeco\":\"uz\",\"albaania\":\"sq\",\"amhaari\":\"am\",\"araabia\":\"ar\",\"armeenia\":\"hy\",\"aserbaidaani\":\"az\",\"birma\":\"my\",\"bulgaaria\":\"bg\",\"eesti\":\"et\",\"galeegi\":\"gl\",\"haitikreooli\":\"ht\",\"heebrea\":\"he\",\"hispaania\":\"es\",\"hollandi\":\"nl\",\"horvaadi\":\"hr\",\"indoneesia\":\"id\",\"inglise\":\"en\",\"islandi\":\"is\",\"itaalia\":\"it\",\"jaapani\":\"ja\",\"kreeka\":\"el\",\"ladina\":\"la\",\"leedu\":\"lt\",\"lihtsustatud hiina\":\"zh-cn\",\"lti\":\"lv\",\"makedoonia\":\"mk\",\"malajalaami\":\"ml\",\"maoori\":\"mi\",\"mongoli\":\"mn\",\"norra\":\"nb\",\"poola\":\"pl\",\"prantsuse\":\"fr\",\"prsia\":\"fa\",\"rootsi\":\"sv\",\"rumeenia\":\"ro\",\"slovaki\":\"sk\",\"sloveeni\":\"sl\",\"soome\":\"fi\",\"suulu\":\"zu\",\"oti\":\"gd\",\"taani\":\"da\",\"traditsiooniline hiina\":\"zh-tw\",\"tehhi\":\"cs\",\"trgi\":\"tr\",\"uelsi\":\"cy\",\"ungari\":\"hu\",\"usbeki\":\"uz\",\"valgevene\":\"be\",\"vene\":\"ru\",\"albanyen\":\"sq\",\"amenyen\":\"hy\",\"angl\":\"en\",\"azbajani\":\"az\",\"belarisyen\":\"be\",\"bilgaryen\":\"bg\",\"chinwa (senp)\":\"zh-cn\",\"chinwa (tradisyonl)\":\"zh-tw\",\"danwa\":\"da\",\"ebre\":\"he\",\"endonezyen\":\"id\",\"endou\":\"hi\",\"estonyen\":\"et\",\"fenland\":\"fi\",\"franse\":\"fr\",\"gaelik ekos\":\"gd\",\"galisyen\":\"gl\",\"grk\":\"el\",\"ikrenyen\":\"uk\",\"iland\":\"ga\",\"island\":\"is\",\"italyen\":\"it\",\"izbk\":\"uz\",\"japon\":\"ja\",\"koreyen\":\"ko\",\"kreyl ayisyen\":\"ht\",\"kurde (kurmandji)\":\"ku\",\"kwoasyen\":\"hr\",\"laten\":\"la\",\"letonyen\":\"lv\",\"lityanyen\":\"lt\",\"mal\":\"ms\",\"malt\":\"mt\",\"masedonyen\":\"mk\",\"mongolyen\":\"mn\",\"myanma (burmese)\":\"my\",\"nvejyen\":\"nb\",\"oland, neyland\":\"nl\",\"onngaryen\":\"hu\",\"panyl\":\"es\",\"psyen\":\"fa\",\"polon\":\"pl\",\"ptig\":\"pt\",\"ris\":\"ru\",\"romanyen\":\"ro\",\"sb\":\"sr\",\"slovenyen\":\"sl\",\"syedwa\":\"sv\",\"tuk\":\"tr\",\"tyk\":\"cs\",\"vyetnamyen\":\"vi\",\"albaneg\":\"sq\",\"almaeneg\":\"de\",\"arabeg\":\"ar\",\"armeneg\":\"hy\",\"aserbaijaneg\":\"az\",\"basgeg\":\"eu\",\"belarwseg\":\"be\",\"bwlgaraidd\":\"bg\",\"catalaneg\":\"ca\",\"creol haiti\":\"ht\",\"croateg\":\"hr\",\"cymraeg\":\"cy\",\"cyrdeg (kurmandji)\":\"ku\",\"daneg\":\"da\",\"eidaleg\":\"it\",\"estoneg\":\"et\",\"fietnameg\":\"vi\",\"ffineg\":\"fi\",\"fflemeg\":\"nl\",\"ffrangeg\":\"fr\",\"gaeleg yr alban\":\"gd\",\"galisaidd\":\"gl\",\"groeg\":\"el\",\"gwyddeleg\":\"ga\",\"hebraeg\":\"he\",\"hwngareg\":\"hu\",\"iaith corea\":\"ko\",\"indonesieg\":\"id\",\"islandeg\":\"is\",\"iwcraineg\":\"uk\",\"japaneg\":\"ja\",\"latfieg\":\"lv\",\"lithwaneg\":\"lt\",\"lladin\":\"la\",\"macedoneg\":\"mk\",\"malteseg\":\"mt\",\"mongoleg\":\"mn\",\"myanmar (byrma)\":\"my\",\"norwyeg\":\"nb\",\"perseg\":\"fa\",\"portiwgaleg\":\"pt\",\"pwyleg\":\"pl\",\"rwmaneg\":\"ro\",\"rwsieg\":\"ru\",\"saesneg\":\"en\",\"sbaeneg\":\"es\",\"serbeg\":\"sr\",\"slofac\":\"sk\",\"slofenia\":\"sl\",\"swedeg\":\"sv\",\"swlw\":\"zu\",\"tsieceg\":\"cs\",\"tsieineeg (traddodiadol)\":\"zh-tw\",\"tsieineeg (wedi symleiddio)\":\"zh-cn\",\"twrceg\":\"tr\",\"usbec\":\"uz\",\"\":\"en\",\"\":\"az\",\"\":\"sq\",\"\":\"is\",\"\":\"hy\",\"\":\"it\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"am\",\"\":\"kn\",\" ()\":\"ku\",\"\":\"ca\",\"\":\"gl\",\" ()\":\"zh-tw\",\"\":\"cs\",\"\":\"ja\",\"\":\"zu\",\"\":\"da\",\"\":\"tr\",\"\":\"te\",\"\":\"pt\",\"\":\"fi\",\"\":\"fr\",\"\":\"my\",\"\":\"bg\",\"\":\"be\",\"\":\"eu\",\"\":\"ml\",\"\":\"mi\",\"\":\"mt\",\"\":\"mk\",\"\":\"uk\",\"\":\"ru\",\"\":\"ro\",\"\":\"lv\",\"\":\"la\",\"\":\"vi\",\"\":\"sr\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"hu\",\"\":\"he\",\" \":\"ht\",\"\":\"sq\",\"\":\"ar\",\"\":\"am\",\"\":\"az\",\"\":\"ga\",\"\":\"et\",\"\":\"eu\",\"\":\"be\",\"\":\"bg\",\"\":\"is\",\"\":\"pl\",\"\":\"fa\",\"\":\"da\",\"\":\"de\",\"\":\"ru\",\"\":\"fr\",\"\":\"fi\",\"\":\"ht\",\"\":\"ko\",\"\":\"nl\",\"\":\"gl\",\"\":\"ca\",\"\":\"cs\",\"\":\"kn\",\"\":\"hr\",\"\":\"ku\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"ro\",\"\":\"mt\",\"\":\"mr\",\"\":\"ml\",\"\":\"ms\",\"\":\"mk\",\"\":\"mi\",\"\":\"mn\",\"\":\"my\",\"\":\"zu\",\"\":\"nb\",\"\":\"pt\",\"\":\"ja\",\"\":\"sv\",\"\":\"sr\",\"\":\"eo\",\"\":\"sk\",\"\":\"sl\",\"\":\"gd\",\"\":\"te\",\"\":\"th\",\"\":\"tr\",\"\":\"cy\",\"\":\"uk\",\"\":\"uz\",\"\":\"es\",\"\":\"he\",\"\":\"el\",\"\":\"hu\",\"\":\"hy\",\"\":\"it\",\"\":\"hi\",\"\":\"id\",\"\":\"en\",\"\":\"vi\",\"()\":\"zh-tw\",\"()\":\"zh-cn\",\"\":\"az\",\"\":\"en\",\"\":\"ar\",\"\":\"hy\",\"\":\"eu\",\"\":\"be\",\"\":\"my\",\"\":\"bg\",\"\":\"gl\",\"\":\"el\",\"\":\"da\",\"\":\"id\",\"\":\"ga\",\"\":\"es\",\"\":\"it\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ko\",\"\":\"ku\",\"\":\"lv\",\"\":\"lt\",\"\":\"ms\",\"\":\"mt\",\"\":\"de\",\"\":\"nl\",\"\":\"nb\",\"\":\"fa\",\"\":\"ro\",\"\":\"sk\",\"\":\"sl\",\"\":\"sr\",\"\":\"th\",\"\":\"cy\",\"\":\"uz\",\"\":\"fi\",\"\":\"fr\",\" \":\"ht\",\"\":\"hr\",\" \":\"gd\",\"\":\"ja\",\"\":\"is\",\"\":\"az\",\"\":\"hy\",\"\":\"es\",\"\":\"eo\",\"\":\"et\",\" \":\"gd\",\"\":\"sq\",\"\":\"de\",\"\":\"am\",\"\":\"en\",\"\":\"id\",\"\":\"uz\",\"\":\"uk\",\"\":\"ga\",\"\":\"it\",\"\":\"eu\",\"\":\"pt\",\"\":\"bg\",\"\":\"my\",\"\":\"pl\",\"\":\"be\",\"\":\"th\",\"\":\"tr\",\"\":\"cs\",\"\":\"te\",\"\":\"gl\",\"\":\"da\",\"\":\"ru\",\"\":\"ro\",\"\":\"zu\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"sr\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"he\",\"\":\"ar\",\"\":\"fa\",\"\":\"fr\",\"\":\"fi\",\"\":\"vi\",\"\":\"ca\",\"\":\"kn\",\"\":\"ku\",\"\":\"hr\",\"\":\"ko\",\"\":\"lv\",\"\":\"la\",\"  \":\"ht\",\"\":\"lt\",\"\":\"ml\",\"\":\"mt\",\"\":\"mi\",\"\":\"mk\",\"\":\"ms\",\"\":\"mn\",\"\":\"mr\",\"\":\"nb\",\"\":\"hi\",\"\":\"hu\",\"\":\"nl\",\"\":\"cy\",\"\":\"ja\",\"\":\"el\",\"\":\"eu\",\"\":\"vi\",\"\":\"gl\",\"\":\"en\",\"\":\"id\",\"\":\"ja\",\"\":\"hy\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\" ()\":\"ht\",\"\":\"lv\",\"\":\"hu\",\"\":\"mr\",\"\":\"de\",\"\":\"fa\",\"\":\"pl\",\"\":\"ro\",\"\":\"sl\",\"\":\"th\",\"\":\"uk\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"hy\",\"\":\"eu\",\"\":\"be\",\"\":\"my\",\"\":\"bg\",\"\":\"vi\",\" \":\"ht\",\"\":\"gl\",\"\":\"gd\",\"\":\"de\",\"\":\"nl\",\"\":\"el\",\"\":\"da\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"ca\",\"\":\"he\",\"\":\"ku\",\"\":\"lv\",\"\":\"la\",\"\":\"lt\",\"\":\"mk\",\"\":\"ms\",\"\":\"ml\",\"\":\"mt\",\"\":\"mn\",\"\":\"nb\",\"\":\"ru\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"ro\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"ko\",\"\":\"th\",\"\":\"tr\",\"\":\"te\",\"\":\"uz\",\"\":\"uk\",\"\":\"hu\",\"\":\"cy\",\"\":\"fi\",\"\":\"fr\",\"\":\"hr\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"cs\",\"\":\"sv\",\"\":\"et\",\"\":\"ja\",\"amhariska\":\"am\",\"arabiska\":\"ar\",\"armeniska\":\"hy\",\"azerbajdzjanska\":\"az\",\"baskiska\":\"eu\",\"bulgariska\":\"bg\",\"burmesiska\":\"my\",\"engelska\":\"en\",\"estniska\":\"et\",\"finska\":\"fi\",\"gaeliska\":\"gd\",\"galiciska\":\"gl\",\"grekiska\":\"el\",\"haitiska\":\"ht\",\"hebreiska\":\"he\",\"indonesiska\":\"id\",\"irlndska\":\"ga\",\"islndska\":\"is\",\"italienska\":\"it\",\"kanaresiska\":\"kn\",\"katalanska\":\"ca\",\"kinesiska (frenklad)\":\"zh-cn\",\"kinesiska (traditionell)\":\"zh-tw\",\"koreanska\":\"ko\",\"kroatiska\":\"hr\",\"kurdiska\":\"ku\",\"lettiska\":\"lv\",\"litauiska\":\"lt\",\"makedonska\":\"mk\",\"malaysiska\":\"ms\",\"maltesiska\":\"mt\",\"mongoliska\":\"mn\",\"nederlndska\":\"nl\",\"persiska\":\"fa\",\"polska\":\"pl\",\"portugisiska\":\"pt\",\"rumnska\":\"ro\",\"ryska\":\"ru\",\"serbiska\":\"sr\",\"slovakiska\":\"sk\",\"slovenska\":\"sl\",\"spanska\":\"es\",\"svenska\":\"sv\",\"thailndska\":\"th\",\"tjeckiska\":\"cs\",\"turkiska\":\"tr\",\"tyska\":\"de\",\"ukrainska\":\"uk\",\"ungerska\":\"hu\",\"uzbekiska\":\"uz\",\"vietnamesiska\":\"vi\",\"vitryska\":\"be\",\"walesiska\":\"cy\",\"albanez\":\"sq\",\"amharic\":\"am\",\"arab\":\"ar\",\"armean\":\"hy\",\"azerbaidjan\":\"az\",\"basc\":\"eu\",\"bielorus\":\"be\",\"birman\":\"my\",\"bulgar\":\"bg\",\"catalan\":\"ca\",\"ceh\":\"cs\",\"chinez (simplificat)\":\"zh-cn\",\"chinez (tradiional)\":\"zh-tw\",\"coreean\":\"ko\",\"creol haitian\":\"ht\",\"croat\":\"hr\",\"danez\":\"da\",\"ebraic\":\"he\",\"englez\":\"en\",\"eston\":\"et\",\"finlandez\":\"fi\",\"francez\":\"fr\",\"galez\":\"cy\",\"galica scoian\":\"gd\",\"galician\":\"gl\",\"german\":\"de\",\"greac\":\"el\",\"indonezian\":\"id\",\"irlandez\":\"ga\",\"islandez\":\"is\",\"italian\":\"it\",\"japonez\":\"ja\",\"kurd\":\"ku\",\"latin\":\"la\",\"leton\":\"lv\",\"lituanian\":\"lt\",\"macedonean\":\"mk\",\"maghiar\":\"hu\",\"malaez\":\"ms\",\"maltez\":\"mt\",\"mongol\":\"mn\",\"neerlandez\":\"nl\",\"norvegian\":\"nb\",\"persan\":\"fa\",\"polonez\":\"pl\",\"portughez\":\"pt\",\"romn\":\"ro\",\"rus\":\"ru\",\"srb\":\"sr\",\"slovac\":\"sk\",\"sloven\":\"sl\",\"spaniol\":\"es\",\"suedez\":\"sv\",\"thailandez\":\"th\",\"turc\":\"tr\",\"ucrainean\":\"uk\",\"uzbec\":\"uz\",\"vietnamez\":\"vi\",\"airi\":\"ga\",\"alban\":\"sq\",\"amhar\":\"am\",\"angl\":\"en\",\"arab\":\"ar\",\"armn\":\"hy\",\"azerbaidaniei\":\"az\",\"baltarusi\":\"be\",\"bask\":\"eu\",\"birmiei\":\"my\",\"bulgar\":\"bg\",\"ek\":\"cs\",\"dan\":\"da\",\"est\":\"et\",\"galis\":\"gl\",\"graik\":\"el\",\"haiio kreol\":\"ht\",\"hebraj\":\"he\",\"indoneziei\":\"id\",\"island\":\"is\",\"ispan\":\"es\",\"ital\":\"it\",\"japon\":\"ja\",\"kanad\":\"kn\",\"kataloniei\":\"ca\",\"kin (supaprastinta)\":\"zh-cn\",\"kin (tradicin)\":\"zh-tw\",\"korjiei\":\"ko\",\"kroat\":\"hr\",\"kurd\":\"ku\",\"latvi\":\"lv\",\"lenk\":\"pl\",\"lietuvi\":\"lt\",\"lotyn\":\"la\",\"makedoniei\":\"mk\",\"malajali\":\"ml\",\"malajiei\":\"ms\",\"maltiei\":\"mt\",\"maori\":\"mi\",\"marat\":\"mr\",\"mongol\":\"mn\",\"norveg\":\"nb\",\"oland\":\"nl\",\"pers\":\"fa\",\"portugal\":\"pt\",\"prancz\":\"fr\",\"rumun\":\"ro\",\"rus\":\"ru\",\"serb\":\"sr\",\"slovak\":\"sk\",\"slovn\":\"sl\",\"suomi\":\"fi\",\"kot (gl)\":\"gd\",\"ved\":\"sv\",\"taj\":\"th\",\"telug\":\"te\",\"turk\":\"tr\",\"ukrainiei\":\"uk\",\"uzbek\":\"uz\",\"val\":\"cy\",\"vengr\":\"hu\",\"vietnamiei\":\"vi\",\"vokiei\":\"de\",\"zulus\":\"zu\",\"\":\"gl\",\"\":\"el\",\"\":\"nl\",\"\":\"nb\",\"\":\"da\",\"\":\"de\",\"\":\"lv\",\"\":\"la\",\"\":\"ru\",\"\":\"ro\",\"\":\"lt\",\"\":\"mr\",\"\":\"mi\",\"\":\"mk\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mn\",\" ()\":\"my\",\"\":\"eu\",\"\":\"vi\",\"\":\"be\",\"\":\"bg\",\"\":\"sr\",\"\":\"sv\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"ar\",\"\":\"hy\",\"\":\"is\",\" \":\"ht\",\"\":\"ga\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"et\",\"\":\"eo\",\"\":\"en\",\"\":\"uz\",\"\":\"uk\",\"\":\"cy\",\"\":\"it\",\"\":\"id\",\"\":\"ja\",\"\":\"zu\",\"()\":\"zh-cn\",\"()\":\"zh-tw\",\"\":\"cs\",\"\":\"ca\",\"\":\"kn\",\"\":\"ku\",\"\":\"hr\",\"\":\"th\",\"\":\"tr\",\"\":\"te\",\"\":\"fa\",\"\":\"pt\",\"\":\"pl\",\"\":\"fr\",\"\":\"fi\",\"\":\"ko\",\"\":\"hu\",\"\":\"he\",\"\":\"hi\",\"albanese\":\"sq\",\"amarico\":\"am\",\"arabo\":\"ar\",\"armeno\":\"hy\",\"azero\":\"az\",\"bielorusso\":\"be\",\"bulgaro\":\"bg\",\"catalano\":\"ca\",\"ceco\":\"cs\",\"cinese (semplificato)\":\"zh-cn\",\"cinese (tradizionale)\":\"zh-tw\",\"creolo haitiano\":\"ht\",\"croato\":\"hr\",\"curdo (kurmanji)\":\"ku\",\"danese\":\"da\",\"ebraico\":\"he\",\"estone\":\"et\",\"finlandese\":\"fi\",\"francese\":\"fr\",\"gaelico scozzese\":\"gd\",\"galiziano\":\"gl\",\"gallese\":\"cy\",\"giapponese\":\"ja\",\"greco\":\"el\",\"indonesiano\":\"id\",\"inglese\":\"en\",\"irlandese\":\"ga\",\"islandese\":\"is\",\"latino\":\"la\",\"lettone\":\"lv\",\"macedone\":\"mk\",\"malese\":\"ms\",\"mongolo\":\"mn\",\"norvegese\":\"nb\",\"olandese\":\"nl\",\"persiano\":\"fa\",\"polacco\":\"pl\",\"portoghese\":\"pt\",\"rumeno\":\"ro\",\"serbo\":\"sr\",\"slovacco\":\"sk\",\"sloveno\":\"sl\",\"spagnolo\":\"es\",\"svedese\":\"sv\",\"tailandese\":\"th\",\"tedesco\":\"de\",\"ucraino\":\"uk\",\"ungherese\":\"hu\",\"quc t ng\":\"eo\",\"ting  rp\":\"ar\",\"ting albania\":\"sq\",\"ting amharic\":\"am\",\"ting anh\":\"en\",\"ting armenia\":\"hy\",\"ting azerbaijan\":\"az\",\"ting ba lan\":\"pl\",\"ting ba t\":\"fa\",\"ting basque\":\"eu\",\"ting belarus\":\"be\",\"ting b o nha\":\"pt\",\"ting bulgaria\":\"bg\",\"ting catalan\":\"ca\",\"ting creole  haiti\":\"ht\",\"ting croatia\":\"hr\",\"ting do thi\":\"he\",\"ting an mch\":\"da\",\"ting c\":\"de\",\"ting estonia\":\"et\",\"ting gael scotland\":\"gd\",\"ting galicia\":\"gl\",\"ting h lan\":\"nl\",\"ting hn\":\"ko\",\"ting hindi\":\"hi\",\"ting hungary\":\"hu\",\"ting hy lp\":\"el\",\"ting iceland\":\"is\",\"ting indonesia\":\"id\",\"ting ireland\":\"ga\",\"ting kannada\":\"kn\",\"ting kurd\":\"ku\",\"ting latinh\":\"la\",\"ting latvia\":\"lv\",\"ting litva\":\"lt\",\"ting m lai\":\"ms\",\"ting macedonia\":\"mk\",\"ting malayalam\":\"ml\",\"ting malta\":\"mt\",\"ting maori\":\"mi\",\"ting marathi\":\"mr\",\"ting mng c\":\"mn\",\"ting myanmar\":\"my\",\"ting na uy\":\"nb\",\"ting nga\":\"ru\",\"ting nht\":\"ja\",\"ting php\":\"fr\",\"ting phn lan\":\"fi\",\"ting rumani\":\"ro\",\"ting sc\":\"cs\",\"ting serbia\":\"sr\",\"ting slovak\":\"sk\",\"ting slovenia\":\"sl\",\"ting ty ban nha\":\"es\",\"ting telugu\":\"te\",\"ting thi\":\"th\",\"ting th nh k\":\"tr\",\"ting thy in\":\"sv\",\"ting trung (gian th)\":\"zh-cn\",\"ting trung (phn th)\":\"zh-tw\",\"ting ukraina\":\"uk\",\"ting uzbek\":\"uz\",\"ting vit\":\"vi\",\"ting x wales\":\"cy\",\"ting \":\"it\",\"ting zulu\":\"zu\",\"\":\"ja\"},\"scratchToGoogleMap\":{\"zh-cn\":\"zh\",\"nb\":\"no\",\"he\":\"iw\",\"es-419\":\"es\",\"pt-br\":\"pt\",\"ja-hira\":\"ja\"},\"previouslySupported\":[\"ab\",\"ms\",\"be\",\"eo\",\"hy\",\"hi\",\"kn\",\"ht\",\"ku\",\"la\",\"mk\",\"ml\",\"mt\",\"mr\",\"mn\",\"my\",\"nn\",\"sq\",\"te\",\"uz\"],\"spokenLanguages\":{\"en\":[{\"code\":\"zh-cn\",\"name\":\"Chinese (Mandarin)\"}],\"cy\":[{\"code\":\"zh-cn\",\"name\":\"Tsieineaidd (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portiwgaleg (Brasil)\"},{\"code\":\"es-419\",\"name\":\"Sbaeneg (America Ladin)\"}],\"zu\":[{\"code\":\"zh-cn\",\"name\":\"IsiShayina (isiMandarin)\"},{\"code\":\"hi\",\"name\":\"IsiHindi\"},{\"code\":\"pt-br\",\"name\":\"IsiPutukezi (saseBrazil)\"},{\"code\":\"es-419\",\"name\":\"ISpanishi (Latin American)\"}],\"ko\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\" \"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"az\":[{\"code\":\"zh-cn\",\"name\":\"in (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portuqal (Braziliya)\"},{\"code\":\"es-419\",\"name\":\"span (Latn Amerikas)\"}],\"he\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"mk\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"am\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"mr\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"cs\":[{\"code\":\"zh-cn\",\"name\":\"ntina (mandarinka)\"},{\"code\":\"hi\",\"name\":\"hindtina\"},{\"code\":\"pt-br\",\"name\":\"Portugaltina (brazilsk)\"},{\"code\":\"es-419\",\"name\":\"panltina (latinskoamerick)\"}],\"zh-cn\":[{\"code\":\"zh-cn\",\"name\":\"\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\"\"},{\"code\":\"es-419\",\"name\":\"\"}],\"la\":[{\"code\":\"zh-cn\",\"name\":\"Seres (Latin)\"},{\"code\":\"hi\",\"name\":\"Hibernica\"},{\"code\":\"pt-br\",\"name\":\"Portuguese (Spanish)\"},{\"code\":\"es-419\",\"name\":\"Hispanica (Latin American)\"}],\"nn\":[{\"code\":\"zh-cn\",\"name\":\"Kinesisk (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisisk (brasiliansk)\"},{\"code\":\"es-419\",\"name\":\"Spansk (latinamerikansk)\"}],\"my\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"ga\":[{\"code\":\"zh-cn\",\"name\":\"Snis (Mandairnis)\"},{\"code\":\"hi\",\"name\":\"Hiondis\"},{\"code\":\"pt-br\",\"name\":\"Portaingilis (Brasale)\"},{\"code\":\"es-419\",\"name\":\"Spinnis (Meirice Laidineach)\"}],\"es\":[{\"code\":\"zh-cn\",\"name\":\"Chino (Mandarn)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasileo)\"},{\"code\":\"es-419\",\"name\":\"Espaol (latinoamericano)\"}],\"nl\":[{\"code\":\"zh-cn\",\"name\":\"Chinees (Mandarijn)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugees (Braziliaans)\"},{\"code\":\"es-419\",\"name\":\"Spaans (Latijns-Amerikaans)\"}],\"zh-tw\":[{\"code\":\"zh-cn\",\"name\":\"\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\"\"},{\"code\":\"es-419\",\"name\":\"\"}],\"pt-br\":[{\"code\":\"zh-cn\",\"name\":\"Mandarim (chins)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasileiro)\"},{\"code\":\"es-419\",\"name\":\"Espanhol (latino-americano)\"}],\"kn\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"uz\":[{\"code\":\"zh-cn\",\"name\":\"Xitoy (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindcha\"},{\"code\":\"pt-br\",\"name\":\"Portugal (Braziliya)\"},{\"code\":\"es-419\",\"name\":\"Ispan (Lotin Amerikasi)\"}],\"ja\":[{\"code\":\"zh-cn\",\"name\":\"\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\"\"},{\"code\":\"es-419\",\"name\":\"\"}],\"is\":[{\"code\":\"zh-cn\",\"name\":\"Knverska (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hind\"},{\"code\":\"pt-br\",\"name\":\"Portgalska (brasilska)\"},{\"code\":\"es-419\",\"name\":\"Spnska (rmnsku-amerska)\"}],\"sk\":[{\"code\":\"zh-cn\",\"name\":\"ntina (mandarnska)\"},{\"code\":\"hi\",\"name\":\"hindina\"},{\"code\":\"pt-br\",\"name\":\"Portugalina (brazlska)\"},{\"code\":\"es-419\",\"name\":\"panielina (latinskoamerick)\"}],\"ht\":[{\"code\":\"zh-cn\",\"name\":\"Chinwa (Mandaren)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Ptig (brezilyen)\"},{\"code\":\"es-419\",\"name\":\"Panyl (Amerik Latin)\"}],\"bg\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"de\":[{\"code\":\"zh-cn\",\"name\":\"Chinesisch (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugiesisch (brasilianisch)\"},{\"code\":\"es-419\",\"name\":\"Spanisch (Lateinamerikanisch)\"}],\"gd\":[{\"code\":\"zh-cn\",\"name\":\"Sneach (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Indeach\"},{\"code\":\"pt-br\",\"name\":\"Portuguese (Brazilian)\"},{\"code\":\"es-419\",\"name\":\"Spinntis (Ameireagaidh Laidinn)\"}],\"et\":[{\"code\":\"zh-cn\",\"name\":\"Hiina (mandariini)\"},{\"code\":\"hi\",\"name\":\"Hindi keel\"},{\"code\":\"pt-br\",\"name\":\"Portugali (Brasiilia)\"},{\"code\":\"es-419\",\"name\":\"Hispaania keel (Ladina-Ameerika)\"}],\"fi\":[{\"code\":\"zh-cn\",\"name\":\"Kiina (mandariini)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugali (brasilia)\"},{\"code\":\"es-419\",\"name\":\"Espanja (Latinalainen Amerikka)\"}],\"ar\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"hu\":[{\"code\":\"zh-cn\",\"name\":\"Knai (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugl (brazil)\"},{\"code\":\"es-419\",\"name\":\"Spanyol (latin-amerikai)\"}],\"mt\":[{\"code\":\"zh-cn\",\"name\":\"ini (Mandarin)\"},{\"code\":\"hi\",\"name\":\"indi\"},{\"code\":\"pt-br\",\"name\":\"Portugi (Brailjan)\"},{\"code\":\"es-419\",\"name\":\"Spanjol (Latin-Amerikan)\"}],\"ro\":[{\"code\":\"zh-cn\",\"name\":\"Chinez (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portughez (brazilian)\"},{\"code\":\"es-419\",\"name\":\"Spaniol (latino-american)\"}],\"fa\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"hi\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"eo\":[{\"code\":\"zh-cn\",\"name\":\"ina (mandarena)\"},{\"code\":\"hi\",\"name\":\"Hinda\"},{\"code\":\"pt-br\",\"name\":\"Portugala (brazila)\"},{\"code\":\"es-419\",\"name\":\"Hispana (latina)\"}],\"lt\":[{\"code\":\"zh-cn\",\"name\":\"Kin (mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugal (Brazilijos)\"},{\"code\":\"es-419\",\"name\":\"Ispan (Lotyn Amerikos)\"}],\"it\":[{\"code\":\"zh-cn\",\"name\":\"Cinese (mandarino)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portoghese (brasiliano)\"},{\"code\":\"es-419\",\"name\":\"Spagnolo (latino-americano)\"}],\"el\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"mi\":[{\"code\":\"zh-cn\",\"name\":\"Hainamana (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Potukua (Brazil)\"},{\"code\":\"es-419\",\"name\":\"Pniora (Latin American)\"}],\"hr\":[{\"code\":\"zh-cn\",\"name\":\"Kineski (mandarinski)\"},{\"code\":\"hi\",\"name\":\"hindski\"},{\"code\":\"pt-br\",\"name\":\"Portugalski (brazilski)\"},{\"code\":\"es-419\",\"name\":\"panjolski (latinoameriki)\"}],\"ca\":[{\"code\":\"zh-cn\",\"name\":\"Xins (mandar)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasiler)\"},{\"code\":\"es-419\",\"name\":\"Espanyol (llatinoameric)\"}],\"th\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"hy\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"id\":[{\"code\":\"zh-cn\",\"name\":\"Mandarin (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugis (Brasil)\"},{\"code\":\"es-419\",\"name\":\"Spanyol (Amerika Latin)\"}],\"eu\":[{\"code\":\"zh-cn\",\"name\":\"Txinera (mandarina)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugesa (brasildarra)\"},{\"code\":\"es-419\",\"name\":\"Espainiera (latinoamerikarra)\"}],\"da\":[{\"code\":\"zh-cn\",\"name\":\"Kinesisk (mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisisk (brasiliansk)\"},{\"code\":\"es-419\",\"name\":\"Spansk (latinamerikansk)\"}],\"ru\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"sr\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"gl\":[{\"code\":\"zh-cn\",\"name\":\"Chins (mandarn)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasileiro)\"},{\"code\":\"es-419\",\"name\":\"Espaol (latinoamericano)\"}],\"lv\":[{\"code\":\"zh-cn\",\"name\":\"nieu (mandarnu)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugu (Brazlijas)\"},{\"code\":\"es-419\",\"name\":\"Spu (latameriku)\"}],\"nb\":[{\"code\":\"zh-cn\",\"name\":\"Kinesisk (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisisk (brasiliansk)\"},{\"code\":\"es-419\",\"name\":\"Spansk (latinamerikansk)\"}],\"tr\":[{\"code\":\"zh-cn\",\"name\":\"in (mandalinas)\"},{\"code\":\"hi\",\"name\":\"Hinte\"},{\"code\":\"pt-br\",\"name\":\"Portekizce (Brezilya)\"},{\"code\":\"es-419\",\"name\":\"spanyolca (Latin Amerika)\"}],\"fr\":[{\"code\":\"zh-cn\",\"name\":\"Mandarin (chinois)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugais (brsilien)\"},{\"code\":\"es-419\",\"name\":\"Espagnol (latino-amricain)\"}],\"sv\":[{\"code\":\"zh-cn\",\"name\":\"Kinesiska (mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisiska (brasilianska)\"},{\"code\":\"es-419\",\"name\":\"Spanska (latinamerikanska)\"}],\"sl\":[{\"code\":\"zh-cn\",\"name\":\"Kitajina (mandarina)\"},{\"code\":\"hi\",\"name\":\"Hindujina\"},{\"code\":\"pt-br\",\"name\":\"Portugalina (brazilska)\"},{\"code\":\"es-419\",\"name\":\"panina (latinskoamerika)\"}],\"ml\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"be\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"pl\":[{\"code\":\"zh-cn\",\"name\":\"Chiski (mandaryski)\"},{\"code\":\"hi\",\"name\":\"hinduski\"},{\"code\":\"pt-br\",\"name\":\"Portugalski (brazylijski)\"},{\"code\":\"es-419\",\"name\":\"Hiszpaski (latynoamerykaski)\"}],\"pt\":[{\"code\":\"zh-cn\",\"name\":\"Mandarim (chins)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasileiro)\"},{\"code\":\"es-419\",\"name\":\"Espanhol (latino-americano)\"}],\"ku\":[{\"code\":\"zh-cn\",\"name\":\"Chinese (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hind\"},{\"code\":\"pt-br\",\"name\":\"Portekz (Brazilian)\"},{\"code\":\"es-419\",\"name\":\"Spanish (Amerkaya Latn)\"}],\"sq\":[{\"code\":\"zh-cn\",\"name\":\"Kinezisht (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugeze (Braziliane)\"},{\"code\":\"es-419\",\"name\":\"Spanjisht (Amerika Latine)\"}],\"ms\":[{\"code\":\"zh-cn\",\"name\":\"Cina (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugis (Brazil)\"},{\"code\":\"es-419\",\"name\":\"Sepanyol (Amerika Latin)\"}],\"vi\":[{\"code\":\"zh-cn\",\"name\":\"Ting trung quc\"},{\"code\":\"hi\",\"name\":\"Ting Hindi\"},{\"code\":\"pt-br\",\"name\":\"B o Nha (Brazil)\"},{\"code\":\"es-419\",\"name\":\"Ty Ban Nha (M Latinh)\"}],\"te\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"uk\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"mn\":[{\"code\":\"zh-cn\",\"name\":\"  ()\"},{\"code\":\"hi\",\"name\":\" \"},{\"code\":\"pt-br\",\"name\":\"  ()\"},{\"code\":\"es-419\",\"name\":\"  ( )\"}],\"es-419\":[{\"code\":\"zh-cn\",\"name\":\"Chino (Mandarn)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasileo)\"},{\"code\":\"es-419\",\"name\":\"Espaol (latinoamericano)\"}],\"ja-hira\":[{\"code\":\"zh-cn\",\"name\":\"\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\"\"},{\"code\":\"es-419\",\"name\":\"\"}]}}");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js?name=extension-worker.js!./src/extension-support/extension-worker.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js?name=extension-worker.js!./src/extension-support/extension-worker.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return new Worker(__webpack_require__.p + "extension-worker.js");
};

/***/ }),

/***/ "./node_modules/xhr/index.js":
/*!***********************************!*\
  !*** ./node_modules/xhr/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var window = __webpack_require__(/*! global/window */ "./node_modules/global/window.js")
var isFunction = __webpack_require__(/*! is-function */ "./node_modules/is-function/index.js")
var parseHeaders = __webpack_require__(/*! parse-headers */ "./node_modules/parse-headers/parse-headers.js")
var xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js")

module.exports = createXHR
// Allow use of default import syntax in TypeScript
module.exports.default = createXHR;
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
    try {
        if (xhr.responseType === "document") {
            return xhr.responseXML
        }
        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
        if (xhr.responseType === "" && !firefoxBugTakenEffect) {
            return xhr.responseXML
        }
    } catch (e) {}

    return null
}

function noop() {}


/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ "./src/dispatch/central-dispatch.js":
/*!******************************************!*\
  !*** ./src/dispatch/central-dispatch.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const SharedDispatch = __webpack_require__(/*! ./shared-dispatch */ "./src/dispatch/shared-dispatch.js");
/**
 * . /. "call""service". The dispatch system will forward function arguments and return values across worker boundaries as needed. 
 * @see {WorkerDispatch}
 */


class CentralDispatch extends SharedDispatch {
  constructor() {
    super();
    /**
     * Map of channel name to worker or local service provider.
     * If the entry is a Worker, the service is provided by an object on that worker.
     * Otherwise, the service is provided locally and methods on the service will be called directly.
     * @see {setService}
     * @type {object.<Worker|object>}
     */

    this.services = {};
    /**
     * The constructor we will use to recognize workers.
     * @type {Function}
     */

    this.workerClass = typeof Worker === "undefined" ? null : Worker;
    /**
     * List of workers attached to this dispatcher.
     * @type {Array}
     */

    this.workers = [];
  }
  /**
   * Synchronously call a particular method on a particular service provided locally.
   * Calling this function on a remote service will fail.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {*} - the return value of the service method.
   */


  callSync(service, method, ...args) {
    const {
      provider,
      isRemote
    } = this._getServiceProvider(service);

    if (provider) {
      if (isRemote) {
        throw new Error(`Cannot use 'callSync' on remote provider for service ${service}.`);
      }

      return provider[method].apply(provider, args);
    }

    throw new Error(`Provider not found for service: ${service}`);
  }
  /**
   * Synchronously set a local object as the global provider of the specified service.
   * WARNING: Any method on the provider can be called from any worker within the dispatch system.
   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.
   * @param {object} provider - a local object which provides this service.
   */


  setServiceSync(service, provider) {
    if (this.services.hasOwnProperty(service)) {
      console.warn(`Central dispatch replacing existing service provider for ${service}`);
    }

    this.services[service] = provider;
  }
  /**
   * Set a local object as the global provider of the specified service.
   * WARNING: Any method on the provider can be called from any worker within the dispatch system.
   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.
   * @param {object} provider - a local object which provides this service.
   * @returns {Promise} - a promise which will resolve once the service is registered.
   */


  setService(service, provider) {
    /** Return a promise for consistency with {@link WorkerDispatch#setService} */
    try {
      this.setServiceSync(service, provider);
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Add a worker to the message dispatch system. The worker must implement a compatible message dispatch framework.
   * The dispatcher will immediately attempt to "handshake" with the worker.
   * @param {Worker} worker - the worker to add into the dispatch system.
   */


  addWorker(worker) {
    if (this.workers.indexOf(worker) === -1) {
      this.workers.push(worker);
      worker.onmessage = this._onMessage.bind(this, worker);

      this._remoteCall(worker, "dispatch", "handshake").catch(e => {
        console.error(`Could not handshake with worker: ${JSON.stringify(e)}`);
      });
    } else {
      console.warn("Central dispatch ignoring attempt to add duplicate worker");
    }
  }
  /**
   * Fetch the service provider object for a particular service name.
   * @override
   * @param {string} service - the name of the service to look up
   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found
   * @protected
   */


  _getServiceProvider(service) {
    const provider = this.services[service];
    return provider && {
      provider,
      isRemote: Boolean(this.workerClass && provider instanceof this.workerClass)
    };
  }
  /**
   * Handle a call message sent to the dispatch service itself
   * @override
   * @param {Worker} worker - the worker which sent the message.
   * @param {DispatchCallMessage} message - the message to be handled.
   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate
   * @protected
   */


  _onDispatchMessage(worker, message) {
    let promise;

    switch (message.method) {
      case "setService":
        promise = this.setService(message.args[0], worker);
        break;

      default:
        console.error(`Central dispatch received message for unknown method: ${message.method}`);
    }

    return promise;
  }

}

module.exports = new CentralDispatch();

/***/ }),

/***/ "./src/dispatch/shared-dispatch.js":
/*!*****************************************!*\
  !*** ./src/dispatch/shared-dispatch.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call
 * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}
 * @property {string} service - the name of the service to be called
 * @property {string} method - the name of the method to be called
 * @property {Array|undefined} args - the arguments to be passed to the method
 */

/**
 * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call
 * @property {*} responseId - a copy of the response ID from the call which generated this response
 * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)
 * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)
 */

/**
 * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage
 * Any message to the dispatch system.
 */

/**
 * SharedDispatch
 * {@link CentralDispatch} and {@link WorkerDispatch}.
 */
class SharedDispatch {
  constructor() {
    /**
     * List of callback registrations for promises waiting for a response from a call to a service on another
     * worker. A callback registration is an array of [resolve,reject] Promise functions.
     * Calls to local services don't enter this list.
     * @type {Array.<Function[]>}
     */
    this.callbacks = [];
    /**
     * The next response ID to be used.
     * @type {int}
     */

    this.nextResponseId = 0;
  }
  /**
   * Call a particular method on a particular service, regardless of whether that service is provided locally or on
   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone
   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be
   * transferred to the worker, and they should not be used after this call.
   * @example
   *      dispatcher.call('vm', 'setData', 'cat', 42);
   *      // this finds the worker for the 'vm' service, then on that worker calls:
   *      vm.setData('cat', 42);
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  call(service, method, ...args) {
    return this.transferCall(service, method, null, ...args);
  }
  /**
   * Call a particular method on a particular service, regardless of whether that service is provided locally or on
   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone
   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be
   * transferred to the worker, and they should not be used after this call.
   * @example
   *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);
   *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:
   *      vm.setData('cat', myArrayBuffer);
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  transferCall(service, method, transfer, ...args) {
    try {
      const {
        provider,
        isRemote
      } = this._getServiceProvider(service);

      if (provider) {
        if (isRemote) {
          return this._remoteTransferCall(provider, service, method, transfer, ...args);
        }

        const result = provider[method].apply(provider, args);
        return Promise.resolve(result);
      }

      return Promise.reject(new Error(`Service not found: ${service}`));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Check if a particular service lives on another worker.
   * @param {string} service - the service to check.
   * @returns {boolean} - true if the service is remote (calls must cross a Worker boundary), false otherwise.
   * @private
   */


  _isRemoteService(service) {
    return this._getServiceProvider(service).isRemote;
  }
  /**
   * Like {@link call}, but force the call to be posted through a particular communication channel.
   * @param {object} provider - send the call through this object's `postMessage` function.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  _remoteCall(provider, service, method, ...args) {
    return this._remoteTransferCall(provider, service, method, null, ...args);
  }
  /**
   * Like {@link transferCall}, but force the call to be posted through a particular communication channel.
   * @param {object} provider - send the call through this object's `postMessage` function.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  _remoteTransferCall(provider, service, method, transfer, ...args) {
    return new Promise((resolve, reject) => {
      const responseId = this._storeCallbacks(resolve, reject);
      /** @TODO: remove this hack! this is just here so we don't try to send `util` to a worker */


      if (args.length > 0 && typeof args[args.length - 1].yield === "function") {
        args.pop();
      }

      if (transfer) {
        provider.postMessage({
          service,
          method,
          responseId,
          args
        }, transfer);
      } else {
        provider.postMessage({
          service,
          method,
          responseId,
          args
        });
      }
    });
  }
  /**
   * Store callback functions pending a response message.
   * @param {Function} resolve - function to call if the service method returns.
   * @param {Function} reject - function to call if the service method throws.
   * @returns {*} - a unique response ID for this set of callbacks. See {@link _deliverResponse}.
   * @protected
   */


  _storeCallbacks(resolve, reject) {
    const responseId = this.nextResponseId++;
    this.callbacks[responseId] = [resolve, reject];
    return responseId;
  }
  /**
   * Deliver call response from a worker. This should only be called as the result of a message from a worker.
   * @param {int} responseId - the response ID of the callback set to call.
   * @param {DispatchResponseMessage} message - the message containing the response value(s).
   * @protected
   */


  _deliverResponse(responseId, message) {
    try {
      const [resolve, reject] = this.callbacks[responseId];
      delete this.callbacks[responseId];

      if (message.error) {
        reject(message.error);
      } else {
        resolve(message.result);
      }
    } catch (e) {
      console.error(`Dispatch callback failed: ${JSON.stringify(e)}`);
    }
  }
  /**
   * Handle a message event received from a connected worker.
   * @param {Worker} worker - the worker which sent the message, or the global object if running in a worker.
   * @param {MessageEvent} event - the message event to be handled.
   * @protected
   */


  _onMessage(worker, event) {
    /** @type {DispatchMessage} */
    const message = event.data;
    message.args = message.args || [];
    let promise;

    if (message.service) {
      if (message.service === "dispatch") {
        promise = this._onDispatchMessage(worker, message);
      } else {
        promise = this.call(message.service, message.method, ...message.args);
      }
    } else if (typeof message.responseId === "undefined") {
      console.error(`Dispatch caught malformed message from a worker: ${JSON.stringify(event)}`);
    } else {
      this._deliverResponse(message.responseId, message);
    }

    if (promise) {
      if (typeof message.responseId === "undefined") {
        console.error(`Dispatch message missing required response ID: ${JSON.stringify(event)}`);
      } else {
        promise.then(result => worker.postMessage({
          responseId: message.responseId,
          result
        }), error => worker.postMessage({
          responseId: message.responseId,
          error
        }));
      }
    }
  }
  /**
   * Fetch the service provider object for a particular service name.
   * @abstract
   * @param {string} service - the name of the service to look up
   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found
   * @protected
   */


  _getServiceProvider(service) {
    throw new Error(`Could not get provider for ${service}: _getServiceProvider not implemented`);
  }
  /**
   * Handle a call message sent to the dispatch service itself
   * @abstract
   * @param {Worker} worker - the worker which sent the message.
   * @param {DispatchCallMessage} message - the message to be handled.
   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate
   * @private
   */


  _onDispatchMessage(worker, message) {
    throw new Error(`Unimplemented dispatch message handler cannot handle ${message.method} method`);
  }

}

module.exports = SharedDispatch;

/***/ }),

/***/ "./src/engine/adapter.js":
/*!*******************************!*\
  !*** ./src/engine/adapter.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const mutationAdapter = __webpack_require__(/*! ./mutation-adapter */ "./src/engine/mutation-adapter.js");

const html = __webpack_require__(/*! htmlparser2 */ "./node_modules/htmlparser2/lib/index.js");
/**
 * Convert and an individual block DOM to the representation tree.
 * Based on Blockly's `domToBlockHeadless_`.
 * @param {Element} blockDOM DOM tree for an individual block.
 * @param {object} blocks Collection of blocks to add to.
 * @param {boolean} isTopBlock Whether blocks at this level are "top blocks."
 * @param {?string} parent Parent block ID.
 * @return {undefined}
 */


const domToBlock = function (blockDOM, blocks, isTopBlock, parent) {
  if (!blockDOM.attribs.id) {
    console.warn("adapter:", Utility.uid());
    blockDOM.attribs.id = Utility.uid();
  } // Block skeleton.


  const block = {
    id: blockDOM.attribs.id,
    // Block ID
    opcode: blockDOM.attribs.type,
    // For execution, "event_whengreenflag".
    inputs: {},
    // Inputs to this block and the blocks they point to.
    fields: {},
    // Fields on this block and their values.
    next: null,
    // Next block in the stack, if one exists.
    topLevel: isTopBlock,
    // If this block starts a stack.
    parent: parent,
    // Parent block ID, if available.
    shadow: blockDOM.name === "shadow",
    // If this represents a shadow/slot.
    x: blockDOM.attribs.x,
    // X position of script, if top-level.
    y: blockDOM.attribs.y // Y position of script, if top-level.

  }; // Add the block to the representation tree.

  blocks[block.id] = block; // Process XML children and find enclosed blocks, fields, etc.

  for (let i = 0; i < blockDOM.children.length; i++) {
    const xmlChild = blockDOM.children[i]; // Enclosed blocks and shadows

    let childBlockNode = null;
    let childShadowNode = null;

    for (let j = 0; j < xmlChild.children.length; j++) {
      const grandChildNode = xmlChild.children[j];

      if (!grandChildNode.name) {
        // Non-XML tag node.
        continue;
      }

      const grandChildNodeName = grandChildNode.name.toLowerCase();

      if (grandChildNodeName === "block") {
        childBlockNode = grandChildNode;
      } else if (grandChildNodeName === "shadow") {
        childShadowNode = grandChildNode;
      }
    } // Use shadow block only if there's no real block node.


    if (!childBlockNode && childShadowNode) {
      childBlockNode = childShadowNode;
    } // Not all Blockly-type blocks are handled here,
    // as we won't be using all of them for Scratch.


    switch (xmlChild.name.toLowerCase()) {
      case "field":
        {
          // Add the field to this block.
          const fieldName = xmlChild.attribs.name; // Add id in case it is a variable field

          const fieldId = xmlChild.attribs.id;
          let fieldData = "";

          if (xmlChild.children.length > 0 && xmlChild.children[0].data) {
            fieldData = xmlChild.children[0].data;
          } else {
            // If the child of the field with a data property
            // doesn't exist, set the data to an empty string.
            fieldData = "";
          }

          block.fields[fieldName] = {
            name: fieldName,
            id: fieldId,
            value: fieldData
          };
          const fieldVarType = xmlChild.attribs.variabletype;

          if (typeof fieldVarType === "string") {
            block.fields[fieldName].variableType = fieldVarType;
          }

          break;
        }

      case "comment":
        {
          block.comment = xmlChild.attribs.id;
          break;
        }

      case "value":
      case "statement":
        {
          // Recursively generate block structure for input block.
          domToBlock(childBlockNode, blocks, false, block.id);

          if (childShadowNode && childBlockNode !== childShadowNode) {
            // Also generate the shadow block.
            domToBlock(childShadowNode, blocks, false, block.id);
          } // Link this block's input to the child block.


          const inputName = xmlChild.attribs.name;
          block.inputs[inputName] = {
            name: inputName,
            block: childBlockNode.attribs.id,
            shadow: childShadowNode ? childShadowNode.attribs.id : null
          };
          break;
        }

      case "next":
        {
          if (!childBlockNode || !childBlockNode.attribs) {
            // Invalid child block.
            continue;
          } // Recursively generate block structure for next block.


          domToBlock(childBlockNode, blocks, false, block.id); // Link next block to this block.

          block.next = childBlockNode.attribs.id;
          break;
        }

      case "mutation":
        {
          block.mutation = mutationAdapter(xmlChild);
          break;
        }
    }
  }
};
/**
 * Convert outer blocks DOM from a Blockly CREATE event
 * to a usable form for the Scratch runtime.
 * This structure is based on Blockly xml.js:`domToWorkspace` and `domToBlock`.
 * @param {Element} blocksDOM DOM tree for this event.
 * @return {Array.<object>} Usable list of blocks from this CREATE event.
 */


const domToBlocks = function (blocksDOM) {
  // At this level, there could be multiple blocks adjacent in the DOM tree.
  const blocks = {};

  for (let i = 0; i < blocksDOM.length; i++) {
    const block = blocksDOM[i];

    if (!block.name || !block.attribs) {
      continue;
    }

    const tagName = block.name.toLowerCase();

    if (tagName === "block" || tagName === "shadow") {
      domToBlock(block, blocks, true, null);
    }
  } // Flatten blocks object into a list.


  const blocksList = [];

  for (const b in blocks) {
    if (!blocks.hasOwnProperty(b)) continue;
    blocksList.push(blocks[b]);
  }

  return blocksList;
};
/**
 * .
 * @param {object} e `Blockly.events.create` or `Blockly.events.endDrag`
 * @return {Array.<object>} List of blocks from this CREATE event.
 */


const adapter = function (e) {
  // Validate input
  if (typeof e !== "object") return;
  if (typeof e.xml !== "object") return; // console.log("HTML:", html);
  // console.log(
  //   "!!!!!!",
  //   html.parseDOM(e.xml.outerHTML, { decodeEntities: true })
  // );

  return domToBlocks(html.parseDOM(e.xml.outerHTML, {
    decodeEntities: true
  }));
};

module.exports = adapter;

/***/ }),

/***/ "./src/engine/block-utility.js":
/*!*************************************!*\
  !*** ./src/engine/block-utility.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");
/**
 * @fileoverview
 * Interface provided to block primitive functions for interacting with the
 * runtime, thread, target, and convenient methods.
 */


class BlockUtility {
  constructor(sequencer = null, thread = null) {
    /**
     * A sequencer block primitives use to branch or start procedures with
     * @type {?Sequencer}
     */
    this.sequencer = sequencer;
    /**
     * The block primitives thread with the block's target, stackFrame and
     * modifiable status.
     * @type {?Thread}
     */

    this.thread = thread;
    this._nowObj = {
      now: () => this.sequencer.runtime.currentMSecs
    };
  }
  /**
   * The target the primitive is working on.
   * @type {Target}
   */


  get target() {
    return this.thread.target;
  }
  /**
   * The runtime the block primitive is running in.
   * @type {Runtime}
   */


  get runtime() {
    return this.sequencer.runtime;
  }
  /**
   * Use the runtime's currentMSecs value as a timestamp value for now
   * This is useful in some cases where we need compatibility with Scratch 2
   * @type {function}
   */


  get nowObj() {
    if (this.runtime) {
      return this._nowObj;
    }

    return null;
  }
  /**
   * The stack frame used by loop and other blocks to track internal state.
   * @type {object}
   */


  get stackFrame() {
    const frame = this.thread.peekStackFrame();

    if (frame.executionContext === null) {
      frame.executionContext = {};
    }

    return frame.executionContext;
  }
  /**
   * Check the stack timer and return a boolean based on whether it has finished or not.
   * @return {boolean} - true if the stack timer has finished.
   */


  stackTimerFinished() {
    const timeElapsed = this.stackFrame.timer.timeElapsed();

    if (timeElapsed < this.stackFrame.duration) {
      return false;
    }

    return true;
  }
  /**
   * Check if the stack timer needs initialization.
   * @return {boolean} - true if the stack timer needs to be initialized.
   */


  stackTimerNeedsInit() {
    return !this.stackFrame.timer;
  }
  /**
   * Create and start a stack timer
   * @param {number} duration - a duration in milliseconds to set the timer for.
   */


  startStackTimer(duration) {
    if (this.nowObj) {
      this.stackFrame.timer = new Timer(this.nowObj);
    } else {
      this.stackFrame.timer = new Timer();
    }

    this.stackFrame.timer.start();
    this.stackFrame.duration = duration;
  }
  /**
   * Set the thread to yield.
   */


  yield() {
    this.thread.status = Thread.STATUS_YIELD;
  }
  /**
   * Set the thread to yield until the next tick of the runtime.
   */


  yieldTick() {
    this.thread.status = Thread.STATUS_YIELD_TICK;
  }
  /**
   * Start a branch in the current block.
   * @param {number} branchNum Which branch to step to (i.e., 1, 2).
   * @param {boolean} isLoop Whether this block is a loop.
   */


  startBranch(branchNum, isLoop) {
    this.sequencer.stepToBranch(this.thread, branchNum, isLoop);
  }
  /**
   * Stop all threads.
   */


  stopAll() {
    this.sequencer.runtime.stopAll();
  }
  /**
   * Stop threads other on this target other than the thread holding the
   * executed block.
   */


  stopOtherTargetThreads() {
    this.sequencer.runtime.stopForTarget(this.thread.target, this.thread);
  }
  /**
   * Stop this thread.
   */


  stopThisScript() {
    this.thread.stopThisScript();
  }
  /**
   * Start a specified procedure on this thread.
   * @param {string} procedureCode Procedure code for procedure to start.
   */


  startProcedure(procedureCode) {
    this.sequencer.stepToProcedure(this.thread, procedureCode);
  }
  /**
   * Get names and ids of parameters for the given procedure.
   * @param {string} procedureCode Procedure code for procedure to query.
   * @return {Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesAndIds(procedureCode) {
    return this.thread.target.blocks.getProcedureParamNamesAndIds(procedureCode);
  }
  /**
   * Get names, ids, and defaults of parameters for the given procedure.
   * @param {string} procedureCode Procedure code for procedure to query.
   * @return {Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesIdsAndDefaults(procedureCode) {
    return this.thread.target.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);
  }
  /**
   * Initialize procedure parameters in the thread before pushing parameters.
   */


  initParams() {
    this.thread.initParams();
  }
  /**
   * Store a procedure parameter value by its name.
   * @param {string} paramName The procedure's parameter name.
   * @param {*} paramValue The procedure's parameter value.
   */


  pushParam(paramName, paramValue) {
    this.thread.pushParam(paramName, paramValue);
  }
  /**
   * Retrieve the stored parameter value for a given parameter name.
   * @param {string} paramName The procedure's parameter name.
   * @return {*} The parameter's current stored value.
   */


  getParam(paramName) {
    return this.thread.getParam(paramName);
  }
  /**
   * Start all relevant hats.
   * @param {!string} requestedHat Opcode of hats to start.
   * @param {object=} optMatchFields Optionally, fields to match on the hat.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   * @return {Array.<Thread>} List of threads started by this function.
   */


  startHats(requestedHat, optMatchFields, optTarget) {
    // Store thread and sequencer to ensure we can return to the calling block's context.
    // startHats may execute further blocks and dirty the BlockUtility's execution context
    // and confuse the calling block when we return to it.
    const callerThread = this.thread;
    const callerSequencer = this.sequencer;
    const result = this.sequencer.runtime.startHats(requestedHat, optMatchFields, optTarget); // Restore thread and sequencer to prior values before we return to the calling block.

    this.thread = callerThread;
    this.sequencer = callerSequencer;
    return result;
  }
  /**
   * IO.
   * @param {string} device .
   * @param {string} func .
   * @param {Array.<*>} args .
   * @return {*} .
   */


  ioQuery(device, func, args) {
    // I / O/.
    if (this.sequencer.runtime.ioDevices[device] && this.sequencer.runtime.ioDevices[device][func]) {
      const devObject = this.sequencer.runtime.ioDevices[device];
      return devObject[func].apply(devObject, args);
    }
  }

}

module.exports = BlockUtility;

/***/ }),

/***/ "./src/engine/blocks-execute-cache.js":
/*!********************************************!*\
  !*** ./src/engine/blocks-execute-cache.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * Access point for private method shared between blocks.js and execute.js for
 * caching execute information.
 */

/**
 * A private method shared with execute to build an object containing the block
 * information execute needs and that is reset when other cached Blocks info is
 * reset.
 * @param {Blocks} blocks Blocks containing the expected blockId
 * @param {string} blockId blockId for the desired execute cache
 */
exports.getCached = function () {
  throw new Error('blocks.js has not initialized BlocksExecuteCache');
}; // Call after the default throwing getCached is assigned for Blocks to replace.


__webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

/***/ }),

/***/ "./src/engine/blocks-runtime-cache.js":
/*!********************************************!*\
  !*** ./src/engine/blocks-runtime-cache.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * The BlocksRuntimeCache caches data about the top block of scripts so that
 * Runtime can iterate a targeted opcode and iterate the returned set faster.
 * Many top blocks need to match fields as well as opcode, since that matching
 * compares strings in uppercase we can go ahead and uppercase the cached value
 * so we don't need to in the future.
 */

/**
 * A set of cached data about the top block of a script.
 * @param {Blocks} container - Container holding the block and related data
 * @param {string} blockId - Id for whose block data is cached in this instance
 */
class RuntimeScriptCache {
  constructor(container, blockId) {
    /**
     * Container with block data for blockId.
     * @type {Blocks}
     */
    this.container = container;
    /**
     * ID for block this instance caches.
     * @type {string}
     */

    this.blockId = blockId;
    const block = container.getBlock(blockId);
    const fields = container.getFields(block);
    /**
     * Formatted fields or fields of input blocks ready for comparison in
     * runtime.
     *
     * This is a clone of parts of the targeted blocks. Changes to these
     * clones are limited to copies under RuntimeScriptCache and will not
     * appear in the original blocks in their container. This copy is
     * modified changing the case of strings to uppercase. These uppercase
     * values will be compared later by the VM.
     * @type {object}
     */

    this.fieldsOfInputs = Object.assign({}, fields);

    if (Object.keys(fields).length === 0) {
      const inputs = container.getInputs(block);

      for (const input in inputs) {
        if (!inputs.hasOwnProperty(input)) continue;
        const id = inputs[input].block;
        const inputBlock = container.getBlock(id);
        const inputFields = container.getFields(inputBlock);
        Object.assign(this.fieldsOfInputs, inputFields);
      }
    }

    for (const key in this.fieldsOfInputs) {
      const field = this.fieldsOfInputs[key] = Object.assign({}, this.fieldsOfInputs[key]);

      if (field.value.toUpperCase) {
        field.value = field.value.toUpperCase();
      }
    }
  }

}
/**
 * Get an array of scripts from a block container prefiltered to match opcode.
 * @param {Blocks} container - Container of blocks
 * @param {string} opcode - Opcode to filter top blocks by
 */


exports.getScripts = function () {
  throw new Error('blocks.js has not initialized BlocksRuntimeCache');
};
/**
 * Exposed RuntimeScriptCache class used by integration in blocks.js.
 * @private
 */


exports._RuntimeScriptCache = RuntimeScriptCache;

__webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

/***/ }),

/***/ "./src/engine/blocks.js":
/*!******************************!*\
  !*** ./src/engine/blocks.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const adapter = __webpack_require__(/*! ./adapter */ "./src/engine/adapter.js");

const mutationAdapter = __webpack_require__(/*! ./mutation-adapter */ "./src/engine/mutation-adapter.js");

const MonitorRecord = __webpack_require__(/*! ./monitor-record */ "./src/engine/monitor-record.js");

const {
  Map
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");

const BlocksExecuteCache = __webpack_require__(/*! ./blocks-execute-cache */ "./src/engine/blocks-execute-cache.js");

const BlocksRuntimeCache = __webpack_require__(/*! ./blocks-runtime-cache */ "./src/engine/blocks-runtime-cache.js");

const Variable = __webpack_require__(/*! ./variable */ "./src/engine/variable.js");
/**
 * @fileoverview
 * VM Blocks
 */

/**
 * .
 * @param {Runtime} runtime 
 * @param {boolean} optNoGlow  .
 */


class Blocks {
  constructor(runtime, optNoGlow) {
    this.runtime = runtime;
    /**
     * All blocks in the workspace.
     * Keys are block IDs, values are metadata about the block.
     * @type {Object.<string, Object>}
     */

    this._blocks = {};
    /**
     * All top-level scripts in the workspace.
     * A list of block IDs that represent scripts (i.e., first block in script).
     * @type {Array.<String>}
     */

    this._scripts = [];
    /**
     * Runtime Cache
     * @type {{inputs: {}, procedureParamNames: {}, procedureDefinitions: {}}}
     * @private
     */

    Object.defineProperty(this, "_cache", {
      writable: true,
      enumerable: false
    });
    this._cache = {
      /**
       * Cache block inputs by block id
       * @type {object.<string, !Array.<object>>}
       */
      inputs: {},

      /**
       * Cache procedure Param Names by block id
       * @type {object.<string, ?Array.<string>>}
       */
      procedureParamNames: {},

      /**
       * Cache procedure definitions by block id
       * @type {object.<string, ?string>}
       */
      procedureDefinitions: {},

      /**
       * A cache for execute to use and store on. Only available to
       * execute.
       * @type {object.<string, object>}
       */
      _executeCached: {},

      /**
       * A cache of block IDs and targets to start threads on as they are
       * actively monitored.
       * @type {Array<{blockId: string, target: Target}>}
       */
      _monitored: null,

      /**
       * A cache of hat opcodes to collection of theads to execute.
       * @type {object.<string, object>}
       */
      scripts: {}
    };
    /**
     * Flag which indicates that blocks in this container should not glow.
     * Blocks will still glow when clicked on, but this flag is used to control
     * whether the blocks in this container can request a glow as part of
     * a running stack. E.g. the flyout block container and the monitor block container
     * should not be able to request a glow, but blocks containers belonging to
     * sprites should.
     * @type {boolean}
     */

    this.forceNoGlow = optNoGlow || false;
  }
  /**
   * Blockly inputs that represent statements/branch.
   * are prefixed with this string.
   * @const{string}
   */


  static get BRANCH_INPUT_PREFIX() {
    return "SUBSTACK";
  }
  /**
   * Provide an object with metadata for the requested block ID.
   * @param {!string} blockId ID of block we have stored.
   * @return {?object} Metadata about the block, if it exists.
   */


  getBlock(blockId) {
    return this._blocks[blockId];
  }
  /**
   * Get all known top-level blocks that start scripts.
   * @return {Array.<string>} List of block IDs.
   */


  getScripts() {
    return this._scripts;
  }
  /**
   * Get the next block for a particular block
   * @param {?string} id ID of block to get the next block for
   * @return {?string} ID of next block in the sequence
   */


  getNextBlock(id) {
    const block = this._blocks[id];
    return typeof block === "undefined" ? null : block.next;
  }
  /**
   * Get the branch for a particular C-shaped block.
   * @param {?string} id ID for block to get the branch for.
   * @param {?number} branchNum Which branch to select (e.g. for if-else).
   * @return {?string} ID of block in the branch.
   */


  getBranch(id, branchNum) {
    const block = this._blocks[id];
    if (typeof block === "undefined") return null;
    if (!branchNum) branchNum = 1;
    let inputName = Blocks.BRANCH_INPUT_PREFIX;

    if (branchNum > 1) {
      inputName += branchNum;
    } // Empty C-block?


    const input = block.inputs[inputName];
    return typeof input === "undefined" ? null : input.block;
  }
  /**
   * Get the opcode for a particular block
   * @param {?object} block The block to query
   * @return {?string} the opcode corresponding to that block
   */


  getOpcode(block) {
    return typeof block === "undefined" ? null : block.opcode;
  }
  /**
   * Get all fields and their values for a block.
   * @param {?object} block The block to query.
   * @return {?object} All fields and their values.
   */


  getFields(block) {
    return typeof block === "undefined" ? null : block.fields;
  }
  /**
   * Get all non-branch inputs for a block.
   * @param {?object} block the block to query.
   * @return {?Array.<object>} All non-branch inputs and their associated blocks.
   */


  getInputs(block) {
    if (typeof block === "undefined") return null;
    let inputs = this._cache.inputs[block.id];

    if (typeof inputs !== "undefined") {
      return inputs;
    }

    inputs = {};

    for (const input in block.inputs) {
      // Ignore blocks prefixed with branch prefix.
      if (input.substring(0, Blocks.BRANCH_INPUT_PREFIX.length) !== Blocks.BRANCH_INPUT_PREFIX) {
        inputs[input] = block.inputs[input];
      }
    }

    this._cache.inputs[block.id] = inputs;
    return inputs;
  }
  /**
   * Get mutation data for a block.
   * @param {?object} block The block to query.
   * @return {?object} Mutation for the block.
   */


  getMutation(block) {
    return typeof block === "undefined" ? null : block.mutation;
  }
  /**
   * Get the top-level script for a given block.
   * @param {?string} id ID of block to query.
   * @return {?string} ID of top-level script block.
   */


  getTopLevelScript(id) {
    let block = this._blocks[id];
    if (typeof block === "undefined") return null;

    while (block.parent !== null) {
      block = this._blocks[block.parent];
    }

    return block.id;
  }
  /**
   * Get the procedure definition for a given name.
   * @param {?string} name Name of procedure to query.
   * @return {?string} ID of procedure definition.
   */


  getProcedureDefinition(name) {
    const blockID = this._cache.procedureDefinitions[name];

    if (typeof blockID !== "undefined") {
      return blockID;
    }

    for (const id in this._blocks) {
      if (!this._blocks.hasOwnProperty(id)) continue;
      const block = this._blocks[id];

      if (block.opcode === "procedures_definition") {
        const internal = this._getCustomBlockInternal(block);

        if (internal && internal.mutation.proccode === name) {
          this._cache.procedureDefinitions[name] = id; // The outer define block id

          return id;
        }
      }
    }

    this._cache.procedureDefinitions[name] = null;
    return null;
  }
  /**
   * Get names and ids of parameters for the given procedure.
   * @param {?string} name Name of procedure to query.
   * @return {?Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesAndIds(name) {
    return this.getProcedureParamNamesIdsAndDefaults(name).slice(0, 2);
  }
  /**
   * Get names, ids, and defaults of parameters for the given procedure.
   * @param {?string} name Name of procedure to query.
   * @return {?Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesIdsAndDefaults(name) {
    const cachedNames = this._cache.procedureParamNames[name];

    if (typeof cachedNames !== "undefined") {
      return cachedNames;
    }

    for (const id in this._blocks) {
      if (!this._blocks.hasOwnProperty(id)) continue;
      const block = this._blocks[id];

      if (block.opcode === "procedures_prototype" && block.mutation.proccode === name) {
        const names = JSON.parse(block.mutation.argumentnames);
        const ids = JSON.parse(block.mutation.argumentids);
        const defaults = JSON.parse(block.mutation.argumentdefaults);
        this._cache.procedureParamNames[name] = [names, ids, defaults];
        return this._cache.procedureParamNames[name];
      }
    }

    this._cache.procedureParamNames[name] = null;
    return null;
  }

  duplicate() {
    const newBlocks = new Blocks(this.runtime, this.forceNoGlow);
    newBlocks._blocks = Utility.cloneSimple(this._blocks);
    newBlocks._scripts = Utility.cloneSimple(this._scripts);
    return newBlocks;
  } // ---------------------------------------------------------------------

  /**
   * Create event listener for blocks, variables, and comments. Handles validation and
   * serves as a generic adapter between the blocks, variables, and the
   * runtime interface.
   * @param {object} e Blockly "block" or "variable" event
   */


  blocklyListen(e) {
    // Validate event
    if (typeof e !== "object") return;

    if (typeof e.blockId !== "string" && typeof e.varId !== "string" && typeof e.commentId !== "string") {
      return;
    }

    const stage = this.runtime.getTargetForStage();
    const editingTarget = this.runtime.getEditingTarget(); // UI event: clicked scripts toggle in the runtime.

    if (e.element === "stackclick") {
      this.runtime.toggleScript(e.blockId, {
        stackClick: true
      });
      return;
    } // Block create/update/destroy


    switch (e.type) {
      case "create":
        {
          const newBlocks = adapter(e); // A create event can create many blocks. Add them all.

          for (let i = 0; i < newBlocks.length; i++) {
            this.createBlock(newBlocks[i]);
          }

          break;
        }

      case "change":
        this.changeBlock({
          id: e.blockId,
          element: e.element,
          name: e.name,
          value: e.newValue
        });
        break;

      case "move":
        this.moveBlock({
          id: e.blockId,
          oldParent: e.oldParentId,
          oldInput: e.oldInputName,
          newParent: e.newParentId,
          newInput: e.newInputName,
          newCoordinate: e.newCoordinate
        });
        break;

      case "dragOutside":
        this.runtime.emitBlockDragUpdate(e.isOutside);
        break;

      case "endDrag":
        this.runtime.emitBlockDragUpdate(false
        /* areBlocksOverGui */
        ); // Drag blocks onto another sprite

        if (e.isOutside) {
          const newBlocks = adapter(e);
          this.runtime.emitBlockEndDrag(newBlocks, e.blockId);
        }

        break;

      case "delete":
        // Don't accept delete events for missing blocks,
        // or shadow blocks being obscured.
        if (!this._blocks.hasOwnProperty(e.blockId) || this._blocks[e.blockId].shadow) {
          return;
        } // Inform any runtime to forget about glows on this script.


        if (this._blocks[e.blockId].topLevel) {
          this.runtime.quietGlow(e.blockId);
        }

        this.deleteBlock(e.blockId);
        break;

      case "var_create":
        // Check if the variable being created is global or local
        // If local, create a local var on the current editing target, as long
        // as there are no conflicts, and the current target is actually a sprite
        // If global or if the editing target is not present or we somehow got
        // into a state where a local var was requested for the stage,
        // create a stage (global) var after checking for name conflicts
        // on all the sprites.
        if (e.isLocal && editingTarget && !editingTarget.isStage && !e.isCloud) {
          if (!editingTarget.lookupVariableById(e.varId)) {
            editingTarget.createVariable(e.varId, e.varName, e.varType);
            this.emitProjectChanged();
          }
        } else {
          if (stage.lookupVariableById(e.varId)) {
            // Do not re-create a variable if it already exists
            return;
          } // Check for name conflicts in all of the targets


          const allTargets = this.runtime.targets.filter(t => t.isOriginal);

          for (const target of allTargets) {
            if (target.lookupVariableByNameAndType(e.varName, e.varType, true)) {
              return;
            }
          }

          stage.createVariable(e.varId, e.varName, e.varType, e.isCloud);
          this.emitProjectChanged();
        }

        break;

      case "var_rename":
        if (editingTarget && editingTarget.variables.hasOwnProperty(e.varId)) {
          // This is a local variable, rename on the current target
          editingTarget.renameVariable(e.varId, e.newName); // Update all the blocks on the current target that use
          // this variable

          editingTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);
        } else {
          // This is a global variable
          stage.renameVariable(e.varId, e.newName); // Update all blocks on all targets that use the renamed variable

          const targets = this.runtime.targets;

          for (let i = 0; i < targets.length; i++) {
            const currTarget = targets[i];
            currTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);
          }
        }

        this.emitProjectChanged();
        break;

      case "var_delete":
        {
          const target = editingTarget && editingTarget.variables.hasOwnProperty(e.varId) ? editingTarget : stage;
          target.deleteVariable(e.varId);
          this.emitProjectChanged();
          break;
        }

      case "comment_create":
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();
          currTarget.createComment(e.commentId, e.blockId, e.text, e.xy.x, e.xy.y, e.width, e.height, e.minimized);

          if (currTarget.comments[e.commentId].x === null && currTarget.comments[e.commentId].y === null) {
            // Block comments imported from 2.0 projects are imported with their
            // x and y coordinates set to null so that scratch-blocks can
            // auto-position them. If we are receiving a create event for these
            // comments, then the auto positioning should have taken place.
            // Update the x and y position of these comments to match the
            // one from the event.
            currTarget.comments[e.commentId].x = e.xy.x;
            currTarget.comments[e.commentId].y = e.xy.y;
          }
        }

        this.emitProjectChanged();
        break;

      case "comment_change":
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();

          if (!currTarget.comments.hasOwnProperty(e.commentId)) {
            console.warn(`Cannot change comment with id ${e.commentId} because it does not exist.`);
            return;
          }

          const comment = currTarget.comments[e.commentId];
          const change = e.newContents_;

          if (change.hasOwnProperty("minimized")) {
            comment.minimized = change.minimized;
          }

          if (change.hasOwnProperty("width") && change.hasOwnProperty("height")) {
            comment.width = change.width;
            comment.height = change.height;
          }

          if (change.hasOwnProperty("text")) {
            comment.text = change.text;
          }

          this.emitProjectChanged();
        }

        break;

      case "comment_move":
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();

          if (currTarget && !currTarget.comments.hasOwnProperty(e.commentId)) {
            console.warn(`Cannot change comment with id ${e.commentId} because it does not exist.`);
            return;
          }

          const comment = currTarget.comments[e.commentId];
          const newCoord = e.newCoordinate_;
          comment.x = newCoord.x;
          comment.y = newCoord.y;
          this.emitProjectChanged();
        }

        break;

      case "comment_delete":
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();

          if (!currTarget.comments.hasOwnProperty(e.commentId)) {
            // If we're in this state, we have probably received
            // a delete event from a workspace that we switched from
            // (e.g. a delete event for a comment on sprite a's workspace
            // when switching from sprite a to sprite b)
            return;
          }

          delete currTarget.comments[e.commentId];

          if (e.blockId) {
            const block = currTarget.blocks.getBlock(e.blockId);

            if (!block) {
              console.warn(`Could not find block referenced by comment with id: ${e.commentId}`);
              return;
            }

            delete block.comment;
          }

          this.emitProjectChanged();
        }

        break;
    }
  } // ---------------------------------------------------------------------

  /**
   * Reset all runtime caches.
   */


  resetCache() {
    this._cache.inputs = {};
    this._cache.procedureParamNames = {};
    this._cache.procedureDefinitions = {};
    this._cache._executeCached = {};
    this._cache._monitored = null;
    this._cache.scripts = {};
  }
  /**
   * Emit a project changed event if this is a block container
   * that can affect the project state.
   */


  emitProjectChanged() {
    if (!this.forceNoGlow) {
      this.runtime.emitProjectChanged();
    }
  }
  /**
   * Block management: create blocks and scripts from a `create` event
   * @param {!object} block Blockly create event to be processed
   */


  createBlock(block) {
    // Does the block already exist?
    // Could happen, e.g., for an unobscured shadow.
    if (this._blocks.hasOwnProperty(block.id)) {
      return;
    } // Create new block.


    this._blocks[block.id] = block; // Push block id to scripts array.
    // Blocks are added as a top-level stack if they are marked as a top-block
    // (if they were top-level XML in the event).

    if (block.topLevel) {
      this._addScript(block.id);
    }

    this.resetCache(); // A new block was actually added to the block container,
    // emit a project changed event

    this.emitProjectChanged();
  }
  /**
   * Block management: change block field values
   * @param {!object} args Blockly change event to be processed
   */


  changeBlock(args) {
    // Validate
    if (["field", "mutation", "checkbox"].indexOf(args.element) === -1) return;
    let block = this._blocks[args.id];
    if (typeof block === "undefined") return;

    switch (args.element) {
      case "field":
        // TODO when the field of a monitored block changes,
        // update the checkbox in the flyout based on whether
        // a monitor for that current combination of selected parameters exists
        // e.g.
        // 1. check (current [v year])
        // 2. switch dropdown in flyout block to (current [v minute])
        // 3. the checkbox should become unchecked if we're not already
        //    monitoring current minute
        // Update block value
        if (!block.fields[args.name]) return;

        if (args.name === "VARIABLE" || args.name === "LIST" || args.name === "BROADCAST_OPTION") {
          // Get variable name using the id in args.value.
          const variable = this.runtime.getEditingTarget().lookupVariableById(args.value);

          if (variable) {
            block.fields[args.name].value = variable.name;
            block.fields[args.name].id = args.value;
          }
        } else {
          // Changing the value in a dropdown
          block.fields[args.name].value = args.value; // The selected item in the sensing of block menu needs to change based on the
          // selected target.  Set it to the first item in the menu list.
          // TODO: (#1787)

          if (block.opcode === "sensing_of_object_menu") {
            if (block.fields.OBJECT.value === "_stage_") {
              this._blocks[block.parent].fields.PROPERTY.value = "backdrop #";
            } else {
              this._blocks[block.parent].fields.PROPERTY.value = "x position";
            }

            this.runtime.requestBlocksUpdate();
          }

          const flyoutBlock = block.shadow && block.parent ? this._blocks[block.parent] : block;

          if (flyoutBlock.isMonitored) {
            this.runtime.requestUpdateMonitor(Map({
              id: flyoutBlock.id,
              params: this._getBlockParams(flyoutBlock)
            }));
          }
        }

        break;

      case "mutation":
        block.mutation = mutationAdapter(args.value);
        break;

      case "checkbox":
        {
          // A checkbox usually has a one to one correspondence with the monitor
          // block but in the case of monitored reporters that have arguments,
          // map the old id to a new id, creating a new monitor block if necessary
          if (block.fields && Object.keys(block.fields).length > 0 && block.opcode !== "data_variable" && block.opcode !== "data_listcontents") {
            // This block has an argument which needs to get separated out into
            // multiple monitor blocks with ids based on the selected argument
            const newId = Utility.getMonitorIdForBlockWithArgs(block.id, block.fields); // Note: we're not just constantly creating a longer and longer id everytime we check
            // the checkbox because we're using the id of the block in the flyout as the base
            // check if a block with the new id already exists, otherwise create

            let newBlock = this.runtime.monitorBlocks.getBlock(newId);

            if (!newBlock) {
              newBlock = JSON.parse(JSON.stringify(block));
              newBlock.id = newId;
              this.runtime.monitorBlocks.createBlock(newBlock);
            }

            block = newBlock; // Carry on through the rest of this code with newBlock
          }

          const wasMonitored = block.isMonitored;
          block.isMonitored = args.value; // Variable blocks may be sprite specific depending on the owner of the variable

          let isSpriteLocalVariable = false;

          if (block.opcode === "data_variable") {
            isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.VARIABLE.id];
          } else if (block.opcode === "data_listcontents") {
            isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.LIST.id];
          }

          const isSpriteSpecific = isSpriteLocalVariable || this.runtime.monitorBlockInfo.hasOwnProperty(block.opcode) && this.runtime.monitorBlockInfo[block.opcode].isSpriteSpecific;

          if (isSpriteSpecific) {
            // If creating a new sprite specific monitor, the only possible target is
            // the current editing one b/c you cannot dynamically create monitors.
            // Also, do not change the targetId if it has already been assigned
            block.targetId = block.targetId || this.runtime.getEditingTarget().id;
          } else {
            block.targetId = null;
          }

          if (wasMonitored && !block.isMonitored) {
            this.runtime.requestHideMonitor(block.id);
          } else if (!wasMonitored && block.isMonitored) {
            // Tries to show the monitor for specified block. If it doesn't exist, add the monitor.
            if (!this.runtime.requestShowMonitor(block.id)) {
              this.runtime.requestAddMonitor(MonitorRecord({
                id: block.id,
                targetId: block.targetId,
                spriteName: block.targetId ? this.runtime.getTargetById(block.targetId).getName() : null,
                opcode: block.opcode,
                params: this._getBlockParams(block),
                // @todo(vm#565) for numerical values with decimals, some countries use comma
                value: "",
                mode: block.opcode === "data_listcontents" ? "list" : "default"
              }));
            }
          }

          break;
        }
    }

    this.emitProjectChanged();
    this.resetCache();
  }
  /**
   * Block management: move blocks from parent to parent
   * @param {!object} e Blockly move event to be processed
   */


  moveBlock(e) {
    if (!this._blocks.hasOwnProperty(e.id)) {
      return;
    }

    const block = this._blocks[e.id]; // Track whether a change actually occurred
    // ignoring changes like routine re-positioning
    // of a block when loading a workspace

    let didChange = false; // Move coordinate changes.

    if (e.newCoordinate) {
      didChange = block.x !== e.newCoordinate.x || block.y !== e.newCoordinate.y;
      block.x = e.newCoordinate.x;
      block.y = e.newCoordinate.y;
    } // Remove from any old parent.


    if (typeof e.oldParent !== "undefined") {
      const oldParent = this._blocks[e.oldParent];

      if (typeof e.oldInput !== "undefined" && oldParent.inputs[e.oldInput].block === e.id) {
        // This block was connected to the old parent's input.
        oldParent.inputs[e.oldInput].block = null;
      } else if (oldParent.next === e.id) {
        // This block was connected to the old parent's next connection.
        oldParent.next = null;
      }

      this._blocks[e.id].parent = null;
      didChange = true;
    } // Is this block a top-level block?


    if (typeof e.newParent === "undefined") {
      this._addScript(e.id);
    } else {
      // Remove script, if one exists.
      this._deleteScript(e.id); // Otherwise, try to connect it in its new place.


      if (typeof e.newInput === "undefined") {
        // Moved to the new parent's next connection.
        this._blocks[e.newParent].next = e.id;
      } else {
        // Moved to the new parent's input.
        // Don't obscure the shadow block.
        let oldShadow = null;

        if (this._blocks[e.newParent].inputs.hasOwnProperty(e.newInput)) {
          oldShadow = this._blocks[e.newParent].inputs[e.newInput].shadow;
        } // If the block being attached is itself a shadow, make sure to set
        // both block and shadow to that blocks ID. This happens when adding
        // inputs to a custom procedure.


        if (this._blocks[e.id].shadow) oldShadow = e.id;
        this._blocks[e.newParent].inputs[e.newInput] = {
          name: e.newInput,
          block: e.id,
          shadow: oldShadow
        };
      }

      this._blocks[e.id].parent = e.newParent;
      didChange = true;
    }

    this.resetCache();
    if (didChange) this.emitProjectChanged();
  }
  /**
   * Block management: run all blocks.
   * @param {!object} runtime Runtime to run all blocks in.
   */


  runAllMonitored(runtime) {
    if (this._cache._monitored === null) {
      this._cache._monitored = Object.keys(this._blocks).filter(blockId => this.getBlock(blockId).isMonitored).map(blockId => {
        const targetId = this.getBlock(blockId).targetId;
        return {
          blockId,
          target: targetId ? runtime.getTargetById(targetId) : null
        };
      });
    }

    const monitored = this._cache._monitored;

    for (let i = 0; i < monitored.length; i++) {
      const {
        blockId,
        target
      } = monitored[i];
      runtime.addMonitorScript(blockId, target);
    }
  }
  /**
   * Block management: delete blocks and their associated scripts. Does nothing if a block
   * with the given ID does not exist.
   * @param {!string} blockId Id of block to delete
   */


  deleteBlock(blockId) {
    // @todo In runtime, stop threads running on this script.
    // Get block
    const block = this._blocks[blockId];

    if (!block) {
      // No block with the given ID exists
      return;
    } // Delete children


    if (block.next !== null) {
      this.deleteBlock(block.next);
    } // Delete inputs (including branches)


    for (const input in block.inputs) {
      // If it's null, the block in this input moved away.
      if (block.inputs[input].block !== null) {
        this.deleteBlock(block.inputs[input].block);
      } // Delete obscured shadow blocks.


      if (block.inputs[input].shadow !== null && block.inputs[input].shadow !== block.inputs[input].block) {
        this.deleteBlock(block.inputs[input].shadow);
      }
    } // Delete any script starting with this block.


    this._deleteScript(blockId); // Delete block itself.


    delete this._blocks[blockId];
    this.resetCache();
    this.emitProjectChanged();
  }
  /**
   * Returns a map of all references to variables or lists from blocks
   * in this block container.
   * @param {Array<object>} optBlocks Optional list of blocks to constrain the search to.
   * This is useful for getting variable/list references for a stack of blocks instead
   * of all blocks on the workspace
   * @param {?boolean} optIncludeBroadcast Optional whether to include broadcast fields.
   * @return {object} A map of variable ID to a list of all variable references
   * for that ID. A variable reference contains the field referencing that variable
   * and also the type of the variable being referenced.
   */


  getAllVariableAndListReferences(optBlocks, optIncludeBroadcast) {
    const blocks = optBlocks ? optBlocks : this._blocks;
    const allReferences = Object.create(null);

    for (const blockId in blocks) {
      let varOrListField = null;
      let varType = null;

      if (blocks[blockId].fields.VARIABLE) {
        varOrListField = blocks[blockId].fields.VARIABLE;
        varType = Variable.SCALAR_TYPE;
      } else if (blocks[blockId].fields.LIST) {
        varOrListField = blocks[blockId].fields.LIST;
        varType = Variable.LIST_TYPE;
      } else if (optIncludeBroadcast && blocks[blockId].fields.BROADCAST_OPTION) {
        varOrListField = blocks[blockId].fields.BROADCAST_OPTION;
        varType = Variable.BROADCAST_MESSAGE_TYPE;
      }

      if (varOrListField) {
        const currVarId = varOrListField.id;

        if (allReferences[currVarId]) {
          allReferences[currVarId].push({
            referencingField: varOrListField,
            type: varType
          });
        } else {
          allReferences[currVarId] = [{
            referencingField: varOrListField,
            type: varType
          }];
        }
      }
    }

    return allReferences;
  }
  /**
   * Keep blocks up to date after a variable gets renamed.
   * @param {string} varId The id of the variable that was renamed
   * @param {string} newName The new name of the variable that was renamed
   */


  updateBlocksAfterVarRename(varId, newName) {
    const blocks = this._blocks;

    for (const blockId in blocks) {
      let varOrListField = null;

      if (blocks[blockId].fields.VARIABLE) {
        varOrListField = blocks[blockId].fields.VARIABLE;
      } else if (blocks[blockId].fields.LIST) {
        varOrListField = blocks[blockId].fields.LIST;
      }

      if (varOrListField) {
        const currFieldId = varOrListField.id;

        if (varId === currFieldId) {
          varOrListField.value = newName;
        }
      }
    }
  }
  /**
   * Keep blocks up to date after they are shared between targets.
   * @param {boolean} isStage If the new target is a stage.
   */


  updateTargetSpecificBlocks(isStage) {
    const blocks = this._blocks;

    for (const blockId in blocks) {
      if (isStage && blocks[blockId].opcode === "event_whenthisspriteclicked") {
        blocks[blockId].opcode = "event_whenstageclicked";
      } else if (!isStage && blocks[blockId].opcode === "event_whenstageclicked") {
        blocks[blockId].opcode = "event_whenthisspriteclicked";
      }
    }
  }
  /**
   * Update blocks after a sound, costume, or backdrop gets renamed.
   * Any block referring to the old name of the asset should get updated
   * to refer to the new name.
   * @param {string} oldName The old name of the asset that was renamed.
   * @param {string} newName The new name of the asset that was renamed.
   * @param {string} assetType String representation of the kind of asset
   * that was renamed. This can be one of 'sprite','costume', 'sound', or
   * 'backdrop'.
   */


  updateAssetName(oldName, newName, assetType) {
    let getAssetField;

    if (assetType === "costume") {
      getAssetField = this._getCostumeField.bind(this);
    } else if (assetType === "sound") {
      getAssetField = this._getSoundField.bind(this);
    } else if (assetType === "backdrop") {
      getAssetField = this._getBackdropField.bind(this);
    } else if (assetType === "sprite") {
      getAssetField = this._getSpriteField.bind(this);
    } else {
      return;
    }

    const blocks = this._blocks;

    for (const blockId in blocks) {
      const assetField = getAssetField(blockId);

      if (assetField && assetField.value === oldName) {
        assetField.value = newName;
      }
    }
  }
  /**
   * Update sensing_of blocks after a variable gets renamed.
   * @param {string} oldName The old name of the variable that was renamed.
   * @param {string} newName The new name of the variable that was renamed.
   * @param {string} targetName The name of the target the variable belongs to.
   * @return {boolean} Returns true if any of the blocks were updated.
   */


  updateSensingOfReference(oldName, newName, targetName) {
    const blocks = this._blocks;
    let blockUpdated = false;

    for (const blockId in blocks) {
      const block = blocks[blockId];

      if (block.opcode === "sensing_of" && block.fields.PROPERTY.value === oldName && // If block and shadow are different, it means a block is inserted to OBJECT, and should be ignored.
      block.inputs.OBJECT.block === block.inputs.OBJECT.shadow) {
        const inputBlock = this.getBlock(block.inputs.OBJECT.block);

        if (inputBlock.fields.OBJECT.value === targetName) {
          block.fields.PROPERTY.value = newName;
          blockUpdated = true;
        }
      }
    }

    if (blockUpdated) this.resetCache();
    return blockUpdated;
  }
  /**
   * Helper function to retrieve a costume menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The costume menu field of the block with the given block id.
   * Null if either a block with the given id doesn't exist or if a costume menu field
   * does not exist on the block with the given id.
   */


  _getCostumeField(blockId) {
    const block = this.getBlock(blockId);

    if (block && block.fields.hasOwnProperty("COSTUME")) {
      return block.fields.COSTUME;
    }

    return null;
  }
  /**
   * Helper function to retrieve a sound menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The sound menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a sound menu field
   * does not exist on the block with the given id.
   */


  _getSoundField(blockId) {
    const block = this.getBlock(blockId);

    if (block && block.fields.hasOwnProperty("SOUND_MENU")) {
      return block.fields.SOUND_MENU;
    }

    return null;
  }
  /**
   * Helper function to retrieve a backdrop menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The backdrop menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a backdrop menu field
   * does not exist on the block with the given id.
   */


  _getBackdropField(blockId) {
    const block = this.getBlock(blockId);

    if (block && block.fields.hasOwnProperty("BACKDROP")) {
      return block.fields.BACKDROP;
    }

    return null;
  }
  /**
   * Helper function to retrieve a sprite menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The sprite menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a sprite menu field
   * does not exist on the block with the given id.
   */


  _getSpriteField(blockId) {
    const block = this.getBlock(blockId);

    if (!block) {
      return null;
    }

    const spriteMenuNames = ["TOWARDS", "TO", "OBJECT", "VIDEOONMENU2", "DISTANCETOMENU", "TOUCHINGOBJECTMENU", "CLONE_OPTION"];

    for (let i = 0; i < spriteMenuNames.length; i++) {
      const menuName = spriteMenuNames[i];

      if (block.fields.hasOwnProperty(menuName)) {
        return block.fields[menuName];
      }
    }

    return null;
  } // ---------------------------------------------------------------------

  /**
   * Encode all of `this._blocks` as an XML string usable
   * by a Blockly/scratch-blocks workspace.
   * @param {object<string, Comment>} comments Map of comments referenced by id
   * @return {string} String of XML representing this object's blocks.
   */


  toXML(comments) {
    return this._scripts.map(script => this.blockToXML(script, comments)).join();
  }
  /**
   * Recursively encode an individual block and its children
   * into a Blockly/scratch-blocks XML string.
   * @param {!string} blockId ID of block to encode.
   * @param {object<string, Comment>} comments Map of comments referenced by id
   * @return {string} String of XML representing this block and any children.
   */


  blockToXML(blockId, comments) {
    const block = this._blocks[blockId]; // block should exist, but currently some blocks' next property point
    // to a blockId for non-existent blocks. Until we track down that behavior,
    // this early exit allows the project to load.

    if (!block) return; // Encode properties of this block.

    const tagName = block.shadow ? "shadow" : "block";
    let xmlString = `<${tagName}
                id="${block.id}"
                type="${block.opcode}"
                ${block.topLevel ? `x="${block.x}" y="${block.y}"` : ""}
            >`;
    const commentId = block.comment;

    if (commentId) {
      if (comments) {
        if (comments.hasOwnProperty(commentId)) {
          xmlString += comments[commentId].toXML();
        } else {
          console.warn(`Could not find comment with id: ${commentId} in provided comment descriptions.`);
        }
      } else {
        console.warn(`Cannot serialize comment with id: ${commentId}; no comment descriptions provided.`);
      }
    } // Add any mutation. Must come before inputs.


    if (block.mutation) {
      xmlString += this.mutationToXML(block.mutation);
    } // Add any inputs on this block.


    for (const input in block.inputs) {
      if (!block.inputs.hasOwnProperty(input)) continue;
      const blockInput = block.inputs[input]; // Only encode a value tag if the value input is occupied.

      if (blockInput.block || blockInput.shadow) {
        xmlString += `<value name="${blockInput.name}">`;

        if (blockInput.block) {
          xmlString += this.blockToXML(blockInput.block, comments);
        }

        if (blockInput.shadow && blockInput.shadow !== blockInput.block) {
          // Obscured shadow.
          xmlString += this.blockToXML(blockInput.shadow, comments);
        }

        xmlString += "</value>";
      }
    } // Add any fields on this block.


    for (const field in block.fields) {
      if (!block.fields.hasOwnProperty(field)) continue;
      const blockField = block.fields[field];
      xmlString += `<field name="${blockField.name}"`;
      const fieldId = blockField.id;

      if (fieldId) {
        xmlString += ` id="${fieldId}"`;
      }

      const varType = blockField.variableType;

      if (typeof varType === "string") {
        xmlString += ` variabletype="${varType}"`;
      }

      let value = blockField.value;

      if (typeof value === "string") {
        value = Utility.xmlEscape(blockField.value);
      }

      xmlString += `>${value}</field>`;
    } // Add blocks connected to the next connection.


    if (block.next) {
      xmlString += `<next>${this.blockToXML(block.next, comments)}</next>`;
    }

    xmlString += `</${tagName}>`;
    return xmlString;
  }
  /**
   * Recursively encode a mutation object to XML.
   * @param {!object} mutation Object representing a mutation.
   * @return {string} XML string representing a mutation.
   */


  mutationToXML(mutation) {
    let mutationString = `<${mutation.tagName}`;

    for (const prop in mutation) {
      if (prop === "children" || prop === "tagName") continue;
      let mutationValue = typeof mutation[prop] === "string" ? Utility.xmlEscape(mutation[prop]) : mutation[prop]; // Handle dynamic extension blocks

      if (prop === "blockInfo") {
        mutationValue = Utility.xmlEscape(JSON.stringify(mutation[prop]));
      }

      mutationString += ` ${prop}="${mutationValue}"`;
    }

    mutationString += ">";

    for (let i = 0; i < mutation.children.length; i++) {
      mutationString += this.mutationToXML(mutation.children[i]);
    }

    mutationString += `</${mutation.tagName}>`;
    return mutationString;
  } // ---------------------------------------------------------------------

  /**
   * Helper to serialize block fields and input fields for reporting new monitors
   * @param {!object} block Block to be paramified.
   * @return {!object} object of param key/values.
   */


  _getBlockParams(block) {
    const params = {};

    for (const key in block.fields) {
      params[key] = block.fields[key].value;
    }

    for (const inputKey in block.inputs) {
      const inputBlock = this._blocks[block.inputs[inputKey].block];

      for (const key in inputBlock.fields) {
        params[key] = inputBlock.fields[key].value;
      }
    }

    return params;
  }
  /**
   * Helper to get the corresponding internal procedure definition block
   * @param {!object} defineBlock Outer define block.
   * @return {!object} internal definition block which has the mutation.
   */


  _getCustomBlockInternal(defineBlock) {
    if (defineBlock.inputs && defineBlock.inputs.custom_block) {
      return this._blocks[defineBlock.inputs.custom_block.block];
    }
  }
  /**
   * Helper to add a stack to `this._scripts`.
   * @param {?string} topBlockId ID of block that starts the script.
   */


  _addScript(topBlockId) {
    const i = this._scripts.indexOf(topBlockId);

    if (i > -1) return; // Already in scripts.

    this._scripts.push(topBlockId); // Update `topLevel` property on the top block.


    this._blocks[topBlockId].topLevel = true;
  }
  /**
   * Helper to remove a script from `this._scripts`.
   * @param {?string} topBlockId ID of block that starts the script.
   */


  _deleteScript(topBlockId) {
    const i = this._scripts.indexOf(topBlockId);

    if (i > -1) this._scripts.splice(i, 1); // Update `topLevel` property on the top block.

    if (this._blocks[topBlockId]) this._blocks[topBlockId].topLevel = false;
  }

}
/**
 * A private method shared with execute to build an object containing the block
 * information execute needs and that is reset when other cached Blocks info is
 * reset.
 * @param {Blocks} blocks Blocks containing the expected blockId
 * @param {string} blockId blockId for the desired execute cache
 * @param {function} CacheType constructor for cached block information
 * @return {object} execute cache object
 */


BlocksExecuteCache.getCached = function (blocks, blockId, CacheType) {
  let cached = blocks._cache._executeCached[blockId];

  if (typeof cached !== "undefined") {
    return cached;
  }

  const block = blocks.getBlock(blockId);
  if (typeof block === "undefined") return null;

  if (typeof CacheType === "undefined") {
    cached = {
      id: blockId,
      opcode: blocks.getOpcode(block),
      fields: blocks.getFields(block),
      inputs: blocks.getInputs(block),
      mutation: blocks.getMutation(block)
    };
  } else {
    cached = new CacheType(blocks, {
      id: blockId,
      opcode: blocks.getOpcode(block),
      fields: blocks.getFields(block),
      inputs: blocks.getInputs(block),
      mutation: blocks.getMutation(block)
    });
  }

  blocks._cache._executeCached[blockId] = cached;
  return cached;
};
/**
 * Cache class constructor for runtime. Used to consider what threads should
 * start based on hat data.
 * @type {function}
 */


const RuntimeScriptCache = BlocksRuntimeCache._RuntimeScriptCache;
/**
 * Get an array of scripts from a block container prefiltered to match opcode.
 * @param {Blocks} blocks - Container of blocks
 * @param {string} opcode - Opcode to filter top blocks by
 * @returns {Array.<RuntimeScriptCache>} - Array of RuntimeScriptCache cache
 *   objects
 */

BlocksRuntimeCache.getScripts = function (blocks, opcode) {
  let scripts = blocks._cache.scripts[opcode];

  if (!scripts) {
    scripts = blocks._cache.scripts[opcode] = [];
    const allScripts = blocks._scripts;

    for (let i = 0; i < allScripts.length; i++) {
      const topBlockId = allScripts[i];
      const block = blocks.getBlock(topBlockId);

      if (block.opcode === opcode) {
        scripts.push(new RuntimeScriptCache(blocks, topBlockId));
      }
    }
  }

  return scripts;
};

module.exports = Blocks;

/***/ }),

/***/ "./src/engine/comment.js":
/*!*******************************!*\
  !*** ./src/engine/comment.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview
 * Object representing a Scratch Comment (block or workspace).
 */
class Comment {
  /**
   * @param {string} id Id of the comment.
   * @param {string} text Text content of the comment.
   * @param {number} x X position of the comment on the workspace.
   * @param {number} y Y position of the comment on the workspace.
   * @param {number} width The width of the comment when it is full size.
   * @param {number} height The height of the comment when it is full size.
   * @param {boolean} minimized Whether the comment is minimized.
   * @constructor
   */
  constructor(id, text, x, y, width, height, minimized) {
    console.warn("comment:", Utility.uid());
    this.id = id || Utility.uid();
    this.text = text;
    this.x = x;
    this.y = y;
    this.width = Math.max(Number(width), Comment.MIN_WIDTH);
    this.height = Math.max(Number(height), Comment.MIN_HEIGHT);
    this.minimized = minimized || false;
    this.blockId = null;
  }

  toXML() {
    return `<comment id="${this.id}" x="${this.x}" y="${this.y}" w="${this.width}" h="${this.height}" pinned="${this.blockId !== null}" minimized="${this.minimized}">${Utility.xmlEscape(this.text)}</comment>`;
  } // TODO choose min and defaults for width and height


  static get MIN_WIDTH() {
    return 20;
  }

  static get MIN_HEIGHT() {
    return 20;
  }

  static get DEFAULT_WIDTH() {
    return 100;
  }

  static get DEFAULT_HEIGHT() {
    return 100;
  }

}

module.exports = Comment;

/***/ }),

/***/ "./src/engine/execute.js":
/*!*******************************!*\
  !*** ./src/engine/execute.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const BlockUtility = __webpack_require__(/*! ./block-utility */ "./src/engine/block-utility.js");

const BlocksExecuteCache = __webpack_require__(/*! ./blocks-execute-cache */ "./src/engine/blocks-execute-cache.js");

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const {
  Map
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
/**
 * Single BlockUtility instance reused by execute for every pritimive ran.
 * @const
 */


const blockUtility = new BlockUtility();
/**
 * Profiler frame name for block functions.
 * @const {string}
 */

const blockFunctionProfilerFrame = "blockFunction";
/**
 * Profiler frame ID for 'blockFunction'.
 * @type {number}
 */

let blockFunctionProfilerId = -1;
/**
 * Utility function to determine if a value is a Promise.
 * @param {*} value Value to check for a Promise.
 * @return {boolean} True if the value appears to be a Promise.
 */

const isPromise = function (value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
};
/**
 * Handle any reported value from the primitive, either directly returned
 * or after a promise resolves.
 * @param {*} resolvedValue Value eventually returned from the primitive.
 * @param {!Sequencer} sequencer Sequencer stepping the thread for the ran
 * primitive.
 * @param {!Thread} thread Thread containing the primitive.
 * @param {!string} currentBlockId Id of the block in its thread for value from
 * the primitive.
 * @param {!string} opcode opcode used to identify a block function primitive.
 * @param {!boolean} isHat Is the current block a hat?
 */
// @todo move this to callback attached to the thread when we have performance
// metrics (dd)


const handleReport = function (resolvedValue, sequencer, thread, blockCached, lastOperation) {
  const currentBlockId = blockCached.id;
  const opcode = blockCached.opcode;
  const isHat = blockCached._isHat;
  thread.pushReportedValue(resolvedValue);

  if (isHat) {
    // Hat predicate was evaluated.
    if (sequencer.runtime.getIsEdgeActivatedHat(opcode)) {
      // If this is an edge-activated hat, only proceed if the value is
      // true and used to be false, or the stack was activated explicitly
      // via stack click
      if (!thread.stackClick) {
        const hasOldEdgeValue = thread.target.hasEdgeActivatedValue(currentBlockId);
        const oldEdgeValue = thread.target.updateEdgeActivatedValue(currentBlockId, resolvedValue);
        const edgeWasActivated = hasOldEdgeValue ? !oldEdgeValue && resolvedValue : resolvedValue;

        if (!edgeWasActivated) {
          sequencer.retireThread(thread);
        }
      }
    } else if (!resolvedValue) {
      // Not an edge-activated hat: retire the thread
      // if predicate was false.
      sequencer.retireThread(thread);
    }
  } else {
    // In a non-hat, report the value visually if necessary if
    // at the top of the thread stack.
    if (lastOperation && typeof resolvedValue !== "undefined" && thread.atStackTop()) {
      if (thread.stackClick) {
        sequencer.runtime.visualReport(currentBlockId, resolvedValue);
      }

      if (thread.updateMonitor) {
        const targetId = sequencer.runtime.monitorBlocks.getBlock(currentBlockId).targetId;

        if (targetId && !sequencer.runtime.getTargetById(targetId)) {
          // Target no longer exists
          return;
        }

        sequencer.runtime.requestUpdateMonitor(Map({
          id: currentBlockId,
          spriteName: targetId ? sequencer.runtime.getTargetById(targetId).getName() : null,
          value: resolvedValue
        }));
      }
    } // Finished any yields.


    thread.status = Thread.STATUS_RUNNING;
  }
};

const handlePromise = (primitiveReportedValue, sequencer, thread, blockCached, lastOperation) => {
  if (thread.status === Thread.STATUS_RUNNING) {
    // Primitive returned a promise; automatically yield thread.
    thread.status = Thread.STATUS_PROMISE_WAIT;
  } // Promise handlers


  primitiveReportedValue.then(resolvedValue => {
    handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation); // If it's a command block or a top level reporter in a stackClick.

    if (lastOperation) {
      let stackFrame;
      let nextBlockId;

      do {
        // In the case that the promise is the last block in the current thread stack
        // We need to pop out repeatedly until we find the next block.
        const popped = thread.popStack();

        if (popped === null) {
          return;
        }

        nextBlockId = thread.target.blocks.getNextBlock(popped);

        if (nextBlockId !== null) {
          // A next block exists so break out this loop
          break;
        } // Investigate the next block and if not in a loop,
        // then repeat and pop the next item off the stack frame


        stackFrame = thread.peekStackFrame();
      } while (stackFrame !== null && !stackFrame.isLoop);

      thread.pushStack(nextBlockId);
    }
  }, rejectionReason => {
    // Promise rejected: the primitive had some error.
    // Log it and proceed.
    console.warn("Primitive rejected promise: ", rejectionReason);
    thread.status = Thread.STATUS_RUNNING;
    thread.popStack();
  });
};
/**
 * A execute.js internal representation of a block to reduce the time spent in
 * execute as the same blocks are called the most.
 *
 * With the help of the Blocks class create a mutable copy of block
 * information. The members of BlockCached derived values of block information
 * that does not need to be reevaluated until a change in Blocks. Since Blocks
 * handles where the cache instance is stored, it drops all cache versions of a
 * block when any change happens to it. This way we can quickly execute blocks
 * and keep perform the right action according to the current block information
 * in the editor.
 *
 * @param {Blocks} blockContainer the related Blocks instance
 * @param {object} cached default set of cached values
 */


class BlockCached {
  constructor(blockContainer, cached) {
    /**
     * Block id in its parent set of blocks.
     * @type {string}
     */
    this.id = cached.id;
    /**
     * Block operation code for this block.
     * @type {string}
     */

    this.opcode = cached.opcode;
    /**
     * Original block object containing argument values for static fields.
     * @type {object}
     */

    this.fields = cached.fields;
    /**
     * Original block object containing argument values for executable inputs.
     * @type {object}
     */

    this.inputs = cached.inputs;
    /**
     * Procedure mutation.
     * @type {?object}
     */

    this.mutation = cached.mutation;
    /**
     * The profiler the block is configured with.
     * @type {?Profiler}
     */

    this._profiler = null;
    /**
     * Profiler information frame.
     * @type {?ProfilerFrame}
     */

    this._profilerFrame = null;
    /**
     * Is the opcode a hat (event responder) block.
     * @type {boolean}
     */

    this._isHat = false;
    /**
     * The block opcode's implementation function.
     * @type {?function}
     */

    this._blockFunction = null;
    /**
     * Is the block function defined for this opcode?
     * @type {boolean}
     */

    this._definedBlockFunction = false;
    /**
     * Is this block a block with no function but a static value to return.
     * @type {boolean}
     */

    this._isShadowBlock = false;
    /**
     * The static value of this block if it is a shadow block.
     * @type {?any}
     */

    this._shadowValue = null;
    /**
     * A copy of the block's fields that may be modified.
     * @type {object}
     */

    this._fields = Object.assign({}, this.fields);
    /**
     * A copy of the block's inputs that may be modified.
     * @type {object}
     */

    this._inputs = Object.assign({}, this.inputs);
    /**
     * An arguments object for block implementations. All executions of this
     * specific block will use this objecct.
     * @type {object}
     */

    this._argValues = {
      mutation: this.mutation
    };
    /**
     * The inputs key the parent refers to this BlockCached by.
     * @type {string}
     */

    this._parentKey = null;
    /**
     * The target object where the parent wants the resulting value stored
     * with _parentKey as the key.
     * @type {object}
     */

    this._parentValues = null;
    /**
     * A sequence of non-shadow operations that can must be performed. This
     * list recreates the order this block and its children are executed.
     * Since the order is always the same we can safely store that order
     * and iterate over the operations instead of dynamically walking the
     * tree every time.
     * @type {Array<BlockCached>}
     */

    this._ops = [];
    const {
      runtime
    } = blockUtility.sequencer;
    const {
      opcode,
      fields,
      inputs
    } = this; // Assign opcode isHat and blockFunction data to avoid dynamic lookups.

    this._isHat = runtime.getIsHat(opcode);
    this._blockFunction = runtime.getOpcodeFunction(opcode);
    this._definedBlockFunction = typeof this._blockFunction !== "undefined"; // Store the current shadow value if there is a shadow value.

    const fieldKeys = Object.keys(fields);
    this._isShadowBlock = !this._definedBlockFunction && fieldKeys.length === 1 && Object.keys(inputs).length === 0;
    this._shadowValue = this._isShadowBlock && fields[fieldKeys[0]].value; // Store the static fields onto _argValues.

    for (const fieldName in fields) {
      if (fieldName === "VARIABLE" || fieldName === "LIST" || fieldName === "BROADCAST_OPTION") {
        this._argValues[fieldName] = {
          id: fields[fieldName].id,
          name: fields[fieldName].value
        };
      } else {
        this._argValues[fieldName] = fields[fieldName].value;
      }
    } // Remove custom_block. It is not part of block execution.


    delete this._inputs.custom_block;

    if ("BROADCAST_INPUT" in this._inputs) {
      // BROADCAST_INPUT is called BROADCAST_OPTION in the args and is an
      // object with an unchanging shape.
      this._argValues.BROADCAST_OPTION = {
        id: null,
        name: null
      }; // We can go ahead and compute BROADCAST_INPUT if it is a shadow
      // value.

      const broadcastInput = this._inputs.BROADCAST_INPUT;

      if (broadcastInput.block === broadcastInput.shadow) {
        // Shadow dropdown menu is being used.
        // Get the appropriate information out of it.
        const shadow = blockContainer.getBlock(broadcastInput.shadow);
        const broadcastField = shadow.fields.BROADCAST_OPTION;
        this._argValues.BROADCAST_OPTION.id = broadcastField.id;
        this._argValues.BROADCAST_OPTION.name = broadcastField.value; // Evaluating BROADCAST_INPUT here we do not need to do so
        // later.

        delete this._inputs.BROADCAST_INPUT;
      }
    } // Cache all input children blocks in the operation lists. The
    // operations can later be run in the order they appear in correctly
    // executing the operations quickly in a flat loop instead of needing to
    // recursivly iterate them.


    for (const inputName in this._inputs) {
      const input = this._inputs[inputName];

      if (input.block) {
        const inputCached = BlocksExecuteCache.getCached(blockContainer, input.block, BlockCached);

        if (inputCached._isHat) {
          continue;
        }

        this._ops.push(...inputCached._ops);

        inputCached._parentKey = inputName;
        inputCached._parentValues = this._argValues; // Shadow values are static and do not change, go ahead and
        // store their value on args.

        if (inputCached._isShadowBlock) {
          this._argValues[inputName] = inputCached._shadowValue;
        }
      }
    } // The final operation is this block itself. At the top most block is a
    // command block or a block that is being run as a monitor.


    if (this._definedBlockFunction) {
      this._ops.push(this);
    }
  }

}
/**
 * Initialize a BlockCached instance so its command/hat
 * block and reporters can be profiled during execution.
 * @param {Profiler} profiler - The profiler that is currently enabled.
 * @param {BlockCached} blockCached - The blockCached instance to profile.
 */


const _prepareBlockProfiling = function (profiler, blockCached) {
  blockCached._profiler = profiler;

  if (blockFunctionProfilerId === -1) {
    blockFunctionProfilerId = profiler.idByName(blockFunctionProfilerFrame);
  }

  const ops = blockCached._ops;

  for (let i = 0; i < ops.length; i++) {
    ops[i]._profilerFrame = profiler.frame(blockFunctionProfilerId, ops[i].opcode);
  }
};
/**
 * Execute a block.
 * @param {!Sequencer} sequencer Which sequencer is executing.
 * @param {!Thread} thread Thread which to read and execute.
 */


const execute = function (sequencer, thread) {
  const runtime = sequencer.runtime; // store sequencer and thread so block functions can access them through
  // convenience methods.

  blockUtility.sequencer = sequencer;
  blockUtility.thread = thread; // Current block to execute is the one on the top of the stack.

  const currentBlockId = thread.peekStack();
  const currentStackFrame = thread.peekStackFrame();
  let blockContainer = thread.blockContainer;
  let blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached);

  if (blockCached === null) {
    blockContainer = runtime.flyoutBlocks;
    blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached); // Stop if block or target no longer exists.

    if (blockCached === null) {
      // No block found: stop the thread; script no longer exists.
      sequencer.retireThread(thread);
      return;
    }
  }

  const ops = blockCached._ops;
  const length = ops.length;
  let i = 0;

  if (currentStackFrame.reported !== null) {
    const reported = currentStackFrame.reported; // Reinstate all the previous values.

    for (; i < reported.length; i++) {
      const {
        opCached: oldOpCached,
        inputValue
      } = reported[i];
      const opCached = ops.find(op => op.id === oldOpCached);

      if (opCached) {
        const inputName = opCached._parentKey;
        const argValues = opCached._parentValues;

        if (inputName === "BROADCAST_INPUT") {
          // Something is plugged into the broadcast input.
          // Cast it to a string. We don't need an id here.
          argValues.BROADCAST_OPTION.id = null;
          argValues.BROADCAST_OPTION.name = String(inputValue);
        } else {
          argValues[inputName] = inputValue;
        }
      }
    } // Find the last reported block that is still in the set of operations.
    // This way if the last operation was removed, we'll find the next
    // candidate. If an earlier block that was performed was removed then
    // we'll find the index where the last operation is now.


    if (reported.length > 0) {
      const lastExisting = reported.reverse().find(report => ops.find(op => op.id === report.opCached));

      if (lastExisting) {
        i = ops.findIndex(opCached => opCached.id === lastExisting.opCached) + 1;
      } else {
        i = 0;
      }
    } // The reporting block must exist and must be the next one in the sequence of operations.


    if (thread.justReported !== null && ops[i] && ops[i].id === currentStackFrame.reporting) {
      const opCached = ops[i];
      const inputValue = thread.justReported;
      thread.justReported = null;
      const inputName = opCached._parentKey;
      const argValues = opCached._parentValues;

      if (inputName === "BROADCAST_INPUT") {
        // Something is plugged into the broadcast input.
        // Cast it to a string. We don't need an id here.
        argValues.BROADCAST_OPTION.id = null;
        argValues.BROADCAST_OPTION.name = String(inputValue);
      } else {
        argValues[inputName] = inputValue;
      }

      i += 1;
    }

    currentStackFrame.reporting = null;
    currentStackFrame.reported = null;
  }

  const start = i;

  for (; i < length; i++) {
    const lastOperation = i === length - 1;
    const opCached = ops[i];
    const blockFunction = opCached._blockFunction; // Update values for arguments (inputs).

    const argValues = opCached._argValues; // Fields are set during opCached initialization.
    // Blocks should glow when a script is starting,
    // not after it has finished (see #1404).
    // Only blocks in blockContainers that don't forceNoGlow
    // should request a glow.

    if (!blockContainer.forceNoGlow) {
      thread.requestScriptGlowInFrame = true;
    } // Inputs are set during previous steps in the loop.


    const primitiveReportedValue = blockFunction(argValues, blockUtility); // If it's a promise, wait until promise resolves.

    if (isPromise(primitiveReportedValue)) {
      handlePromise(primitiveReportedValue, sequencer, thread, opCached, lastOperation); // Store the already reported values. They will be thawed into the
      // future versions of the same operations by block id. The reporting
      // operation if it is promise waiting will set its parent value at
      // that time.

      thread.justReported = null;
      currentStackFrame.reporting = ops[i].id;
      currentStackFrame.reported = ops.slice(0, i).map(reportedCached => {
        const inputName = reportedCached._parentKey;
        const reportedValues = reportedCached._parentValues;

        if (inputName === "BROADCAST_INPUT") {
          return {
            opCached: reportedCached.id,
            inputValue: reportedValues[inputName].BROADCAST_OPTION.name
          };
        }

        return {
          opCached: reportedCached.id,
          inputValue: reportedValues[inputName]
        };
      }); // We are waiting for a promise. Stop running this set of operations
      // and continue them later after thawing the reported values.

      break;
    } else if (thread.status === Thread.STATUS_RUNNING) {
      if (lastOperation) {
        handleReport(primitiveReportedValue, sequencer, thread, opCached, lastOperation);
      } else {
        // By definition a block that is not last in the list has a
        // parent.
        const inputName = opCached._parentKey;
        const parentValues = opCached._parentValues;

        if (inputName === "BROADCAST_INPUT") {
          // Something is plugged into the broadcast input.
          // Cast it to a string. We don't need an id here.
          parentValues.BROADCAST_OPTION.id = null;
          parentValues.BROADCAST_OPTION.name = String(primitiveReportedValue);
        } else {
          parentValues[inputName] = primitiveReportedValue;
        }
      }
    }
  }

  if (runtime.profiler !== null) {
    if (blockCached._profiler !== runtime.profiler) {
      _prepareBlockProfiling(runtime.profiler, blockCached);
    } // Determine the index that is after the last executed block. `i` is
    // currently the block that was just executed. `i + 1` will be the block
    // after that. `length` with the min call makes sure we don't try to
    // reference an operation outside of the set of operations.


    const end = Math.min(i + 1, length);

    for (let p = start; p < end; p++) {
      ops[p]._profilerFrame.count += 1;
    }
  }
};

module.exports = execute;

/***/ }),

/***/ "./src/engine/monitor-record.js":
/*!**************************************!*\
  !*** ./src/engine/monitor-record.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
  Record
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");

const MonitorRecord = Record({
  id: null,
  // Block Id

  /** Present only if the monitor is sprite-specific, such as x position */
  spriteName: null,

  /** Present only if the monitor is sprite-specific, such as x position */
  targetId: null,
  opcode: null,
  value: null,
  params: null,
  mode: 'default',
  sliderMin: 0,
  sliderMax: 100,
  isDiscrete: true,
  x: null,
  // (x: null, y: null) Indicates that the monitor should be auto-positioned
  y: null,
  width: 0,
  height: 0,
  visible: true
});
module.exports = MonitorRecord;

/***/ }),

/***/ "./src/engine/mutation-adapter.js":
/*!****************************************!*\
  !*** ./src/engine/mutation-adapter.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const html = __webpack_require__(/*! htmlparser2 */ "./node_modules/htmlparser2/lib/index.js");

const decodeHtml = __webpack_require__(/*! decode-html */ "./node_modules/decode-html/index.js");
/**
 * Convert a part of a mutation DOM to a mutation VM object, recursively.
 * @param {object} dom DOM object for mutation tag.
 * @return {object} Object representing useful parts of this mutation.
 */


const mutatorTagToObject = function (dom) {
  const obj = Object.create(null);
  obj.tagName = dom.name;
  obj.children = [];

  for (const prop in dom.attribs) {
    if (prop === 'xmlns') continue;
    obj[prop] = decodeHtml(dom.attribs[prop]); // Note: the capitalization of block info in the following lines is important.
    // The lowercase is read in from xml which normalizes case. The VM uses camel case everywhere else.

    if (prop === 'blockinfo') {
      obj.blockInfo = JSON.parse(obj.blockinfo);
      delete obj.blockinfo;
    }
  }

  for (let i = 0; i < dom.children.length; i++) {
    obj.children.push(mutatorTagToObject(dom.children[i]));
  }

  return obj;
};
/**
 * Adapter between mutator XML or DOM and block representation which can be
 * used by the Scratch runtime.
 * @param {(object|string)} mutation Mutation XML string or DOM.
 * @return {object} Object representing the mutation.
 */


const mutationAdpater = function (mutation) {
  let mutationParsed; // Check if the mutation is already parsed; if not, parse it.

  if (typeof mutation === 'object') {
    mutationParsed = mutation;
  } else {
    mutationParsed = html.parseDOM(mutation)[0];
  }

  return mutatorTagToObject(mutationParsed);
};

module.exports = mutationAdpater;

/***/ }),

/***/ "./src/engine/profiler.js":
/*!********************************!*\
  !*** ./src/engine/profiler.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview
 * A way to profile Scratch internal performance. Like what blocks run during a
 * step? How much time do they take? How much time is spent inbetween blocks?
 *
 * Profiler aims for to spend as little time inside its functions while
 * recording. For this it has a simple internal record structure that records a
 * series of values for each START and STOP event in a single array. This lets
 * all the values be pushed in one call for the array. This simplicity allows
 * the contents of the start() and stop() calls to be inlined in areas that are
 * called frequently enough to want even greater performance from Profiler so
 * what is recorded better reflects on the profiled code and not Profiler
 * itself.
 */

/**
 * The next id returned for a new profile'd function.
 * @type {number}
 */
let nextId = 0;
/**
 * The mapping of names to ids.
 * @const {Object.<string, number>}
 */

const profilerNames = {};
/**
 * The START event identifier in Profiler records.
 * @const {number}
 */

const START = 0;
/**
 * The STOP event identifier in Profiler records.
 * @const {number}
 */

const STOP = 1;
/**
 * The number of cells used in the records array by a START event.
 * @const {number}
 */

const START_SIZE = 4;
/**
 * The number of cells used in the records array by a STOP event.
 * @const {number}
 */

const STOP_SIZE = 2;
/**
 * Stored reference to Performance instance provided by the Browser.
 * @const {Performance}
 */

const performance = typeof window === 'object' && window.performance;
/**
 * Callback handle called by Profiler for each frame it decodes from its
 * records.
 * @callback FrameCallback
 * @param {ProfilerFrame} frame
 */

/**
 * A set of information about a frame of execution that was recorded.
 */

class ProfilerFrame {
  /**
   * @param {number} depth Depth of the frame in the recorded stack.
   */
  constructor(depth) {
    /**
     * The numeric id of a record symbol like Runtime._step or
     * blockFunction.
     * @type {number}
     */
    this.id = -1;
    /**
     * The amount of time spent inside the recorded frame and any deeper
     * frames.
     * @type {number}
     */

    this.totalTime = 0;
    /**
     * The amount of time spent only inside this record frame. Not
     * including time in any deeper frames.
     * @type {number}
     */

    this.selfTime = 0;
    /**
     * An arbitrary argument for the recorded frame. For example a block
     * function might record its opcode as an argument.
     * @type {*}
     */

    this.arg = null;
    /**
     * The depth of the recorded frame. This can help compare recursive
     * funtions that are recorded. Each level of recursion with have a
     * different depth value.
     * @type {number}
     */

    this.depth = depth;
    /**
     * A summarized count of the number of calls to this frame.
     * @type {number}
     */

    this.count = 0;
  }

}

class Profiler {
  /**
   * @param {FrameCallback} onFrame a handle called for each recorded frame.
   * The passed frame value may not be stored as it'll be updated with later
   * frame information. Any information that is further stored by the handler
   * should make copies or reduce the information.
   */
  constructor(onFrame = function () {}) {
    /**
     * A series of START and STOP values followed by arguments. After
     * recording is complete the full set of records is reported back by
     * stepping through the series to connect the relative START and STOP
     * information.
     * @type {Array.<*>}
     */
    this.records = [];
    /**
     * An array of frames incremented on demand instead as part of start
     * and stop.
     * @type {Array.<ProfilerFrame>}
     */

    this.increments = [];
    /**
     * An array of profiler frames separated by counter argument. Generally
     * for Scratch these frames are separated by block function opcode.
     * This tracks each time an opcode is called.
     * @type {Array.<ProfilerFrame>}
     */

    this.counters = [];
    /**
     * A frame with no id or argument.
     * @type {ProfilerFrame}
     */

    this.nullFrame = new ProfilerFrame(-1);
    /**
     * A cache of ProfilerFrames to reuse when reporting the recorded
     * frames in records.
     * @type {Array.<ProfilerFrame>}
     */

    this._stack = [new ProfilerFrame(0)];
    /**
     * A callback handle called with each decoded frame when reporting back
     * all the recorded times.
     * @type {FrameCallback}
     */

    this.onFrame = onFrame;
    /**
     * A reference to the START record id constant.
     * @const {number}
     */

    this.START = START;
    /**
     * A reference to the STOP record id constant.
     * @const {number}
     */

    this.STOP = STOP;
  }
  /**
   * Start recording a frame of time for an id and optional argument.
   * @param {number} id The id returned by idByName for a name symbol like
   * Runtime._step.
   * @param {?*} arg An arbitrary argument value to store with the frame.
   */


  start(id, arg) {
    this.records.push(START, id, arg, performance.now());
  }
  /**
   * Stop the current frame.
   */


  stop() {
    this.records.push(STOP, performance.now());
  }
  /**
   * Increment the number of times this symbol is called.
   * @param {number} id The id returned by idByName for a name symbol.
   */


  increment(id) {
    if (!this.increments[id]) {
      this.increments[id] = new ProfilerFrame(-1);
      this.increments[id].id = id;
    }

    this.increments[id].count += 1;
  }
  /**
   * Find or create a ProfilerFrame-like object whose counter can be
   * incremented outside of the Profiler.
   * @param {number} id The id returned by idByName for a name symbol.
   * @param {*} arg The argument for a frame that identifies it in addition
   *   to the id.
   * @return {{count: number}} A ProfilerFrame-like whose count should be
   *   incremented for each call.
   */


  frame(id, arg) {
    for (let i = 0; i < this.counters.length; i++) {
      if (this.counters[i].id === id && this.counters[i].arg === arg) {
        return this.counters[i];
      }
    }

    const newCounter = new ProfilerFrame(-1);
    newCounter.id = id;
    newCounter.arg = arg;
    this.counters.push(newCounter);
    return newCounter;
  }
  /**
   * Decode records and report all frames to `this.onFrame`.
   */


  reportFrames() {
    const stack = this._stack;
    let depth = 1; // Step through the records and initialize Frame instances from the
    // START and STOP events. START and STOP events are separated by events
    // for deeper frames run by higher frames. Frames are stored on a stack
    // and reinitialized for each START event. When a stop event is reach
    // the Frame for the current depth has its final values stored and its
    // passed to the current onFrame callback. This way Frames are "pushed"
    // for each START event and "popped" for each STOP and handed to an
    // outside handle to any desired reduction of the collected data.

    for (let i = 0; i < this.records.length;) {
      if (this.records[i] === START) {
        if (depth >= stack.length) {
          stack.push(new ProfilerFrame(depth));
        } // Store id, arg, totalTime, and initialize selfTime.


        const frame = stack[depth++];
        frame.id = this.records[i + 1];
        frame.arg = this.records[i + 2]; // totalTime is first set as the time recorded by this START
        // event. Once the STOP event is reached the stored start time
        // is subtracted from the recorded stop time. The resulting
        // difference is the actual totalTime, and replaces the start
        // time in frame.totalTime.
        //
        // totalTime is used this way as a convenient member to store a
        // value between the two events without needing additional
        // members on the Frame or in a shadow map.

        frame.totalTime = this.records[i + 3]; // selfTime is decremented until we reach the STOP event for
        // this frame. totalTime will be added to it then to get the
        // time difference.

        frame.selfTime = 0;
        i += START_SIZE;
      } else if (this.records[i] === STOP) {
        const now = this.records[i + 1];
        const frame = stack[--depth]; // totalTime is the difference between the start event time
        // stored in totalTime and the stop event time pulled from this
        // record.

        frame.totalTime = now - frame.totalTime; // selfTime is the difference of this frame's totalTime and the
        // sum of totalTime of deeper frames.

        frame.selfTime += frame.totalTime; // Remove this frames totalTime from the parent's selfTime.

        stack[depth - 1].selfTime -= frame.totalTime; // This frame occured once.

        frame.count = 1;
        this.onFrame(frame);
        i += STOP_SIZE;
      } else {
        this.records.length = 0;
        throw new Error('Unable to decode Profiler records.');
      }
    }

    for (let j = 0; j < this.increments.length; j++) {
      if (this.increments[j] && this.increments[j].count > 0) {
        this.onFrame(this.increments[j]);
        this.increments[j].count = 0;
      }
    }

    for (let k = 0; k < this.counters.length; k++) {
      if (this.counters[k].count > 0) {
        this.onFrame(this.counters[k]);
        this.counters[k].count = 0;
      }
    }

    this.records.length = 0;
  }
  /**
   * Lookup or create an id for a frame name.
   * @param {string} name The name to return an id for.
   * @return {number} The id for the passed name.
   */


  idByName(name) {
    return Profiler.idByName(name);
  }
  /**
   * Reverse lookup the name from a given frame id.
   * @param {number} id The id to search for.
   * @return {string} The name for the given id.
   */


  nameById(id) {
    return Profiler.nameById(id);
  }
  /**
   * Lookup or create an id for a frame name.
   * @static
   * @param {string} name The name to return an id for.
   * @return {number} The id for the passed name.
   */


  static idByName(name) {
    if (typeof profilerNames[name] !== 'number') {
      profilerNames[name] = nextId++;
    }

    return profilerNames[name];
  }
  /**
   * Reverse lookup the name from a given frame id.
   * @static
   * @param {number} id The id to search for.
   * @return {string} The name for the given id.
   */


  static nameById(id) {
    for (const name in profilerNames) {
      if (profilerNames[name] === id) {
        return name;
      }
    }

    return null;
  }
  /**
   * Profiler is only available on platforms with the Performance API.
   * @return {boolean} Can the Profiler run in this browser?
   */


  static available() {
    return typeof window === 'object' && typeof window.performance !== 'undefined';
  }

}
/**
 * A reference to the START record id constant.
 * @const {number}
 */


Profiler.START = START;
/**
 * A reference to the STOP record id constant.
 * @const {number}
 */

Profiler.STOP = STOP;
module.exports = Profiler;

/***/ }),

/***/ "./src/engine/runtime.js":
/*!*******************************!*\
  !*** ./src/engine/runtime.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const {
  OrderedMap
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");

const ArgumentType = __webpack_require__(/*! ../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const Blocks = __webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

const BlocksRuntimeCache = __webpack_require__(/*! ./blocks-runtime-cache */ "./src/engine/blocks-runtime-cache.js");

const BlockType = __webpack_require__(/*! ../extension-support/block-type */ "./src/extension-support/block-type.js");

const Profiler = __webpack_require__(/*! ./profiler */ "./src/engine/profiler.js");

const Sequencer = __webpack_require__(/*! ./sequencer */ "./src/engine/sequencer.js");

const execute = __webpack_require__(/*! ./execute.js */ "./src/engine/execute.js");

const TargetType = __webpack_require__(/*! ../extension-support/target-type */ "./src/extension-support/target-type.js");

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const maybeFormatMessage = __webpack_require__(/*! ../util/maybe-format-message */ "./src/util/maybe-format-message.js");

const StageLayering = __webpack_require__(/*! ./stage-layering */ "./src/engine/stage-layering.js");

const Variable = __webpack_require__(/*! ./variable */ "./src/engine/variable.js");

const ScratchLinkWebSocket = __webpack_require__(/*! ../util/scratch-link-websocket */ "./src/util/scratch-link-websocket.js"); // Virtual I/O devices.


const Clock = __webpack_require__(/*! ../io/clock */ "./src/io/clock.js");

const Cloud = __webpack_require__(/*! ../io/cloud */ "./src/io/cloud.js");

const Keyboard = __webpack_require__(/*! ../io/keyboard */ "./src/io/keyboard.js");

const Mouse = __webpack_require__(/*! ../io/mouse */ "./src/io/mouse.js");

const MouseWheel = __webpack_require__(/*! ../io/mouseWheel */ "./src/io/mouseWheel.js");

const UserData = __webpack_require__(/*! ../io/userData */ "./src/io/userData.js");

const Video = __webpack_require__(/*! ../io/video */ "./src/io/video.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const defaultBlockPackages = __webpack_require__(/*! ../vm-blocks.js */ "./src/vm-blocks.js");

console.warn(":", defaultBlockPackages);
/**
 * These constants are copied from scratch-blocks/core/constants.js
 * @TODO find a way to require() these straight from scratch-blocks... maybe make a scratch-blocks/dist/constants.js?
 * @readonly
 * @enum {int}
 */

const KidBlocksConstants = {
  /**
   * ENUM for output shape: hexagonal (booleans/predicates).
   * @const
   */
  OUTPUT_SHAPE_HEXAGONAL: 1,

  /**
   * ENUM for output shape: rounded (numbers).
   * @const
   */
  OUTPUT_SHAPE_ROUND: 2,

  /**
   * ENUM for output shape: squared (any/all values; strings).
   * @const
   */
  OUTPUT_SHAPE_SQUARE: 3
};
const defaultExtensionColors = ["#0FBD8C", "#0DA57A", "#0B8E69"];
/**
 * Information used for converting Scratch argument types into scratch-blocks data.
 * @type {object.<ArgumentType, {shadowType: string, fieldType: string}>}
 */

const ArgumentTypeMap = (() => {
  const map = {};
  map[ArgumentType.ANGLE] = {
    shadow: {
      type: "math_angle",
      // We specify fieldNames here so that we can pick
      // create and populate a field with the defaultValue
      // specified in the extension.
      // When the `fieldName` property is not specified,
      // the <field></field> will be left out of the XML and
      // the scratch-blocks defaults for that field will be
      // used instead (e.g. default of 0 for number fields)
      fieldName: "NUM"
    }
  };
  map[ArgumentType.COLOR] = {
    shadow: {
      type: "colour_picker",
      fieldName: "COLOUR"
    }
  };
  map[ArgumentType.NUMBER] = {
    shadow: {
      type: "math_number",
      fieldName: "NUM"
    }
  };
  map[ArgumentType.STRING] = {
    shadow: {
      type: "text",
      fieldName: "TEXT"
    }
  };
  map[ArgumentType.BOOLEAN] = {
    check: "Boolean"
  };
  map[ArgumentType.MATRIX] = {
    shadow: {
      type: "matrix",
      fieldName: "MATRIX"
    }
  };
  map[ArgumentType.NOTE] = {
    shadow: {
      type: "note",
      fieldName: "NOTE"
    }
  };
  map[ArgumentType.IMAGE] = {
    // Inline images are weird because they're not actually "arguments".
    // They are more analagous to the label on a block.
    fieldType: "field_image"
  };
  return map;
})();
/**
 * A pair of functions used to manage the cloud variable limit,
 * to be used when adding (or attempting to add) or removing a cloud variable.
 * @typedef {object} CloudDataManager
 * @property {function} canAddCloudVariable A function to call to check that
 * a cloud variable can be added.
 * @property {function} addCloudVariable A function to call to track a new
 * cloud variable on the runtime.
 * @property {function} removeCloudVariable A function to call when
 * removing an existing cloud variable.
 * @property {function} hasCloudVariables A function to call to check that
 * the runtime has any cloud variables.
 */

/**
 * Creates and manages cloud variable limit in a project,
 * and returns two functions to be used to add a new
 * cloud variable (while checking that it can be added)
 * and remove an existing cloud variable.
 * These are to be called whenever attempting to create or delete
 * a cloud variable.
 * @return {CloudDataManager} The functions to be used when adding or removing a
 * cloud variable.
 */


const cloudDataManager = () => {
  const limit = 10;
  let count = 0;

  const canAddCloudVariable = () => count < limit;

  const addCloudVariable = () => {
    count++;
  };

  const removeCloudVariable = () => {
    count--;
  };

  const hasCloudVariables = () => count > 0;

  return {
    canAddCloudVariable,
    addCloudVariable,
    removeCloudVariable,
    hasCloudVariables
  };
};
/**
 * Numeric ID for Runtime._step in Profiler instances.
 * @type {number}
 */


let stepProfilerId = -1;
/**
 * Numeric ID for Sequencer.stepThreads in Profiler instances.
 * @type {number}
 */

let stepThreadsProfilerId = -1;
/**
 * Numeric ID for RenderWebGL.draw in Profiler instances.
 * @type {number}
 */

let rendererDrawProfilerId = -1;
/**
 * Manages targets, scripts, and the sequencer.
 * @constructor
 */

class Runtime extends EventEmitter {
  constructor() {
    super();
    console.log("class Runtime");
    /**
     * Target management and storage.
     * @type {Array.<!Target>}
     */

    this.targets = [];
    /**
     * Targets in reverse order of execution. Shares its order with drawables.
     * @type {Array.<!Target>}
     */

    this.executableTargets = [];
    /**
     * A list of threads that are currently running in the VM.
     * Threads are added when execution starts and pruned when execution ends.
     * @type {Array.<Thread>}
     */

    this.threads = [];
    /** @type {!Sequencer} */

    this.sequencer = new Sequencer(this);
    /**
     * Storage container for flyout blocks.
     * These will execute on `_editingTarget.`
     * @type {!Blocks}
     */

    this.flyoutBlocks = new Blocks(this, true
    /* force no glow */
    );
    /**
     * Storage container for monitor blocks.
     * These will execute on a target maybe
     * @type {!Blocks}
     */

    this.monitorBlocks = new Blocks(this, true
    /* force no glow */
    );
    /**
     * Currently known editing target for the VM.
     * @type {?Target}
     */

    this._editingTarget = null;
    /**
     * Map to look up a block primitive's implementation function by its opcode.
     * This is a two-step lookup: package name first, then primitive name.
     * @type {Object.<string, Function>}
     */

    this._primitives = {};
    /**
     * Map to look up all block information by extended opcode.
     * @type {Array.<CategoryInfo>}
     * @private
     */

    this._blockInfo = [];
    /**
     * Map to look up hat blocks' metadata.
     * Keys are opcode for hat, values are metadata objects.
     * @type {Object.<string, Object>}
     */

    this._hats = {};
    /**
     * A list of script block IDs that were glowing during the previous frame.
     * @type {!Array.<!string>}
     */

    this._scriptGlowsPreviousFrame = [];
    /**
     * Number of non-monitor threads running during the previous frame.
     * @type {number}
     */

    this._nonMonitorThreadCount = 0;
    /**
     * All threads that finished running and were removed from this.threads
     * by behaviour in Sequencer.stepThreads.
     * @type {Array<Thread>}
     */

    this._lastStepDoneThreads = null;
    /**
     * Currently known number of clones, used to enforce clone limit.
     * @type {number}
     */

    this._cloneCounter = 0;
    /**
     * Flag to emit a targets update at the end of a step. When target data
     * changes, this flag is set to true.
     * @type {boolean}
     */

    this._refreshTargets = false;
    /**
     * Map to look up all monitor block information by opcode.
     * @type {object}
     * @private
     */

    this.monitorBlockInfo = {};
    /**
     * Ordered map of all monitors, which are MonitorReporter objects.
     */

    this._monitorState = OrderedMap({});
    /**
     * Monitor state from last tick
     */

    this._prevMonitorState = OrderedMap({});
    /**
     * Whether the project is in "turbo mode."
     * @type {Boolean}
     */

    this.turboMode = false;
    /**
     * Whether the project is in "compatibility mode" (30 TPS).
     * @type {Boolean}
     */

    this.compatibilityMode = false;
    /**
     * A reference to the current runtime stepping interval, set
     * by a `setInterval`.
     * @type {!number}
     */

    this._steppingInterval = null;
    /**
     * Current length of a step.
     * Changes as mode switches, and used by the sequencer to calculate
     * WORK_TIME.
     * @type {!number}
     */

    this.currentStepTime = null; // Set an intial value for this.currentMSecs

    this.updateCurrentMSecs();
    /**
     * Whether any primitive has requested a redraw.
     * Affects whether `Sequencer.stepThreads` will yield
     * after stepping each thread.
     * Reset on every frame.
     * @type {boolean}
     */

    this.redrawRequested = false; // .

    this._registerBlockPackages(); // "IO devices" I/O .

    /** @type {Object.<string, Object>} */


    this.ioDevices = {
      clock: new Clock(this),
      cloud: new Cloud(this),
      keyboard: new Keyboard(this),
      mouse: new Mouse(this),
      mouseWheel: new MouseWheel(this),
      userData: new UserData(),
      video: new Video(this)
    };
    /**
     * A list of extensions, used to manage hardware connection.
     */

    this.peripheralExtensions = {};
    /**
     * A runtime profiler that records timed events for later playback to
     * diagnose Scratch performance.
     * @type {Profiler}
     */

    this.profiler = null;
    const newCloudDataManager = cloudDataManager();
    /**
     * Check wether the runtime has any cloud data.
     * @type {function}
     * @return {boolean} Whether or not the runtime currently has any
     * cloud variables.
     */

    this.hasCloudData = newCloudDataManager.hasCloudVariables;
    /**
     * A function which checks whether a new cloud variable can be added
     * to the runtime.
     * @type {function}
     * @return {boolean} Whether or not a new cloud variable can be added
     * to the runtime.
     */

    this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;
    /**
     * A function that tracks a new cloud variable in the runtime,
     * updating the cloud variable limit. Calling this function will
     * emit a cloud data update event if this is the first cloud variable
     * being added.
     * @type {function}
     */

    this.addCloudVariable = this._initializeAddCloudVariable(newCloudDataManager);
    /**
     * A function which updates the runtime's cloud variable limit
     * when removing a cloud variable and emits a cloud update event
     * if the last of the cloud variables is being removed.
     * @type {function}
     */

    this.removeCloudVariable = this._initializeRemoveCloudVariable(newCloudDataManager);
  }
  /**
   * Width of the stage, in pixels.
   * @const {number}
   */


  static get STAGE_WIDTH() {
    return 480;
  }
  /**
   * Height of the stage, in pixels.
   * @const {number}
   */


  static get STAGE_HEIGHT() {
    return 360;
  }
  /**
   * Event name for glowing a script.
   * @const {string}
   */


  static get SCRIPT_GLOW_ON() {
    return "SCRIPT_GLOW_ON";
  }
  /**
   * Event name for unglowing a script.
   * @const {string}
   */


  static get SCRIPT_GLOW_OFF() {
    return "SCRIPT_GLOW_OFF";
  }
  /**
   * Event name for glowing a block.
   * @const {string}
   */


  static get BLOCK_GLOW_ON() {
    return "BLOCK_GLOW_ON";
  }
  /**
   * Event name for unglowing a block.
   * @const {string}
   */


  static get BLOCK_GLOW_OFF() {
    return "BLOCK_GLOW_OFF";
  }
  /**
   * Event name for a cloud data update
   * to this project.
   * @const {string}
   */


  static get HAS_CLOUD_DATA_UPDATE() {
    return "HAS_CLOUD_DATA_UPDATE";
  }
  /**
   * Event name for turning on turbo mode.
   * @const {string}
   */


  static get TURBO_MODE_ON() {
    return "TURBO_MODE_ON";
  }
  /**
   * Event name for turning off turbo mode.
   * @const {string}
   */


  static get TURBO_MODE_OFF() {
    return "TURBO_MODE_OFF";
  }
  /**
   * Event name when the project is started (threads may not necessarily be
   * running).
   * @const {string}
   */


  static get PROJECT_START() {
    return "PROJECT_START";
  }
  /**
   * Event name when threads start running.
   * Used by the UI to indicate running status.
   * @const {string}
   */


  static get PROJECT_RUN_START() {
    return "PROJECT_RUN_START";
  }
  /**
   * Event name when threads stop running
   * Used by the UI to indicate not-running status.
   * @const {string}
   */


  static get PROJECT_RUN_STOP() {
    return "PROJECT_RUN_STOP";
  }
  /**
   * Event name for project being stopped or restarted by the user.
   * Used by blocks that need to reset state.
   * @const {string}
   */


  static get PROJECT_STOP_ALL() {
    return "PROJECT_STOP_ALL";
  }
  /**
   * Event name for target being stopped by a stop for target call.
   * Used by blocks that need to stop individual targets.
   * @const {string}
   */


  static get STOP_FOR_TARGET() {
    return "STOP_FOR_TARGET";
  }
  /**
   * Event name for visual value report.
   * @const {string}
   */


  static get VISUAL_REPORT() {
    return "VISUAL_REPORT";
  }
  /**
   * .
   * @const {string}
   */


  static get PROJECT_LOADED() {
    return "PROJECT_LOADED";
  }
  /**
   * Event name for report that a change was made that can be saved
   * @const {string}
   */


  static get PROJECT_CHANGED() {
    return "PROJECT_CHANGED";
  }
  /**
   * Event name for report that a change was made to an extension in the toolbox.
   * @const {string}
   */


  static get TOOLBOX_EXTENSIONS_NEED_UPDATE() {
    return "TOOLBOX_EXTENSIONS_NEED_UPDATE";
  }
  /**
   * Event name for targets update report.
   * @const {string}
   */


  static get TARGETS_UPDATE() {
    return "TARGETS_UPDATE";
  }
  /**
   * Event name for monitors update.
   * @const {string}
   */


  static get MONITORS_UPDATE() {
    return "MONITORS_UPDATE";
  }
  /**
   * Event name for block drag update.
   * @const {string}
   */


  static get BLOCK_DRAG_UPDATE() {
    return "BLOCK_DRAG_UPDATE";
  }
  /**
   * Event name for block drag end.
   * @const {string}
   */


  static get BLOCK_DRAG_END() {
    return "BLOCK_DRAG_END";
  }
  /**
   * Event name for reporting that an extension was added.
   * @const {string}
   */


  static get EXTENSION_ADDED() {
    return "EXTENSION_ADDED";
  }
  /**
   * Event name for reporting that an extension as asked for a custom field to be added
   * @const {string}
   */


  static get EXTENSION_FIELD_ADDED() {
    return "EXTENSION_FIELD_ADDED";
  }
  /**
   * Event name for updating the available set of peripheral devices.
   * This causes the peripheral connection modal to update a list of
   * available peripherals.
   * @const {string}
   */


  static get PERIPHERAL_LIST_UPDATE() {
    return "PERIPHERAL_LIST_UPDATE";
  }
  /**
   * Event name for reporting that a peripheral has connected.
   * This causes the status button in the blocks menu to indicate 'connected'.
   * @const {string}
   */


  static get PERIPHERAL_CONNECTED() {
    return "PERIPHERAL_CONNECTED";
  }
  /**
   * Event name for reporting that a peripheral has been intentionally disconnected.
   * This causes the status button in the blocks menu to indicate 'disconnected'.
   * @const {string}
   */


  static get PERIPHERAL_DISCONNECTED() {
    return "PERIPHERAL_DISCONNECTED";
  }
  /**
   * Event name for reporting that a peripheral has encountered a request error.
   * This causes the peripheral connection modal to switch to an error state.
   * @const {string}
   */


  static get PERIPHERAL_REQUEST_ERROR() {
    return "PERIPHERAL_REQUEST_ERROR";
  }
  /**
   * Event name for reporting that a peripheral connection has been lost.
   * This causes a 'peripheral connection lost' error alert to display.
   * @const {string}
   */


  static get PERIPHERAL_CONNECTION_LOST_ERROR() {
    return "PERIPHERAL_CONNECTION_LOST_ERROR";
  }
  /**
   * Event name for reporting that a peripheral has not been discovered.
   * This causes the peripheral connection modal to show a timeout state.
   * @const {string}
   */


  static get PERIPHERAL_SCAN_TIMEOUT() {
    return "PERIPHERAL_SCAN_TIMEOUT";
  }
  /**
   * Event name to indicate that the microphone is being used to stream audio.
   * @const {string}
   */


  static get MIC_LISTENING() {
    return "MIC_LISTENING";
  }
  /**
   * Event name for reporting that blocksInfo was updated.
   * @const {string}
   */


  static get BLOCKSINFO_UPDATE() {
    return "BLOCKSINFO_UPDATE";
  }
  /**
   * Event name when the runtime tick loop has been started.
   * @const {string}
   */


  static get RUNTIME_STARTED() {
    return "RUNTIME_STARTED";
  }
  /**
   * Event name when the runtime dispose has been called.
   * @const {string}
   */


  static get RUNTIME_DISPOSED() {
    return "RUNTIME_DISPOSED";
  }
  /**
   * Event name for reporting that a block was updated and needs to be rerendered.
   * @const {string}
   */


  static get BLOCKS_NEED_UPDATE() {
    return "BLOCKS_NEED_UPDATE";
  }
  /**
   * How rapidly we try to step threads by default, in ms.
   */


  static get THREAD_STEP_INTERVAL() {
    return 1000 / 60;
  }
  /**
   * In compatibility mode, how rapidly we try to step threads, in ms.
   */


  static get THREAD_STEP_INTERVAL_COMPATIBILITY() {
    return 1000 / 30;
  }
  /**
   * How many clones can be created at a time.
   * @const {number}
   */


  static get MAX_CLONES() {
    return 300;
  } // -----------------------------------------------------------------------------
  // -----------------------------------------------------------------------------
  // Helper function for initializing the addCloudVariable function


  _initializeAddCloudVariable(newCloudDataManager) {
    // The addCloudVariable function
    return () => {
      const hadCloudVarsBefore = this.hasCloudData();
      newCloudDataManager.addCloudVariable();

      if (!hadCloudVarsBefore && this.hasCloudData()) {
        this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, true);
      }
    };
  } // Helper function for initializing the removeCloudVariable function


  _initializeRemoveCloudVariable(newCloudDataManager) {
    return () => {
      const hadCloudVarsBefore = this.hasCloudData();
      newCloudDataManager.removeCloudVariable();

      if (hadCloudVarsBefore && !this.hasCloudData()) {
        this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);
      }
    };
  }
  /**
   * .
   * @todo Prefix opcodes with package name.
   * @private
   */


  _registerBlockPackages() {
    for (const packageName in defaultBlockPackages) {
      if (defaultBlockPackages.hasOwnProperty(packageName)) {
        // @?
        const packageObject = new defaultBlockPackages[packageName](this); // .

        if (packageObject.getPrimitives) {
          const packagePrimitives = packageObject.getPrimitives();

          for (const op in packagePrimitives) {
            if (packagePrimitives.hasOwnProperty(op)) {
              this._primitives[op] = packagePrimitives[op].bind(packageObject);
            }
          }
        } // Collect hat metadata from package.


        if (packageObject.getHats) {
          const packageHats = packageObject.getHats();

          for (const hatName in packageHats) {
            if (packageHats.hasOwnProperty(hatName)) {
              this._hats[hatName] = packageHats[hatName];
            }
          }
        } // Collect monitored from package.


        if (packageObject.getMonitored) {
          this.monitorBlockInfo = Object.assign({}, this.monitorBlockInfo, packageObject.getMonitored());
        }
      }
    }
  }

  getMonitorState() {
    return this._monitorState;
  }
  /**
   * Generate an extension-specific menu ID.
   * @param {string} menuName - the name of the menu.
   * @param {string} extensionId - the ID of the extension hosting the menu.
   * @returns {string} - the constructed ID.
   * @private
   */


  _makeExtensionMenuId(menuName, extensionId) {
    return `${extensionId}_menu_${Utility.xmlEscape(menuName)}`;
  }
  /**
   * Create a context ("args") object for use with `formatMessage` on messages which might be target-specific.
   * @param {Target} [target] - the target to use as context. If a target is not provided, default to the current
   * editing target or the stage.
   */


  makeMessageContextForTarget(target) {
    const context = {};
    target = target || this.getEditingTarget() || this.getTargetForStage();

    if (target) {
      context.targetType = target.isStage ? TargetType.STAGE : TargetType.SPRITE;
    }
  }
  /**
   * Register the primitives provided by an extension.
   * @param {ExtensionMetadata} extensionInfo - information about the extension (id, blocks, etc.)
   * @private
   */


  _registerExtensionPrimitives(extensionInfo) {
    const categoryInfo = {
      id: extensionInfo.id,
      name: maybeFormatMessage(extensionInfo.name),
      showStatusButton: extensionInfo.showStatusButton,
      blockIconURI: extensionInfo.blockIconURI,
      menuIconURI: extensionInfo.menuIconURI
    };

    if (extensionInfo.color1) {
      categoryInfo.color1 = extensionInfo.color1;
      categoryInfo.color2 = extensionInfo.color2;
      categoryInfo.color3 = extensionInfo.color3;
    } else {
      categoryInfo.color1 = defaultExtensionColors[0];
      categoryInfo.color2 = defaultExtensionColors[1];
      categoryInfo.color3 = defaultExtensionColors[2];
    }

    this._blockInfo.push(categoryInfo);

    this._fillExtensionCategory(categoryInfo, extensionInfo);

    for (const fieldTypeName in categoryInfo.customFieldTypes) {
      if (extensionInfo.customFieldTypes.hasOwnProperty(fieldTypeName)) {
        const fieldTypeInfo = categoryInfo.customFieldTypes[fieldTypeName]; // Emit events for custom field types from extension

        this.emit(Runtime.EXTENSION_FIELD_ADDED, {
          name: `field_${fieldTypeInfo.extendedName}`,
          implementation: fieldTypeInfo.fieldImplementation
        });
      }
    }

    this.emit(Runtime.EXTENSION_ADDED, categoryInfo);
  }
  /**
   * Reregister the primitives for an extension
   * @param  {ExtensionMetadata} extensionInfo - new info (results of running getInfo) for an extension
   * @private
   */


  _refreshExtensionPrimitives(extensionInfo) {
    const categoryInfo = this._blockInfo.find(info => info.id === extensionInfo.id);

    if (categoryInfo) {
      categoryInfo.name = maybeFormatMessage(extensionInfo.name);

      this._fillExtensionCategory(categoryInfo, extensionInfo);

      this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);
    }
  }
  /**
   * Read extension information, convert menus, blocks and custom field types
   * and store the results in the provided category object.
   * @param {CategoryInfo} categoryInfo - the category to be filled
   * @param {ExtensionMetadata} extensionInfo - the extension metadata to read
   * @private
   */


  _fillExtensionCategory(categoryInfo, extensionInfo) {
    categoryInfo.blocks = [];
    categoryInfo.customFieldTypes = {};
    categoryInfo.menus = [];
    categoryInfo.menuInfo = {};

    for (const menuName in extensionInfo.menus) {
      if (extensionInfo.menus.hasOwnProperty(menuName)) {
        const menuInfo = extensionInfo.menus[menuName];

        const convertedMenu = this._buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo);

        categoryInfo.menus.push(convertedMenu);
        categoryInfo.menuInfo[menuName] = menuInfo;
      }
    }

    for (const fieldTypeName in extensionInfo.customFieldTypes) {
      if (extensionInfo.customFieldTypes.hasOwnProperty(fieldTypeName)) {
        const fieldType = extensionInfo.customFieldTypes[fieldTypeName];

        const fieldTypeInfo = this._buildCustomFieldInfo(fieldTypeName, fieldType, extensionInfo.id, categoryInfo);

        categoryInfo.customFieldTypes[fieldTypeName] = fieldTypeInfo;
      }
    }

    for (const blockInfo of extensionInfo.blocks) {
      try {
        const convertedBlock = this._convertForScratchBlocks(blockInfo, categoryInfo);

        categoryInfo.blocks.push(convertedBlock);

        if (convertedBlock.json) {
          const opcode = convertedBlock.json.type;

          if (blockInfo.blockType !== BlockType.EVENT) {
            this._primitives[opcode] = convertedBlock.info.func;
          }

          if (blockInfo.blockType === BlockType.EVENT || blockInfo.blockType === BlockType.HAT) {
            this._hats[opcode] = {
              edgeActivated: blockInfo.isEdgeActivated,
              restartExistingThreads: blockInfo.shouldRestartExistingThreads
            };
          }
        }
      } catch (e) {
        console.error("Error parsing block: ", {
          block: blockInfo,
          error: e
        });
      }
    }
  }
  /**
   * Convert the given extension menu items into the scratch-blocks style of list of pairs.
   * If the menu is dynamic (e.g. the passed in argument is a function), return the input unmodified.
   * @param {object} menuItems - an array of menu items or a function to retrieve such an array
   * @returns {object} - an array of 2 element arrays or the original input function
   * @private
   */


  _convertMenuItems(menuItems) {
    if (typeof menuItems !== "function") {
      const extensionMessageContext = this.makeMessageContextForTarget();
      return menuItems.map(item => {
        const formattedItem = maybeFormatMessage(item, extensionMessageContext);

        switch (typeof formattedItem) {
          case "string":
            return [formattedItem, formattedItem];

          case "object":
            return [maybeFormatMessage(item.text, extensionMessageContext), item.value];

          default:
            throw new Error(`Can't interpret menu item: ${JSON.stringify(item)}`);
        }
      });
    }

    return menuItems;
  }
  /**
   * Build the scratch-blocks JSON for a menu. Note that scratch-blocks treats menus as a special kind of block.
   * @param {string} menuName - the name of the menu
   * @param {object} menuInfo - a description of this menu and its items
   * @property {*} items - an array of menu items or a function to retrieve such an array
   * @property {boolean} [acceptReporters] - if true, allow dropping reporters onto this menu
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {object} - a JSON-esque object ready for scratch-blocks' consumption
   * @private
   */


  _buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo) {
    const menuId = this._makeExtensionMenuId(menuName, categoryInfo.id);

    const menuItems = this._convertMenuItems(menuInfo.items);

    return {
      json: {
        message0: "%1",
        type: menuId,
        inputsInline: true,
        output: "String",
        colour: categoryInfo.color1,
        colourSecondary: categoryInfo.color2,
        colourTertiary: categoryInfo.color3,
        outputShape: menuInfo.acceptReporters ? KidBlocksConstants.OUTPUT_SHAPE_ROUND : KidBlocksConstants.OUTPUT_SHAPE_SQUARE,
        args0: [{
          type: "field_dropdown",
          name: menuName,
          options: menuItems
        }]
      }
    };
  }

  _buildCustomFieldInfo(fieldName, fieldInfo, extensionId, categoryInfo) {
    const extendedName = `${extensionId}_${fieldName}`;
    return {
      fieldName: fieldName,
      extendedName: extendedName,
      argumentTypeInfo: {
        shadow: {
          type: extendedName,
          fieldName: `field_${extendedName}`
        }
      },
      scratchBlocksDefinition: this._buildCustomFieldTypeForScratchBlocks(extendedName, fieldInfo.output, fieldInfo.outputShape, categoryInfo),
      fieldImplementation: fieldInfo.implementation
    };
  }
  /**
   * Build the scratch-blocks JSON needed for a fieldType.
   * Custom field types need to be namespaced to the extension so that extensions can't interfere with each other
   * @param  {string} fieldName - The name of the field
   * @param {string} output - The output of the field
   * @param {number} outputShape - Shape of the field (from KidBlocksConstants)
   * @param {object} categoryInfo - The category the field belongs to (Used to set its colors)
   * @returns {object} - Object to be inserted into scratch-blocks
   */


  _buildCustomFieldTypeForScratchBlocks(fieldName, output, outputShape, categoryInfo) {
    return {
      json: {
        type: fieldName,
        message0: "%1",
        inputsInline: true,
        output: output,
        colour: categoryInfo.color1,
        colourSecondary: categoryInfo.color2,
        colourTertiary: categoryInfo.color3,
        outputShape: outputShape,
        args0: [{
          name: `field_${fieldName}`,
          type: `field_${fieldName}`
        }]
      }
    };
  }
  /**
   * Convert ExtensionBlockMetadata into data ready for scratch-blocks.
   * @param {ExtensionBlockMetadata} blockInfo - the block info to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */


  _convertForScratchBlocks(blockInfo, categoryInfo) {
    if (blockInfo === "---") {
      return this._convertSeparatorForScratchBlocks(blockInfo);
    }

    if (blockInfo.blockType === BlockType.BUTTON) {
      return this._convertButtonForScratchBlocks(blockInfo);
    }

    return this._convertBlockForScratchBlocks(blockInfo, categoryInfo);
  }
  /**
   * Convert ExtensionBlockMetadata into scratch-blocks JSON & XML, and generate a proxy function.
   * @param {ExtensionBlockMetadata} blockInfo - the block to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */


  _convertBlockForScratchBlocks(blockInfo, categoryInfo) {
    const extendedOpcode = `${categoryInfo.id}_${blockInfo.opcode}`;
    const blockJSON = {
      type: extendedOpcode,
      inputsInline: true,
      category: categoryInfo.name,
      colour: categoryInfo.color1,
      colourSecondary: categoryInfo.color2,
      colourTertiary: categoryInfo.color3
    };
    const context = {
      // TODO: store this somewhere so that we can map args appropriately after translation.
      // This maps an arg name to its relative position in the original (usually English) block text.
      // When displaying a block in another language we'll need to run a `replace` action similar to the one
      // below, but each `[ARG]` will need to be replaced with the number in this map.
      argsMap: {},
      blockJSON,
      categoryInfo,
      blockInfo,
      inputList: []
    }; // If an icon for the extension exists, prepend it to each block, with a vertical separator.
    // We can overspecify an icon for each block, but if no icon exists on a block, fall back to
    // the category block icon.

    const iconURI = blockInfo.blockIconURI || categoryInfo.blockIconURI;

    if (iconURI) {
      blockJSON.extensions = ["scratch_extension"];
      blockJSON.message0 = "%1 %2";
      const iconJSON = {
        type: "field_image",
        src: iconURI,
        width: 40,
        height: 40
      };
      const separatorJSON = {
        type: "field_vertical_separator"
      };
      blockJSON.args0 = [iconJSON, separatorJSON];
    }

    switch (blockInfo.blockType) {
      case BlockType.COMMAND:
        blockJSON.outputShape = KidBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.previousStatement = null; // null = available connection; undefined = hat

        if (!blockInfo.isTerminal) {
          blockJSON.nextStatement = null; // null = available connection; undefined = terminal
        }

        break;

      case BlockType.REPORTER:
        blockJSON.output = "String"; // TODO: distinguish number & string here?

        blockJSON.outputShape = KidBlocksConstants.OUTPUT_SHAPE_ROUND;
        break;

      case BlockType.BOOLEAN:
        blockJSON.output = "Boolean";
        blockJSON.outputShape = KidBlocksConstants.OUTPUT_SHAPE_HEXAGONAL;
        break;

      case BlockType.HAT:
      case BlockType.EVENT:
        if (!blockInfo.hasOwnProperty("isEdgeActivated")) {
          // if absent, this property defaults to true
          blockInfo.isEdgeActivated = true;
        }

        blockJSON.outputShape = KidBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.nextStatement = null; // null = available connection; undefined = terminal

        break;

      case BlockType.CONDITIONAL:
      case BlockType.LOOP:
        blockInfo.branchCount = blockInfo.branchCount || 1;
        blockJSON.outputShape = KidBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.previousStatement = null; // null = available connection; undefined = hat

        if (!blockInfo.isTerminal) {
          blockJSON.nextStatement = null; // null = available connection; undefined = terminal
        }

        break;
    }

    const blockText = Array.isArray(blockInfo.text) ? blockInfo.text : [blockInfo.text];
    let inTextNum = 0; // text for the next block "arm" is blockText[inTextNum]

    let inBranchNum = 0; // how many branches have we placed into the JSON so far?

    let outLineNum = 0; // used for scratch-blocks `message${outLineNum}` and `args${outLineNum}`

    const convertPlaceholders = this._convertPlaceholders.bind(this, context);

    const extensionMessageContext = this.makeMessageContextForTarget(); // alternate between a block "arm" with text on it and an open slot for a substack

    while (inTextNum < blockText.length || inBranchNum < blockInfo.branchCount) {
      if (inTextNum < blockText.length) {
        context.outLineNum = outLineNum;
        const lineText = maybeFormatMessage(blockText[inTextNum], extensionMessageContext);
        const convertedText = lineText.replace(/\[(.+?)]/g, convertPlaceholders);

        if (blockJSON[`message${outLineNum}`]) {
          blockJSON[`message${outLineNum}`] += convertedText;
        } else {
          blockJSON[`message${outLineNum}`] = convertedText;
        }

        ++inTextNum;
        ++outLineNum;
      }

      if (inBranchNum < blockInfo.branchCount) {
        blockJSON[`message${outLineNum}`] = "%1";
        blockJSON[`args${outLineNum}`] = [{
          type: "input_statement",
          name: `SUBSTACK${inBranchNum > 0 ? inBranchNum + 1 : ""}`
        }];
        ++inBranchNum;
        ++outLineNum;
      }
    }

    if (blockInfo.blockType === BlockType.REPORTER) {
      if (!blockInfo.disableMonitor && context.inputList.length === 0) {
        blockJSON.checkboxInFlyout = true;
      }
    } else if (blockInfo.blockType === BlockType.LOOP) {
      // Add icon to the bottom right of a loop block
      blockJSON[`lastDummyAlign${outLineNum}`] = "RIGHT";
      blockJSON[`message${outLineNum}`] = "%1";
      blockJSON[`args${outLineNum}`] = [{
        type: "field_image",
        src: "./static/blocks-media/repeat.svg",
        // TODO: use a constant or make this configurable?
        width: 24,
        height: 24,
        alt: "*",
        // TODO remove this since we don't use collapsed blocks in scratch
        flip_rtl: true
      }];
      ++outLineNum;
    }

    const mutation = blockInfo.isDynamic ? `<mutation blockInfo="${Utility.xmlEscape(JSON.stringify(blockInfo))}"/>` : "";
    const inputs = context.inputList.join("");
    const blockXML = `<block type="${extendedOpcode}">${mutation}${inputs}</block>`;
    return {
      info: context.blockInfo,
      json: context.blockJSON,
      xml: blockXML
    };
  }
  /**
   * Generate a separator between blocks categories or sub-categories.
   * @param {ExtensionBlockMetadata} blockInfo - the block to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */


  _convertSeparatorForScratchBlocks(blockInfo) {
    return {
      info: blockInfo,
      xml: '<sep gap="36"/>'
    };
  }
  /**
   * Convert a button for scratch-blocks. A button has no opcode but specifies a callback name in the `func` field.
   * @param {ExtensionBlockMetadata} buttonInfo - the button to convert
   * @property {string} func - the callback name
   * @param {CategoryInfo} categoryInfo - the category for this button
   * @returns {ConvertedBlockInfo} - the converted & original button information
   * @private
   */


  _convertButtonForScratchBlocks(buttonInfo) {
    // for now we only support these pre-defined callbacks handled in scratch-blocks
    const supportedCallbackKeys = ["MAKE_A_LIST", "MAKE_A_PROCEDURE", "MAKE_A_VARIABLE"];

    if (supportedCallbackKeys.indexOf(buttonInfo.func) < 0) {
      console.error(`Custom button callbacks not supported yet: ${buttonInfo.func}`);
    }

    const extensionMessageContext = this.makeMessageContextForTarget();
    const buttonText = maybeFormatMessage(buttonInfo.text, extensionMessageContext);
    return {
      info: buttonInfo,
      xml: `<button text="${buttonText}" callbackKey="${buttonInfo.func}"></button>`
    };
  }
  /**
   * Helper for _convertPlaceholdes which handles inline images which are a specialized case of block "arguments".
   * @param {object} argInfo Metadata about the inline image as specified by the extension
   * @return {object} JSON blob for a scratch-blocks image field.
   * @private
   */


  _constructInlineImageJson(argInfo) {
    if (!argInfo.dataURI) {
      console.warn("Missing data URI in extension block with argument type IMAGE");
    }

    return {
      type: "field_image",
      src: argInfo.dataURI || "",
      // TODO these probably shouldn't be hardcoded...?
      width: 24,
      height: 24,
      // Whether or not the inline image should be flipped horizontally
      // in RTL languages. Defaults to false, indicating that the
      // image will not be flipped.
      flip_rtl: argInfo.flipRTL || false
    };
  }
  /**
   * Helper for _convertForScratchBlocks which handles linearization of argument placeholders. Called as a callback
   * from string#replace. In addition to the return value the JSON and XML items in the context will be filled.
   * @param {object} context - information shared with _convertForScratchBlocks about the block, etc.
   * @param {string} match - the overall string matched by the placeholder regex, including brackets: '[FOO]'.
   * @param {string} placeholder - the name of the placeholder being matched: 'FOO'.
   * @return {string} scratch-blocks placeholder for the argument: '%1'.
   * @private
   */


  _convertPlaceholders(context, match, placeholder) {
    // Sanitize the placeholder to ensure valid XML
    placeholder = placeholder.replace(/[<"&]/, "_"); // Determine whether the argument type is one of the known standard field types

    const argInfo = context.blockInfo.arguments[placeholder] || {};
    let argTypeInfo = ArgumentTypeMap[argInfo.type] || {}; // Field type not a standard field type, see if extension has registered custom field type

    if (!ArgumentTypeMap[argInfo.type] && context.categoryInfo.customFieldTypes[argInfo.type]) {
      argTypeInfo = context.categoryInfo.customFieldTypes[argInfo.type].argumentTypeInfo;
    } // Start to construct the scratch-blocks style JSON defining how the block should be
    // laid out


    let argJSON; // Most field types are inputs (slots on the block that can have other blocks plugged into them)
    // check if this is not one of those cases. E.g. an inline image on a block.

    if (argTypeInfo.fieldType === "field_image") {
      argJSON = this._constructInlineImageJson(argInfo);
    } else {
      // Construct input value
      // Layout a block argument (e.g. an input slot on the block)
      argJSON = {
        type: "input_value",
        name: placeholder
      };
      const defaultValue = typeof argInfo.defaultValue === "undefined" ? "" : Utility.xmlEscape(maybeFormatMessage(argInfo.defaultValue, this.makeMessageContextForTarget()).toString());

      if (argTypeInfo.check) {
        // Right now the only type of 'check' we have specifies that the
        // input slot on the block accepts Boolean reporters, so it should be
        // shaped like a hexagon
        argJSON.check = argTypeInfo.check;
      }

      let valueName;
      let shadowType;
      let fieldName;

      if (argInfo.menu) {
        const menuInfo = context.categoryInfo.menuInfo[argInfo.menu];

        if (menuInfo.acceptReporters) {
          valueName = placeholder;
          shadowType = this._makeExtensionMenuId(argInfo.menu, context.categoryInfo.id);
          fieldName = argInfo.menu;
        } else {
          argJSON.type = "field_dropdown";
          argJSON.options = this._convertMenuItems(menuInfo.items);
          valueName = null;
          shadowType = null;
          fieldName = placeholder;
        }
      } else {
        valueName = placeholder;
        shadowType = argTypeInfo.shadow && argTypeInfo.shadow.type || null;
        fieldName = argTypeInfo.shadow && argTypeInfo.shadow.fieldName || null;
      } // <value> is the ScratchBlocks name for a block input.


      if (valueName) {
        context.inputList.push(`<value name="${placeholder}">`);
      } // The <shadow> is a placeholder for a reporter and is visible when there's no reporter in this input.
      // Boolean inputs don't need to specify a shadow in the XML.


      if (shadowType) {
        context.inputList.push(`<shadow type="${shadowType}">`);
      } // A <field> displays a dynamic value: a user-editable text field, a drop-down menu, etc.
      // Leave out the field if defaultValue or fieldName are not specified


      if (defaultValue && fieldName) {
        context.inputList.push(`<field name="${fieldName}">${defaultValue}</field>`);
      }

      if (shadowType) {
        context.inputList.push("</shadow>");
      }

      if (valueName) {
        context.inputList.push("</value>");
      }
    }

    const argsName = `args${context.outLineNum}`;
    const blockArgs = context.blockJSON[argsName] = context.blockJSON[argsName] || [];
    if (argJSON) blockArgs.push(argJSON);
    const argNum = blockArgs.length;
    context.argsMap[placeholder] = argNum;
    return `%${argNum}`;
  }
  /**
   * @returns {Array.<object>} scratch-blocks XML for each category of extension blocks, in category order.
   * @param {?Target} [target] - the active editing target (optional)
   * @property {string} id - the category / extension ID
   * @property {string} xml - the XML text for this category, starting with `<category>` and ending with `</category>`
   */


  getBlocksXML(target) {
    return this._blockInfo.map(categoryInfo => {
      const {
        name,
        color1,
        color2
      } = categoryInfo; // Filter out blocks that aren't supposed to be shown on this target, as determined by the block info's
      // `hideFromPalette` and `filter` properties.

      const paletteBlocks = categoryInfo.blocks.filter(block => {
        let blockFilterIncludesTarget = true; // If an editing target is not passed, include all blocks
        // If the block info doesn't include a `filter` property, always include it

        if (target && block.info.filter) {
          blockFilterIncludesTarget = block.info.filter.includes(target.isStage ? TargetType.STAGE : TargetType.SPRITE);
        } // If the block info's `hideFromPalette` is true, then filter out this block


        return blockFilterIncludesTarget && !block.info.hideFromPalette;
      });
      const colorXML = `colour="${color1}" secondaryColour="${color2}"`; // Use a menu icon if there is one. Otherwise, use the block icon. If there's no icon,
      // the category menu will show its default colored circle.

      let menuIconURI = "";

      if (categoryInfo.menuIconURI) {
        menuIconURI = categoryInfo.menuIconURI;
      } else if (categoryInfo.blockIconURI) {
        menuIconURI = categoryInfo.blockIconURI;
      }

      const menuIconXML = menuIconURI ? `iconURI="${menuIconURI}"` : "";
      let statusButtonXML = "";

      if (categoryInfo.showStatusButton) {
        statusButtonXML = 'showStatusButton="true"';
      }

      return {
        id: categoryInfo.id,
        xml: `<category name="${name}" id="${categoryInfo.id}" ${statusButtonXML} ${colorXML} ${menuIconXML}>${paletteBlocks.map(block => block.xml).join("")}</category>`
      };
    });
  }
  /**
   * @returns {Array.<string>} - an array containing the scratch-blocks JSON information for each dynamic block.
   */


  getBlocksJSON() {
    return this._blockInfo.reduce((result, categoryInfo) => result.concat(categoryInfo.blocks.map(blockInfo => blockInfo.json)), []);
  }
  /**
   * Get a scratch link socket.
   * @param {string} type Either BLE or BT
   * @returns {ScratchLinkSocket} The scratch link socket.
   */


  getScratchLinkSocket(type) {
    const factory = this._linkSocketFactory || this._defaultScratchLinkSocketFactory;
    return factory(type);
  }
  /**
   * Configure how ScratchLink sockets are created. Factory must consume a "type" parameter
   * either BT or BLE.
   * @param {Function} factory The new factory for creating ScratchLink sockets.
   */


  configureScratchLinkSocketFactory(factory) {
    this._linkSocketFactory = factory;
  }
  /**
   * The default scratch link socket creator, using websockets to the installed device manager.
   * @param {string} type Either BLE or BT
   * @returns {ScratchLinkSocket} The new scratch link socket (a WebSocket object)
   */


  _defaultScratchLinkSocketFactory(type) {
    return new ScratchLinkWebSocket(type);
  }
  /**
   * Register an extension that communications with a hardware peripheral by id,
   * to have access to it and its peripheral functions in the future.
   * @param {string} extensionId - the id of the extension.
   * @param {object} extension - the extension to register.
   */


  registerPeripheralExtension(extensionId, extension) {
    this.peripheralExtensions[extensionId] = extension;
  }
  /**
   * Tell the specified extension to scan for a peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  scanForPeripheral(extensionId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].scan();
    }
  }
  /**
   * Connect to the extension's specified peripheral.
   * @param {string} extensionId - the id of the extension.
   * @param {number} peripheralId - the id of the peripheral.
   */


  connectPeripheral(extensionId, peripheralId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].connect(peripheralId);
    }
  }
  /**
   * Disconnect from the extension's connected peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  disconnectPeripheral(extensionId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].disconnect();
    }
  }
  /**
   * Returns whether the extension has a currently connected peripheral.
   * @param {string} extensionId - the id of the extension.
   * @return {boolean} - whether the extension has a connected peripheral.
   */


  getPeripheralIsConnected(extensionId) {
    let isConnected = false;

    if (this.peripheralExtensions[extensionId]) {
      isConnected = this.peripheralExtensions[extensionId].isConnected();
    }

    return isConnected;
  }
  /**
   * Emit an event to indicate that the microphone is being used to stream audio.
   * @param {boolean} listening - true if the microphone is currently listening.
   */


  emitMicListening(listening) {
    this.emit(Runtime.MIC_LISTENING, listening);
  }
  /**
   * Retrieve the function associated with the given opcode.
   * @param {!string} opcode The opcode to look up.
   * @return {Function} The function which implements the opcode.
   */


  getOpcodeFunction(opcode) {
    return this._primitives[opcode];
  }
  /**
   * Return whether an opcode represents a hat block.
   * @param {!string} opcode The opcode to look up.
   * @return {boolean} True if the op is known to be a hat.
   */


  getIsHat(opcode) {
    return this._hats.hasOwnProperty(opcode);
  }
  /**
   * Return whether an opcode represents an edge-activated hat block.
   * @param {!string} opcode The opcode to look up.
   * @return {boolean} True if the op is known to be a edge-activated hat.
   */


  getIsEdgeActivatedHat(opcode) {
    return this._hats.hasOwnProperty(opcode) && this._hats[opcode].edgeActivated;
  }
  /**
   * Attach the audio engine
   * @param {!AudioEngine} audioEngine The audio engine to attach
   */


  attachAudioEngine(audioEngine) {
    this.audioEngine = audioEngine;
  }
  /**
   * Attach the renderer
   * @param {!RenderWebGL} renderer The renderer to attach
   */


  attachRenderer(renderer) {
    console.warn("runtime.js  renderer", renderer);
    this.renderer = renderer;
    this.renderer.setLayerGroupOrdering(StageLayering.LAYER_GROUPS);
  }
  /**
   * svgscratch 2 svgsscratch 3 svgs
   * @param {!SvgRenderer} svgAdapter The adapter to attach
   */


  attachV2SVGAdapter(svgAdapter) {
    console.log("svgscratch 2 svgsscratch 3 svgs:", svgAdapter);
    this.v2SvgAdapter = svgAdapter;
  }
  /**
   * VM /23 32
   * @param {!function} bitmapAdapter The adapter to attach
   */


  attachV2BitmapAdapter(bitmapAdapter) {
    this.v2BitmapAdapter = bitmapAdapter;
  }
  /**
   * 
   * @param {!Storage} storage 
   */


  attachStorage(storage) {
    console.log("", storage);
    this.storage = storage;
  } // -----------------------------------------------------------------------------
  // -----------------------------------------------------------------------------

  /**
   * .
   * @param {!string} id ID.
   * @param {!Target} target .
   * @param {?object} opts 
   * @param {?boolean} opts.stackClick true
   * @param {?boolean} opts.updateMonitor true
   * @return {!Thread} .
   */


  _pushThread(id, target, opts) {
    const thread = new Thread(id);
    thread.target = target;
    thread.stackClick = Boolean(opts && opts.stackClick);
    thread.updateMonitor = Boolean(opts && opts.updateMonitor);
    thread.blockContainer = thread.updateMonitor ? this.monitorBlocks : target.blocks;
    thread.pushStack(id);
    this.threads.push(thread);
    return thread;
  }
  /**
   * Stop a thread: stop running it immediately, and remove it from the thread list later.
   * @param {!Thread} thread Thread object to remove from actives
   */


  _stopThread(thread) {
    // Mark the thread for later removal
    thread.isKilled = true; // Inform sequencer to stop executing that thread.

    this.sequencer.retireThread(thread);
  }
  /**
   * Restart a thread in place, maintaining its position in the list of threads.
   * This is used by `startHats` to and is necessary to ensure 2.0-like execution order.
   * Test project: https://scratch.mit.edu/projects/130183108/
   * @param {!Thread} thread Thread object to restart.
   * @return {Thread} The restarted thread.
   */


  _restartThread(thread) {
    const newThread = new Thread(thread.topBlock);
    newThread.target = thread.target;
    newThread.stackClick = thread.stackClick;
    newThread.updateMonitor = thread.updateMonitor;
    newThread.blockContainer = thread.blockContainer;
    newThread.pushStack(thread.topBlock);
    const i = this.threads.indexOf(thread);

    if (i > -1) {
      this.threads[i] = newThread;
      return newThread;
    }

    this.threads.push(thread);
    return thread;
  }
  /**
   * Return whether a thread is currently active/running.
   * @param {?Thread} thread Thread object to check.
   * @return {boolean} True if the thread is active/running.
   */


  isActiveThread(thread) {
    return thread.stack.length > 0 && thread.status !== Thread.STATUS_DONE && this.threads.indexOf(thread) > -1;
  }
  /**
   * Return whether a thread is waiting for more information or done.
   * @param {?Thread} thread Thread object to check.
   * @return {boolean} True if the thread is waiting
   */


  isWaitingThread(thread) {
    return thread.status === Thread.STATUS_PROMISE_WAIT || thread.status === Thread.STATUS_YIELD_TICK || !this.isActiveThread(thread);
  }
  /**
   * Toggle a script.
   * @param {!string} topBlockId ID of block that starts the script.
   * @param {?object} opts optional arguments to toggle script
   * @param {?string} opts.target target ID for target to run script on. If not supplied, uses editing target.
   * @param {?boolean} opts.stackClick true if the user activated the stack by clicking, false if not. This
   *     determines whether we show a visual report when turning on the script.
   */


  toggleScript(topBlockId, opts) {
    opts = Object.assign({
      target: this._editingTarget,
      stackClick: false
    }, opts); // Remove any existing thread.

    for (let i = 0; i < this.threads.length; i++) {
      // Toggling a script that's already running turns it off
      if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE) {
        const blockContainer = opts.target.blocks;
        const opcode = blockContainer.getOpcode(blockContainer.getBlock(topBlockId));

        if (this.getIsEdgeActivatedHat(opcode) && this.threads[i].stackClick !== opts.stackClick) {
          // Allow edge activated hat thread stack click to coexist with
          // edge activated hat thread that runs every frame
          continue;
        }

        this._stopThread(this.threads[i]);

        return;
      }
    } // Otherwise add it.


    this._pushThread(topBlockId, opts.target, opts);
  }
  /**
   * Enqueue a script that when finished will update the monitor for the block.
   * @param {!string} topBlockId ID of block that starts the script.
   * @param {?Target} optTarget target Target to run script on. If not supplied, uses editing target.
   */


  addMonitorScript(topBlockId, optTarget) {
    if (!optTarget) optTarget = this._editingTarget;

    for (let i = 0; i < this.threads.length; i++) {
      // Don't re-add the script if it's already running
      if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE && this.threads[i].updateMonitor) {
        return;
      }
    } // Otherwise add it.


    this._pushThread(topBlockId, optTarget, {
      updateMonitor: true
    });
  }
  /**
   * Run a function `f` for all scripts in a workspace.
   * `f` will be called with two parameters:
   *  - the top block ID of the script.
   *  - the target that owns the script.
   * @param {!Function} f Function to call for each script.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   */


  allScriptsDo(f, optTarget) {
    let targets = this.executableTargets;

    if (optTarget) {
      targets = [optTarget];
    }

    for (let t = targets.length - 1; t >= 0; t--) {
      const target = targets[t];
      const scripts = target.blocks.getScripts();

      for (let j = 0; j < scripts.length; j++) {
        const topBlockId = scripts[j];
        f(topBlockId, target);
      }
    }
  }

  allScriptsByOpcodeDo(opcode, f, optTarget) {
    let targets = this.executableTargets;

    if (optTarget) {
      targets = [optTarget];
    }

    for (let t = targets.length - 1; t >= 0; t--) {
      const target = targets[t];
      const scripts = BlocksRuntimeCache.getScripts(target.blocks, opcode);

      for (let j = 0; j < scripts.length; j++) {
        f(scripts[j], target);
      }
    }
  }
  /**
   * Start all relevant hats.
   * @param {!string} requestedHatOpcode Opcode of hats to start.
   * @param {object=} optMatchFields Optionally, fields to match on the hat.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   * @return {Array.<Thread>} List of threads started by this function.
   */


  startHats(requestedHatOpcode, optMatchFields, optTarget) {
    if (!this._hats.hasOwnProperty(requestedHatOpcode)) {
      // No known hat with this opcode.
      return;
    }

    const instance = this;
    const newThreads = []; // Look up metadata for the relevant hat.

    const hatMeta = instance._hats[requestedHatOpcode];

    for (const opts in optMatchFields) {
      if (!optMatchFields.hasOwnProperty(opts)) continue;
      optMatchFields[opts] = optMatchFields[opts].toUpperCase();
    } // Consider all scripts, looking for hats with opcode `requestedHatOpcode`.


    this.allScriptsByOpcodeDo(requestedHatOpcode, (script, target) => {
      const {
        blockId: topBlockId,
        fieldsOfInputs: hatFields
      } = script; // Match any requested fields.
      // For example: ensures that broadcasts match.
      // This needs to happen before the block is evaluated
      // (i.e., before the predicate can be run) because "broadcast and wait"
      // needs to have a precise collection of started threads.

      for (const matchField in optMatchFields) {
        if (hatFields[matchField].value !== optMatchFields[matchField]) {
          // Field mismatch.
          return;
        }
      }

      if (hatMeta.restartExistingThreads) {
        // If `restartExistingThreads` is true, we should stop
        // any existing threads starting with the top block.
        for (let i = 0; i < this.threads.length; i++) {
          if (this.threads[i].target === target && this.threads[i].topBlock === topBlockId && // stack click threads and hat threads can coexist
          !this.threads[i].stackClick) {
            newThreads.push(this._restartThread(this.threads[i]));
            return;
          }
        }
      } else {
        // If `restartExistingThreads` is false, we should
        // give up if any threads with the top block are running.
        for (let j = 0; j < this.threads.length; j++) {
          if (this.threads[j].target === target && this.threads[j].topBlock === topBlockId && // stack click threads and hat threads can coexist
          !this.threads[j].stackClick && this.threads[j].status !== Thread.STATUS_DONE) {
            // Some thread is already running.
            return;
          }
        }
      } // Start the thread with this top block.


      newThreads.push(this._pushThread(topBlockId, target));
    }, optTarget); // For compatibility with Scratch 2, edge triggered hats need to be processed before
    // threads are stepped. See ScratchRuntime.as for original implementation

    newThreads.forEach(thread => {
      execute(this.sequencer, thread);
      thread.goToNextBlock();
    });
    return newThreads;
  }
  /**
   * Dispose all targets. Return to clean state.
   */


  dispose() {
    this.stopAll(); // Deleting each target's variable's monitors.

    this.targets.forEach(target => {
      if (target.isOriginal) target.deleteMonitors();
    });
    this.targets.map(this.disposeTarget, this);
    this._monitorState = OrderedMap({});
    this.emit(Runtime.RUNTIME_DISPOSED);
    this.ioDevices.clock.resetProjectTimer(); // @todo clear out extensions? turboMode? etc.
    // *********** Cloud *******************
    // If the runtime currently has cloud data,
    // emit a has cloud data update event resetting
    // it to false

    if (this.hasCloudData()) {
      this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);
    }

    this.ioDevices.cloud.clear(); // Reset runtime cloud data info

    const newCloudDataManager = cloudDataManager();
    this.hasCloudData = newCloudDataManager.hasCloudVariables;
    this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;
    this.addCloudVariable = this._initializeAddCloudVariable(newCloudDataManager);
    this.removeCloudVariable = this._initializeRemoveCloudVariable(newCloudDataManager);
  }
  /**
   *  .
   * @param {Target} target target to add
   */


  addTarget(target) {
    console.log("runtime.js addTarget()", target);
    this.targets.push(target);
    this.executableTargets.push(target);
  }
  /**
   * Move a target in the execution order by a relative amount.
   *
   * A positve number will make the target execute earlier. A negative number
   * will make the target execute later in the order.
   *
   * @param {Target} executableTarget target to move
   * @param {number} delta number of positions to move target by
   * @returns {number} new position in execution order
   */


  moveExecutable(executableTarget, delta) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);
    this.executableTargets.splice(oldIndex, 1);
    let newIndex = oldIndex + delta;

    if (newIndex > this.executableTargets.length) {
      newIndex = this.executableTargets.length;
    }

    if (newIndex <= 0) {
      if (this.executableTargets.length > 0 && this.executableTargets[0].isStage) {
        newIndex = 1;
      } else {
        newIndex = 0;
      }
    }

    this.executableTargets.splice(newIndex, 0, executableTarget);
    return newIndex;
  }
  /**
   * Set a target to execute at a specific position in the execution order.
   *
   * Infinity will set the target to execute first. 0 will set the target to
   * execute last (before the stage).
   *
   * @param {Target} executableTarget target to move
   * @param {number} newIndex position in execution order to place the target
   * @returns {number} new position in the execution order
   */


  setExecutablePosition(executableTarget, newIndex) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);
    return this.moveExecutable(executableTarget, newIndex - oldIndex);
  }
  /**
   * Remove a target from the execution set.
   * @param {Target} executableTarget target to remove
   */


  removeExecutable(executableTarget) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);

    if (oldIndex > -1) {
      this.executableTargets.splice(oldIndex, 1);
    }
  }
  /**
   * Dispose of a target.
   * @param {!Target} disposingTarget Target to dispose of.
   */


  disposeTarget(disposingTarget) {
    this.targets = this.targets.filter(target => {
      if (disposingTarget !== target) return true; // Allow target to do dispose actions.

      target.dispose(); // Remove from list of targets.

      return false;
    });
  }
  /**
   * Stop any threads acting on the target.
   * @param {!Target} target Target to stop threads for.
   * @param {Thread=} optThreadException Optional thread to skip.
   */


  stopForTarget(target, optThreadException) {
    // Emit stop event to allow blocks to clean up any state.
    this.emit(Runtime.STOP_FOR_TARGET, target, optThreadException); // Stop any threads on the target.

    for (let i = 0; i < this.threads.length; i++) {
      if (this.threads[i] === optThreadException) {
        continue;
      }

      if (this.threads[i].target === target) {
        this._stopThread(this.threads[i]);
      }
    }
  }
  /**
   * Start all threads that start with the green flag.
   */


  greenFlag() {
    this.stopAll();
    this.emit(Runtime.PROJECT_START);
    this.ioDevices.clock.resetProjectTimer();
    this.targets.forEach(target => target.clearEdgeActivatedValues()); // Inform all targets of the green flag.

    for (let i = 0; i < this.targets.length; i++) {
      this.targets[i].onGreenFlag();
    }

    this.startHats("event_whenflagclicked");
  }
  /**
   * Stop "everything."
   */


  stopAll() {
    // Emit stop event to allow blocks to clean up any state.
    this.emit(Runtime.PROJECT_STOP_ALL); // Dispose all clones.

    const newTargets = [];

    for (let i = 0; i < this.targets.length; i++) {
      this.targets[i].onStopAll();

      if (this.targets[i].hasOwnProperty("isOriginal") && !this.targets[i].isOriginal) {
        this.targets[i].dispose();
      } else {
        newTargets.push(this.targets[i]);
      }
    }

    this.targets = newTargets; // Dispose of the active thread.

    if (this.sequencer.activeThread !== null) {
      this._stopThread(this.sequencer.activeThread);
    } // Remove all remaining threads from executing in the next tick.


    this.threads = [];
  }
  /**
   * Repeatedly run `sequencer.stepThreads` and filter out
   * inactive threads after each iteration.
   */


  _step() {
    if (this.profiler !== null) {
      if (stepProfilerId === -1) {
        stepProfilerId = this.profiler.idByName("Runtime._step");
      }

      this.profiler.start(stepProfilerId);
    } // Clean up threads that were told to stop during or since the last step


    this.threads = this.threads.filter(thread => !thread.isKilled); // Find all edge-activated hats, and add them to threads to be evaluated.

    for (const hatType in this._hats) {
      if (!this._hats.hasOwnProperty(hatType)) continue;
      const hat = this._hats[hatType];

      if (hat.edgeActivated) {
        this.startHats(hatType);
      }
    }

    this.redrawRequested = false;

    this._pushMonitors();

    if (this.profiler !== null) {
      if (stepThreadsProfilerId === -1) {
        stepThreadsProfilerId = this.profiler.idByName("Sequencer.stepThreads");
      }

      this.profiler.start(stepThreadsProfilerId);
    }

    const doneThreads = this.sequencer.stepThreads();

    if (this.profiler !== null) {
      this.profiler.stop();
    }

    this._updateGlows(doneThreads); // Add done threads so that even if a thread finishes within 1 frame, the green
    // flag will still indicate that a script ran.


    this._emitProjectRunStatus(this.threads.length + doneThreads.length - this._getMonitorThreadCount([...this.threads, ...doneThreads])); // Store threads that completed this iteration for testing and other
    // internal purposes.


    this._lastStepDoneThreads = doneThreads;

    if (this.renderer) {
      // @todo: Only render when this.redrawRequested or clones rendered.
      if (this.profiler !== null) {
        if (rendererDrawProfilerId === -1) {
          rendererDrawProfilerId = this.profiler.idByName("RenderWebGL.draw");
        }

        this.profiler.start(rendererDrawProfilerId);
      }

      this.renderer.draw();

      if (this.profiler !== null) {
        this.profiler.stop();
      }
    }

    if (this._refreshTargets) {
      this.emit(Runtime.TARGETS_UPDATE, false
      /* Don't emit project changed */
      );
      this._refreshTargets = false;
    }

    if (!this._prevMonitorState.equals(this._monitorState)) {
      this.emit(Runtime.MONITORS_UPDATE, this._monitorState);
      this._prevMonitorState = this._monitorState;
    }

    if (this.profiler !== null) {
      this.profiler.stop();
      this.profiler.reportFrames();
    }
  }
  /**
   * Get the number of threads in the given array that are monitor threads (threads
   * that update monitor values, and don't count as running a script).
   * @param {!Array.<Thread>} threads The set of threads to look through.
   * @return {number} The number of monitor threads in threads.
   */


  _getMonitorThreadCount(threads) {
    let count = 0;
    threads.forEach(thread => {
      if (thread.updateMonitor) count++;
    });
    return count;
  }
  /**
   * Queue monitor blocks to sequencer to be run.
   */


  _pushMonitors() {
    this.monitorBlocks.runAllMonitored(this);
  }
  /**
   * .
   * @param {!Target} editingTarget New editing target.
   */


  setEditingTarget(editingTarget) {
    const oldEditingTarget = this._editingTarget;
    this._editingTarget = editingTarget; // .

    this._scriptGlowsPreviousFrame = [];

    this._updateGlows();

    if (oldEditingTarget !== this._editingTarget) {
      this.requestToolboxExtensionsUpdate();
    }
  }
  /**
   * Set whether we are in 30 TPS compatibility mode.
   * @param {boolean} compatibilityModeOn True iff in compatibility mode.
   */


  setCompatibilityMode(compatibilityModeOn) {
    this.compatibilityMode = compatibilityModeOn;

    if (this._steppingInterval) {
      clearInterval(this._steppingInterval);
      this._steppingInterval = null;
      this.start();
    }
  }
  /**
   * Emit glows/glow clears for scripts after a single tick.
   * Looks at `this.threads` and notices which have turned on/off new glows.
   * @param {Array.<Thread>=} optExtraThreads Optional list of inactive threads.
   */


  _updateGlows(optExtraThreads) {
    const searchThreads = [];
    searchThreads.push.apply(searchThreads, this.threads);

    if (optExtraThreads) {
      searchThreads.push.apply(searchThreads, optExtraThreads);
    } // Set of scripts that request a glow this frame.


    const requestedGlowsThisFrame = []; // Final set of scripts glowing during this frame.

    const finalScriptGlows = []; // Find all scripts that should be glowing.

    for (let i = 0; i < searchThreads.length; i++) {
      const thread = searchThreads[i];
      const target = thread.target;

      if (target === this._editingTarget) {
        const blockForThread = thread.blockGlowInFrame;

        if (thread.requestScriptGlowInFrame || thread.stackClick) {
          let script = target.blocks.getTopLevelScript(blockForThread);

          if (!script) {
            // Attempt to find in flyout blocks.
            script = this.flyoutBlocks.getTopLevelScript(blockForThread);
          }

          if (script) {
            requestedGlowsThisFrame.push(script);
          }
        }
      }
    } // Compare to previous frame.


    for (let j = 0; j < this._scriptGlowsPreviousFrame.length; j++) {
      const previousFrameGlow = this._scriptGlowsPreviousFrame[j];

      if (requestedGlowsThisFrame.indexOf(previousFrameGlow) < 0) {
        // Glow turned off.
        this.glowScript(previousFrameGlow, false);
      } else {
        // Still glowing.
        finalScriptGlows.push(previousFrameGlow);
      }
    }

    for (let k = 0; k < requestedGlowsThisFrame.length; k++) {
      const currentFrameGlow = requestedGlowsThisFrame[k];

      if (this._scriptGlowsPreviousFrame.indexOf(currentFrameGlow) < 0) {
        // Glow turned on.
        this.glowScript(currentFrameGlow, true);
        finalScriptGlows.push(currentFrameGlow);
      }
    }

    this._scriptGlowsPreviousFrame = finalScriptGlows;
  }
  /**
   * Emit run start/stop after each tick. Emits when `this.threads.length` goes
   * between non-zero and zero
   *
   * @param {number} nonMonitorThreadCount The new nonMonitorThreadCount
   */


  _emitProjectRunStatus(nonMonitorThreadCount) {
    if (this._nonMonitorThreadCount === 0 && nonMonitorThreadCount > 0) {
      this.emit(Runtime.PROJECT_RUN_START);
    }

    if (this._nonMonitorThreadCount > 0 && nonMonitorThreadCount === 0) {
      this.emit(Runtime.PROJECT_RUN_STOP);
    }

    this._nonMonitorThreadCount = nonMonitorThreadCount;
  }
  /**
   * "Quiet" a script's glow: stop the VM from generating glow/unglow events
   * about that script. Use when a script has just been deleted, but we may
   * still be tracking glow data about it.
   * @param {!string} scriptBlockId Id of top-level block in script to quiet.
   */


  quietGlow(scriptBlockId) {
    const index = this._scriptGlowsPreviousFrame.indexOf(scriptBlockId);

    if (index > -1) {
      this._scriptGlowsPreviousFrame.splice(index, 1);
    }
  }
  /**
   * Emit feedback for block glowing (used in the sequencer).
   * @param {?string} blockId ID for the block to update glow
   * @param {boolean} isGlowing True to turn on glow; false to turn off.
   */


  glowBlock(blockId, isGlowing) {
    if (isGlowing) {
      this.emit(Runtime.BLOCK_GLOW_ON, {
        id: blockId
      });
    } else {
      this.emit(Runtime.BLOCK_GLOW_OFF, {
        id: blockId
      });
    }
  }
  /**
   * Emit feedback for script glowing.
   * @param {?string} topBlockId ID for the top block to update glow
   * @param {boolean} isGlowing True to turn on glow; false to turn off.
   */


  glowScript(topBlockId, isGlowing) {
    if (isGlowing) {
      this.emit(Runtime.SCRIPT_GLOW_ON, {
        id: topBlockId
      });
    } else {
      this.emit(Runtime.SCRIPT_GLOW_OFF, {
        id: topBlockId
      });
    }
  }
  /**
   * Emit whether blocks are being dragged over gui
   * @param {boolean} areBlocksOverGui True if blocks are dragged out of blocks workspace, false otherwise
   */


  emitBlockDragUpdate(areBlocksOverGui) {
    this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);
  }
  /**
   * Emit event to indicate that the block drag has ended with the blocks outside the blocks workspace
   * @param {Array.<object>} blocks The set of blocks dragged to the GUI
   * @param {string} topBlockId The original id of the top block being dragged
   */


  emitBlockEndDrag(blocks, topBlockId) {
    this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);
  }
  /**
   * Emit value for reporter to show in the blocks.
   * @param {string} blockId ID for the block.
   * @param {string} value Value to show associated with the block.
   */


  visualReport(blockId, value) {
    this.emit(Runtime.VISUAL_REPORT, {
      id: blockId,
      value: String(value)
    });
  }
  /**
   * Add a monitor to the state. If the monitor already exists in the state,
   * updates those properties that are defined in the given monitor record.
   * @param {!MonitorRecord} monitor Monitor to add.
   */


  requestAddMonitor(monitor) {
    const id = monitor.get("id");

    if (!this.requestUpdateMonitor(monitor)) {
      // update monitor if it exists in the state
      // if the monitor did not exist in the state, add it
      this._monitorState = this._monitorState.set(id, monitor);
    }
  }
  /**
   * /.
   * @param {!Map} monitor  ID .
   * @return {boolean} truefalse.
   */


  requestUpdateMonitor(monitor) {
    const id = monitor.get("id");

    if (this._monitorState.has(id)) {
      this._monitorState = // mergeWith
      this._monitorState.set(id, this._monitorState.get(id).mergeWith((prev, next) => {
        if (typeof next === "undefined" || next === null) {
          return prev;
        }

        return next;
      }, monitor));
      return true;
    }

    return false;
  }
  /**
   * Removes a monitor from the state. Does nothing if the monitor already does
   * not exist in the state.
   * @param {!string} monitorId ID of the monitor to remove.
   */


  requestRemoveMonitor(monitorId) {
    this._monitorState = this._monitorState.delete(monitorId);
  }
  /**
   * Hides a monitor and returns success/failure of action.
   * @param {!string} monitorId ID of the monitor to hide.
   * @return {boolean} true if monitor exists and was updated, false otherwise
   */


  requestHideMonitor(monitorId) {
    return this.requestUpdateMonitor(new Map([["id", monitorId], ["visible", false]]));
  }
  /**
   * Shows a monitor and returns success/failure of action.
   * not exist in the state.
   * @param {!string} monitorId ID of the monitor to show.
   * @return {boolean} true if monitor exists and was updated, false otherwise
   */


  requestShowMonitor(monitorId) {
    return this.requestUpdateMonitor(new Map([["id", monitorId], ["visible", true]]));
  }
  /**
   * Removes all monitors with the given target ID from the state. Does nothing if
   * the monitor already does not exist in the state.
   * @param {!string} targetId Remove all monitors with given target ID.
   */


  requestRemoveMonitorByTargetId(targetId) {
    this._monitorState = this._monitorState.filterNot(value => value.targetId === targetId);
  }
  /**
   * Get a target by its id.
   * @param {string} targetId Id of target to find.
   * @return {?Target} The target, if found.
   */


  getTargetById(targetId) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];

      if (target.id === targetId) {
        return target;
      }
    }
  }
  /**
   * Get the first original (non-clone-block-created) sprite given a name.
   * @param {string} spriteName Name of sprite to look for.
   * @return {?Target} Target representing a sprite of the given name.
   */


  getSpriteTargetByName(spriteName) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];

      if (target.isStage) {
        continue;
      }

      if (target.sprite && target.sprite.name === spriteName) {
        return target;
      }
    }
  }
  /**
   * Get a target by its drawable id.
   * @param {number} drawableID drawable id of target to find
   * @return {?Target} The target, if found
   */


  getTargetByDrawableId(drawableID) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];
      if (target.drawableID === drawableID) return target;
    }
  }
  /**
   * Update the clone counter to track how many clones are created.
   * @param {number} changeAmount How many clones have been created/destroyed.
   */


  changeCloneCounter(changeAmount) {
    this._cloneCounter += changeAmount;
  }
  /**
   * .
   * @return {boolean} True until the number of clones hits Runtime.MAX_CLONES.
   */


  clonesAvailable() {
    return this._cloneCounter < Runtime.MAX_CLONES;
  }
  /**
   * .
   */


  emitProjectLoaded() {
    console.log("runtime.js ", Runtime.PROJECT_LOADED);
    this.emit(Runtime.PROJECT_LOADED);
  }
  /**
   * Report that the project has changed in a way that would affect serialization
   */


  emitProjectChanged() {
    this.emit(Runtime.PROJECT_CHANGED);
  }
  /**
   * Report that a new target has been created, possibly by cloning an existing target.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @fires Runtime#targetWasCreated
   */


  fireTargetWasCreated(newTarget, sourceTarget) {
    this.emit("targetWasCreated", newTarget, sourceTarget);
  }
  /**
   * Report that a clone target is being removed.
   * @param {Target} target - the target being removed
   * @fires Runtime#targetWasRemoved
   */


  fireTargetWasRemoved(target) {
    this.emit("targetWasRemoved", target);
  }
  /**
   * Get a target representing the Scratch stage, if one exists.
   * @return {?Target} The target, if found.
   */


  getTargetForStage() {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];

      if (target.isStage) {
        return target;
      }
    }
  }
  /**
   * Get the editing target.
   * @return {?Target} The editing target.
   */


  getEditingTarget() {
    return this._editingTarget;
  }

  getAllVarNamesOfType(varType) {
    let varNames = [];

    for (const target of this.targets) {
      const targetVarNames = target.getAllVariableNamesInScopeByType(varType, true);
      varNames = varNames.concat(targetVarNames);
    }

    return varNames;
  }
  /**
   * Get the label or label function for an opcode
   * @param {string} extendedOpcode - the opcode you want a label for
   * @return {object} - object with label and category
   * @property {string} category - the category for this opcode
   * @property {Function} [labelFn] - function to generate the label for this opcode
   * @property {string} [label] - the label for this opcode if `labelFn` is absent
   */


  getLabelForOpcode(extendedOpcode) {
    const [category, opcode] = StringUtil.splitFirst(extendedOpcode, "_");
    if (!(category && opcode)) return;

    const categoryInfo = this._blockInfo.find(ci => ci.id === category);

    if (!categoryInfo) return;
    const block = categoryInfo.blocks.find(b => b.info.opcode === opcode);
    if (!block) return; // TODO: we may want to format the label in a locale-specific way.

    return {
      category: "extension",
      // This assumes that all extensions have the same monitor color.
      label: `${categoryInfo.name}: ${block.info.text}`
    };
  }
  /**
   * Create a new global variable avoiding conflicts with other variable names.
   * @param {string} variableName The desired variable name for the new global variable.
   * This can be turned into a fresh name as necessary.
   * @param {string} optVarId An optional ID to use for the variable. A new one will be generated
   * if a falsey value for this parameter is provided.
   * @param {string} optVarType The type of the variable to create. Defaults to Variable.SCALAR_TYPE.
   * @return {Variable} The new variable that was created.
   */


  createNewGlobalVariable(variableName, optVarId, optVarType) {
    const varType = typeof optVarType === "string" ? optVarType : Variable.SCALAR_TYPE;
    const allVariableNames = this.getAllVarNamesOfType(varType);
    const newName = StringUtil.unusedName(variableName, allVariableNames);
    console.warn("runtime:", Utility.uid());
    const variable = new Variable(optVarId || Utility.uid(), newName, varType);
    const stage = this.getTargetForStage();
    stage.variables[variable.id] = variable;
    return variable;
  }
  /**
   * Tell the runtime to request a redraw.
   * Use after a clone/sprite has completed some visible operation on the stage.
   */


  requestRedraw() {
    this.redrawRequested = true;
  }
  /**
   * Emit a targets update at the end of the step if the provided target is
   * the original sprite
   * @param {!Target} target Target requesting the targets update
   */


  requestTargetsUpdate(target) {
    if (!target.isOriginal) return;
    this._refreshTargets = true;
  }
  /**
   * Emit an event that indicates that the blocks on the workspace need updating.
   */


  requestBlocksUpdate() {
    this.emit(Runtime.BLOCKS_NEED_UPDATE);
  }
  /**
   * Emit an event that indicates that the toolbox extension blocks need updating.
   */


  requestToolboxExtensionsUpdate() {
    this.emit(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE);
  }
  /**
   * Set up timers to repeatedly step in a browser.
   */


  start() {
    // Do not start if we are already running
    if (this._steppingInterval) return;
    let interval = Runtime.THREAD_STEP_INTERVAL;

    if (this.compatibilityMode) {
      interval = Runtime.THREAD_STEP_INTERVAL_COMPATIBILITY;
    }

    this.currentStepTime = interval;
    this._steppingInterval = setInterval(() => {
      this._step();
    }, interval);
    this.emit(Runtime.RUNTIME_STARTED);
  }
  /**
   * Turn on profiling.
   * @param {Profiler/FrameCallback} onFrame A callback handle passed a
   * profiling frame when the profiler reports its collected data.
   */


  enableProfiling(onFrame) {
    if (Profiler.available()) {
      this.profiler = new Profiler(onFrame);
    }
  }
  /**
   * Turn off profiling.
   */


  disableProfiling() {
    this.profiler = null;
  }
  /**
   * Update a millisecond timestamp value that is saved on the Runtime.
   * This value is helpful in certain instances for compatibility with Scratch 2,
   * which sometimes uses a `currentMSecs` timestamp value in Interpreter.as
   */


  updateCurrentMSecs() {
    this.currentMSecs = Date.now();
  }

}
/**
 * Event fired after a new target has been created, possibly by cloning an existing target.
 *
 * @event Runtime#targetWasCreated
 * @param {Target} newTarget - the newly created target.
 * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
 */


module.exports = Runtime;

/***/ }),

/***/ "./src/engine/sequencer.js":
/*!*********************************!*\
  !*** ./src/engine/sequencer.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const execute = __webpack_require__(/*! ./execute.js */ "./src/engine/execute.js");
/**
 * Profiler frame name for stepping a single thread.
 * @const {string}
 */


const stepThreadProfilerFrame = 'Sequencer.stepThread';
/**
 * Profiler frame name for the inner loop of stepThreads.
 * @const {string}
 */

const stepThreadsInnerProfilerFrame = 'Sequencer.stepThreads#inner';
/**
 * Profiler frame name for execute.
 * @const {string}
 */

const executeProfilerFrame = 'execute';
/**
 * Profiler frame ID for stepThreadProfilerFrame.
 * @type {number}
 */

let stepThreadProfilerId = -1;
/**
 * Profiler frame ID for stepThreadsInnerProfilerFrame.
 * @type {number}
 */

let stepThreadsInnerProfilerId = -1;
/**
 * Profiler frame ID for executeProfilerFrame.
 * @type {number}
 */

let executeProfilerId = -1;

class Sequencer {
  constructor(runtime) {
    /**
     * A utility timer for timing thread sequencing.
     * @type {!Timer}
     */
    this.timer = new Timer();
    /**
     * Reference to the runtime owning this sequencer.
     * @type {!Runtime}
     */

    this.runtime = runtime;
    this.activeThread = null;
  }
  /**
   * Time to run a warp-mode thread, in ms.
   * @type {number}
   */


  static get WARP_TIME() {
    return 500;
  }
  /**
   * Step through all threads in `this.runtime.threads`, running them in order.
   * @return {Array.<!Thread>} List of inactive threads after stepping.
   */


  stepThreads() {
    // Work time is 75% of the thread stepping interval.
    const WORK_TIME = 0.75 * this.runtime.currentStepTime; // For compatibility with Scatch 2, update the millisecond clock
    // on the Runtime once per step (see Interpreter.as in Scratch 2
    // for original use of `currentMSecs`)

    this.runtime.updateCurrentMSecs(); // Start counting toward WORK_TIME.

    this.timer.start(); // Count of active threads.

    let numActiveThreads = Infinity; // Whether `stepThreads` has run through a full single tick.

    let ranFirstTick = false;
    const doneThreads = []; // Conditions for continuing to stepping threads:
    // 1. We must have threads in the list, and some must be active.
    // 2. Time elapsed must be less than WORK_TIME.
    // 3. Either turbo mode, or no redraw has been requested by a primitive.

    while (this.runtime.threads.length > 0 && numActiveThreads > 0 && this.timer.timeElapsed() < WORK_TIME && (this.runtime.turboMode || !this.runtime.redrawRequested)) {
      if (this.runtime.profiler !== null) {
        if (stepThreadsInnerProfilerId === -1) {
          stepThreadsInnerProfilerId = this.runtime.profiler.idByName(stepThreadsInnerProfilerFrame);
        }

        this.runtime.profiler.start(stepThreadsInnerProfilerId);
      }

      numActiveThreads = 0;
      let stoppedThread = false; // Attempt to run each thread one time.

      const threads = this.runtime.threads;

      for (let i = 0; i < threads.length; i++) {
        const activeThread = this.activeThread = threads[i]; // Check if the thread is done so it is not executed.

        if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {
          // Finished with this thread.
          stoppedThread = true;
          continue;
        }

        if (activeThread.status === Thread.STATUS_YIELD_TICK && !ranFirstTick) {
          // Clear single-tick yield from the last call of `stepThreads`.
          activeThread.status = Thread.STATUS_RUNNING;
        }

        if (activeThread.status === Thread.STATUS_RUNNING || activeThread.status === Thread.STATUS_YIELD) {
          // Normal-mode thread: step.
          if (this.runtime.profiler !== null) {
            if (stepThreadProfilerId === -1) {
              stepThreadProfilerId = this.runtime.profiler.idByName(stepThreadProfilerFrame);
            } // Increment the number of times stepThread is called.


            this.runtime.profiler.increment(stepThreadProfilerId);
          }

          this.stepThread(activeThread);
          activeThread.warpTimer = null;

          if (activeThread.isKilled) {
            i--; // if the thread is removed from the list (killed), do not increase index
          }
        }

        if (activeThread.status === Thread.STATUS_RUNNING) {
          numActiveThreads++;
        } // Check if the thread completed while it just stepped to make
        // sure we remove it before the next iteration of all threads.


        if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {
          // Finished with this thread.
          stoppedThread = true;
        }
      } // We successfully ticked once. Prevents running STATUS_YIELD_TICK
      // threads on the next tick.


      ranFirstTick = true;

      if (this.runtime.profiler !== null) {
        this.runtime.profiler.stop();
      } // Filter inactive threads from `this.runtime.threads`.


      if (stoppedThread) {
        let nextActiveThread = 0;

        for (let i = 0; i < this.runtime.threads.length; i++) {
          const thread = this.runtime.threads[i];

          if (thread.stack.length !== 0 && thread.status !== Thread.STATUS_DONE) {
            this.runtime.threads[nextActiveThread] = thread;
            nextActiveThread++;
          } else {
            doneThreads.push(thread);
          }
        }

        this.runtime.threads.length = nextActiveThread;
      }
    }

    this.activeThread = null;
    return doneThreads;
  }
  /**
   * Step the requested thread for as long as necessary.
   * @param {!Thread} thread Thread object to step.
   */


  stepThread(thread) {
    let currentBlockId = thread.peekStack();

    if (!currentBlockId) {
      // A "null block" - empty branch.
      thread.popStack(); // Did the null follow a hat block?

      if (thread.stack.length === 0) {
        thread.status = Thread.STATUS_DONE;
        return;
      }
    } // Save the current block ID to notice if we did control flow.


    while (currentBlockId = thread.peekStack()) {
      let isWarpMode = thread.peekStackFrame().warpMode;

      if (isWarpMode && !thread.warpTimer) {
        // Initialize warp-mode timer if it hasn't been already.
        // This will start counting the thread toward `Sequencer.WARP_TIME`.
        thread.warpTimer = new Timer();
        thread.warpTimer.start();
      } // Execute the current block.


      if (this.runtime.profiler !== null) {
        if (executeProfilerId === -1) {
          executeProfilerId = this.runtime.profiler.idByName(executeProfilerFrame);
        } // Increment the number of times execute is called.


        this.runtime.profiler.increment(executeProfilerId);
      }

      if (thread.target === null) {
        this.retireThread(thread);
      } else {
        execute(this, thread);
      }

      thread.blockGlowInFrame = currentBlockId; // If the thread has yielded or is waiting, yield to other threads.

      if (thread.status === Thread.STATUS_YIELD) {
        // Mark as running for next iteration.
        thread.status = Thread.STATUS_RUNNING; // In warp mode, yielded blocks are re-executed immediately.

        if (isWarpMode && thread.warpTimer.timeElapsed() <= Sequencer.WARP_TIME) {
          continue;
        }

        return;
      } else if (thread.status === Thread.STATUS_PROMISE_WAIT) {
        // A promise was returned by the primitive. Yield the thread
        // until the promise resolves. Promise resolution should reset
        // thread.status to Thread.STATUS_RUNNING.
        return;
      } else if (thread.status === Thread.STATUS_YIELD_TICK) {
        // stepThreads will reset the thread to Thread.STATUS_RUNNING
        return;
      } // If no control flow has happened, switch to next block.


      if (thread.peekStack() === currentBlockId) {
        thread.goToNextBlock();
      } // If no next block has been found at this point, look on the stack.


      while (!thread.peekStack()) {
        thread.popStack();

        if (thread.stack.length === 0) {
          // No more stack to run!
          thread.status = Thread.STATUS_DONE;
          return;
        }

        const stackFrame = thread.peekStackFrame();
        isWarpMode = stackFrame.warpMode;

        if (stackFrame.isLoop) {
          // The current level of the stack is marked as a loop.
          // Return to yield for the frame/tick in general.
          // Unless we're in warp mode - then only return if the
          // warp timer is up.
          if (!isWarpMode || thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {
            // Don't do anything to the stack, since loops need
            // to be re-executed.
            return;
          } // Don't go to the next block for this level of the stack,
          // since loops need to be re-executed.


          continue;
        } else if (stackFrame.waitingReporter) {
          // This level of the stack was waiting for a value.
          // This means a reporter has just returned - so don't go
          // to the next block for this level of the stack.
          return;
        } // Get next block of existing block on the stack.


        thread.goToNextBlock();
      }
    }
  }
  /**
   * Step a thread into a block's branch.
   * @param {!Thread} thread Thread object to step to branch.
   * @param {number} branchNum Which branch to step to (i.e., 1, 2).
   * @param {boolean} isLoop Whether this block is a loop.
   */


  stepToBranch(thread, branchNum, isLoop) {
    if (!branchNum) {
      branchNum = 1;
    }

    const currentBlockId = thread.peekStack();
    const branchId = thread.target.blocks.getBranch(currentBlockId, branchNum);
    thread.peekStackFrame().isLoop = isLoop;

    if (branchId) {
      // Push branch ID to the thread's stack.
      thread.pushStack(branchId);
    } else {
      thread.pushStack(null);
    }
  }
  /**
   * Step a procedure.
   * @param {!Thread} thread Thread object to step to procedure.
   * @param {!string} procedureCode Procedure code of procedure to step to.
   */


  stepToProcedure(thread, procedureCode) {
    const definition = thread.target.blocks.getProcedureDefinition(procedureCode);

    if (!definition) {
      return;
    } // Check if the call is recursive.
    // If so, set the thread to yield after pushing.


    const isRecursive = thread.isRecursiveCall(procedureCode); // To step to a procedure, we put its definition on the stack.
    // Execution for the thread will proceed through the definition hat
    // and on to the main definition of the procedure.
    // When that set of blocks finishes executing, it will be popped
    // from the stack by the sequencer, returning control to the caller.

    thread.pushStack(definition); // In known warp-mode threads, only yield when time is up.

    if (thread.peekStackFrame().warpMode && thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {
      thread.status = Thread.STATUS_YIELD;
    } else {
      // Look for warp-mode flag on definition, and set the thread
      // to warp-mode if needed.
      const definitionBlock = thread.target.blocks.getBlock(definition);
      const innerBlock = thread.target.blocks.getBlock(definitionBlock.inputs.custom_block.block);
      let doWarp = false;

      if (innerBlock && innerBlock.mutation) {
        const warp = innerBlock.mutation.warp;

        if (typeof warp === 'boolean') {
          doWarp = warp;
        } else if (typeof warp === 'string') {
          doWarp = JSON.parse(warp);
        }
      }

      if (doWarp) {
        thread.peekStackFrame().warpMode = true;
      } else if (isRecursive) {
        // In normal-mode threads, yield any time we have a recursive call.
        thread.status = Thread.STATUS_YIELD;
      }
    }
  }
  /**
   * Retire a thread in the middle, without considering further blocks.
   * @param {!Thread} thread Thread object to retire.
   */


  retireThread(thread) {
    thread.stack = [];
    thread.stackFrame = [];
    thread.requestScriptGlowInFrame = false;
    thread.status = Thread.STATUS_DONE;
  }

}

module.exports = Sequencer;

/***/ }),

/***/ "./src/engine/stage-layering.js":
/*!**************************************!*\
  !*** ./src/engine/stage-layering.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

class StageLayering {
  static get BACKGROUND_LAYER() {
    return 'background';
  }

  static get VIDEO_LAYER() {
    return 'video';
  }

  static get PEN_LAYER() {
    return 'pen';
  }

  static get SPRITE_LAYER() {
    return 'sprite';
  } // Order of layer groups relative to each other,


  static get LAYER_GROUPS() {
    return [StageLayering.BACKGROUND_LAYER, StageLayering.VIDEO_LAYER, StageLayering.PEN_LAYER, StageLayering.SPRITE_LAYER];
  }

}

module.exports = StageLayering;

/***/ }),

/***/ "./src/engine/target.js":
/*!******************************!*\
  !*** ./src/engine/target.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const Blocks = __webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");

const {
  Map
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const VariableUtil = __webpack_require__(/*! ../util/variable-util */ "./src/util/variable-util.js");
/**
 * @fileoverview
 * A Target is an abstract "code-running" object for the VM.
 * Examples include sprites/clones or potentially physical-world devices.
 *
 * target
 */


class Target extends EventEmitter {
  /**
   * @param {Runtime} runtime .
   * @param {?Blocks} blocks .
   * @constructor
   */
  constructor(runtime, blocks) {
    super();
    console.log("class Target ,id", blocks, runtime);

    if (!blocks) {
      blocks = new Blocks(runtime);
    }
    /**
     * Reference to the runtime.
     * @type {Runtime}
     */


    this.runtime = runtime;
    /**
     * ID.
     * @type {string}
     */

    this.id = Utility.uid();
    /**
     * Blocks run as code for this target.
     * @type {!Blocks}
     */

    this.blocks = blocks;
    /**
     * Dictionary of variables and their values for this target.
     * Key is the variable id.
     * @type {Object.<string,*>}
     */

    this.variables = {};
    /**
     * Dictionary of comments for this target.
     * Key is the comment id.
     * @type {Object.<string,*>}
     */

    this.comments = {};
    /**
     * Dictionary of custom state for this target.
     * This can be used to store target-specific custom state for blocks which need it.
     * TODO: do we want to persist this in SB3 files?
     * @type {Object.<string,*>}
     */

    this._customState = {};
    /**
     * Currently known values for edge-activated hats.
     * Keys are block ID for the hat; values are the currently known values.
     * @type {Object.<string, *>}
     */

    this._edgeActivatedHatValues = {};
  }
  /**
   * 
   * @abstract
   */


  onGreenFlag() {}
  /**
   * ..
   * @abstract
   * @returns {string} Human-readable name for the target.
   */


  getName() {
    return this.id;
  }
  /**
   * .
   * @param {!string} blockId ID of hat to store value for.
   * @param {*} newValue Value to store for edge-activated hat.
   * @return {*} The old value for the edge-activated hat.
   */


  updateEdgeActivatedValue(blockId, newValue) {
    const oldValue = this._edgeActivatedHatValues[blockId];
    this._edgeActivatedHatValues[blockId] = newValue;
    return oldValue;
  }

  hasEdgeActivatedValue(blockId) {
    return this._edgeActivatedHatValues.hasOwnProperty(blockId);
  }
  /**
   * Clear all edge-activaed hat values.
   */


  clearEdgeActivatedValues() {
    this._edgeActivatedHatValues = {};
  }
  /**
   * idid.
   * .
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {!Variable} Variable object.
   */


  lookupOrCreateVariable(id, name) {
    let variable = this.lookupVariableById(id);
    if (variable) return variable;
    variable = this.lookupVariableByNameAndType(name, Variable.SCALAR_TYPE);
    if (variable) return variable; // -.

    const newVariable = new Variable(id, name, Variable.SCALAR_TYPE, false);
    this.variables[id] = newVariable;
    return newVariable;
  }
  /**
   * Look up a broadcast message object with the given id and return it
   * if it exists.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {?Variable} Variable object.
   */


  lookupBroadcastMsg(id, name) {
    let broadcastMsg;

    if (id) {
      broadcastMsg = this.lookupVariableById(id);
    } else if (name) {
      broadcastMsg = this.lookupBroadcastByInputValue(name);
    } else {
      console.error("Cannot find broadcast message if neither id nor name are provided.");
    }

    if (broadcastMsg) {
      if (name && broadcastMsg.name.toLowerCase() !== name.toLowerCase()) {
        console.error(`Found broadcast message with id: ${id}, but` + `its name, ${broadcastMsg.name} did not match expected name ${name}.`);
      }

      if (broadcastMsg.type !== Variable.BROADCAST_MESSAGE_TYPE) {
        console.error(`Found variable with id: ${id}, but its type ${broadcastMsg.type}` + `did not match expected type ${Variable.BROADCAST_MESSAGE_TYPE}`);
      }

      return broadcastMsg;
    }
  }
  /**
   * Look up a broadcast message with the given name and return the variable
   * if it exists. Does not create a new broadcast message variable if
   * it doesn't exist.
   * @param {string} name Name of the variable.
   * @return {?Variable} Variable object.
   */


  lookupBroadcastByInputValue(name) {
    const vars = this.variables;

    for (const propName in vars) {
      if (vars[propName].type === Variable.BROADCAST_MESSAGE_TYPE && vars[propName].name.toLowerCase() === name.toLowerCase()) {
        return vars[propName];
      }
    }
  }
  /**
   * Look up a variable object.
   * Search begins for local variables; then look for globals.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {!Variable} Variable object.
   */


  lookupVariableById(id) {
    // If we have a local copy, return it.
    if (this.variables.hasOwnProperty(id)) {
      return this.variables[id];
    } // If the stage has a global copy, return it.


    if (this.runtime && !this.isStage) {
      const stage = this.runtime.getTargetForStage();

      if (stage && stage.variables.hasOwnProperty(id)) {
        return stage.variables[id];
      }
    }
  }
  /**
   * Look up a variable object by its name and variable type.
   * Search begins with local variables; then global variables if a local one
   * was not found.
   * @param {string} name Name of the variable.
   * @param {string} type Type of the variable. Defaults to Variable.SCALAR_TYPE.
   * @param {?bool} skipStage Optional flag to skip checking the stage
   * @return {?Variable} Variable object if found, or null if not.
   */


  lookupVariableByNameAndType(name, type, skipStage) {
    if (typeof name !== "string") return;
    if (typeof type !== "string") type = Variable.SCALAR_TYPE;
    skipStage = skipStage || false;

    for (const varId in this.variables) {
      const currVar = this.variables[varId];

      if (currVar.name === name && currVar.type === type) {
        return currVar;
      }
    }

    if (!skipStage && this.runtime && !this.isStage) {
      const stage = this.runtime.getTargetForStage();

      if (stage) {
        for (const varId in stage.variables) {
          const currVar = stage.variables[varId];

          if (currVar.name === name && currVar.type === type) {
            return currVar;
          }
        }
      }
    }

    return null;
  }
  /**
   * Look up a list object for this target, and create it if one doesn't exist.
   * Search begins for local lists; then look for globals.
   * @param {!string} id Id of the list.
   * @param {!string} name Name of the list.
   * @return {!Varible} Variable object representing the found/created list.
   */


  lookupOrCreateList(id, name) {
    let list = this.lookupVariableById(id);
    if (list) return list;
    list = this.lookupVariableByNameAndType(name, Variable.LIST_TYPE);
    if (list) return list; // No variable with this name exists - create it locally.

    const newList = new Variable(id, name, Variable.LIST_TYPE, false);
    this.variables[id] = newList;
    return newList;
  }
  /**
   * Creates a variable with the given id and name and adds it to the
   * dictionary of variables.
   * @param {string} id Id of variable
   * @param {string} name Name of variable.
   * @param {string} type Type of variable, '', 'broadcast_msg', or 'list'
   * @param {boolean} isCloud Whether the variable to create has the isCloud flag set.
   * Additional checks are made that the variable can be created as a cloud variable.
   */


  createVariable(id, name, type, isCloud) {
    if (!this.variables.hasOwnProperty(id)) {
      const newVariable = new Variable(id, name, type, false);

      if (isCloud && this.isStage && this.runtime.canAddCloudVariable()) {
        newVariable.isCloud = true;
        this.runtime.addCloudVariable();
        this.runtime.ioDevices.cloud.requestCreateVariable(newVariable);
      }

      this.variables[id] = newVariable;
    }
  }
  /**
   * Creates a comment with the given properties.
   * @param {string} id Id of the comment.
   * @param {string} blockId Optional id of the block the comment is attached
   * to if it is a block comment.
   * @param {string} text The text the comment contains.
   * @param {number} x The x coordinate of the comment on the workspace.
   * @param {number} y The y coordinate of the comment on the workspace.
   * @param {number} width The width of the comment when it is full size
   * @param {number} height The height of the comment when it is full size
   * @param {boolean} minimized Whether the comment is minimized.
   */


  createComment(id, blockId, text, x, y, width, height, minimized) {
    if (!this.comments.hasOwnProperty(id)) {
      const newComment = new Comment(id, text, x, y, width, height, minimized);

      if (blockId) {
        newComment.blockId = blockId;
        const blockWithComment = this.blocks.getBlock(blockId);

        if (blockWithComment) {
          blockWithComment.comment = id;
        } else {
          console.warn(`Could not find block with id ${blockId} associated with commentId: ${id}`);
        }
      }

      this.comments[id] = newComment;
    }
  }
  /**
   * Renames the variable with the given id to newName.
   * @param {string} id Id of variable to rename.
   * @param {string} newName New name for the variable.
   */


  renameVariable(id, newName) {
    if (this.variables.hasOwnProperty(id)) {
      const variable = this.variables[id];

      if (variable.id === id) {
        const oldName = variable.name;
        variable.name = newName;

        if (this.runtime) {
          if (variable.isCloud && this.isStage) {
            this.runtime.ioDevices.cloud.requestRenameVariable(oldName, newName);
          }

          if (variable.type === Variable.SCALAR_TYPE) {
            // sensing__of may be referencing to this variable.
            // Change the reference.
            let blockUpdated = false;
            this.runtime.targets.forEach(t => {
              blockUpdated = t.blocks.updateSensingOfReference(oldName, newName, this.isStage ? "_stage_" : this.getName()) || blockUpdated;
            }); // Request workspace change only if sensing_of blocks were actually updated.

            if (blockUpdated) this.runtime.requestBlocksUpdate();
          }

          const blocks = this.runtime.monitorBlocks;
          blocks.changeBlock({
            id: id,
            element: "field",
            name: variable.type === Variable.LIST_TYPE ? "LIST" : "VARIABLE",
            value: id
          }, this.runtime);
          const monitorBlock = blocks.getBlock(variable.id);

          if (monitorBlock) {
            this.runtime.requestUpdateMonitor(Map({
              id: id,
              params: blocks._getBlockParams(monitorBlock)
            }));
          }
        }
      }
    }
  }
  /**
   * Removes the variable with the given id from the dictionary of variables.
   * @param {string} id Id of variable to delete.
   */


  deleteVariable(id) {
    if (this.variables.hasOwnProperty(id)) {
      // Get info about the variable before deleting it
      const deletedVariableName = this.variables[id].name;
      const deletedVariableWasCloud = this.variables[id].isCloud;
      delete this.variables[id];

      if (this.runtime) {
        if (deletedVariableWasCloud && this.isStage) {
          this.runtime.ioDevices.cloud.requestDeleteVariable(deletedVariableName);
          this.runtime.removeCloudVariable();
        }

        this.runtime.monitorBlocks.deleteBlock(id);
        this.runtime.requestRemoveMonitor(id);
      }
    }
  }
  /**
   * Remove this target's monitors from the runtime state and remove the
   * target-specific monitored blocks (e.g. local variables, global variables for the stage, x-position).
   * NOTE: This does not delete any of the stage monitors like backdrop name.
   */


  deleteMonitors() {
    this.runtime.requestRemoveMonitorByTargetId(this.id);
    let targetSpecificMonitorBlockIds;

    if (this.isStage) {
      // This only deletes global variables and not other stage monitors like backdrop number.
      targetSpecificMonitorBlockIds = Object.keys(this.variables);
    } else {
      targetSpecificMonitorBlockIds = Object.keys(this.runtime.monitorBlocks._blocks).filter(key => this.runtime.monitorBlocks._blocks[key].targetId === this.id);
    }

    for (const blockId of targetSpecificMonitorBlockIds) {
      this.runtime.monitorBlocks.deleteBlock(blockId);
    }
  }
  /**
   * Create a clone of the variable with the given id from the dictionary of
   * this target's variables.
   * @param {string} id Id of variable to duplicate.
   * @param {boolean=} optKeepOriginalId Optional flag to keep the original variable ID
   * for the duplicate variable. This is necessary when cloning a sprite, for example.
   * @return {?Variable} The duplicated variable, or null if
   * the original variable was not found.
   */


  duplicateVariable(id, optKeepOriginalId) {
    if (this.variables.hasOwnProperty(id)) {
      const originalVariable = this.variables[id];
      const newVariable = new Variable(optKeepOriginalId ? id : null, // conditionally keep original id or generate a new one
      originalVariable.name, originalVariable.type, originalVariable.isCloud);

      if (newVariable.type === Variable.LIST_TYPE) {
        newVariable.value = originalVariable.value.slice(0);
      } else {
        newVariable.value = originalVariable.value;
      }

      return newVariable;
    }

    return null;
  }
  /**
   * Duplicate the dictionary of this target's variables as part of duplicating.
   * this target or making a clone.
   * @param {object=} optBlocks Optional block container for the target being duplicated.
   * If provided, new variables will be generated with new UIDs and any variable references
   * in this blocks container will be updated to refer to the corresponding new IDs.
   * @return {object} The duplicated dictionary of variables
   */


  duplicateVariables(optBlocks) {
    let allVarRefs;

    if (optBlocks) {
      allVarRefs = optBlocks.getAllVariableAndListReferences();
    }

    return Object.keys(this.variables).reduce((accum, varId) => {
      const newVariable = this.duplicateVariable(varId, !optBlocks);
      accum[newVariable.id] = newVariable;

      if (optBlocks && allVarRefs) {
        const currVarRefs = allVarRefs[varId];

        if (currVarRefs) {
          this.mergeVariables(varId, newVariable.id, currVarRefs);
        }
      }

      return accum;
    }, {});
  }
  /**
   * Post/edit sprite info.
   * @param {object} data An object with sprite info data to set.
   * @abstract
   */


  postSpriteInfo() {}
  /**
   * Retrieve custom state associated with this target and the provided state ID.
   * @param {string} stateId - specify which piece of state to retrieve.
   * @returns {*} the associated state, if any was found.
   */


  getCustomState(stateId) {
    return this._customState[stateId];
  }
  /**
   * Store custom state associated with this target and the provided state ID.
   * @param {string} stateId - specify which piece of state to store on this target.
   * @param {*} newValue - the state value to store.
   */


  setCustomState(stateId, newValue) {
    this._customState[stateId] = newValue;
  }
  /**
   * Call to destroy a target.
   * @abstract
   */


  dispose() {
    this._customState = {};

    if (this.runtime) {
      this.runtime.removeExecutable(this);
    }
  } // Variable Conflict Resolution Helpers

  /**
   * Get the names of all the variables of the given type that are in scope for this target.
   * For targets that are not the stage, this includes any target-specific
   * variables as well as any stage variables unless the skipStage flag is true.
   * For the stage, this is all stage variables.
   * @param {string} type The variable type to search for; defaults to Variable.SCALAR_TYPE
   * @param {?bool} skipStage Optional flag to skip the stage.
   * @return {Array<string>} A list of variable names
   */


  getAllVariableNamesInScopeByType(type, skipStage) {
    if (typeof type !== "string") type = Variable.SCALAR_TYPE;
    skipStage = skipStage || false;
    const targetVariables = Object.values(this.variables).filter(v => v.type === type).map(variable => variable.name);

    if (skipStage || this.isStage || !this.runtime) {
      return targetVariables;
    }

    const stage = this.runtime.getTargetForStage();
    const stageVariables = stage.getAllVariableNamesInScopeByType(type);
    return targetVariables.concat(stageVariables);
  }
  /**
   * Merge variable references with another variable.
   * @param {string} idToBeMerged ID of the variable whose references need to be updated
   * @param {string} idToMergeWith ID of the variable that the old references should be replaced with
   * @param {?Array<Object>} optReferencesToUpdate Optional context of the change.
   * Defaults to all the blocks in this target.
   * @param {?string} optNewName New variable name to merge with. The old
   * variable name in the references being updated should be replaced with this new name.
   * If this parameter is not provided or is '', no name change occurs.
   */


  mergeVariables(idToBeMerged, idToMergeWith, optReferencesToUpdate, optNewName) {
    const referencesToChange = optReferencesToUpdate || // TODO should there be a separate helper function that traverses the blocks
    // for all references for a given ID instead of doing the below..?
    this.blocks.getAllVariableAndListReferences()[idToBeMerged];
    VariableUtil.updateVariableIdentifiers(referencesToChange, idToMergeWith, optNewName);
  }
  /**
   * Share a local variable (and given references for that variable) to the stage.
   * @param {string} varId The ID of the variable to share.
   * @param {Array<object>} varRefs The list of variable references being shared,
   * that reference the given variable ID. The names and IDs of these variable
   * references will be updated to refer to the new (or pre-existing) global variable.
   */


  shareLocalVariableToStage(varId, varRefs) {
    if (!this.runtime) return;
    const variable = this.variables[varId];

    if (!variable) {
      console.warn(`Cannot share a local variable to the stage if it's not local.`);
      return;
    }

    const stage = this.runtime.getTargetForStage(); // If a local var is being shared with the stage,
    // sharing will make the variable global, resulting in a conflict
    // with the existing local variable. Preemptively Resolve this conflict
    // by renaming the new global variable.
    // First check if we've already done the local to global transition for this
    // variable. If we have, merge it with the global variable we've already created.

    const varIdForStage = `StageVarFromLocal_${varId}`;
    let stageVar = stage.lookupVariableById(varIdForStage); // If a global var doesn't already exist, create a new one with a fresh name.
    // Use the ID we created above so that we can lookup this new variable in the
    // future if we decide to share this same variable again.

    if (!stageVar) {
      const varName = variable.name;
      const varType = variable.type;
      const newStageName = `Stage: ${varName}`;
      stageVar = this.runtime.createNewGlobalVariable(newStageName, varIdForStage, varType);
    } // Update all variable references to use the new name and ID


    this.mergeVariables(varId, stageVar.id, varRefs, stageVar.name);
  }
  /**
   * Share a local variable with a sprite, merging with one of the same name and
   * type if it already exists on the sprite, or create a new one.
   * @param {string} varId Id of the variable to share
   * @param {Target} sprite The sprite to share the variable with
   * @param {Array<object>} varRefs A list of all the variable references currently being shared.
   */


  shareLocalVariableToSprite(varId, sprite, varRefs) {
    if (!this.runtime) return;
    if (this.isStage) return;
    const variable = this.variables[varId];

    if (!variable) {
      console.warn(`Tried to call 'shareLocalVariableToSprite' with a non-local variable.`);
      return;
    }

    const varName = variable.name;
    const varType = variable.type; // Check if the receiving sprite already has a variable of the same name and type
    // and use the existing variable, otherwise create a new one.

    const existingLocalVar = sprite.lookupVariableByNameAndType(varName, varType);
    let newVarId;

    if (existingLocalVar) {
      newVarId = existingLocalVar.id;
    } else {
      const newVar = new Variable(null, varName, varType);
      newVarId = newVar.id;
      sprite.variables[newVarId] = newVar;
    } // Merge with the local variable on the new sprite.


    this.mergeVariables(varId, newVarId, varRefs);
  }
  /**
   * Given a list of variable referencing fields, shares those variables with
   * the target with the provided id, resolving any variable conflicts that arise
   * using the following rules:
   *
   * If this target is the stage, exit. There are no conflicts that arise
   * from sharing variables from the stage to another sprite. The variables
   * already exist globally, so no further action is needed.
   *
   * If a variable being referenced is a global variable, do nothing. The
   * global variable already exists so no further action is needed.
   *
   * If a variable being referenced is local, and
   * 1) The receiving target is a sprite:
   * create a new local variable or merge with an existing local variable
   * of the same name and type. Update all the referencing fields
   * for the original variable to reference the new variable.
   * 2) The receiving target is the stage:
   * Create a new global variable with a fresh name and update all the referencing
   * fields to reference the new variable.
   *
   * @param {Array<object>} blocks The blocks containing
   * potential conflicting references to variables.
   * @param {Target} receivingTarget The target receiving the variables
   */


  resolveVariableSharingConflictsWithTarget(blocks, receivingTarget) {
    if (this.isStage) return; // Get all the variable references in the given list of blocks

    const allVarListRefs = this.blocks.getAllVariableAndListReferences(blocks); // For all the variables being referenced, check for which ones are local
    // to this target, and resolve conflicts based on whether the receiving target
    // is a sprite (with a conflicting local variable) or whether it is
    // the stage (which cannot have local variables)

    for (const varId in allVarListRefs) {
      const currVar = this.variables[varId];
      if (!currVar) continue; // The current variable is global, there shouldn't be any conflicts here, skip it.
      // Get the list of references for the current variable id

      const currVarListRefs = allVarListRefs[varId];

      if (receivingTarget.isStage) {
        this.shareLocalVariableToStage(varId, currVarListRefs);
      } else {
        this.shareLocalVariableToSprite(varId, receivingTarget, currVarListRefs);
      }
    }
  }
  /**
   * .
   * Sprite.
   *
   * If this target has a block that references an existing global variable and that
   * variable *does not* exist in this target (e.g. it was a global variable in the
   * project the sprite was originally exported from), merge the variables. This entails
   * fixing the variable references in this sprite to reference the id of the pre-existing global variable.
   *
   * If this target has a block that references an existing global variable and that
   * variable does exist in the target itself (e.g. it's a local variable in the sprite being uploaded),
   * then the local variable is renamed to distinguish itself from the pre-existing variable.
   * All blocks that reference the local variable will be updated to use the new name.
   */
  // TODO (#1360) This function is too long, add some helpers for the different chunks and cases...


  fixUpVariableReferences() {
    if (!this.runtime) return; // There's no runtime context to conflict with

    if (this.isStage) return; // Stage can't have variable conflicts with itself (and also can't be uploaded)

    const stage = this.runtime.getTargetForStage();
    if (!stage || !stage.variables) return;

    const renameConflictingLocalVar = (id, name, type) => {
      const conflict = stage.lookupVariableByNameAndType(name, type);

      if (conflict) {
        const newName = StringUtil.unusedName(`${this.getName()}: ${name}`, this.getAllVariableNamesInScopeByType(type));
        this.renameVariable(id, newName);
        return newName;
      }

      return null;
    };

    const allReferences = this.blocks.getAllVariableAndListReferences();
    const unreferencedLocalVarIds = [];

    if (Object.keys(this.variables).length > 0) {
      for (const localVarId in this.variables) {
        if (!this.variables.hasOwnProperty(localVarId)) continue;
        if (!allReferences[localVarId]) unreferencedLocalVarIds.push(localVarId);
      }
    }

    const conflictIdsToReplace = Object.create(null);
    const conflictNamesToReplace = Object.create(null); // Cache the list of all variable names by type so that we don't need to
    // re-calculate this in every iteration of the following loop.

    const varNamesByType = {};

    const allVarNames = type => {
      const namesOfType = varNamesByType[type];
      if (namesOfType) return namesOfType;
      varNamesByType[type] = this.runtime.getAllVarNamesOfType(type);
      return varNamesByType[type];
    };

    for (const varId in allReferences) {
      // We don't care about which var ref we get, they should all have the same var info
      const varRef = allReferences[varId][0];
      const varName = varRef.referencingField.value;
      const varType = varRef.type;

      if (this.lookupVariableById(varId)) {
        // Found a variable with the id in either the target or the stage,
        // figure out which one.
        if (this.variables.hasOwnProperty(varId)) {
          // If the target has the variable, then check whether the stage
          // has one with the same name and type. If it does, then rename
          // this target specific variable so that there is a distinction.
          const newVarName = renameConflictingLocalVar(varId, varName, varType);

          if (newVarName) {
            // We are not calling this.blocks.updateBlocksAfterVarRename
            // here because it will search through all the blocks. We already
            // have access to all the references for this var id.
            allReferences[varId].map(ref => {
              ref.referencingField.value = newVarName;
              return ref;
            });
          }
        }
      } else {
        // We didn't find the referenced variable id anywhere,
        // Treat it as a reference to a global variable (from the original
        // project this sprite was exported from).
        // Check for whether a global variable of the same name and type exists,
        // and if so, track it to merge with the existing global in a second pass of the blocks.
        const existingVar = stage.lookupVariableByNameAndType(varName, varType);

        if (existingVar) {
          if (!conflictIdsToReplace[varId]) {
            conflictIdsToReplace[varId] = existingVar.id;
          }
        } else {
          // A global variable with the same name did not already exist,
          // create a new one such that it does not conflict with any
          // names of local variables of the same type.
          const allNames = allVarNames(varType);
          const freshName = StringUtil.unusedName(varName, allNames);
          stage.createVariable(varId, freshName, varType);

          if (!conflictNamesToReplace[varId]) {
            conflictNamesToReplace[varId] = freshName;
          }
        }
      }
    } // Rename any local variables that were missed above because they aren't
    // referenced by any blocks


    for (const id in unreferencedLocalVarIds) {
      const varId = unreferencedLocalVarIds[id];
      const name = this.variables[varId].name;
      const type = this.variables[varId].type;
      renameConflictingLocalVar(varId, name, type);
    } // Handle global var conflicts with existing global vars (e.g. a sprite is uploaded, and has
    // blocks referencing some variable that the sprite does not own, and this
    // variable conflicts with a global var)
    // In this case, we want to merge the new variable referenes with the
    // existing global variable


    for (const conflictId in conflictIdsToReplace) {
      const existingId = conflictIdsToReplace[conflictId];
      const referencesToUpdate = allReferences[conflictId];
      this.mergeVariables(conflictId, existingId, referencesToUpdate);
    } // Handle global var conflicts existing local vars (e.g a sprite is uploaded,
    // and has blocks referencing some variable that the sprite does not own, and this
    // variable conflcits with another sprite's local var).
    // In this case, we want to go through the variable references and update
    // the name of the variable in that reference.


    for (const conflictId in conflictNamesToReplace) {
      const newName = conflictNamesToReplace[conflictId];
      const referencesToUpdate = allReferences[conflictId];
      referencesToUpdate.map(ref => {
        ref.referencingField.value = newName;
        return ref;
      });
    }
  }

}

module.exports = Target;

/***/ }),

/***/ "./src/engine/thread.js":
/*!******************************!*\
  !*** ./src/engine/thread.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Recycle bin for empty stackFrame objects
 * @type Array<_StackFrame>
 */
const _stackFrameFreeList = [];
/**
 * A frame used for each level of the stack. A general purpose
 * place to store a bunch of execution context and parameters
 * @param {boolean} warpMode Whether this level of the stack is warping
 * @constructor
 * @private
 */

class _StackFrame {
  constructor(warpMode) {
    /**
     * Whether this level of the stack is a loop.
     * @type {boolean}
     */
    this.isLoop = false;
    /**
     * Whether this level is in warp mode.  Is set by some legacy blocks and
     * "turbo mode"
     * @type {boolean}
     */

    this.warpMode = warpMode;
    /**
     * Reported value from just executed block.
     * @type {Any}
     */

    this.justReported = null;
    /**
     * The active block that is waiting on a promise.
     * @type {string}
     */

    this.reporting = '';
    /**
     * Persists reported inputs during async block.
     * @type {Object}
     */

    this.reported = null;
    /**
     * Name of waiting reporter.
     * @type {string}
     */

    this.waitingReporter = null;
    /**
     * Procedure parameters.
     * @type {Object}
     */

    this.params = null;
    /**
     * A context passed to block implementations.
     * @type {Object}
     */

    this.executionContext = null;
  }
  /**
   * Reset all properties of the frame to pristine null and false states.
   * Used to recycle.
   * @return {_StackFrame} this
   */


  reset() {
    this.isLoop = false;
    this.warpMode = false;
    this.justReported = null;
    this.reported = null;
    this.waitingReporter = null;
    this.params = null;
    this.executionContext = null;
    return this;
  }
  /**
   * Reuse an active stack frame in the stack.
   * @param {?boolean} warpMode defaults to current warpMode
   * @returns {_StackFrame} this
   */


  reuse(warpMode = this.warpMode) {
    this.reset();
    this.warpMode = Boolean(warpMode);
    return this;
  }
  /**
   * Create or recycle a stack frame object.
   * @param {boolean} warpMode Enable warpMode on this frame.
   * @returns {_StackFrame} The clean stack frame with correct warpMode setting.
   */


  static create(warpMode) {
    const stackFrame = _stackFrameFreeList.pop();

    if (typeof stackFrame !== 'undefined') {
      stackFrame.warpMode = Boolean(warpMode);
      return stackFrame;
    }

    return new _StackFrame(warpMode);
  }
  /**
   * Put a stack frame object into the recycle bin for reuse.
   * @param {_StackFrame} stackFrame The frame to reset and recycle.
   */


  static release(stackFrame) {
    if (typeof stackFrame !== 'undefined') {
      _stackFrameFreeList.push(stackFrame.reset());
    }
  }

}
/**
 * A thread is a running stack context and all the metadata needed.
 * @param {?string} firstBlock First block to execute in the thread.
 * @constructor
 */


class Thread {
  constructor(firstBlock) {
    /**
     * ID of top block of the thread
     * @type {!string}
     */
    this.topBlock = firstBlock;
    /**
     * Stack for the thread. When the sequencer enters a control structure,
     * the block is pushed onto the stack so we know where to exit.
     * @type {Array.<string>}
     */

    this.stack = [];
    /**
     * Stack frames for the thread. Store metadata for the executing blocks.
     * @type {Array.<_StackFrame>}
     */

    this.stackFrames = [];
    /**
     * Status of the thread, one of three states (below)
     * @type {number}
     */

    this.status = 0;
    /* Thread.STATUS_RUNNING */

    /**
     * Whether the thread is killed in the middle of execution.
     * @type {boolean}
     */

    this.isKilled = false;
    /**
     * Target of this thread.
     * @type {?Target}
     */

    this.target = null;
    /**
     * The Blocks this thread will execute.
     * @type {Blocks}
     */

    this.blockContainer = null;
    /**
     * Whether the thread requests its script to glow during this frame.
     * @type {boolean}
     */

    this.requestScriptGlowInFrame = false;
    /**
     * Which block ID should glow during this frame, if any.
     * @type {?string}
     */

    this.blockGlowInFrame = null;
    /**
     * A timer for when the thread enters warp mode.
     * Substitutes the sequencer's count toward WORK_TIME on a per-thread basis.
     * @type {?Timer}
     */

    this.warpTimer = null;
    this.justReported = null;
  }
  /**
   * Thread status for initialized or running thread.
   * This is the default state for a thread - execution should run normally,
   * stepping from block to block.
   * @const
   */


  static get STATUS_RUNNING() {
    return 0;
  }
  /**
   * Threads are in this state when a primitive is waiting on a promise;
   * execution is paused until the promise changes thread status.
   * @const
   */


  static get STATUS_PROMISE_WAIT() {
    return 1;
  }
  /**
   * Thread status for yield.
   * @const
   */


  static get STATUS_YIELD() {
    return 2;
  }
  /**
   * Thread status for a single-tick yield. This will be cleared when the
   * thread is resumed.
   * @const
   */


  static get STATUS_YIELD_TICK() {
    return 3;
  }
  /**
   * Thread status for a finished/done thread.
   * Thread is in this state when there are no more blocks to execute.
   * @const
   */


  static get STATUS_DONE() {
    return 4;
  }
  /**
   * Push stack and update stack frames appropriately.
   * @param {string} blockId Block ID to push to stack.
   */


  pushStack(blockId) {
    this.stack.push(blockId); // Push an empty stack frame, if we need one.
    // Might not, if we just popped the stack.

    if (this.stack.length > this.stackFrames.length) {
      const parent = this.stackFrames[this.stackFrames.length - 1];
      this.stackFrames.push(_StackFrame.create(typeof parent !== 'undefined' && parent.warpMode));
    }
  }
  /**
   * Reset the stack frame for use by the next block.
   * (avoids popping and re-pushing a new stack frame - keeps the warpmode the same
   * @param {string} blockId Block ID to push to stack.
   */


  reuseStackForNextBlock(blockId) {
    this.stack[this.stack.length - 1] = blockId;
    this.stackFrames[this.stackFrames.length - 1].reuse();
  }
  /**
   * Pop last block on the stack and its stack frame.
   * @return {string} Block ID popped from the stack.
   */


  popStack() {
    _StackFrame.release(this.stackFrames.pop());

    return this.stack.pop();
  }
  /**
   * Pop back down the stack frame until we hit a procedure call or the stack frame is emptied
   */


  stopThisScript() {
    let blockID = this.peekStack();

    while (blockID !== null) {
      const block = this.target.blocks.getBlock(blockID);

      if (typeof block !== 'undefined' && block.opcode === 'procedures_call') {
        break;
      }

      this.popStack();
      blockID = this.peekStack();
    }

    if (this.stack.length === 0) {
      // Clean up!
      this.requestScriptGlowInFrame = false;
      this.status = Thread.STATUS_DONE;
    }
  }
  /**
   * Get top stack item.
   * @return {?string} Block ID on top of stack.
   */


  peekStack() {
    return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
  }
  /**
   * Get top stack frame.
   * @return {?object} Last stack frame stored on this thread.
   */


  peekStackFrame() {
    return this.stackFrames.length > 0 ? this.stackFrames[this.stackFrames.length - 1] : null;
  }
  /**
   * Get stack frame above the current top.
   * @return {?object} Second to last stack frame stored on this thread.
   */


  peekParentStackFrame() {
    return this.stackFrames.length > 1 ? this.stackFrames[this.stackFrames.length - 2] : null;
  }
  /**
   * Push a reported value to the parent of the current stack frame.
   * @param {*} value Reported value to push.
   */


  pushReportedValue(value) {
    this.justReported = typeof value === 'undefined' ? null : value;
  }
  /**
   * Initialize procedure parameters on this stack frame.
   */


  initParams() {
    const stackFrame = this.peekStackFrame();

    if (stackFrame.params === null) {
      stackFrame.params = {};
    }
  }
  /**
   * Add a parameter to the stack frame.
   * Use when calling a procedure with parameter values.
   * @param {!string} paramName Name of parameter.
   * @param {*} value Value to set for parameter.
   */


  pushParam(paramName, value) {
    const stackFrame = this.peekStackFrame();
    stackFrame.params[paramName] = value;
  }
  /**
   * Get a parameter at the lowest possible level of the stack.
   * @param {!string} paramName Name of parameter.
   * @return {*} value Value for parameter.
   */


  getParam(paramName) {
    for (let i = this.stackFrames.length - 1; i >= 0; i--) {
      const frame = this.stackFrames[i];

      if (frame.params === null) {
        continue;
      }

      if (frame.params.hasOwnProperty(paramName)) {
        return frame.params[paramName];
      }

      return null;
    }

    return null;
  }
  /**
   * Whether the current execution of a thread is at the top of the stack.
   * @return {boolean} True if execution is at top of the stack.
   */


  atStackTop() {
    return this.peekStack() === this.topBlock;
  }
  /**
   * Switch the thread to the next block at the current level of the stack.
   * For example, this is used in a standard sequence of blocks,
   * where execution proceeds from one block to the next.
   */


  goToNextBlock() {
    const nextBlockId = this.target.blocks.getNextBlock(this.peekStack());
    this.reuseStackForNextBlock(nextBlockId);
  }
  /**
   * Attempt to determine whether a procedure call is recursive,
   * by examining the stack.
   * @param {!string} procedureCode Procedure code of procedure being called.
   * @return {boolean} True if the call appears recursive.
   */


  isRecursiveCall(procedureCode) {
    let callCount = 5; // Max number of enclosing procedure calls to examine.

    const sp = this.stack.length - 1;

    for (let i = sp - 1; i >= 0; i--) {
      const block = this.target.blocks.getBlock(this.stack[i]);

      if (block.opcode === 'procedures_call' && block.mutation.proccode === procedureCode) {
        return true;
      }

      if (--callCount < 0) return false;
    }

    return false;
  }

}

module.exports = Thread;

/***/ }),

/***/ "./src/engine/variable.js":
/*!********************************!*\
  !*** ./src/engine/variable.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview
 * Scratch
 */
class Variable {
  /**
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @param {string} type Type of the variable, one of '' or 'list'
   * @param {boolean} isCloud Whether the variable is stored in the cloud.
   * @constructor
   */
  constructor(id, name, type, isCloud) {
    console.log("class Variable:", id, name, type, isCloud);
    this.id = id || Utility.uid();
    this.name = name;
    this.type = type;
    this.isCloud = isCloud;

    switch (this.type) {
      case Variable.SCALAR_TYPE:
        this.value = 0;
        break;

      case Variable.LIST_TYPE:
        this.value = [];
        break;

      case Variable.BROADCAST_MESSAGE_TYPE:
        this.value = this.name;
        break;

      default:
        throw new Error(`Invalid variable type: ${this.type}`);
    }
  }

  toXML(isLocal) {
    isLocal = isLocal === true;
    return `<variable type="${this.type}" id="${this.id}" islocal="${isLocal}" iscloud="${this.isCloud}">${Utility.xmlEscape(this.name)}</variable>`;
  }
  /**
   * Type representation for scalar variables.
   * This is currently represented as ''
   * for compatibility with blockly.
   * @const {string}
   */


  static get SCALAR_TYPE() {
    return "";
  }
  /**
   * Type representation for list variables.
   * @const {string}
   */


  static get LIST_TYPE() {
    return "list";
  }
  /**
   * Type representation for list variables.
   * @const {string}
   */


  static get BROADCAST_MESSAGE_TYPE() {
    return "broadcast_msg";
  }

}

module.exports = Variable;

/***/ }),

/***/ "./src/extension-support/argument-type.js":
/*!************************************************!*\
  !*** ./src/extension-support/argument-type.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Block argument types
 * @enum {string}
 */
const ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',

  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',

  /**
   * Numeric value with color picker
   */
  COLOR: 'color',

  /**
   * Numeric value with text field
   */
  NUMBER: 'number',

  /**
   * String value with text field
   */
  STRING: 'string',

  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',

  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',

  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
module.exports = ArgumentType;

/***/ }),

/***/ "./src/extension-support/block-type.js":
/*!*********************************************!*\
  !*** ./src/extension-support/block-type.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Types of block
 * @enum {string}
 */
const BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',

  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',

  /**
   * Command block
   */
  COMMAND: 'command',

  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',

  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',

  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',

  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',

  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
module.exports = BlockType;

/***/ }),

/***/ "./src/extension-support/extension-manager.js":
/*!****************************************************!*\
  !*** ./src/extension-support/extension-manager.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const dispatch = __webpack_require__(/*! ../dispatch/central-dispatch */ "./src/dispatch/central-dispatch.js");

const maybeFormatMessage = __webpack_require__(/*! ../util/maybe-format-message */ "./src/util/maybe-format-message.js");

const BlockType = __webpack_require__(/*! ./block-type */ "./src/extension-support/block-type.js");

const ArgumentType = __webpack_require__(/*! ./argument-type */ "./src/extension-support/argument-type.js");

const TargetType = __webpack_require__(/*! ../extension-support/target-type */ "./src/extension-support/target-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const RenderedTarget = __webpack_require__(/*! ../sprites/rendered-target */ "./src/sprites/rendered-target.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");
/**  core_example */

/* eslint-disable-next-line max-len */


const blockIconURICoreExample = 'data:image/svg+xml,%3Csvg id="rotate-counter-clockwise" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%233d79cc;%7D.cls-2%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3Erotate-counter-clockwise%3C/title%3E%3Cpath class="cls-1" d="M22.68,12.2a1.6,1.6,0,0,1-1.27.63H13.72a1.59,1.59,0,0,1-1.16-2.58l1.12-1.41a4.82,4.82,0,0,0-3.14-.77,4.31,4.31,0,0,0-2,.8,4.25,4.25,0,0,0-1.34,1.73,5.06,5.06,0,0,0,.54,4.62A5.58,5.58,0,0,0,12,17.74h0a2.26,2.26,0,0,1-.16,4.52A10.25,10.25,0,0,1,3.74,18,10.14,10.14,0,0,1,2.25,8.78,9.7,9.7,0,0,1,5.08,4.64,9.92,9.92,0,0,1,9.66,2.5a10.66,10.66,0,0,1,7.72,1.68l1.08-1.35a1.57,1.57,0,0,1,1.24-.6,1.6,1.6,0,0,1,1.54,1.21l1.7,7.37A1.57,1.57,0,0,1,22.68,12.2Z"/%3E%3Cpath class="cls-2" d="M21.38,11.83H13.77a.59.59,0,0,1-.43-1l1.75-2.19a5.9,5.9,0,0,0-4.7-1.58,5.07,5.07,0,0,0-4.11,3.17A6,6,0,0,0,7,15.77a6.51,6.51,0,0,0,5,2.92,1.31,1.31,0,0,1-.08,2.62,9.3,9.3,0,0,1-7.35-3.82A9.16,9.16,0,0,1,3.17,9.12,8.51,8.51,0,0,1,5.71,5.4,8.76,8.76,0,0,1,9.82,3.48a9.71,9.71,0,0,1,7.75,2.07l1.67-2.1a.59.59,0,0,1,1,.21L22,11.08A.59.59,0,0,1,21.38,11.83Z"/%3E%3C/svg%3E';
/**
 * An example core block implemented using the extension spec.
 * This is not loaded as part of the core blocks in the VM but it is provided
 * and used as part of tests.
 */

class KidCoreExample {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: "coreExample",
      name: "CoreEx",
      // This string does not need to be translated as this extension is only used as an example.
      blocks: [{
        func: "MAKE_A_VARIABLE",
        blockType: BlockType.BUTTON,
        text: "make a variable (CoreEx)"
      }, {
        opcode: "exampleOpcode",
        blockType: BlockType.REPORTER,
        text: "example block"
      }, {
        opcode: "exampleWithInlineImage",
        blockType: BlockType.COMMAND,
        text: "block with image [CLOCKWISE] inline",
        arguments: {
          CLOCKWISE: {
            type: ArgumentType.IMAGE,
            dataURI: blockIconURICoreExample
          }
        }
      }]
    };
  }
  /**
   * Example opcode just returns the name of the stage target.
   * @returns {string} The name of the first target in the project.
   */


  exampleOpcode() {
    const stage = this.runtime.getTargetForStage();
    return stage ? stage.getName() : "no stage yet";
  }

  exampleWithInlineImage() {
    return;
  }

}
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURIPenBlocks = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+cGVuLWljb248L3RpdGxlPjxnIHN0cm9rZT0iIzU3NUU3NSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik04Ljc1MyAzNC42MDJsLTQuMjUgMS43OCAxLjc4My00LjIzN2MxLjIxOC0yLjg5MiAyLjkwNy01LjQyMyA1LjAzLTcuNTM4TDMxLjA2NiA0LjkzYy44NDYtLjg0MiAyLjY1LS40MSA0LjAzMi45NjcgMS4zOCAxLjM3NSAxLjgxNiAzLjE3My45NyA0LjAxNUwxNi4zMTggMjkuNTljLTIuMTIzIDIuMTE2LTQuNjY0IDMuOC03LjU2NSA1LjAxMiIgZmlsbD0iI0ZGRiIvPjxwYXRoIGQ9Ik0yOS40MSA2LjExcy00LjQ1LTIuMzc4LTguMjAyIDUuNzcyYy0xLjczNCAzLjc2Ni00LjM1IDEuNTQ2LTQuMzUgMS41NDYiLz48cGF0aCBkPSJNMzYuNDIgOC44MjVjMCAuNDYzLS4xNC44NzMtLjQzMiAxLjE2NGwtOS4zMzUgOS4zYy4yODItLjI5LjQxLS42NjguNDEtMS4xMiAwLS44NzQtLjUwNy0xLjk2My0xLjQwNi0yLjg2OC0xLjM2Mi0xLjM1OC0zLjE0Ny0xLjgtNC4wMDItLjk5TDMwLjk5IDUuMDFjLjg0NC0uODQgMi42NS0uNDEgNC4wMzUuOTYuODk4LjkwNCAxLjM5NiAxLjk4MiAxLjM5NiAyLjg1NU0xMC41MTUgMzMuNzc0Yy0uNTczLjMwMi0xLjE1Ny41Ny0xLjc2NC44M0w0LjUgMzYuMzgybDEuNzg2LTQuMjM1Yy4yNTgtLjYwNC41My0xLjE4Ni44MzMtMS43NTcuNjkuMTgzIDEuNDQ4LjYyNSAyLjEwOCAxLjI4Mi42Ni42NTggMS4xMDIgMS40MTIgMS4yODcgMi4xMDIiIGZpbGw9IiM0Qzk3RkYiLz48cGF0aCBkPSJNMzYuNDk4IDguNzQ4YzAgLjQ2NC0uMTQuODc0LS40MzMgMS4xNjVsLTE5Ljc0MiAxOS42OGMtMi4xMyAyLjExLTQuNjczIDMuNzkzLTcuNTcyIDUuMDFMNC41IDM2LjM4bC45NzQtMi4zMTYgMS45MjUtLjgwOGMyLjg5OC0xLjIxOCA1LjQ0LTIuOSA3LjU3LTUuMDFsMTkuNzQzLTE5LjY4Yy4yOTItLjI5Mi40MzItLjcwMi40MzItMS4xNjUgMC0uNjQ2LS4yNy0xLjQtLjc4LTIuMTIyLjI1LjE3Mi41LjM3Ny43MzcuNjE0Ljg5OC45MDUgMS4zOTYgMS45ODMgMS4zOTYgMi44NTYiIGZpbGw9IiM1NzVFNzUiIG9wYWNpdHk9Ii4xNSIvPjxwYXRoIGQ9Ik0xOC40NSAxMi44M2MwIC41LS40MDQuOTA1LS45MDQuOTA1cy0uOTA1LS40MDUtLjkwNS0uOTA0YzAtLjUuNDA3LS45MDMuOTA2LS45MDMuNSAwIC45MDQuNDA0LjkwNC45MDR6IiBmaWxsPSIjNTc1RTc1Ii8+PC9nPjwvc3ZnPg==";
/**
 * Enum for pen color parameter values.
 * @readonly
 * @enum {string}
 */

const ColorParam = {
  COLOR: "color",
  SATURATION: "saturation",
  BRIGHTNESS: "brightness",
  TRANSPARENCY: "transparency"
};
/**
 * @typedef {object} PenState - the pen state associated with a particular target.
 * @property {Boolean} penDown - tracks whether the pen should draw for this target.
 * @property {number} color - the current color (hue) of the pen.
 * @property {PenAttributes} penAttributes - cached pen attributes for the renderer. This is the authoritative value for
 *   diameter but not for pen color.
 */

/**
 * Host for the Pen-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */

class kidPenBlocksExtensions {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The ID of the renderer Drawable corresponding to the pen layer.
     * @type {int}
     * @private
     */

    this._penDrawableId = -1;
    /**
     * The ID of the renderer Skin corresponding to the pen layer.
     * @type {int}
     * @private
     */

    this._penSkinId = -1;
    this._onTargetCreated = this._onTargetCreated.bind(this);
    this._onTargetMoved = this._onTargetMoved.bind(this);
    runtime.on("targetWasCreated", this._onTargetCreated);
    runtime.on("RUNTIME_DISPOSED", this.clear.bind(this));
  }
  /**
   * The default pen state, to be used when a target has no existing pen state.
   * @type {PenState}
   */


  static get DEFAULT_PEN_STATE() {
    return {
      penDown: false,
      color: 66.66,
      saturation: 100,
      brightness: 100,
      transparency: 0,
      _shade: 50,
      // Used only for legacy `change shade by` blocks
      penAttributes: {
        color4f: [0, 0, 1, 1],
        diameter: 1
      }
    };
  }
  /**
   * The minimum and maximum allowed pen size.
   * The maximum is twice the diagonal of the stage, so that even an
   * off-stage sprite can fill it.
   * @type {{min: number, max: number}}
   */


  static get PEN_SIZE_RANGE() {
    return {
      min: 1,
      max: 1200
    };
  }
  /**
   * The key to load & store a target's pen-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.pen";
  }
  /**
   * Clamp a pen size value to the range allowed by the pen.
   * @param {number} requestedSize - the requested pen size.
   * @returns {number} the clamped size.
   * @private
   */


  _clampPenSize(requestedSize) {
    return Utility.clamp(requestedSize, kidPenBlocksExtensions.PEN_SIZE_RANGE.min, kidPenBlocksExtensions.PEN_SIZE_RANGE.max);
  }
  /**
   * Retrieve the ID of the renderer "Skin" corresponding to the pen layer. If
   * the pen Skin doesn't yet exist, create it.
   * @returns {int} the Skin ID of the pen layer, or -1 on failure.
   * @private
   */


  _getPenLayerID() {
    if (this._penSkinId < 0 && this.runtime.renderer) {
      this._penSkinId = this.runtime.renderer.createPenSkin();
      this._penDrawableId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);
      this.runtime.renderer.updateDrawableProperties(this._penDrawableId, {
        skinId: this._penSkinId
      });
    }

    return this._penSkinId;
  }
  /**
   * @param {Target} target - collect pen state for this target. Probably, but not necessarily, a RenderedTarget.
   * @returns {PenState} the mutable pen state associated with that target. This will be created if necessary.
   * @private
   */


  _getPenState(target) {
    let penState = target.getCustomState(kidPenBlocksExtensions.STATE_KEY);

    if (!penState) {
      penState = Utility.cloneSimple(kidPenBlocksExtensions.DEFAULT_PEN_STATE);
      target.setCustomState(kidPenBlocksExtensions.STATE_KEY, penState);
    }

    return penState;
  }
  /**
   * When a pen-using Target is cloned, clone the pen state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const penState = sourceTarget.getCustomState(kidPenBlocksExtensions.STATE_KEY);

      if (penState) {
        newTarget.setCustomState(kidPenBlocksExtensions.STATE_KEY, Utility.cloneSimple(penState));

        if (penState.penDown) {
          newTarget.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
        }
      }
    }
  }
  /**
   * Handle a target which has moved. This only fires when the pen is down.
   * @param {RenderedTarget} target - the target which has moved.
   * @param {number} oldX - the previous X position.
   * @param {number} oldY - the previous Y position.
   * @param {boolean} isForce - whether the movement was forced.
   * @private
   */


  _onTargetMoved(target, oldX, oldY, isForce) {
    // Only move the pen if the movement isn't forced (ie. dragged).
    if (!isForce) {
      const penSkinId = this._getPenLayerID();

      if (penSkinId >= 0) {
        const penState = this._getPenState(target);

        this.runtime.renderer.penLine(penSkinId, penState.penAttributes, oldX, oldY, target.x, target.y);
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * Wrap a color input into the range (0,100).
   * @param {number} value - the value to be wrapped.
   * @returns {number} the wrapped value.
   * @private
   */


  _wrapColor(value) {
    return Utility.wrapClamp(value, 0, 100);
  }
  /**
   * Initialize color parameters menu with localized strings
   * @returns {array} of the localized text and values for each menu element
   * @private
   */


  _initColorParam() {
    return [{
      text: formatMessage({
        id: "pen.colorMenu.color",
        default: "color",
        description: "label for color element in color picker for pen extension"
      }),
      value: ColorParam.COLOR
    }, {
      text: formatMessage({
        id: "pen.colorMenu.saturation",
        default: "saturation",
        description: "label for saturation element in color picker for pen extension"
      }),
      value: ColorParam.SATURATION
    }, {
      text: formatMessage({
        id: "pen.colorMenu.brightness",
        default: "brightness",
        description: "label for brightness element in color picker for pen extension"
      }),
      value: ColorParam.BRIGHTNESS
    }, {
      text: formatMessage({
        id: "pen.colorMenu.transparency",
        default: "transparency",
        description: "label for transparency element in color picker for pen extension"
      }),
      value: ColorParam.TRANSPARENCY
    }];
  }
  /**
   * Clamp a pen color parameter to the range (0,100).
   * @param {number} value - the value to be clamped.
   * @returns {number} the clamped value.
   * @private
   */


  _clampColorParam(value) {
    return Utility.clamp(value, 0, 100);
  }
  /**
   * Convert an alpha value to a pen transparency value.
   * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
   * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
   * @param {number} alpha - the input alpha value.
   * @returns {number} the transparency value.
   * @private
   */


  _alphaToTransparency(alpha) {
    return (1.0 - alpha) * 100.0;
  }
  /**
   * Convert a pen transparency value to an alpha value.
   * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
   * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
   * @param {number} transparency - the input transparency value.
   * @returns {number} the alpha value.
   * @private
   */


  _transparencyToAlpha(transparency) {
    return 1.0 - transparency / 100.0;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: "pen",
      name: formatMessage({
        id: "pen.categoryName",
        default: "Pen",
        description: "Label for the pen extension category"
      }),
      blockIconURI: blockIconURIPenBlocks,
      blocks: [{
        opcode: "clear",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.clear",
          default: "erase all",
          description: "erase all pen trails and stamps"
        })
      }, {
        opcode: "stamp",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.stamp",
          default: "stamp",
          description: "render current costume on the background"
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: "penDown",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.penDown",
          default: "pen down",
          description: "start leaving a trail when the sprite moves"
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: "penUp",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.penUp",
          default: "pen up",
          description: "stop leaving a trail behind the sprite"
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: "setPenColorToColor",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.setColor",
          default: "set pen color to [COLOR]",
          description: "set the pen color to a particular (RGB) value"
        }),
        arguments: {
          COLOR: {
            type: ArgumentType.COLOR
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: "changePenColorParamBy",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.changeColorParam",
          default: "change pen [COLOR_PARAM] by [VALUE]",
          description: "change the state of a pen color parameter"
        }),
        arguments: {
          COLOR_PARAM: {
            type: ArgumentType.STRING,
            menu: "colorParam",
            defaultValue: ColorParam.COLOR
          },
          VALUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 10
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: "setPenColorParamTo",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.setColorParam",
          default: "set pen [COLOR_PARAM] to [VALUE]",
          description: "set the state for a pen color parameter e.g. saturation"
        }),
        arguments: {
          COLOR_PARAM: {
            type: ArgumentType.STRING,
            menu: "colorParam",
            defaultValue: ColorParam.COLOR
          },
          VALUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: "changePenSizeBy",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.changeSize",
          default: "change pen size by [SIZE]",
          description: "change the diameter of the trail left by a sprite"
        }),
        arguments: {
          SIZE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: "setPenSizeTo",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.setSize",
          default: "set pen size to [SIZE]",
          description: "set the diameter of a trail left by a sprite"
        }),
        arguments: {
          SIZE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        filter: [TargetType.SPRITE]
      },
      /* Legacy blocks, should not be shown in flyout */
      {
        opcode: "setPenShadeToNumber",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.setShade",
          default: "set pen shade to [SHADE]",
          description: "legacy pen blocks - set pen shade"
        }),
        arguments: {
          SHADE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: "changePenShadeBy",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.changeShade",
          default: "change pen shade by [SHADE]",
          description: "legacy pen blocks - change pen shade"
        }),
        arguments: {
          SHADE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: "setPenHueToNumber",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.setHue",
          default: "set pen color to [HUE]",
          description: "legacy pen blocks - set pen color to number"
        }),
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: "changePenHueBy",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.changeHue",
          default: "change pen color by [HUE]",
          description: "legacy pen blocks - change pen color"
        }),
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }],
      menus: {
        colorParam: {
          acceptReporters: true,
          items: this._initColorParam()
        }
      }
    };
  }
  /**
   * The pen "clear" block clears the pen layer's contents.
   */


  clear() {
    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penClear(penSkinId);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "stamp" block stamps the current drawable's image onto the pen layer.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  stamp(args, util) {
    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      const target = util.target;
      this.runtime.renderer.penStamp(penSkinId, target.drawableID);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "pen down" block causes the target to leave pen trails on future motion.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  penDown(args, util) {
    const target = util.target;

    const penState = this._getPenState(target);

    if (!penState.penDown) {
      penState.penDown = true;
      target.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
    }

    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penPoint(penSkinId, penState.penAttributes, target.x, target.y);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "pen up" block stops the target from leaving pen trails.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  penUp(args, util) {
    const target = util.target;

    const penState = this._getPenState(target);

    if (penState.penDown) {
      penState.penDown = false;
      target.removeListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
    }
  }
  /**
   * The pen "set pen color to {color}" block sets the pen to a particular RGB color.
   * The transparency is reset to 0.
   * @param {object} args - the block arguments.
   *  @property {int} COLOR - the color to set, expressed as a 24-bit RGB value (0xRRGGBB).
   * @param {object} util - utility object provided by the runtime.
   */


  setPenColorToColor(args, util) {
    const penState = this._getPenState(util.target);

    const rgb = Utility.toRgbColorObject(args.COLOR);
    const hsv = Utility.rgbToHsv(rgb);
    penState.color = hsv.h / 360 * 100;
    penState.saturation = hsv.s * 100;
    penState.brightness = hsv.v * 100;

    if (rgb.hasOwnProperty("a")) {
      penState.transparency = 100 * (1 - rgb.a / 255.0);
    } else {
      penState.transparency = 0;
    } // Set the legacy "shade" value the same way scratch 2 did.


    penState._shade = penState.brightness / 2;

    this._updatePenColor(penState);
  }
  /**
   * Update the cached color from the color, saturation, brightness and transparency values
   * in the provided PenState object.
   * @param {PenState} penState - the pen state to update.
   * @private
   */


  _updatePenColor(penState) {
    const rgb = Utility.hsvToRgb({
      h: penState.color * 360 / 100,
      s: penState.saturation / 100,
      v: penState.brightness / 100
    });
    penState.penAttributes.color4f[0] = rgb.r / 255.0;
    penState.penAttributes.color4f[1] = rgb.g / 255.0;
    penState.penAttributes.color4f[2] = rgb.b / 255.0;
    penState.penAttributes.color4f[3] = this._transparencyToAlpha(penState.transparency);
  }
  /**
   * Set or change a single color parameter on the pen state, and update the pen color.
   * @param {ColorParam} param - the name of the color parameter to set or change.
   * @param {number} value - the value to set or change the param by.
   * @param {PenState} penState - the pen state to update.
   * @param {boolean} change - if true change param by value, if false set param to value.
   * @private
   */


  _setOrChangeColorParam(param, value, penState, change) {
    switch (param) {
      case ColorParam.COLOR:
        penState.color = this._wrapColor(value + (change ? penState.color : 0));
        break;

      case ColorParam.SATURATION:
        penState.saturation = this._clampColorParam(value + (change ? penState.saturation : 0));
        break;

      case ColorParam.BRIGHTNESS:
        penState.brightness = this._clampColorParam(value + (change ? penState.brightness : 0));
        break;

      case ColorParam.TRANSPARENCY:
        penState.transparency = this._clampColorParam(value + (change ? penState.transparency : 0));
        break;

      default:
        console.warn(`Tried to set or change unknown color parameter: ${param}`);
    }

    this._updatePenColor(penState);
  }
  /**
   * The "change pen {ColorParam} by {number}" block changes one of the pen's color parameters
   * by a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to change the selected parameter by.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenColorParamBy(args, util) {
    const penState = this._getPenState(util.target);

    this._setOrChangeColorParam(args.COLOR_PARAM, Utility.toNumber(args.VALUE), penState, true);
  }
  /**
   * The "set pen {ColorParam} to {number}" block sets one of the pen's color parameters
   * to a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to set the selected parameter to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenColorParamTo(args, util) {
    const penState = this._getPenState(util.target);

    this._setOrChangeColorParam(args.COLOR_PARAM, Utility.toNumber(args.VALUE), penState, false);
  }
  /**
   * The pen "change pen size by {number}" block changes the pen size by the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenSizeBy(args, util) {
    const penAttributes = this._getPenState(util.target).penAttributes;

    penAttributes.diameter = this._clampPenSize(penAttributes.diameter + Utility.toNumber(args.SIZE));
  }
  /**
   * The pen "set pen size to {number}" block sets the pen size to the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenSizeTo(args, util) {
    const penAttributes = this._getPenState(util.target).penAttributes;

    penAttributes.diameter = this._clampPenSize(Utility.toNumber(args.SIZE));
  }
  /* LEGACY OPCODES */

  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount to set the hue to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenHueToNumber(args, util) {
    const penState = this._getPenState(util.target);

    const hueValue = Utility.toNumber(args.HUE);
    const colorValue = hueValue / 2;

    this._setOrChangeColorParam(ColorParam.COLOR, colorValue, penState, false);

    this._setOrChangeColorParam(ColorParam.TRANSPARENCY, 0, penState, false);

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount of desired hue change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenHueBy(args, util) {
    const penState = this._getPenState(util.target);

    const hueChange = Utility.toNumber(args.HUE);
    const colorChange = hueChange / 2;

    this._setOrChangeColorParam(ColorParam.COLOR, colorChange, penState, true);

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Use legacy "set shade" code to calculate RGB value for shade,
   * then convert back to HSV and store those components.
   * It is important to also track the given shade in penState._shade
   * because it cannot be accurately backed out of the new HSV later.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount to set the shade to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenShadeToNumber(args, util) {
    const penState = this._getPenState(util.target);

    let newShade = Utility.toNumber(args.SHADE); // Wrap clamp the new shade value the way scratch 2 did.

    newShade = newShade % 200;
    if (newShade < 0) newShade += 200; // And store the shade that was used to compute this new color for later use.

    penState._shade = newShade;

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Because "shade" cannot be backed out of hsv consistently, use the previously
   * stored penState._shade to make the shade change.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount of desired shade change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenShadeBy(args, util) {
    const penState = this._getPenState(util.target);

    const shadeChange = Utility.toNumber(args.SHADE);
    this.setPenShadeToNumber({
      SHADE: penState._shade + shadeChange
    }, util);
  }
  /**
   * Update the pen state's color from its hue & shade values, Scratch 2.0 style.
   * @param {object} penState - update the HSV & RGB values in this pen state from its hue & shade values.
   * @private
   */


  _legacyUpdatePenColor(penState) {
    // Create the new color in RGB using the scratch 2 "shade" model
    let rgb = Utility.hsvToRgb({
      h: penState.color * 360 / 100,
      s: 1,
      v: 1
    });
    const shade = penState._shade > 100 ? 200 - penState._shade : penState._shade;

    if (shade < 50) {
      rgb = Utility.mixRgb(Utility.RGB_BLACK, rgb, (10 + shade) / 60);
    } else {
      rgb = Utility.mixRgb(rgb, Utility.RGB_WHITE, (shade - 50) / 60);
    } // Update the pen state according to new color


    const hsv = Utility.rgbToHsv(rgb);
    penState.color = 100 * hsv.h / 360;
    penState.saturation = 100 * hsv.s;
    penState.brightness = 100 * hsv.v;

    this._updatePenColor(penState);
  }

}
/** @description MIDI */


const ASSET_MIDI_HOST = window.location.protocol.indexOf("https") != -1 ? `https://kid.leadersir.net/` : `http://kid.leadersir.net/`;
/** @description midiurl */

const ASSET_MIDI_URL = `${ASSET_MIDI_HOST}kid/material/midi/`;
/** @description midikeybuffer */

let MIDI_BUFFER = {
  "drums/1-snare.mp3": null,
  "drums/2-bass-drum.mp3": null,
  "drums/3-side-stick.mp3": null,
  "drums/4-crash-cymbal.mp3": null,
  "drums/5-open-hi-hat.mp3": null,
  "drums/6-closed-hi-hat.mp3": null,
  "drums/7-tambourine.mp3": null,
  "drums/8-hand-clap.mp3": null,
  "drums/9-claves.mp3": null,
  "drums/10-wood-block.mp3": null,
  "drums/11-cowbell.mp3": null,
  "drums/12-triangle.mp3": null,
  "drums/13-bongo.mp3": null,
  "drums/14-conga.mp3": null,
  "drums/15-cabasa.mp3": null,
  "drums/16-guiro.mp3": null,
  "drums/17-vibraslap.mp3": null,
  "drums/18-cuica.mp3": null,
  "instruments/1-piano/24.mp3": null,
  "instruments/1-piano/36.mp3": null,
  "instruments/1-piano/48.mp3": null,
  "instruments/1-piano/60.mp3": null,
  "instruments/1-piano/72.mp3": null,
  "instruments/1-piano/84.mp3": null,
  "instruments/1-piano/96.mp3": null,
  "instruments/1-piano/108.mp3": null,
  "instruments/2-electric-piano/60.mp3": null,
  "instruments/3-organ/60.mp3": null,
  "instruments/4-guitar/60.mp3": null,
  "instruments/5-electric-guitar/60.mp3": null,
  "instruments/6-bass/36.mp3": null,
  "instruments/6-bass/48.mp3": null,
  "instruments/7-pizzicato/60.mp3": null,
  "instruments/8-cello/36.mp3": null,
  "instruments/8-cello/48.mp3": null,
  "instruments/8-cello/60.mp3": null,
  "instruments/9-trombone/36.mp3": null,
  "instruments/9-trombone/48.mp3": null,
  "instruments/9-trombone/60.mp3": null,
  "instruments/10-clarinet/48.mp3": null,
  "instruments/10-clarinet/60.mp3": null,
  "instruments/11-saxophone/36.mp3": null,
  "instruments/11-saxophone/60.mp3": null,
  "instruments/11-saxophone/84.mp3": null,
  "instruments/12-flute/60.mp3": null,
  "instruments/12-flute/72.mp3": null,
  "instruments/13-wooden-flute/60.mp3": null,
  "instruments/13-wooden-flute/72.mp3": null,
  "instruments/14-bassoon/36.mp3": null,
  "instruments/14-bassoon/48.mp3": null,
  "instruments/14-bassoon/60.mp3": null,
  "instruments/15-choir/48.mp3": null,
  "instruments/15-choir/60.mp3": null,
  "instruments/15-choir/72.mp3": null,
  "instruments/16-vibraphone/60.mp3": null,
  "instruments/16-vibraphone/72.mp3": null,
  "instruments/17-music-box/60.mp3": null,
  "instruments/18-steel-drum/60.mp3": null,
  "instruments/19-marimba/60.mp3": null,
  "instruments/20-synth-lead/60.mp3": null,
  "instruments/21-synth-pad/60.mp3": null
};
/**
 * @type {string} svgURI.
 */

const blockIconURIMusicBlocks = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlPm11c2ljLWJsb2NrLWljb248L3RpdGxlPjxkZWZzPjxwYXRoIGQ9Ik0zMi4xOCAyNS44NzRDMzIuNjM2IDI4LjE1NyAzMC41MTIgMzAgMjcuNDMzIDMwYy0zLjA3IDAtNS45MjMtMS44NDMtNi4zNzItNC4xMjYtLjQ1OC0yLjI4NSAxLjY2NS00LjEzNiA0Ljc0My00LjEzNi42NDcgMCAxLjI4My4wODQgMS44OS4yMzQuMzM4LjA4Ni42MzcuMTguOTM4LjMwMi44Ny0uMDItLjEwNC0yLjI5NC0xLjgzNS0xMi4yMy0yLjEzNC0xMi4zMDIgMy4wNi0xLjg3IDguNzY4LTIuNzUyIDUuNzA4LS44ODUuMDc2IDQuODItMy42NSAzLjg0NC0zLjcyNC0uOTg3LTQuNjUtNy4xNTMuMjYzIDE0LjczOHptLTE2Ljk5OCA1Ljk5QzE1LjYzIDM0LjE0OCAxMy41MDcgMzYgMTAuNDQgMzZjLTMuMDcgMC01LjkyMi0xLjg1Mi02LjM4LTQuMTM2LS40NDgtMi4yODQgMS42NzQtNC4xMzUgNC43NS00LjEzNSAxLjAwMyAwIDEuOTc1LjE5NiAyLjg1NS41NDMuODIyLS4wNTUtLjE1LTIuMzc3LTEuODYyLTEyLjIyOC0yLjEzMy0xMi4zMDMgMy4wNi0xLjg3IDguNzY0LTIuNzUzIDUuNzA2LS44OTQuMDc2IDQuODItMy42NDggMy44MzQtMy43MjQtLjk4Ny00LjY1LTcuMTUyLjI2MiAxNC43Mzh6IiBpZD0iYSIvPjwvZGVmcz48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjx1c2UgZmlsbD0iI0ZGRiIgeGxpbms6aHJlZj0iI2EiLz48cGF0aCBzdHJva2Utb3BhY2l0eT0iLjEiIHN0cm9rZT0iIzAwMCIgZD0iTTI4LjQ1NiAyMS42NzVjLS4wMS0uMzEyLS4wODctLjgyNS0uMjU2LTEuNzAyLS4wOTYtLjQ5NS0uNjEyLTMuMDIyLS43NTMtMy43My0uMzk1LTEuOTgtLjc2LTMuOTItMS4xNDItNi4xMTMtLjczMi00LjIyMy0uNjkzLTYuMDUuMzQ0LTYuNTI3LjUtLjIzIDEuMDYtLjA4IDEuODQuMzUuNDE0LjIyNyAyLjE4MiAxLjM2NSAyLjA3IDEuMjk2IDEuOTk0IDEuMjQyIDMuNDY0IDEuNzc0IDQuOTMgMS41NDggMS41MjYtLjIzNyAyLjUwNC0uMDYgMi44NzYuNjE4LjM0OC42MzUuMDE1IDEuNDE2LS43MyAyLjE4LTEuNDcyIDEuNTE2LTMuOTc1IDIuNTE0LTUuODQ4IDIuMDIzLS44MjItLjIyLTEuMjM4LS40NjUtMi4zOC0xLjI2N2wtLjA5NS0uMDY2Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMy4yOTQgMS4zMzYgMi4wOCA5LjE4NyAyLjYzNyAxMS42NzRsLjAwMi4wMTJjLjUyOCAyLjYzNy0xLjg3MyA0LjcyNC01LjIzNiA0LjcyNC0zLjI5IDAtNi4zNjMtMS45ODgtNi44NjItNC41MjgtLjUzLTIuNjQgMS44NzMtNC43MzQgNS4yMzMtNC43MzQuNjcyIDAgMS4zNDcuMDg1IDIuMDE0LjI1LjIyNy4wNTcuNDM2LjExOC42MzYuMTg3em0tMTYuOTk2IDUuOTljLS4wMS0uMzE4LS4wOS0uODM4LS4yNjYtMS43MzctLjA5LS40Ni0uNTk1LTIuOTM3LS43NTMtMy43MjctLjM5LTEuOTYtLjc1LTMuODktMS4xMy02LjA3LS43MzItNC4yMjMtLjY5Mi02LjA1LjM0NC02LjUyNi41MDItLjIzIDEuMDYtLjA4MiAxLjg0LjM1LjQxNS4yMjcgMi4xODIgMS4zNjQgMi4wNyAxLjI5NSAxLjk5MyAxLjI0MiAzLjQ2MiAxLjc3NCA0LjkyNiAxLjU0OCAxLjUyNS0uMjQgMi41MDQtLjA2NCAyLjg3Ni42MTQuMzQ4LjYzNS4wMTUgMS40MTUtLjcyOCAyLjE4LTEuNDc0IDEuNTE3LTMuOTc3IDIuNTEzLTUuODQ3IDIuMDE3LS44Mi0uMjItMS4yMzYtLjQ2NC0yLjM3OC0xLjI2N2wtLjA5NS0uMDY1Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMi4yOTQgMS4zMzcgMi4wNzggOS4xOSAyLjYzNiAxMS42NzVsLjAwMy4wMTNjLjUxNyAyLjYzOC0xLjg4NCA0LjczMi01LjIzNCA0LjczMi0zLjI4NyAwLTYuMzYtMS45OTMtNi44Ny00LjU0LS41Mi0yLjY0IDEuODg0LTQuNzMgNS4yNC00LjczLjkwNSAwIDEuODAzLjE1IDIuNjUuNDM2eiIvPjwvZz48L3N2Zz4=";
/**
 * @type {string} svgURI.
 */

const menuIconURIMusicBlocks = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE2LjA5IDEyLjkzN2MuMjI4IDEuMTQxLS44MzMgMi4wNjMtMi4zNzMgMi4wNjMtMS41MzUgMC0yLjk2Mi0uOTIyLTMuMTg2LTIuMDYzLS4yMy0xLjE0Mi44MzMtMi4wNjggMi4zNzItMi4wNjguMzIzIDAgLjY0MS4wNDIuOTQ1LjExN2EzLjUgMy41IDAgMCAxIC40NjguMTUxYy40MzUtLjAxLS4wNTItMS4xNDctLjkxNy02LjExNC0xLjA2Ny02LjE1MiAxLjUzLS45MzUgNC4zODQtMS4zNzcgMi44NTQtLjQ0Mi4wMzggMi40MS0xLjgyNSAxLjkyMi0xLjg2Mi0uNDkzLTIuMzI1LTMuNTc3LjEzMiA3LjM3ek03LjQ2IDguNTYzYy0xLjg2Mi0uNDkzLTIuMzI1LTMuNTc2LjEzIDcuMzdDNy44MTYgMTcuMDczIDYuNzU0IDE4IDUuMjIgMThjLTEuNTM1IDAtMi45NjEtLjkyNi0zLjE5LTIuMDY4LS4yMjQtMS4xNDIuODM3LTIuMDY3IDIuMzc1LTIuMDY3LjUwMSAwIC45ODcuMDk4IDEuNDI3LjI3Mi40MTItLjAyOC0uMDc0LTEuMTg5LS45My02LjExNEMzLjgzNCAxLjg3IDYuNDMgNy4wODcgOS4yODIgNi42NDZjMi44NTQtLjQ0Ny4wMzggMi40MS0xLjgyMyAxLjkxN3oiIGZpbGw9IiM1NzVFNzUiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==";
/**
 * @function 
 */

async function pullRemoteAssetAsync() {
  console.warn(":");
  const temp = Object.keys(MIDI_BUFFER);

  for (let i = 0; i < temp.length; i++) {
    console.warn("", temp[i]);
    const response = await fetch(ASSET_MIDI_URL + temp[i]);
    const blob = await response.blob();
    console.warn("blob:", blob);
    let reader = new FileReader(); //  Blob, , result  ArrayBuffer .

    reader.readAsArrayBuffer(blob); // load

    reader.onload = function (event) {
      MIDI_BUFFER[temp[i]] = event.target.result;
    };
  }
}
/**
 * 
 * @param {Runtime} runtime - .
 * @constructor
 */


class kidMusicBlocks {
  constructor(runtime) {
    this.runtime = runtime;
    /** @type {number} . */

    this._concurrencyCounter = 0;
    /** @type {Array} . */

    this._drumPlayers = [];
    /** @type {Array[]}  . */

    this._instrumentPlayerArrays = [];
    /** @type {Array[]}  mya. */

    this._instrumentPlayerNoteArrays = [];
    /** @type {Array} bufferSourceNodes bufferSourceNode . */

    this._bufferSources = [];
    this._onTargetCreated = this._onTargetCreated.bind(this);
    this.runtime.on("targetWasCreated", this._onTargetCreated);
    this._playNoteForPicker = this._playNoteForPicker.bind(this);
    this.runtime.on("PLAY_NOTE", this._playNoteForPicker);

    this._loadAllSounds();
  }
  /**
   * .
   */


  async _loadAllSounds() {
    console.log("index.js _loadAllSounds"); // 

    await pullRemoteAssetAsync();
    const loadingPromises = [];
    this.DRUM_INFO.forEach((drumInfo, index) => {
      const filePath = `drums/${drumInfo.fileName}`;
      console.log("index.js _loadAllSounds drum", drumInfo);

      const promise = this._storeSound(filePath, index, this._drumPlayers);

      loadingPromises.push(promise);
    });
    this.INSTRUMENT_INFO.forEach((instrumentInfo, instrumentIndex) => {
      this._instrumentPlayerArrays[instrumentIndex] = [];
      this._instrumentPlayerNoteArrays[instrumentIndex] = [];
      instrumentInfo.samples.forEach((sample, noteIndex) => {
        const filePath = `instruments/${instrumentInfo.dirName}/${sample}`;
        console.log("index.js _loadAllSounds instrument", instrumentInfo);

        const promise = this._storeSound(filePath, noteIndex, this._instrumentPlayerArrays[instrumentIndex]);

        loadingPromises.push(promise);
      });
    });
    Promise.all(loadingPromises).then(() => {
      // @TODO: .
      console.warn("");
    });
  }
  /**
   * .
   * @param {string} filePath - .
   * @param {number} index - .
   * @param {array} playerArray - .
   * @return {Promise} - .
   */


  _storeSound(filePath, index, playerArray) {
    console.log("index.js _storeSound", filePath, index, playerArray);
    const fullPath = `${filePath}.mp3`;
    if (!MIDI_BUFFER[fullPath]) return; // .

    const soundBuffer = MIDI_BUFFER[fullPath];
    return this._decodeSound(soundBuffer).then(player => {
      playerArray[index] = player;
    });
  }
  /**
   * .
   * @param  {ArrayBuffer} soundBuffer - .
   * @return {Promise} - .
   */


  _decodeSound(soundBuffer) {
    console.log("index.js _decodeSound", soundBuffer);
    const engine = this.runtime.audioEngine;
    if (!engine) return Promise.reject(new Error("No Audio Context Detected")); // API

    return engine.decodeSoundPlayer({
      data: {
        buffer: soundBuffer
      }
    });
  }
  /**
   *  .
   * @param  {object[]} info - An array of info objects each having a name property.
   * @return {array} - An array of objects with text and value properties.
   * @private
   */


  _buildMenu(info) {
    return info.map((entry, index) => {
      const obj = {};
      obj.text = entry.name;
      obj.value = String(index + 1);
      return obj;
    });
  }
  /**
   * .
   * @type {object[]}
   * @param {string} name - the translatable name to display in the drums menu.
   * @param {string} fileName - the name of the audio file containing the drum sound.
   */


  get DRUM_INFO() {
    return [{
      name: formatMessage({
        id: "music.drumSnare",
        default: "(1) Snare Drum",
        description: "Sound of snare drum as used in a standard drum kit"
      }),
      fileName: "1-snare"
    }, {
      name: formatMessage({
        id: "music.drumBass",
        default: "(2) Bass Drum",
        description: "Sound of bass drum as used in a standard drum kit"
      }),
      fileName: "2-bass-drum"
    }, {
      name: formatMessage({
        id: "music.drumSideStick",
        default: "(3) Side Stick",
        description: "Sound of a drum stick hitting the side of a drum (usually the snare)"
      }),
      fileName: "3-side-stick"
    }, {
      name: formatMessage({
        id: "music.drumCrashCymbal",
        default: "(4) Crash Cymbal",
        description: "Sound of a drum stick hitting a crash cymbal"
      }),
      fileName: "4-crash-cymbal"
    }, {
      name: formatMessage({
        id: "music.drumOpenHiHat",
        default: "(5) Open Hi-Hat",
        description: "Sound of a drum stick hitting a hi-hat while open"
      }),
      fileName: "5-open-hi-hat"
    }, {
      name: formatMessage({
        id: "music.drumClosedHiHat",
        default: "(6) Closed Hi-Hat",
        description: "Sound of a drum stick hitting a hi-hat while closed"
      }),
      fileName: "6-closed-hi-hat"
    }, {
      name: formatMessage({
        id: "music.drumTambourine",
        default: "(7) Tambourine",
        description: "Sound of a tambourine being struck"
      }),
      fileName: "7-tambourine"
    }, {
      name: formatMessage({
        id: "music.drumHandClap",
        default: "(8) Hand Clap",
        description: "Sound of two hands clapping together"
      }),
      fileName: "8-hand-clap"
    }, {
      name: formatMessage({
        id: "music.drumClaves",
        default: "(9) Claves",
        description: "Sound of claves being struck together"
      }),
      fileName: "9-claves"
    }, {
      name: formatMessage({
        id: "music.drumWoodBlock",
        default: "(10) Wood Block",
        description: "Sound of a wood block being struck"
      }),
      fileName: "10-wood-block"
    }, {
      name: formatMessage({
        id: "music.drumCowbell",
        default: "(11) Cowbell",
        description: "Sound of a cowbell being struck"
      }),
      fileName: "11-cowbell"
    }, {
      name: formatMessage({
        id: "music.drumTriangle",
        default: "(12) Triangle",
        description: "Sound of a triangle (instrument) being struck"
      }),
      fileName: "12-triangle"
    }, {
      name: formatMessage({
        id: "music.drumBongo",
        default: "(13) Bongo",
        description: "Sound of a bongo being struck"
      }),
      fileName: "13-bongo"
    }, {
      name: formatMessage({
        id: "music.drumConga",
        default: "(14) Conga",
        description: "Sound of a conga being struck"
      }),
      fileName: "14-conga"
    }, {
      name: formatMessage({
        id: "music.drumCabasa",
        default: "(15) Cabasa",
        description: "Sound of a cabasa being shaken"
      }),
      fileName: "15-cabasa"
    }, {
      name: formatMessage({
        id: "music.drumGuiro",
        default: "(16) Guiro",
        description: "Sound of a guiro being played"
      }),
      fileName: "16-guiro"
    }, {
      name: formatMessage({
        id: "music.drumVibraslap",
        default: "(17) Vibraslap",
        description: "Sound of a Vibraslap being played"
      }),
      fileName: "17-vibraslap"
    }, {
      name: formatMessage({
        id: "music.drumCuica",
        default: "(18) Cuica",
        description: "Sound of a cuica being played"
      }),
      fileName: "18-cuica"
    }];
  }
  /**
   * An array of info about each instrument.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the instruments menu.
   * @param {string} dirName - the name of the directory containing audio samples for this instrument.
   * @param {number} [releaseTime] - an optional duration for the release portion of each note.
   * @param {number[]} samples - an array of numbers representing the MIDI note number for each
   *                           sampled sound used to play this instrument.
   */


  get INSTRUMENT_INFO() {
    return [{
      name: formatMessage({
        id: "music.instrumentPiano",
        default: "(1) Piano",
        description: "Sound of a piano"
      }),
      dirName: "1-piano",
      releaseTime: 0.5,
      samples: [24, 36, 48, 60, 72, 84, 96, 108]
    }, {
      name: formatMessage({
        id: "music.instrumentElectricPiano",
        default: "(2) Electric Piano",
        description: "Sound of an electric piano"
      }),
      dirName: "2-electric-piano",
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentOrgan",
        default: "(3) Organ",
        description: "Sound of an organ"
      }),
      dirName: "3-organ",
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentGuitar",
        default: "(4) Guitar",
        description: "Sound of an accoustic guitar"
      }),
      dirName: "4-guitar",
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentElectricGuitar",
        default: "(5) Electric Guitar",
        description: "Sound of an electric guitar"
      }),
      dirName: "5-electric-guitar",
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentBass",
        default: "(6) Bass",
        description: "Sound of an accoustic upright bass"
      }),
      dirName: "6-bass",
      releaseTime: 0.25,
      samples: [36, 48]
    }, {
      name: formatMessage({
        id: "music.instrumentPizzicato",
        default: "(7) Pizzicato",
        description: "Sound of a string instrument (e.g. violin) being plucked"
      }),
      dirName: "7-pizzicato",
      releaseTime: 0.25,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentCello",
        default: "(8) Cello",
        description: "Sound of a cello being played with a bow"
      }),
      dirName: "8-cello",
      releaseTime: 0.1,
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: "music.instrumentTrombone",
        default: "(9) Trombone",
        description: "Sound of a trombone being played"
      }),
      dirName: "9-trombone",
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: "music.instrumentClarinet",
        default: "(10) Clarinet",
        description: "Sound of a clarinet being played"
      }),
      dirName: "10-clarinet",
      samples: [48, 60]
    }, {
      name: formatMessage({
        id: "music.instrumentSaxophone",
        default: "(11) Saxophone",
        description: "Sound of a saxophone being played"
      }),
      dirName: "11-saxophone",
      samples: [36, 60, 84]
    }, {
      name: formatMessage({
        id: "music.instrumentFlute",
        default: "(12) Flute",
        description: "Sound of a flute being played"
      }),
      dirName: "12-flute",
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: "music.instrumentWoodenFlute",
        default: "(13) Wooden Flute",
        description: "Sound of a wooden flute being played"
      }),
      dirName: "13-wooden-flute",
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: "music.instrumentBassoon",
        default: "(14) Bassoon",
        description: "Sound of a bassoon being played"
      }),
      dirName: "14-bassoon",
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: "music.instrumentChoir",
        default: "(15) Choir",
        description: "Sound of a choir singing"
      }),
      dirName: "15-choir",
      releaseTime: 0.25,
      samples: [48, 60, 72]
    }, {
      name: formatMessage({
        id: "music.instrumentVibraphone",
        default: "(16) Vibraphone",
        description: "Sound of a vibraphone being struck"
      }),
      dirName: "16-vibraphone",
      releaseTime: 0.5,
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: "music.instrumentMusicBox",
        default: "(17) Music Box",
        description: "Sound of a music box playing"
      }),
      dirName: "17-music-box",
      releaseTime: 0.25,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentSteelDrum",
        default: "(18) Steel Drum",
        description: "Sound of a steel drum being struck"
      }),
      dirName: "18-steel-drum",
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentMarimba",
        default: "(19) Marimba",
        description: "Sound of a marimba being struck"
      }),
      dirName: "19-marimba",
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentSynthLead",
        default: "(20) Synth Lead",
        description: 'Sound of a "lead" synthesizer being played'
      }),
      dirName: "20-synth-lead",
      releaseTime: 0.1,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentSynthPad",
        default: "(21) Synth Pad",
        description: 'Sound of a "pad" synthesizer being played'
      }),
      dirName: "21-synth-pad",
      releaseTime: 0.25,
      samples: [60]
    }];
  }
  /**
   * MIDIScratch.
   * @type {number[]}
   */


  get MIDI_INSTRUMENTS() {
    return [// Acoustic Grand, Bright Acoustic, Electric Grand, Honky-Tonk
    1, 1, 1, 1, // Electric Piano 1, Electric Piano 2, Harpsichord, Clavinet
    2, 2, 4, 4, // Celesta, Glockenspiel, Music Box, Vibraphone
    17, 17, 17, 16, // Marimba, Xylophone, Tubular Bells, Dulcimer
    19, 16, 17, 17, // Drawbar Organ, Percussive Organ, Rock Organ, Church Organ
    3, 3, 3, 3, // Reed Organ, Accordion, Harmonica, Tango Accordion
    3, 3, 3, 3, // Nylon String Guitar, Steel String Guitar, Electric Jazz Guitar, Electric Clean Guitar
    4, 4, 5, 5, // Electric Muted Guitar, Overdriven Guitar,Distortion Guitar, Guitar Harmonics
    5, 5, 5, 5, // Acoustic Bass, Electric Bass (finger), Electric Bass (pick), Fretless Bass
    6, 6, 6, 6, // Slap Bass 1, Slap Bass 2, Synth Bass 1, Synth Bass 2
    6, 6, 6, 6, // Violin, Viola, Cello, Contrabass
    8, 8, 8, 8, // Tremolo Strings, Pizzicato Strings, Orchestral Strings, Timpani
    8, 7, 8, 19, // String Ensemble 1, String Ensemble 2, SynthStrings 1, SynthStrings 2
    8, 8, 8, 8, // Choir Aahs, Voice Oohs, Synth Voice, Orchestra Hit
    15, 15, 15, 19, // Trumpet, Trombone, Tuba, Muted Trumpet
    9, 9, 9, 9, // French Horn, Brass Section, SynthBrass 1, SynthBrass 2
    9, 9, 9, 9, // Soprano Sax, Alto Sax, Tenor Sax, Baritone Sax
    11, 11, 11, 11, // Oboe, English Horn, Bassoon, Clarinet
    14, 14, 14, 10, // Piccolo, Flute, Recorder, Pan Flute
    12, 12, 13, 13, // Blown Bottle, Shakuhachi, Whistle, Ocarina
    13, 13, 12, 12, // Lead 1 (square), Lead 2 (sawtooth), Lead 3 (calliope), Lead 4 (chiff)
    20, 20, 20, 20, // Lead 5 (charang), Lead 6 (voice), Lead 7 (fifths), Lead 8 (bass+lead)
    20, 20, 20, 20, // Pad 1 (new age), Pad 2 (warm), Pad 3 (polysynth), Pad 4 (choir)
    21, 21, 21, 21, // Pad 5 (bowed), Pad 6 (metallic), Pad 7 (halo), Pad 8 (sweep)
    21, 21, 21, 21, // FX 1 (rain), FX 2 (soundtrack), FX 3 (crystal), FX 4 (atmosphere)
    21, 21, 21, 21, // FX 5 (brightness), FX 6 (goblins), FX 7 (echoes), FX 8 (sci-fi)
    21, 21, 21, 21, // Sitar, Banjo, Shamisen, Koto
    4, 4, 4, 4, // Kalimba, Bagpipe, Fiddle, Shanai
    17, 14, 8, 10, // Tinkle Bell, Agogo, Steel Drums, Woodblock
    17, 17, 18, 19, // Taiko Drum, Melodic Tom, Synth Drum, Reverse Cymbal
    1, 1, 1, 1, // Guitar Fret Noise, Breath Noise, Seashore, Bird Tweet
    21, 21, 21, 21, // Telephone Ring, Helicopter, Applause, Gunshot
    21, 21, 21, 21];
  }
  /**
   * 35..81MIDIScratch.
   * It's in the format [drumNum, pitch, decay].
   * .
   * @type {Array[]}
   */


  get MIDI_DRUMS() {
    return [[1, -4], // "BassDrum" in 2.0, "Bass Drum" in 3.0 (which was "Tom" in 2.0)
    [1, 0], // Same as just above
    [2, 0], [0, 0], [7, 0], [0, 2], [1, -6, 4], [5, 0], [1, -3, 3.2], [5, 0], // "HiHatPedal" in 2.0, "Closed Hi-Hat" in 3.0
    [1, 0, 3], [4, -8], [1, 4, 3], [1, 7, 2.7], [3, -8], [1, 10, 2.7], [4, -2], [3, -11], [4, 2], [6, 0], [3, 0, 3.5], [10, 0], [3, -8, 3.5], [16, -6], [4, 2], [12, 2], [12, 0], [13, 0, 0.2], [13, 0, 2], [13, -5, 2], [12, 12], [12, 5], [10, 19], [10, 12], [14, 0], [14, 0], // "Maracas" in 2.0, "Cabasa" in 3.0 (TODO: pitch up?)
    [17, 12], [17, 5], [15, 0], // "GuiroShort" in 2.0, "Guiro" in 3.0 (which was "GuiroLong" in 2.0) (TODO: decay?)
    [15, 0], [8, 0], [9, 0], [9, -4], [17, -5], [17, 0], [11, -6, 1], [11, -6, 3]];
  }
  /**
   * The key to load & store a target's music-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.music";
  }
  /**
   * The default music-related state, to be used when a target has no existing music state.
   * @type {MusicState}
   */


  static get DEFAULT_MUSIC_STATE() {
    return {
      currentInstrument: 0
    };
  }
  /**
   * The minimum and maximum MIDI note numbers, for clamping the input to play note.
   * @type {{min: number, max: number}}
   */


  static get MIDI_NOTE_RANGE() {
    return {
      min: 0,
      max: 130
    };
  }
  /**
   * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
   * 100 beats at the default tempo of 60bpm is 100 seconds.
   * @type {{min: number, max: number}}
   */


  static get BEAT_RANGE() {
    return {
      min: 0,
      max: 100
    };
  }
  /** The minimum and maximum tempo values, in bpm.
   * @type {{min: number, max: number}}
   */


  static get TEMPO_RANGE() {
    return {
      min: 20,
      max: 500
    };
  }
  /**
   * The maximum number of sounds to allow to play simultaneously.
   * @type {number}
   */


  static get CONCURRENCY_LIMIT() {
    return 30;
  }
  /**
   * @param {Target} target - collect music state for this target.
   * @returns {MusicState} the mutable music state associated with that target. This will be created if necessary.
   * @private
   */


  _getMusicState(target) {
    let musicState = target.getCustomState(kidMusicBlocks.STATE_KEY);

    if (!musicState) {
      musicState = Utility.cloneSimple(kidMusicBlocks.DEFAULT_MUSIC_STATE);
      target.setCustomState(kidMusicBlocks.STATE_KEY, musicState);
    }

    return musicState;
  }
  /**
   * When a music-playing Target is cloned, clone the music state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const musicState = sourceTarget.getCustomState(kidMusicBlocks.STATE_KEY);

      if (musicState) {
        newTarget.setCustomState(kidMusicBlocks.STATE_KEY, Utility.cloneSimple(musicState));
      }
    }
  }
  /**
   * @returns {object} .
   */


  getInfo() {
    return {
      id: "music",
      name: formatMessage({
        id: "music.categoryName",
        default: "Music",
        description: "Label for the Music extension category"
      }),
      menuIconURI: menuIconURIMusicBlocks,
      blockIconURI: blockIconURIMusicBlocks,
      blocks: [{
        opcode: "playDrumForBeats",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.playDrumForBeats",
          default: "play drum [DRUM] for [BEATS] beats",
          description: "play drum sample for a number of beats"
        }),
        arguments: {
          DRUM: {
            type: ArgumentType.NUMBER,
            menu: "DRUM",
            defaultValue: 1
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: "midiPlayDrumForBeats",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.midiPlayDrumForBeats",
          default: "play drum [DRUM] for [BEATS] beats",
          description: "play drum sample for a number of beats according to a mapping of MIDI codes"
        }),
        arguments: {
          DRUM: {
            type: ArgumentType.NUMBER,
            menu: "DRUM",
            defaultValue: 1
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        },
        hideFromPalette: true
      }, {
        opcode: "restForBeats",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.restForBeats",
          default: "rest for [BEATS] beats",
          description: "rest (play no sound) for a number of beats"
        }),
        arguments: {
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: "playNoteForBeats",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.playNoteForBeats",
          default: "play note [NOTE] for [BEATS] beats",
          description: "play a note for a number of beats"
        }),
        arguments: {
          NOTE: {
            type: ArgumentType.NOTE,
            defaultValue: 60
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: "setInstrument",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.setInstrument",
          default: "set instrument to [INSTRUMENT]",
          description: "set the instrument (e.g. piano, guitar, trombone) for notes played"
        }),
        arguments: {
          INSTRUMENT: {
            type: ArgumentType.NUMBER,
            menu: "INSTRUMENT",
            defaultValue: 1
          }
        }
      }, {
        opcode: "midiSetInstrument",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.midiSetInstrument",
          default: "set instrument to [INSTRUMENT]",
          description: "set the instrument for notes played according to a mapping of MIDI codes"
        }),
        arguments: {
          INSTRUMENT: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: "setTempo",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.setTempo",
          default: "set tempo to [TEMPO]",
          description: "set tempo (speed) for notes, drums, and rests played"
        }),
        arguments: {
          TEMPO: {
            type: ArgumentType.NUMBER,
            defaultValue: 60
          }
        }
      }, {
        opcode: "changeTempo",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.changeTempo",
          default: "change tempo by [TEMPO]",
          description: "change tempo (speed) for notes, drums, and rests played"
        }),
        arguments: {
          TEMPO: {
            type: ArgumentType.NUMBER,
            defaultValue: 20
          }
        }
      }, {
        opcode: "getTempo",
        text: formatMessage({
          id: "music.getTempo",
          default: "tempo",
          description: "get the current tempo (speed) for notes, drums, and rests played"
        }),
        blockType: BlockType.REPORTER
      }],
      menus: {
        DRUM: {
          acceptReporters: true,
          items: this._buildMenu(this.DRUM_INFO)
        },
        INSTRUMENT: {
          acceptReporters: true,
          items: this._buildMenu(this.INSTRUMENT_INFO)
        }
      }
    };
  }
  /**
   * Play a drum sound for some number of beats.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} DRUM - the number of the drum to play.
   * @property {number} BEATS - the duration in beats of the drum sound.
   */


  playDrumForBeats(args, util) {
    this._playDrumForBeats(args.DRUM, args.BEATS, util);
  }
  /**
   * Play a drum sound for some number of beats according to the range of "MIDI" drum codes supported.
   * This block is implemented for compatibility with old Scratch projects that use the
   * 'drum:duration:elapsed:from:' block.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  midiPlayDrumForBeats(args, util) {
    let drumNum = Utility.toNumber(args.DRUM);
    drumNum = Math.round(drumNum);
    const midiDescription = this.MIDI_DRUMS[drumNum - 35];

    if (midiDescription) {
      drumNum = midiDescription[0];
    } else {
      drumNum = 2; // Default instrument used in Scratch 2.0
    }

    drumNum += 1; // drumNum input to _playDrumForBeats is one-indexed

    this._playDrumForBeats(drumNum, args.BEATS, util);
  }
  /**
   * Internal code to play a drum sound for some number of beats.
   * @param {number} drumNum - the drum number.
   * @param {beats} beats - the duration in beats to pause after playing the sound.
   * @param {object} util - utility object provided by the runtime.
   */


  _playDrumForBeats(drumNum, beats, util) {
    if (this._stackTimerNeedsInit(util)) {
      drumNum = Utility.toNumber(drumNum);
      drumNum = Math.round(drumNum);
      drumNum -= 1; // drums are one-indexed

      drumNum = Utility.wrapClamp(drumNum, 0, this.DRUM_INFO.length - 1);
      beats = Utility.toNumber(beats);
      beats = this._clampBeats(beats);

      this._playDrumNum(util, drumNum);

      this._startStackTimer(util, this._beatsToSec(beats));
    } else {
      this._checkStackTimer(util);
    }
  }
  /**
   * Play a drum sound using its 0-indexed number.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} drumNum - the number of the drum to play.
   * @private
   */


  _playDrumNum(util, drumNum) {
    if (util.runtime.audioEngine === null) return;
    if (util.target.sprite.soundBank === null) return; // If we're playing too many sounds, do not play the drum sound.

    if (this._concurrencyCounter > kidMusicBlocks.CONCURRENCY_LIMIT) {
      return;
    }

    const player = this._drumPlayers[drumNum];
    if (typeof player === "undefined") return;

    if (player.isPlaying && !player.isStarting) {
      // Take the internal player state and create a new player with it.
      // `.play` does this internally but then instructs the sound to
      // stop.
      player.take();
    }

    const engine = util.runtime.audioEngine;
    const context = engine.audioContext;
    const volumeGain = context.createGain();
    volumeGain.gain.setValueAtTime(util.target.volume / 100, engine.currentTime);
    volumeGain.connect(engine.getInputNode());
    this._concurrencyCounter++;
    player.once("stop", () => {
      this._concurrencyCounter--;
    });
    player.play(); // Connect the player to the gain node.

    player.connect({
      getInputNode() {
        return volumeGain;
      }

    });
  }
  /**
   * Rest for some number of beats.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} BEATS - the duration in beats of the rest.
   */


  restForBeats(args, util) {
    if (this._stackTimerNeedsInit(util)) {
      let beats = Utility.toNumber(args.BEATS);
      beats = this._clampBeats(beats);

      this._startStackTimer(util, this._beatsToSec(beats));
    } else {
      this._checkStackTimer(util);
    }
  }
  /**
   * Play a note using the current musical instrument for some number of beats.
   * This function processes the arguments, and handles the timing of the block's execution.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} NOTE - the pitch of the note to play, interpreted as a MIDI note number.
   * @property {number} BEATS - the duration in beats of the note.
   */


  playNoteForBeats(args, util) {
    if (this._stackTimerNeedsInit(util)) {
      let note = Utility.toNumber(args.NOTE);
      note = Utility.clamp(note, kidMusicBlocks.MIDI_NOTE_RANGE.min, kidMusicBlocks.MIDI_NOTE_RANGE.max);
      let beats = Utility.toNumber(args.BEATS);
      beats = this._clampBeats(beats); // If the duration is 0, do not play the note. In Scratch 2.0, "play drum for 0 beats" plays the drum,
      // but "play note for 0 beats" is silent.

      if (beats === 0) return;

      const durationSec = this._beatsToSec(beats);

      this._playNote(util, note, durationSec);

      this._startStackTimer(util, durationSec);
    } else {
      this._checkStackTimer(util);
    }
  }

  _playNoteForPicker(noteNum, category) {
    if (category !== this.getInfo().name) return;
    const util = {
      runtime: this.runtime,
      target: this.runtime.getEditingTarget()
    };

    this._playNote(util, noteNum, 0.25);
  }
  /**
   * Play a note using the current instrument for a duration in seconds.
   * This function actually plays the sound, and handles the timing of the sound, including the
   * "release" portion of the sound, which continues briefly after the block execution has finished.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} note - the pitch of the note to play, interpreted as a MIDI note number.
   * @param {number} durationSec - the duration in seconds to play the note.
   * @private
   */


  _playNote(util, note, durationSec) {
    if (util.runtime.audioEngine === null) return;
    if (util.target.sprite.soundBank === null) return; // If we're playing too many sounds, do not play the note.

    if (this._concurrencyCounter > kidMusicBlocks.CONCURRENCY_LIMIT) {
      return;
    } // Determine which of the audio samples for this instrument to play


    const musicState = this._getMusicState(util.target);

    const inst = musicState.currentInstrument;
    const instrumentInfo = this.INSTRUMENT_INFO[inst];
    const sampleArray = instrumentInfo.samples;

    const sampleIndex = this._selectSampleIndexForNote(note, sampleArray); // If the audio sample has not loaded yet, bail out


    if (typeof this._instrumentPlayerArrays[inst] === "undefined") return;
    if (typeof this._instrumentPlayerArrays[inst][sampleIndex] === "undefined") return; // Fetch the sound player to play the note.

    const engine = util.runtime.audioEngine;

    if (!this._instrumentPlayerNoteArrays[inst][note]) {
      this._instrumentPlayerNoteArrays[inst][note] = this._instrumentPlayerArrays[inst][sampleIndex].take();
    }

    const player = this._instrumentPlayerNoteArrays[inst][note];

    if (player.isPlaying && !player.isStarting) {
      // Take the internal player state and create a new player with it.
      // `.play` does this internally but then instructs the sound to
      // stop.
      player.take();
    } // Set its pitch.


    const sampleNote = sampleArray[sampleIndex];

    const notePitchInterval = this._ratioForPitchInterval(note - sampleNote); // Create gain nodes for this note's volume and release, and chain them
    // to the output.


    const context = engine.audioContext;
    const volumeGain = context.createGain();
    volumeGain.gain.setValueAtTime(util.target.volume / 100, engine.currentTime);
    const releaseGain = context.createGain();
    volumeGain.connect(releaseGain);
    releaseGain.connect(engine.getInputNode()); // Schedule the release of the note, ramping its gain down to zero,
    // and then stopping the sound.

    let releaseDuration = this.INSTRUMENT_INFO[inst].releaseTime;

    if (typeof releaseDuration === "undefined") {
      releaseDuration = 0.01;
    }

    const releaseStart = context.currentTime + durationSec;
    const releaseEnd = releaseStart + releaseDuration;
    releaseGain.gain.setValueAtTime(1, releaseStart);
    releaseGain.gain.linearRampToValueAtTime(0.0001, releaseEnd);
    this._concurrencyCounter++;
    player.once("stop", () => {
      this._concurrencyCounter--;
    }); // Start playing the note

    player.play(); // Connect the player to the gain node.

    player.connect({
      getInputNode() {
        return volumeGain;
      }

    }); // Set playback now after play creates the outputNode.

    player.outputNode.playbackRate.value = notePitchInterval; // Schedule playback to stop.

    player.outputNode.stop(releaseEnd);
  }
  /**
   * The samples array for each instrument is the set of pitches of the available audio samples.
   * This function selects the best one to use to play a given input note, and returns its index
   * in the samples array.
   * @param  {number} note - the input note to select a sample for.
   * @param  {number[]} samples - an array of the pitches of the available samples.
   * @return {index} the index of the selected sample in the samples array.
   * @private
   */


  _selectSampleIndexForNote(note, samples) {
    // Step backwards through the array of samples, i.e. in descending pitch, in order to find
    // the sample that is the closest one below (or matching) the pitch of the input note.
    for (let i = samples.length - 1; i >= 0; i--) {
      if (note >= samples[i]) {
        return i;
      }
    }

    return 0;
  }
  /**
   * Calcuate the frequency ratio for a given musical interval.
   * @param  {number} interval - the pitch interval to convert.
   * @return {number} a ratio corresponding to the input interval.
   * @private
   */


  _ratioForPitchInterval(interval) {
    return Math.pow(2, interval / 12);
  }
  /**
   * Clamp a duration in beats to the allowed min and max duration.
   * @param  {number} beats - a duration in beats.
   * @return {number} - the clamped duration.
   * @private
   */


  _clampBeats(beats) {
    return Utility.clamp(beats, kidMusicBlocks.BEAT_RANGE.min, kidMusicBlocks.BEAT_RANGE.max);
  }
  /**
   * Convert a number of beats to a number of seconds, using the current tempo.
   * @param  {number} beats - number of beats to convert to secs.
   * @return {number} seconds - number of seconds `beats` will last.
   * @private
   */


  _beatsToSec(beats) {
    return 60 / this.getTempo() * beats;
  }
  /**
   * Check if the stack timer needs initialization.
   * @param {object} util - utility object provided by the runtime.
   * @return {boolean} - true if the stack timer needs to be initialized.
   * @private
   */


  _stackTimerNeedsInit(util) {
    return !util.stackFrame.timer;
  }
  /**
   * Start the stack timer and the yield the thread if necessary.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} duration - a duration in seconds to set the timer for.
   * @private
   */


  _startStackTimer(util, duration) {
    util.stackFrame.timer = new Timer();
    util.stackFrame.timer.start();
    util.stackFrame.duration = duration;
    util.yield();
  }
  /**
   * Check the stack timer, and if its time is not up yet, yield the thread.
   * @param {object} util - utility object provided by the runtime.
   * @private
   */


  _checkStackTimer(util) {
    const timeElapsed = util.stackFrame.timer.timeElapsed();

    if (timeElapsed < util.stackFrame.duration * 1000) {
      util.yield();
    }
  }
  /**
   * Select an instrument for playing notes.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} INSTRUMENT - the number of the instrument to select.
   */


  setInstrument(args, util) {
    this._setInstrument(args.INSTRUMENT, util, false);
  }
  /**
   * Select an instrument for playing notes according to a mapping of MIDI codes to Scratch instrument numbers.
   * This block is implemented for compatibility with old Scratch projects that use the 'midiInstrument:' block.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} INSTRUMENT - the MIDI number of the instrument to select.
   */


  midiSetInstrument(args, util) {
    this._setInstrument(args.INSTRUMENT, util, true);
  }
  /**
   * Internal code to select an instrument for playing notes. If mapMidi is true, set the instrument according to
   * the MIDI to Scratch instrument mapping.
   * @param {number} instNum - the instrument number.
   * @param {object} util - utility object provided by the runtime.
   * @param {boolean} mapMidi - whether or not instNum is a MIDI instrument number.
   */


  _setInstrument(instNum, util, mapMidi) {
    const musicState = this._getMusicState(util.target);

    instNum = Utility.toNumber(instNum);
    instNum = Math.round(instNum);
    instNum -= 1; // instruments are one-indexed

    if (mapMidi) {
      instNum = (this.MIDI_INSTRUMENTS[instNum] || 0) - 1;
    }

    instNum = Utility.wrapClamp(instNum, 0, this.INSTRUMENT_INFO.length - 1);
    musicState.currentInstrument = instNum;
  }
  /**
   * Set the current tempo to a new value.
   * @param {object} args - the block arguments.
   * @property {number} TEMPO - the tempo, in beats per minute.
   */


  setTempo(args) {
    const tempo = Utility.toNumber(args.TEMPO);

    this._updateTempo(tempo);
  }
  /**
   * Change the current tempo by some amount.
   * @param {object} args - the block arguments.
   * @property {number} TEMPO - the amount to change the tempo, in beats per minute.
   */


  changeTempo(args) {
    const change = Utility.toNumber(args.TEMPO);
    const tempo = change + this.getTempo();

    this._updateTempo(tempo);
  }
  /**
   * Update the current tempo, clamping it to the min and max allowable range.
   * @param {number} tempo - the tempo to set, in beats per minute.
   * @private
   */


  _updateTempo(tempo) {
    tempo = Utility.clamp(tempo, kidMusicBlocks.TEMPO_RANGE.min, kidMusicBlocks.TEMPO_RANGE.max);
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      stage.tempo = tempo;
    }
  }
  /**
   * Get the current tempo.
   * @return {number} - the current tempo, in beats per minute.
   */


  getTempo() {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      return stage.tempo;
    }

    return 60;
  }

} // VM.
// TODO: ?
// TODO: ID


const builtinExtensions = {
  // .
  coreExample: () => KidCoreExample,
  // .
  pen: () => kidPenBlocksExtensions,
  wedo2: () => __webpack_require__(/*! ../extensions/scratch3_wedo2 */ "./src/extensions/scratch3_wedo2/index.js"),
  music: () => kidMusicBlocks,
  microbit: () => __webpack_require__(/*! ../extensions/scratch3_microbit */ "./src/extensions/scratch3_microbit/index.js"),
  text2speech: () => __webpack_require__(/*! ../extensions/scratch3_text2speech */ "./src/extensions/scratch3_text2speech/index.js"),
  translate: () => __webpack_require__(/*! ../extensions/scratch3_translate */ "./src/extensions/scratch3_translate/index.js"),
  videoSensing: () => __webpack_require__(/*! ../extensions/scratch3_video_sensing */ "./src/extensions/scratch3_video_sensing/index.js"),
  ev3: () => __webpack_require__(/*! ../extensions/scratch3_ev3 */ "./src/extensions/scratch3_ev3/index.js"),
  makeymakey: () => __webpack_require__(/*! ../extensions/scratch3_makeymakey */ "./src/extensions/scratch3_makeymakey/index.js"),
  boost: () => __webpack_require__(/*! ../extensions/scratch3_boost */ "./src/extensions/scratch3_boost/index.js") // gdxfor: () => require("../extensions/scratch3_gdx_for"),z

};
console.warn("", builtinExtensions);
/**
 * @typedef {object} ArgumentInfo - Information about an extension block argument
 * @property {ArgumentType} type - the type of value this argument can take
 * @property {*|undefined} default - the default value of this argument (default: blank)
 */

/**
 * @typedef {object} ConvertedBlockInfo - Raw extension block data paired with processed data ready for scratch-blocks
 * @property {ExtensionBlockMetadata} info - the raw block info
 * @property {object} json - the scratch-blocks JSON definition for this block
 * @property {string} xml - the scratch-blocks XML definition for this block
 */

/**
 * @typedef {object} CategoryInfo - Information about a block category
 * @property {string} id - the unique ID of this category
 * @property {string} name - the human-readable name of this category
 * @property {string|undefined} blockIconURI - optional URI for the block icon image
 * @property {string} color1 - the primary color for this category, in '#rrggbb' format
 * @property {string} color2 - the secondary color for this category, in '#rrggbb' format
 * @property {string} color3 - the tertiary color for this category, in '#rrggbb' format
 * @property {Array.<ConvertedBlockInfo>} blocks - the blocks, separators, etc. in this category
 * @property {Array.<object>} menus - the menus provided by this category
 */

/**
 * @typedef {object} PendingExtensionWorker - Information about an extension worker still initializing
 * @property {string} extensionURL - the URL of the extension to be loaded by this worker
 * @property {Function} resolve - function to call on successful worker startup
 * @property {Function} reject - function to call on failed worker startup
 */

class ExtensionManager {
  constructor(runtime) {
    /**
     * The ID number to provide to the next extension worker.
     * @type {int}
     */
    this.nextExtensionWorker = 0;
    /**
     * FIFO queue of extensions which have been requested but not yet loaded in a worker,along with promise resolution functions to call once the worker is ready or failed.
     *
     * @type {Array.<PendingExtensionWorker>}
     */

    this.pendingExtensions = [];
    /**
     * Map of worker ID to workers which have been allocated but have not yet finished initialization.
     * @type {Array.<PendingExtensionWorker>}
     */

    this.pendingWorkers = [];
    /**
     * Set of loaded extension URLs/IDs (equivalent for built-in extensions).
     * @type {Set.<string>}
     * @private
     */

    this._loadedExtensions = new Map();
    /**
     * Keep a reference to the runtime so we can construct internal extension objects.
     * TODO: remove this in favor of extensions accessing the runtime as a service.
     * @type {Runtime}
     */

    this.runtime = runtime;
    dispatch.setService("extensions", this).catch(e => {
      console.error(`ExtensionManager was unable to register extension service: ${JSON.stringify(e)}`);
    });
  }
  /**
   * Check whether an extension is registered or is in the process of loading. This is intended to control loading or
   * adding extensions so it may return `true` before the extension is ready to be used. Use the promise returned by
   * `loadExtensionURL` if you need to wait until the extension is truly ready.
   * @param {string} extensionID - the ID of the extension.
   * @returns {boolean} - true if loaded, false otherwise.
   */


  isExtensionLoaded(extensionID) {
    return this._loadedExtensions.has(extensionID);
  }
  /**
   * Synchronously load an internal extension (core or non-core) by ID. This call will
   * fail if the provided id is not does not match an internal extension.
   * @param {string} extensionId - the ID of an internal extension
   */


  loadExtensionIdSync(extensionId) {
    if (!builtinExtensions.hasOwnProperty(extensionId)) {
      console.warn(`Could not find extension ${extensionId} in the built in extensions.`);
      return;
    }
    /** @TODO dupe handling for non-builtin extensions. See commit 670e51d33580e8a2e852b3b038bb3afc282f81b9 */


    if (this.isExtensionLoaded(extensionId)) {
      const message = `Rejecting attempt to load a second extension with ID ${extensionId}`;
      console.warn(message);
      return;
    }

    const extension = builtinExtensions[extensionId]();
    const extensionInstance = new extension(this.runtime);

    const serviceName = this._registerInternalExtension(extensionInstance);

    this._loadedExtensions.set(extensionId, serviceName);
  }
  /**
   * Load an extension by URL or internal extension ID
   * @param {string} extensionURL - the URL for the extension to load OR the ID of an internal extension
   * @returns {Promise} resolved once the extension is loaded and initialized or rejected on failure
   */


  loadExtensionURL(extensionURL) {
    if (builtinExtensions.hasOwnProperty(extensionURL)) {
      /** @TODO dupe handling for non-builtin extensions. See commit 670e51d33580e8a2e852b3b038bb3afc282f81b9 */
      if (this.isExtensionLoaded(extensionURL)) {
        const message = `Rejecting attempt to load a second extension with ID ${extensionURL}`;
        console.warn(message);
        return Promise.resolve();
      }

      const extension = builtinExtensions[extensionURL]();
      const extensionInstance = new extension(this.runtime);

      const serviceName = this._registerInternalExtension(extensionInstance);

      this._loadedExtensions.set(extensionURL, serviceName);

      return Promise.resolve();
    }

    return new Promise((resolve, reject) => {
      // requireWebpack
      const ExtensionWorker = __webpack_require__(/*! worker-loader?name=extension-worker.js!./extension-worker */ "./node_modules/worker-loader/dist/cjs.js?name=extension-worker.js!./src/extension-support/extension-worker.js");

      this.pendingExtensions.push({
        extensionURL,
        resolve,
        reject
      });
      dispatch.addWorker(new ExtensionWorker());
    });
  }
  /**
   * Regenerate blockinfo for any loaded extensions
   * @returns {Promise} resolved once all the extensions have been reinitialized
   */


  refreshBlocks() {
    const allPromises = Array.from(this._loadedExtensions.values()).map(serviceName => dispatch.call(serviceName, "getInfo").then(info => {
      info = this._prepareExtensionInfo(serviceName, info);
      dispatch.call("runtime", "_refreshExtensionPrimitives", info);
    }).catch(e => {
      console.error(`Failed to refresh built-in extension primitives: ${JSON.stringify(e)}`);
    }));
    return Promise.all(allPromises);
  }

  allocateWorker() {
    const id = this.nextExtensionWorker++;
    const workerInfo = this.pendingExtensions.shift();
    this.pendingWorkers[id] = workerInfo;
    return [id, workerInfo.extensionURL];
  }
  /**
   * Synchronously collect extension metadata from the specified service and begin the extension registration process.
   * @param {string} serviceName - the name of the service hosting the extension.
   */


  registerExtensionServiceSync(serviceName) {
    const info = dispatch.callSync(serviceName, "getInfo");

    this._registerExtensionInfo(serviceName, info);
  }
  /**
   * Collect extension metadata from the specified service and begin the extension registration process.
   * @param {string} serviceName - the name of the service hosting the extension.
   */


  registerExtensionService(serviceName) {
    dispatch.call(serviceName, "getInfo").then(info => {
      this._registerExtensionInfo(serviceName, info);
    });
  }
  /**
   * Called by an extension worker to indicate that the worker has finished initialization.
   * @param {int} id - the worker ID.
   * @param {*?} e - the error encountered during initialization, if any.
   */


  onWorkerInit(id, e) {
    const workerInfo = this.pendingWorkers[id];
    delete this.pendingWorkers[id];

    if (e) {
      workerInfo.reject(e);
    } else {
      workerInfo.resolve(id);
    }
  }
  /**
   * Register an internal (non-Worker) extension object
   * @param {object} extensionObject - the extension object to register
   * @returns {string} The name of the registered extension service
   */


  _registerInternalExtension(extensionObject) {
    const extensionInfo = extensionObject.getInfo();
    const fakeWorkerId = this.nextExtensionWorker++;
    const serviceName = `extension_${fakeWorkerId}_${extensionInfo.id}`;
    dispatch.setServiceSync(serviceName, extensionObject);
    dispatch.callSync("extensions", "registerExtensionServiceSync", serviceName);
    return serviceName;
  }
  /**
   * Sanitize extension info then register its primitives with the VM.
   * @param {string} serviceName - the name of the service hosting the extension
   * @param {ExtensionInfo} extensionInfo - the extension's metadata
   * @private
   */


  _registerExtensionInfo(serviceName, extensionInfo) {
    extensionInfo = this._prepareExtensionInfo(serviceName, extensionInfo);
    dispatch.call("runtime", "_registerExtensionPrimitives", extensionInfo).catch(e => {
      console.error(`Failed to register primitives for extension on service ${serviceName}:`, e);
    });
  }
  /**
   * Modify the provided text as necessary to ensure that it may be used as an attribute value in valid XML.
   * @param {string} text - the text to be sanitized
   * @returns {string} - the sanitized text
   * @private
   */


  _sanitizeID(text) {
    return text.toString().replace(/[<"&]/, "_");
  }
  /**
   * Apply minor cleanup and defaults for optional extension fields.
   * TODO: make the ID unique in cases where two copies of the same extension are loaded.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {ExtensionInfo} extensionInfo - the extension info to be sanitized
   * @returns {ExtensionInfo} - a new extension info object with cleaned-up values
   * @private
   */


  _prepareExtensionInfo(serviceName, extensionInfo) {
    extensionInfo = Object.assign({}, extensionInfo);

    if (!/^[a-z0-9]+$/i.test(extensionInfo.id)) {
      throw new Error("Invalid extension id");
    }

    extensionInfo.name = extensionInfo.name || extensionInfo.id;
    extensionInfo.blocks = extensionInfo.blocks || [];
    extensionInfo.targetTypes = extensionInfo.targetTypes || [];
    extensionInfo.blocks = extensionInfo.blocks.reduce((results, blockInfo) => {
      try {
        let result;

        switch (blockInfo) {
          case "---":
            // separator
            result = "---";
            break;

          default:
            // an ExtensionBlockMetadata object
            result = this._prepareBlockInfo(serviceName, blockInfo);
            break;
        }

        results.push(result);
      } catch (e) {
        // TODO: more meaningful error reporting
        console.error(`Error processing block: ${e.message}, Block:\n${JSON.stringify(blockInfo)}`);
      }

      return results;
    }, []);
    extensionInfo.menus = extensionInfo.menus || {};
    extensionInfo.menus = this._prepareMenuInfo(serviceName, extensionInfo.menus);
    return extensionInfo;
  }
  /**
   * Prepare extension menus. e.g. setup binding for dynamic menu functions.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {Array.<MenuInfo>} menus - the menu defined by the extension.
   * @returns {Array.<MenuInfo>} - a menuInfo object with all preprocessing done.
   * @private
   */


  _prepareMenuInfo(serviceName, menus) {
    const menuNames = Object.getOwnPropertyNames(menus);

    for (let i = 0; i < menuNames.length; i++) {
      const menuName = menuNames[i];
      let menuInfo = menus[menuName]; // If the menu description is in short form (items only) then normalize it to general form: an object with
      // its items listed in an `items` property.

      if (!menuInfo.items) {
        menuInfo = {
          items: menuInfo
        };
        menus[menuName] = menuInfo;
      } // If `items` is a string, it should be the name of a function in the extension object. Calling the
      // function should return an array of items to populate the menu when it is opened.


      if (typeof menuInfo.items === "string") {
        const menuItemFunctionName = menuInfo.items;
        const serviceObject = dispatch.services[serviceName]; // Bind the function here so we can pass a simple item generation function to Scratch Blocks later.

        menuInfo.items = this._getExtensionMenuItems.bind(this, serviceObject, menuItemFunctionName);
      }
    }

    return menus;
  }
  /**
   * Fetch the items for a particular extension menu, providing the target ID for context.
   * @param {object} extensionObject - the extension object providing the menu.
   * @param {string} menuItemFunctionName - the name of the menu function to call.
   * @returns {Array} menu items ready for scratch-blocks.
   * @private
   */


  _getExtensionMenuItems(extensionObject, menuItemFunctionName) {
    // Fetch the items appropriate for the target currently being edited. This assumes that menus only
    // collect items when opened by the user while editing a particular target.
    const editingTarget = this.runtime.getEditingTarget() || this.runtime.getTargetForStage();
    const editingTargetID = editingTarget ? editingTarget.id : null;
    const extensionMessageContext = this.runtime.makeMessageContextForTarget(editingTarget); // TODO: Fix this to use dispatch.call when extensions are running in workers.

    const menuFunc = extensionObject[menuItemFunctionName];
    const menuItems = menuFunc.call(extensionObject, editingTargetID).map(item => {
      item = maybeFormatMessage(item, extensionMessageContext);

      switch (typeof item) {
        case "object":
          return [maybeFormatMessage(item.text, extensionMessageContext), item.value];

        case "string":
          return [item, item];

        default:
          return item;
      }
    });

    if (!menuItems || menuItems.length < 1) {
      throw new Error(`Extension menu returned no items: ${menuItemFunctionName}`);
    }

    return menuItems;
  }
  /**
   * Apply defaults for optional block fields.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {ExtensionBlockMetadata} blockInfo - the block info from the extension
   * @returns {ExtensionBlockMetadata} - a new block info object which has values for all relevant optional fields.
   * @private
   */


  _prepareBlockInfo(serviceName, blockInfo) {
    blockInfo = Object.assign({}, {
      blockType: BlockType.COMMAND,
      terminal: false,
      blockAllThreads: false,
      arguments: {}
    }, blockInfo);
    blockInfo.opcode = blockInfo.opcode && this._sanitizeID(blockInfo.opcode);
    blockInfo.text = blockInfo.text || blockInfo.opcode;

    switch (blockInfo.blockType) {
      case BlockType.EVENT:
        if (blockInfo.func) {
          console.warn(`Ignoring function "${blockInfo.func}" for event block ${blockInfo.opcode}`);
        }

        break;

      case BlockType.BUTTON:
        if (blockInfo.opcode) {
          console.warn(`Ignoring opcode "${blockInfo.opcode}" for button with text: ${blockInfo.text}`);
        }

        break;

      default:
        {
          if (!blockInfo.opcode) {
            throw new Error("Missing opcode for block");
          }

          const funcName = blockInfo.func ? this._sanitizeID(blockInfo.func) : blockInfo.opcode;
          const getBlockInfo = blockInfo.isDynamic ? args => args && args.mutation && args.mutation.blockInfo : () => blockInfo;

          const callBlockFunc = (() => {
            if (dispatch._isRemoteService(serviceName)) {
              return (args, util, realBlockInfo) => dispatch.call(serviceName, funcName, args, util, realBlockInfo);
            } // avoid promise latency if we can call direct


            const serviceObject = dispatch.services[serviceName];

            if (!serviceObject[funcName]) {
              // The function might show up later as a dynamic property of the service object
              console.warn(`Could not find extension block function called ${funcName}`);
            }

            return (args, util, realBlockInfo) => serviceObject[funcName](args, util, realBlockInfo);
          })();

          blockInfo.func = (args, util) => {
            const realBlockInfo = getBlockInfo(args); // TODO: filter args using the keys of realBlockInfo.arguments? maybe only if sandboxed?

            return callBlockFunc(args, util, realBlockInfo);
          };

          break;
        }
    }

    return blockInfo;
  }

}

module.exports = ExtensionManager;

/***/ }),

/***/ "./src/extension-support/target-type.js":
/*!**********************************************!*\
  !*** ./src/extension-support/target-type.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Default types of Target supported by the VM
 * @enum {string}
 */
const TargetType = {
  /**
   * Rendered target which can move, change costumes, etc.
   */
  SPRITE: 'sprite',

  /**
   * Rendered target which cannot move but can change backdrops
   */
  STAGE: 'stage'
};
module.exports = TargetType;

/***/ }),

/***/ "./src/extensions/scratch3_boost/index.js":
/*!************************************************!*\
  !*** ./src/extensions/scratch3_boost/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");

const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");
/**
 * The LEGO Wireless Protocol documentation used to create this extension can be found at:
 * https://lego.github.io/lego-ble-wireless-protocol-docs/index.html
 */

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const iconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACpQTFRF////fIel5ufolZ62/2YavsPS+YZOkJmy9/j53+Hk6+zs6N/b6dfO////tDhMHAAAAA50Uk5T/////////////////wBFwNzIAAAA6ElEQVR42uzX2w6DIBAEUGDVtlr//3dLaLwgiwUd2z7MJPJg5EQWiGhGcAxBggQJEiT436CIfqXJPTn3MKNYYMSDFpoAmp24OaYgvwKnFgL2zvVTCwHrMoMi+nUQLFthaNCCa0iwclLkDgYVsQp0mzxuqXgK1MRzoCLWgkPXNN2wI/q6Kvt7u/cX0HtejN8x2sXpnpb8J8D3b0Keuhh3X975M+i0xNVbg3s1TIasgK21bQyGO+s2PykaGMYbge8KrNrssvkOWDXkErB8UuBHETjoYLkKBA8ZfuDkbwVBggQJEiR4MC8BBgDTtMZLx2nFCQAAAABJRU5ErkJggg==";
/**
 * Boost BLE UUIDs.
 * @enum {string}
 */

const BoostBLE = {
  service: "00001623-1212-efde-1623-785feabcd123",
  characteristic: "00001624-1212-efde-1623-785feabcd123",
  sendInterval: 100,
  sendRateMax: 20
};
/**
 * Boost Motor Max Power Add. Defines how much more power than the target speed
 * the motors may supply to reach the target speed faster.
 * Lower number == softer, slower reached target speed.
 * Higher number == harder, faster reached target speed.
 * @constant {number}
 */

const BoostMotorMaxPowerAdd = 10;
/**
 * A time interval to wait (in milliseconds) in between battery check calls.
 * @type {number}
 */

const BoostPingInterval = 5000;
/**
 * The number of continuous samples the color-sensor will evaluate color from.
 * @type {number}
 */

const BoostColorSampleSize = 5;
/**
 * Enum for Boost sensor and actuator types.
 * @readonly
 * @enum {number}
 */

const BoostIO = {
  MOTOR_WEDO: 0x01,
  MOTOR_SYSTEM: 0x02,
  BUTTON: 0x05,
  LIGHT: 0x08,
  VOLTAGE: 0x14,
  CURRENT: 0x15,
  PIEZO: 0x16,
  LED: 0x17,
  TILT_EXTERNAL: 0x22,
  MOTION_SENSOR: 0x23,
  COLOR: 0x25,
  MOTOREXT: 0x26,
  MOTORINT: 0x27,
  TILT: 0x28
};
/**
 * Enum for ids for various output command feedback types on the Boost.
 * @readonly
 * @enum {number}
 */

const BoostPortFeedback = {
  IN_PROGRESS: 0x01,
  COMPLETED: 0x02,
  DISCARDED: 0x04,
  IDLE: 0x08,
  BUSY_OR_FULL: 0x10
};
/**
 * Enum for physical Boost Ports
 * @readonly
 * @enum {number}
 */

const BoostPort10000223OrOlder = {
  A: 55,
  B: 56,
  C: 1,
  D: 2
};
const BoostPort10000224OrNewer = {
  A: 0,
  B: 1,
  C: 2,
  D: 3
}; // Set default port mapping to support the newer firmware

let BoostPort = BoostPort10000224OrNewer;
/**
 * Ids for each color sensor value used by the extension.
 * @readonly
 * @enum {string}
 */

const BoostColor = {
  ANY: "any",
  NONE: "none",
  RED: "red",
  BLUE: "blue",
  GREEN: "green",
  YELLOW: "yellow",
  WHITE: "white",
  BLACK: "black"
};
/**
 * Enum for indices for each color sensed by the Boost vision sensor.
 * @readonly
 * @enum {number}
 */

const BoostColorIndex = {
  [BoostColor.NONE]: 255,
  [BoostColor.RED]: 9,
  [BoostColor.BLUE]: 3,
  [BoostColor.GREEN]: 5,
  [BoostColor.YELLOW]: 7,
  [BoostColor.WHITE]: 10,
  [BoostColor.BLACK]: 0
};
/**
 * Enum for Message Types
 * @readonly
 * @enum {number}
 */

const BoostMessage = {
  HUB_PROPERTIES: 0x01,
  HUB_ACTIONS: 0x02,
  HUB_ALERTS: 0x03,
  HUB_ATTACHED_IO: 0x04,
  ERROR: 0x05,
  PORT_INPUT_FORMAT_SETUP_SINGLE: 0x41,
  PORT_INPUT_FORMAT_SETUP_COMBINED: 0x42,
  PORT_INFORMATION: 0x43,
  PORT_MODEINFORMATION: 0x44,
  PORT_VALUE: 0x45,
  PORT_VALUE_COMBINED: 0x46,
  PORT_INPUT_FORMAT: 0x47,
  PORT_INPUT_FORMAT_COMBINED: 0x48,
  OUTPUT: 0x81,
  PORT_FEEDBACK: 0x82
};
/**
 * Enum for Hub Property Types
 * @readonly
 * @enum {number}
 */

const BoostHubProperty = {
  ADVERTISEMENT_NAME: 0x01,
  BUTTON: 0x02,
  FW_VERSION: 0x03,
  HW_VERSION: 0x04,
  RSSI: 0x05,
  BATTERY_VOLTAGE: 0x06,
  BATTERY_TYPE: 0x07,
  MANUFACTURER_NAME: 0x08,
  RADIO_FW_VERSION: 0x09,
  LEGO_WP_VERSION: 0x0a,
  SYSTEM_TYPE_ID: 0x0b,
  HW_NETWORK_ID: 0x0c,
  PRIMARY_MAC: 0x0d,
  SECONDARY_MAC: 0x0e,
  HW_NETWORK_FAMILY: 0x0f
};
/**
 * Enum for Hub Property Operations
 * @readonly
 * @enum {number}
 */

const BoostHubPropertyOperation = {
  SET: 0x01,
  ENABLE_UPDATES: 0x02,
  DISABLE_UPDATES: 0x03,
  RESET: 0x04,
  REQUEST_UPDATE: 0x05,
  UPDATE: 0x06
};
/**
 * Enum for Motor Subcommands (for 0x81)
 * @readonly
 * @enum {number}
 */

const BoostOutputSubCommand = {
  START_POWER: 0x01,
  START_POWER_PAIR: 0x02,
  SET_ACC_TIME: 0x05,
  SET_DEC_TIME: 0x06,
  START_SPEED: 0x07,
  START_SPEED_PAIR: 0x08,
  START_SPEED_FOR_TIME: 0x09,
  START_SPEED_FOR_TIME_PAIR: 0x0a,
  START_SPEED_FOR_DEGREES: 0x0b,
  START_SPEED_FOR_DEGREES_PAIR: 0x0c,
  GO_TO_ABS_POSITION: 0x0d,
  GO_TO_ABS_POSITION_PAIR: 0x0e,
  PRESET_ENCODER: 0x14,
  WRITE_DIRECT_MODE_DATA: 0x51
};
/**
 * Enum for Startup/Completion information for an output command.
 * Startup and completion bytes must be OR'ed to be combined to a single byte.
 * @readonly
 * @enum {number}
 */

const BoostOutputExecution = {
  // Startup information
  BUFFER_IF_NECESSARY: 0x00,
  EXECUTE_IMMEDIATELY: 0x10,
  // Completion information
  NO_ACTION: 0x00,
  COMMAND_FEEDBACK: 0x01
};
/**
 * Enum for Boost Motor end states
 * @readonly
 * @enum {number}
 */

const BoostMotorEndState = {
  FLOAT: 0,
  HOLD: 126,
  BRAKE: 127
};
/**
 * Enum for Boost Motor acceleration/deceleration profiles
 * @readyonly
 * @enum {number}
 */

const BoostMotorProfile = {
  DO_NOT_USE: 0x00,
  ACCELERATION: 0x01,
  DECELERATION: 0x02
};
/**
 * Enum for when Boost IO's are attached/detached
 * @readonly
 * @enum {number}
 */

const BoostIOEvent = {
  ATTACHED: 0x01,
  DETACHED: 0x00,
  ATTACHED_VIRTUAL: 0x02
};
/**
 * Enum for selected sensor modes.
 * @enum {number}
 */

const BoostMode = {
  TILT: 0,
  // angle (pitch/yaw)
  LED: 1,
  // Set LED to accept RGB values
  COLOR: 0,
  // Read indexed colors from Vision Sensor
  MOTOR_SENSOR: 2,
  // Set motors to report their position
  UNKNOWN: 0 // Anything else will use the default mode (mode 0)

};
/**
 * Enum for Boost motor states.
 * @param {number}
 */

const BoostMotorState = {
  OFF: 0,
  ON_FOREVER: 1,
  ON_FOR_TIME: 2,
  ON_FOR_ROTATION: 3
};
/**
 * Helper function for converting a JavaScript number to an INT32-number
 * @param {number} number - a number
 * @return {array} - a 4-byte array of Int8-values representing an INT32-number
 */

const numberToInt32Array = function (number) {
  const buffer = new ArrayBuffer(4);
  const dataview = new DataView(buffer);
  dataview.setInt32(0, number);
  return [dataview.getInt8(3), dataview.getInt8(2), dataview.getInt8(1), dataview.getInt8(0)];
};
/**
 * Helper function for converting a regular array to a Little Endian INT32-value
 * @param {Array} array - an array containing UInt8-values
 * @return {number} - a number
 */


const int32ArrayToNumber = function (array) {
  const i = Uint8Array.from(array);
  const d = new DataView(i.buffer);
  return d.getInt32(0, true);
};
/**
 * Manage power, direction, position, and timers for one Boost motor.
 */


class BoostMotor {
  /**
   * Construct a Boost Motor instance.
   * @param {Boost} parent - the Boost peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   */
  constructor(parent, index) {
    /**
     * The Boost peripheral which owns this motor.
     * @type {Boost}
     * @private
     */
    this._parent = parent;
    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */

    this._index = index;
    /**
     * This motor's current direction: 1 for "this way" or -1 for "that way"
     * @type {number}
     * @private
     */

    this._direction = 1;
    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */

    this._power = 50;
    /**
     * This motor's current relative position
     * @type {number}
     * @private
     */

    this._position = 0;
    /**
     * Is this motor currently moving?
     * @type {boolean}
     * @private
     */

    this._status = BoostMotorState.OFF;
    /**
     * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for
     * the end-of-action handler. Cancel this when changing plans.
     * @type {Object}
     * @private
     */

    this._pendingDurationTimeoutId = null;
    /**
     * The starting time for the pending duration timeout.
     * @type {number}
     * @private
     */

    this._pendingDurationTimeoutStartTime = null;
    /**
     * The delay/duration of the pending duration timeout.
     * @type {number}
     * @private
     */

    this._pendingDurationTimeoutDelay = null;
    /**
     * The target position of a turn-based command.
     * @type {number}
     * @private
     */

    this._pendingRotationDestination = null;
    /**
     * If the motor has been turned on run for a specific rotation, this is the function
     * that will be called once Scratch VM gets a notification from the Move Hub.
     * @type {Object}
     * @private
     */

    this._pendingRotationPromise = null;
    this.turnOff = this.turnOff.bind(this);
  }
  /**
   * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
   */


  get direction() {
    return this._direction;
  }
  /**
   * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
   */


  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }
  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */


  get power() {
    return this._power;
  }
  /**
   * @param {int} value - this motor's new power level, in the range [10,100].
   */


  set power(value) {
    /**
     * Scale the motor power to a range between 10 and 100,
     * to make sure the motors will run with something built onto them.
     */
    if (value === 0) {
      this._power = 0;
    } else {
      this._power = Utility.scale(value, 1, 100, 10, 100);
    }
  }
  /**
   * @return {int} - this motor's current position, in the range of [-MIN_INT32,MAX_INT32]
   */


  get position() {
    return this._position;
  }
  /**
   * @param {int} value - set this motor's current position.
   */


  set position(value) {
    this._position = value;
  }
  /**
   * @return {BoostMotorState} - the motor's current state.
   */


  get status() {
    return this._status;
  }
  /**
   * @param {BoostMotorState} value - set this motor's state.
   */


  set status(value) {
    this._clearRotationState();

    this._clearDurationTimeout();

    this._status = value;
  }
  /**
   * @return {number} - time, in milliseconds, of when the pending duration timeout began.
   */


  get pendingDurationTimeoutStartTime() {
    return this._pendingDurationTimeoutStartTime;
  }
  /**
   * @return {number} - delay, in milliseconds, of the pending duration timeout.
   */


  get pendingDurationTimeoutDelay() {
    return this._pendingDurationTimeoutDelay;
  }
  /**
   * @return {number} - target position, in degrees, of the pending rotation.
   */


  get pendingRotationDestination() {
    return this._pendingRotationDestination;
  }
  /**
   * @return {Promise} - the Promise function for the pending rotation.
   */


  get pendingRotationPromise() {
    return this._pendingRotationPromise;
  }
  /**
   * @param {function} func - function to resolve pending rotation Promise
   */


  set pendingRotationPromise(func) {
    this._pendingRotationPromise = func;
  }
  /**
   * Turn this motor on indefinitely
   * @private
   */


  _turnOn() {
    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_SPEED, [this.power * this.direction, Utility.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorProfile.DO_NOT_USE]);

    this._parent.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Turn this motor on indefinitely
   */


  turnOnForever() {
    this.status = BoostMotorState.ON_FOREVER;

    this._turnOn();
  }
  /**
   * Turn this motor on for a specific duration.
   * @param {number} milliseconds - run the motor for this long.
   */


  turnOnFor(milliseconds) {
    milliseconds = Math.max(0, milliseconds);
    this.status = BoostMotorState.ON_FOR_TIME;

    this._turnOn();

    this._setNewDurationTimeout(this.turnOff, milliseconds);
  }
  /**
   * Turn this motor on for a specific rotation in degrees.
   * @param {number} degrees - run the motor for this amount of degrees.
   * @param {number} direction - rotate in this direction
   */


  turnOnForDegrees(degrees, direction) {
    degrees = Math.max(0, degrees);

    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.START_SPEED_FOR_DEGREES, [...numberToInt32Array(degrees), this.power * this.direction * direction, Utility.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorEndState.BRAKE, BoostMotorProfile.DO_NOT_USE]);

    this.status = BoostMotorState.ON_FOR_ROTATION;
    this._pendingRotationDestination = this.position + degrees * this.direction * direction;

    this._parent.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Turn this motor off.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   */


  turnOff(useLimiter = true) {
    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_POWER, [BoostMotorEndState.FLOAT]);

    this.status = BoostMotorState.OFF;

    this._parent.send(BoostBLE.characteristic, cmd, useLimiter);
  }
  /**
   * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.
   * @private
   */


  _clearDurationTimeout() {
    if (this._pendingDurationTimeoutId !== null) {
      clearTimeout(this._pendingDurationTimeoutId);
      this._pendingDurationTimeoutId = null;
      this._pendingDurationTimeoutStartTime = null;
      this._pendingDurationTimeoutDelay = null;
    }
  }
  /**
   * Set a new motor action timeout, after clearing an existing one if necessary.
   * @param {Function} callback - to be called at the end of the timeout.
   * @param {int} delay - wait this many milliseconds before calling the callback.
   * @private
   */


  _setNewDurationTimeout(callback, delay) {
    this._clearDurationTimeout();

    const timeoutID = setTimeout(() => {
      if (this._pendingDurationTimeoutId === timeoutID) {
        this._pendingDurationTimeoutId = null;
        this._pendingDurationTimeoutStartTime = null;
        this._pendingDurationTimeoutDelay = null;
      }

      callback();
    }, delay);
    this._pendingDurationTimeoutId = timeoutID;
    this._pendingDurationTimeoutStartTime = Date.now();
    this._pendingDurationTimeoutDelay = delay;
  }
  /**
   * Clear the motor states related to rotation-based commands, if any.
   * Safe to call even when there is no pending promise function.
   * @private
   */


  _clearRotationState() {
    if (this._pendingRotationPromise !== null) {
      this._pendingRotationPromise();

      this._pendingRotationPromise = null;
    }

    this._pendingRotationDestination = null;
  }

}
/**
 * Manage communication with a Boost peripheral over a Bluetooth Low Energy client socket.
 */


class Boost {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    this._runtime.on("PROJECT_STOP_ALL", this.stopAll.bind(this));
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * A list of the ids of the physical or virtual sensors.
     * @type {string[]}
     * @private
     */

    this._ports = [];
    /**
     * A list of motors registered by the Boost hardware.
     * @type {BoostMotor[]}
     * @private
     */

    this._motors = [];
    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */

    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      color: BoostColor.NONE,
      previousColor: BoostColor.NONE
    };
    /**
     * An array of values from the Boost Vision Sensor.
     * @type {Array}
     * @private
     */

    this._colorSamples = [];
    /**
     * The Bluetooth connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * A rate limiter utility, to help limit the rate at which we send BLE messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */


    this._rateLimiter = new RateLimiter(BoostBLE.sendRateMax);
    /**
     * An interval id for the battery check interval.
     * @type {number}
     * @private
     */

    this._pingDeviceId = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._pingDevice = this._pingDevice.bind(this);
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */


  get tiltX() {
    return this._sensors.tiltX;
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */


  get tiltY() {
    return this._sensors.tiltY;
  }
  /**
   * @return {number} - the latest color value received from the vision sensor.
   */


  get color() {
    return this._sensors.color;
  }
  /**
   * @return {number} - the previous color value received from the vision sensor.
   */


  get previousColor() {
    return this._sensors.previousColor;
  }
  /**
   * Look up the color id for an index received from the vision sensor.
   * @param {number} index - the color index to look up.
   * @return {BoostColor} the color id for this index.
   */


  boostColorForIndex(index) {
    const colorForIndex = Object.keys(BoostColorIndex).find(key => BoostColorIndex[key] === index);
    return colorForIndex || BoostColor.NONE;
  }
  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the index of the desired motor.
   * @return {BoostMotor} - the BoostMotor instance, if any, at that index.
   */


  motor(index) {
    return this._motors[index];
  }
  /**
   * Stop all the motors that are currently running.
   */


  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        // Send the motor off command without using the rate limiter.
        // This allows the stop button to stop motors even if we are
        // otherwise flooded with commands.
        motor.turnOff(false);
      }
    });
  }
  /**
   * Set the Boost peripheral's LED to a specific color.
   * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.
   * @return {Promise} - a promise of the completion of the set led send operation.
   */


  setLED(inputRGB) {
    const rgb = [inputRGB >> 16 & 0x000000ff, inputRGB >> 8 & 0x000000ff, inputRGB & 0x000000ff];
    const cmd = this.generateOutputCommand(this._ports.indexOf(BoostIO.LED), BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.WRITE_DIRECT_MODE_DATA, [BoostMode.LED, ...rgb]);
    return this.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Sets the input mode of the LED to RGB.
   * @return {Promise} - a promise returned by the send operation.
   */


  setLEDMode() {
    const cmd = this.generateInputCommand(this._ports.indexOf(BoostIO.LED), BoostMode.LED, 0, false);
    return this.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Stop the motors on the Boost peripheral.
   */


  stopAll() {
    if (!this.isConnected()) return;
    this.stopAllMotors();
  }
  /**
   * Called by the runtime when user wants to scan for a Boost peripheral.
   */


  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BoostBLE.service],
        manufacturerData: {
          0x0397: {
            dataPrefix: [0x00, 0x40],
            mask: [0x00, 0xff]
          }
        }
      }],
      optionalServices: []
    }, this._onConnect, this.reset);
  }
  /**
   * Called by the runtime when user wants to connect to a certain Boost peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }
  /**
   * Disconnects from the current BLE socket and resets state.
   */


  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    this._ports = [];
    this._motors = [];
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      color: BoostColor.NONE,
      previousColor: BoostColor.NONE
    };

    if (this._pingDeviceId) {
      window.clearInterval(this._pingDeviceId);
      this._pingDeviceId = null;
    }
  }
  /**
   * Called by the runtime to detect whether the Boost peripheral is connected.
   * @return {boolean} - the connected state.
   */


  isConnected() {
    let connected = false;

    if (this._ble) {
      connected = this._ble.isConnected();
    }

    return connected;
  }
  /**
   * Write a message to the Boost peripheral BLE socket.
   * @param {number} uuid - the UUID of the characteristic to write to
   * @param {Array} message - the message to write.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the write operation
   */


  send(uuid, message, useLimiter = true) {
    if (!this.isConnected()) return Promise.resolve();

    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }

    return this._ble.write(BoostBLE.service, uuid, Utility.uint8ArrayToBase64(message), "base64");
  }
  /**
   * Generate a Boost 'Output Command' in the byte array format
   * (COMMON HEADER, PORT ID, EXECUTION BYTE, SUBCOMMAND ID, PAYLOAD).
   *
   * Payload is accepted as an array since these vary across different subcommands.
   *
   * @param  {number} portID - the port (Connect ID) to send a command to.
   * @param  {number} execution - Byte containing startup/completion information
   * @param  {number} subCommand - the id of the subcommand byte.
   * @param  {array}  payload    - the list of bytes to send as subcommand payload
   * @return {array}            - a generated output command.
   */


  generateOutputCommand(portID, execution, subCommand, payload) {
    const hubID = 0x00;
    const command = [hubID, BoostMessage.OUTPUT, portID, execution, subCommand, ...payload];
    command.unshift(command.length + 1); // Prepend payload with length byte;

    return command;
  }
  /**
   * Generate a Boost 'Input Command' in the byte array format
   * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),
   * UNIT, NOTIFICATIONS ENABLED).
   *
   * This sends a command to the Boost that sets that input format
   * of the specified inputs and sets value change notifications.
   *
   * @param  {number}  portID           - the port (Connect ID) to send a command to.
   * @param  {number}  mode                - the mode of the input sensor.
   * @param  {number}  delta               - the delta change needed to trigger notification.
   * @param  {boolean} enableNotifications - whether to enable notifications.
   * @return {array}                       - a generated input command.
   */


  generateInputCommand(portID, mode, delta, enableNotifications) {
    const command = [0x00, // Hub ID
    BoostMessage.PORT_INPUT_FORMAT_SETUP_SINGLE, portID, mode].concat(numberToInt32Array(delta)).concat([enableNotifications]);
    command.unshift(command.length + 1); // Prepend payload with length byte;

    return command;
  }
  /**
   * Starts reading data from peripheral after BLE has connected.
   * @private
   */


  _onConnect() {
    this._ble.startNotifications(BoostBLE.service, BoostBLE.characteristic, this._onMessage);

    this._pingDeviceId = window.setInterval(this._pingDevice, BoostPingInterval); // Send a request for firmware version.

    setTimeout(() => {
      const command = [0x00, // Hub ID
      BoostMessage.HUB_PROPERTIES, BoostHubProperty.FW_VERSION, BoostHubPropertyOperation.REQUEST_UPDATE];
      command.unshift(command.length + 1);
      this.send(BoostBLE.characteristic, command, false);
    }, 500);
  }
  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */


  _onMessage(base64) {
    const data = Utility.base64ToUint8Array(base64);
    /**
     * First three bytes are the common header:
     * 0: Length of message
     * 1: Hub ID (always 0x00 at the moment, unused)
     * 2: Message Type
     * 3: Port ID
     * We base our switch-case on Message Type
     */

    const messageType = data[2];
    const portID = data[3];

    switch (messageType) {
      case BoostMessage.HUB_PROPERTIES:
        {
          const property = data[3];

          switch (property) {
            case BoostHubProperty.FW_VERSION:
              {
                // Establish firmware version 1.0.00.0224 as a 32-bit signed integer (little endian)
                const fwVersion10000224 = int32ArrayToNumber([0x24, 0x02, 0x00, 0x10]);
                const fwHub = int32ArrayToNumber(data.slice(5, data.length));

                if (fwHub < fwVersion10000224) {
                  BoostPort = BoostPort10000223OrOlder;
                  console.info("Move Hub firmware older than version 1.0.00.0224 detected. Using old port mapping.");
                } else {
                  BoostPort = BoostPort10000224OrNewer;
                }

                break;
              }
          }

          break;
        }

      case BoostMessage.HUB_ATTACHED_IO:
        {
          // IO Attach/Detach events
          const event = data[4];
          const typeId = data[5];

          switch (event) {
            case BoostIOEvent.ATTACHED:
              this._registerSensorOrMotor(portID, typeId);

              break;

            case BoostIOEvent.DETACHED:
              this._clearPort(portID);

              break;

            case BoostIOEvent.ATTACHED_VIRTUAL:
            default:
          }

          break;
        }

      case BoostMessage.PORT_VALUE:
        {
          const type = this._ports[portID];

          switch (type) {
            case BoostIO.TILT:
              this._sensors.tiltX = data[4];
              this._sensors.tiltY = data[5];
              break;

            case BoostIO.COLOR:
              this._colorSamples.unshift(data[4]);

              if (this._colorSamples.length > BoostColorSampleSize) {
                this._colorSamples.pop();

                if (this._colorSamples.every((v, i, arr) => v === arr[0])) {
                  this._sensors.previousColor = this._sensors.color;
                  this._sensors.color = this.boostColorForIndex(this._colorSamples[0]);
                } else {
                  this._sensors.color = BoostColor.NONE;
                }
              } else {
                this._sensors.color = BoostColor.NONE;
              }

              break;

            case BoostIO.MOTOREXT:
            case BoostIO.MOTORINT:
              this.motor(portID).position = int32ArrayToNumber(data.slice(4, 8));
              break;

            case BoostIO.CURRENT:
            case BoostIO.VOLTAGE:
            case BoostIO.LED:
              break;

            default:
              console.warn(`Unknown sensor value! Type: ${type}`);
          }

          break;
        }

      case BoostMessage.PORT_FEEDBACK:
        {
          const feedback = data[4];
          const motor = this.motor(portID);

          if (motor) {
            // Makes sure that commands resolve both when they actually complete and when they fail
            const isBusy = feedback & BoostPortFeedback.IN_PROGRESS;
            const commandCompleted = feedback & (BoostPortFeedback.COMPLETED ^ BoostPortFeedback.DISCARDED);

            if (!isBusy && commandCompleted) {
              if (motor.status === BoostMotorState.ON_FOR_ROTATION) {
                motor.status = BoostMotorState.OFF;
              }
            }
          }

          break;
        }

      case BoostMessage.ERROR:
        console.warn(`Error reported by hub: ${data}`);
        break;
    }
  }
  /**
   * Ping the Boost hub. If the Boost hub has disconnected
   * for some reason, the BLE socket will get an error back and automatically
   * close the socket.
   * @private
   */


  _pingDevice() {
    this._ble.read(BoostBLE.service, BoostBLE.characteristic, false);
  }
  /**
   * Register a new sensor or motor connected at a port.  Store the type of
   * sensor or motor internally, and then register for notifications on input
   * values if it is a sensor.
   * @param {number} portID - the port to register a sensor or motor on.
   * @param {number} type - the type ID of the sensor or motor
   * @private
   */


  _registerSensorOrMotor(portID, type) {
    // Record which port is connected to what type of device
    this._ports[portID] = type; // Record motor port

    if (type === BoostIO.MOTORINT || type === BoostIO.MOTOREXT) {
      this._motors[portID] = new BoostMotor(this, portID);
    } // Set input format for tilt or distance sensor


    let mode = null;
    let delta = 1;

    switch (type) {
      case BoostIO.MOTORINT:
      case BoostIO.MOTOREXT:
        mode = BoostMode.MOTOR_SENSOR;
        break;

      case BoostIO.COLOR:
        mode = BoostMode.COLOR;
        delta = 0;
        break;

      case BoostIO.LED:
        mode = BoostMode.LED;
        /**
         * Sets the LED to blue to give an indication on the hub
         * that it has connected successfully.
         */

        this.setLEDMode();
        this.setLED(0x0000ff);
        break;

      case BoostIO.TILT:
        mode = BoostMode.TILT;
        break;

      default:
        mode = BoostMode.UNKNOWN;
    }

    const cmd = this.generateInputCommand(portID, mode, delta, true // Receive feedback
    );
    this.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Clear the sensors or motors present on the ports.
   * @param {number} portID - the port to clear.
   * @private
   */


  _clearPort(portID) {
    const type = this._ports[portID];

    if (type === BoostIO.TILT) {
      this._sensors.tiltX = this._sensors.tiltY = 0;
    }

    if (type === BoostIO.COLOR) {
      this._sensors.color = BoostColor.NONE;
    }

    this._ports[portID] = "none";
    this._motors[portID] = null;
  }

}
/**
 * Enum for motor specification.
 * @readonly
 * @enum {string}
 */


const BoostMotorLabel = {
  A: "A",
  B: "B",
  C: "C",
  D: "D",
  AB: "AB",
  ALL: "ABCD"
};
/**
 * Enum for motor direction specification.
 * @readonly
 * @enum {string}
 */

const BoostMotorDirection = {
  FORWARD: "this way",
  BACKWARD: "that way",
  REVERSE: "reverse"
};
/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */

const BoostTiltDirection = {
  UP: "up",
  DOWN: "down",
  LEFT: "left",
  RIGHT: "right",
  ANY: "any"
};
/**
 * Scratch 3.0 blocks to interact with a LEGO Boost peripheral.
 */

class Scratch3BoostBlocks {
  /**
   * @return {string} - the ID of this extension.
   */
  static get EXTENSION_ID() {
    return "boost";
  }
  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */


  static get TILT_THRESHOLD() {
    return 15;
  }
  /**
   * Construct a set of Boost blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new Boost peripheral instance

    this._peripheral = new Boost(this.runtime, Scratch3BoostBlocks.EXTENSION_ID);
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: Scratch3BoostBlocks.EXTENSION_ID,
      name: "BOOST",
      blockIconURI: iconURI,
      showStatusButton: true,
      blocks: [{
        opcode: "motorOnFor",
        text: formatMessage({
          id: "boost.motorOnFor",
          default: "turn motor [MOTOR_ID] for [DURATION] seconds",
          description: "turn a motor on for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.A
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: "motorOnForRotation",
        text: formatMessage({
          id: "boost.motorOnForRotation",
          default: "turn motor [MOTOR_ID] for [ROTATION] rotations",
          description: "turn a motor on for rotation"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.A
          },
          ROTATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: "motorOn",
        text: formatMessage({
          id: "boost.motorOn",
          default: "turn motor [MOTOR_ID] on",
          description: "turn a motor on indefinitely"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: "motorOff",
        text: formatMessage({
          id: "boost.motorOff",
          default: "turn motor [MOTOR_ID] off",
          description: "turn a motor off"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: "setMotorPower",
        text: formatMessage({
          id: "boost.setMotorPower",
          default: "set motor [MOTOR_ID] speed to [POWER] %",
          description: "set the motor's speed without turning it on"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.ALL
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: "setMotorDirection",
        text: formatMessage({
          id: "boost.setMotorDirection",
          default: "set motor [MOTOR_ID] direction [MOTOR_DIRECTION]",
          description: "set the motor's turn direction without turning it on"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.A
          },
          MOTOR_DIRECTION: {
            type: ArgumentType.STRING,
            menu: "MOTOR_DIRECTION",
            defaultValue: BoostMotorDirection.FORWARD
          }
        }
      }, {
        opcode: "getMotorPosition",
        text: formatMessage({
          id: "boost.getMotorPosition",
          default: "motor [MOTOR_REPORTER_ID] position",
          description: "the position returned by the motor"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          MOTOR_REPORTER_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_REPORTER_ID",
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: "whenColor",
        text: formatMessage({
          id: "boost.whenColor",
          default: "when [COLOR] brick seen",
          description: "check for when color"
        }),
        blockType: BlockType.HAT,
        arguments: {
          COLOR: {
            type: ArgumentType.STRING,
            menu: "COLOR",
            defaultValue: BoostColor.ANY
          }
        }
      }, {
        opcode: "seeingColor",
        text: formatMessage({
          id: "boost.seeingColor",
          default: "seeing [COLOR] brick?",
          description: "is the color sensor seeing a certain color?"
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          COLOR: {
            type: ArgumentType.STRING,
            menu: "COLOR",
            defaultValue: BoostColor.ANY
          }
        }
      }, {
        opcode: "whenTilted",
        text: formatMessage({
          id: "boost.whenTilted",
          default: "when tilted [TILT_DIRECTION_ANY]",
          description: "check when tilted in a certain direction"
        }),
        func: "isTilted",
        blockType: BlockType.HAT,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: "TILT_DIRECTION_ANY",
            defaultValue: BoostTiltDirection.ANY
          }
        }
      }, {
        opcode: "getTiltAngle",
        text: formatMessage({
          id: "boost.getTiltAngle",
          default: "tilt angle [TILT_DIRECTION]",
          description: "the angle returned by the tilt sensor"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          TILT_DIRECTION: {
            type: ArgumentType.STRING,
            menu: "TILT_DIRECTION",
            defaultValue: BoostTiltDirection.UP
          }
        }
      }, {
        opcode: "setLightHue",
        text: formatMessage({
          id: "boost.setLightHue",
          default: "set light color to [HUE]",
          description: "set the LED color"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }],
      menus: {
        MOTOR_ID: {
          acceptReporters: true,
          items: [{
            text: "A",
            value: BoostMotorLabel.A
          }, {
            text: "B",
            value: BoostMotorLabel.B
          }, {
            text: "C",
            value: BoostMotorLabel.C
          }, {
            text: "D",
            value: BoostMotorLabel.D
          }, {
            text: "AB",
            value: BoostMotorLabel.AB
          }, {
            text: "ABCD",
            value: BoostMotorLabel.ALL
          }]
        },
        MOTOR_REPORTER_ID: {
          acceptReporters: true,
          items: [{
            text: "A",
            value: BoostMotorLabel.A
          }, {
            text: "B",
            value: BoostMotorLabel.B
          }, {
            text: "C",
            value: BoostMotorLabel.C
          }, {
            text: "D",
            value: BoostMotorLabel.D
          }]
        },
        MOTOR_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "boost.motorDirection.forward",
              default: "this way",
              description: "label for forward element in motor direction menu for LEGO Boost extension"
            }),
            value: BoostMotorDirection.FORWARD
          }, {
            text: formatMessage({
              id: "boost.motorDirection.backward",
              default: "that way",
              description: "label for backward element in motor direction menu for LEGO Boost extension"
            }),
            value: BoostMotorDirection.BACKWARD
          }, {
            text: formatMessage({
              id: "boost.motorDirection.reverse",
              default: "reverse",
              description: "label for reverse element in motor direction menu for LEGO Boost extension"
            }),
            value: BoostMotorDirection.REVERSE
          }]
        },
        TILT_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "boost.tiltDirection.up",
              default: "up",
              description: "label for up element in tilt direction menu for LEGO Boost extension"
            }),
            value: BoostTiltDirection.UP
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.down",
              default: "down",
              description: "label for down element in tilt direction menu for LEGO Boost extension"
            }),
            value: BoostTiltDirection.DOWN
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.left",
              default: "left",
              description: "label for left element in tilt direction menu for LEGO Boost extension"
            }),
            value: BoostTiltDirection.LEFT
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.right",
              default: "right",
              description: "label for right element in tilt direction menu for LEGO Boost extension"
            }),
            value: BoostTiltDirection.RIGHT
          }]
        },
        TILT_DIRECTION_ANY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "boost.tiltDirection.up",
              default: "up"
            }),
            value: BoostTiltDirection.UP
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.down",
              default: "down"
            }),
            value: BoostTiltDirection.DOWN
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.left",
              default: "left"
            }),
            value: BoostTiltDirection.LEFT
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.right",
              default: "right"
            }),
            value: BoostTiltDirection.RIGHT
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.any",
              default: "any",
              description: "label for any element in tilt direction menu for LEGO Boost extension"
            }),
            value: BoostTiltDirection.ANY
          }]
        },
        COLOR: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "boost.color.red",
              default: "red",
              description: "the color red"
            }),
            value: BoostColor.RED
          }, {
            text: formatMessage({
              id: "boost.color.blue",
              default: "blue",
              description: "the color blue"
            }),
            value: BoostColor.BLUE
          }, {
            text: formatMessage({
              id: "boost.color.green",
              default: "green",
              description: "the color green"
            }),
            value: BoostColor.GREEN
          }, {
            text: formatMessage({
              id: "boost.color.yellow",
              default: "yellow",
              description: "the color yellow"
            }),
            value: BoostColor.YELLOW
          }, {
            text: formatMessage({
              id: "boost.color.white",
              default: "white",
              desription: "the color white"
            }),
            value: BoostColor.WHITE
          }, {
            text: formatMessage({
              id: "boost.color.black",
              default: "black",
              description: "the color black"
            }),
            value: BoostColor.BLACK
          }, {
            text: formatMessage({
              id: "boost.color.any",
              default: "any color",
              description: "any color"
            }),
            value: BoostColor.ANY
          }]
        }
      }
    };
  }
  /**
   * Turn specified motor(s) on for a specified duration.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} DURATION - the amount of time to run the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  motorOnFor(args) {
    // TODO: cast args.MOTOR_ID?
    let durationMS = Utility.toNumber(args.DURATION) * 1000;
    durationMS = Utility.clamp(durationMS, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(args.MOTOR_ID, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) motor.turnOnFor(durationMS);
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, durationMS);
    });
  }
  /**
   * Turn specified motor(s) on for a specified rotation in full rotations.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} ROTATION - the amount of full rotations to turn the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  motorOnForRotation(args) {
    // TODO: cast args.MOTOR_ID?
    let degrees = Utility.toNumber(args.ROTATION) * 360; // TODO: Clamps to 100 rotations. Consider changing.

    const sign = Math.sign(degrees);
    degrees = Math.abs(Utility.clamp(degrees, -360000, 360000));
    const motors = [];

    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      motors.push(motorIndex);
    });
    /**
     * Checks that the motors given in args.MOTOR_ID exist,
     * and maps a promise for each of the motor-commands to an array.
     */


    const promises = motors.map(portID => {
      const motor = this._peripheral.motor(portID);

      if (motor) {
        // to avoid a hanging block if power is 0, return an immediately resolving promise.
        if (motor.power === 0) return Promise.resolve();
        return new Promise(resolve => {
          motor.turnOnForDegrees(degrees, sign);
          motor.pendingRotationPromise = resolve;
        });
      }

      return null;
    });
    /**
     * Make sure all promises are resolved, i.e. all motor-commands have completed.
     * To prevent the block from returning a value, an empty function is added to the .then
     */

    return Promise.all(promises).then(() => {});
  }
  /**
   * Turn specified motor(s) on indefinitely.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOn(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) motor.turnOnForever();
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOff(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) motor.turnOff();
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * Set the power level of the specified motor(s).
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {int} POWER - the new power level for the motor(s).
   * @return {Promise} - returns a promise to make sure the block yields.
   */


  setMotorPower(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.power = Utility.clamp(Utility.toNumber(args.POWER), 0, 100);

        switch (motor.status) {
          case BoostMotorState.ON_FOREVER:
            motor.turnOnForever();
            break;

          case BoostMotorState.ON_FOR_TIME:
            motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());
            break;
        }
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * Set the direction of rotation for specified motor(s).
   * If the direction is 'reverse' the motor(s) will be reversed individually.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).
   * @return {Promise} - returns a promise to make sure the block yields.
   */


  setMotorDirection(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        switch (args.MOTOR_DIRECTION) {
          case BoostMotorDirection.FORWARD:
            motor.direction = 1;
            break;

          case BoostMotorDirection.BACKWARD:
            motor.direction = -1;
            break;

          case BoostMotorDirection.REVERSE:
            motor.direction = -motor.direction;
            break;

          default:
            console.warn(`Unknown motor direction in setMotorDirection: ${args.DIRECTION}`);
            break;
        } // keep the motor on if it's running, and update the pending timeout if needed


        if (motor) {
          switch (motor.status) {
            case BoostMotorState.ON_FOREVER:
              motor.turnOnForever();
              break;

            case BoostMotorState.ON_FOR_TIME:
              motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());
              break;
          }
        }
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * @param {object} args - the block's arguments.
   * @return {number} - returns the motor's position.
   */


  getMotorPosition(args) {
    let portID = null;

    switch (args.MOTOR_REPORTER_ID) {
      case BoostMotorLabel.A:
        portID = BoostPort.A;
        break;

      case BoostMotorLabel.B:
        portID = BoostPort.B;
        break;

      case BoostMotorLabel.C:
        portID = BoostPort.C;
        break;

      case BoostMotorLabel.D:
        portID = BoostPort.D;
        break;

      default:
        console.warn("Asked for a motor position that doesnt exist!");
        return false;
    }

    if (portID !== null && this._peripheral.motor(portID)) {
      let val = this._peripheral.motor(portID).position; // Boost motor A position direction is reversed by design
      // so we have to reverse the position here


      if (portID === BoostPort.A) {
        val *= -1;
      }

      return Utility.wrapClamp(val, 0, 360);
    }

    return 0;
  }
  /**
   * Call a callback for each motor indexed by the provided motor ID.
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */


  _forEachMotor(motorID, callback) {
    let motors;

    switch (motorID) {
      case BoostMotorLabel.A:
        motors = [BoostPort.A];
        break;

      case BoostMotorLabel.B:
        motors = [BoostPort.B];
        break;

      case BoostMotorLabel.C:
        motors = [BoostPort.C];
        break;

      case BoostMotorLabel.D:
        motors = [BoostPort.D];
        break;

      case BoostMotorLabel.AB:
        motors = [BoostPort.A, BoostPort.B];
        break;

      case BoostMotorLabel.ALL:
        motors = [BoostPort.A, BoostPort.B, BoostPort.C, BoostPort.D];
        break;

      default:
        console.warn(`Invalid motor ID: ${motorID}`);
        motors = [];
        break;
    }

    for (const index of motors) {
      callback(index);
    }
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  whenTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  isTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   */


  getTiltAngle(args) {
    return this._getTiltAngle(args.TILT_DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */


  _isTilted(direction) {
    switch (direction) {
      case BoostTiltDirection.ANY:
        return Math.abs(this._peripheral.tiltX) >= Scratch3BoostBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY) >= Scratch3BoostBlocks.TILT_THRESHOLD;

      default:
        return this._getTiltAngle(direction) >= Scratch3BoostBlocks.TILT_THRESHOLD;
    }
  }
  /**
   * @param {TiltDirection} direction - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */


  _getTiltAngle(direction) {
    switch (direction) {
      case BoostTiltDirection.UP:
        return this._peripheral.tiltY > 90 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;

      case BoostTiltDirection.DOWN:
        return this._peripheral.tiltY > 90 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;

      case BoostTiltDirection.LEFT:
        return this._peripheral.tiltX > 90 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;

      case BoostTiltDirection.RIGHT:
        return this._peripheral.tiltX > 90 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;

      default:
        console.warn(`Unknown tilt direction in _getTiltAngle: ${direction}`);
    }
  }
  /**
   * Edge-triggering hat function, for when the vision sensor is detecting
   * a certain color.
   * @param {object} args - the block's arguments.
   * @return {boolean} - true when the color sensor senses the specified color.
   */


  whenColor(args) {
    if (args.COLOR === BoostColor.ANY) {
      // For "any" color, return true if the color is not "none", and
      // the color is different from the previous color detected. This
      // allows the hat to trigger when the color changes from one color
      // to another.
      return this._peripheral.color !== BoostColor.NONE && this._peripheral.color !== this._peripheral.previousColor;
    }

    return args.COLOR === this._peripheral.color;
  }
  /**
   * A boolean reporter function, for whether the vision sensor is detecting
   * a certain color.
   * @param {object} args - the block's arguments.
   * @return {boolean} - true when the color sensor senses the specified color.
   */


  seeingColor(args) {
    if (args.COLOR === BoostColor.ANY) {
      return this._peripheral.color !== BoostColor.NONE;
    }

    return args.COLOR === this._peripheral.color;
  }
  /**
   * Set the LED's hue.
   * @param {object} args - the block's arguments.
   * @property {number} HUE - the hue to set, in the range [0,100].
   * @return {Promise} - a Promise that resolves after some delay.
   */


  setLightHue(args) {
    // Convert from [0,100] to [0,360]
    let inputHue = Utility.toNumber(args.HUE);
    inputHue = Utility.wrapClamp(inputHue, 0, 100);
    const hue = inputHue * 360 / 100;
    const rgbObject = Utility.hsvToRgb({
      h: hue,
      s: 1,
      v: 1
    });
    const rgbDecimal = Utility.rgbToDecimal(rgbObject);
    this._peripheral._led = inputHue;

    this._peripheral.setLED(rgbDecimal);

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }

}

module.exports = Scratch3BoostBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_ev3/index.js":
/*!**********************************************!*\
  !*** ./src/extensions/scratch3_ev3/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const BT = __webpack_require__(/*! ../../io/bt */ "./src/io/bt.js");

const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUwLjIgKDU1MDQ3KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5ldjMtYmxvY2staWNvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJldjMtYmxvY2staWNvbiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImV2MyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNS41MDAwMDAsIDMuNTAwMDAwKSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS1wYXRoIiBzdHJva2U9IiM3Qzg3QTUiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgeD0iMC41IiB5PSIzLjU5IiB3aWR0aD0iMjgiIGhlaWdodD0iMjUuODEiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgc3Ryb2tlPSIjN0M4N0E1IiBmaWxsPSIjRTZFN0U4IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjIuNSIgeT0iMC41IiB3aWR0aD0iMjQiIGhlaWdodD0iMzIiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgc3Ryb2tlPSIjN0M4N0E1IiBmaWxsPSIjRkZGRkZGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjIuNSIgeT0iMTQuNSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjEzIj48L3JlY3Q+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC41LDEwLjUgTDE0LjUsMTQuNSIgaWQ9IlNoYXBlIiBzdHJva2U9IiM3Qzg3QTUiIGZpbGw9IiNFNkU3RTgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PC9wYXRoPgogICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIGZpbGw9IiM0MTQ3NTciIHg9IjQuNSIgeT0iMi41IiB3aWR0aD0iMjAiIGhlaWdodD0iMTAiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgZmlsbD0iIzdDODdBNSIgb3BhY2l0eT0iMC41IiB4PSIxMy41IiB5PSIyMC4xMyIgd2lkdGg9IjIiIGhlaWdodD0iMiIgcng9IjAuNSI+PC9yZWN0PgogICAgICAgICAgICA8cGF0aCBkPSJNOS4wNiwyMC4xMyBMMTAuNTYsMjAuMTMgQzEwLjgzNjE0MjQsMjAuMTMgMTEuMDYsMjAuMzUzODU3NiAxMS4wNiwyMC42MyBMMTEuMDYsMjEuNjMgQzExLjA2LDIxLjkwNjE0MjQgMTAuODM2MTQyNCwyMi4xMyAxMC41NiwyMi4xMyBMOS4wNiwyMi4xMyBDOC41MDc3MTUyNSwyMi4xMyA4LjA2LDIxLjY4MjI4NDcgOC4wNiwyMS4xMyBDOC4wNiwyMC41Nzc3MTUzIDguNTA3NzE1MjUsMjAuMTMgOS4wNiwyMC4xMyBaIiBpZD0iU2hhcGUiIGZpbGw9IiM3Qzg3QTUiIG9wYWNpdHk9IjAuNSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMTguOTEsMjAuMTMgTDIwLjQyLDIwLjEzIEMyMC42OTYxNDI0LDIwLjEzIDIwLjkyLDIwLjM1Mzg1NzYgMjAuOTIsMjAuNjMgTDIwLjkyLDIxLjYzIEMyMC45MiwyMS45MDYxNDI0IDIwLjY5NjE0MjQsMjIuMTMgMjAuNDIsMjIuMTMgTDE4LjkyLDIyLjEzIEMxOC4zNjc3MTUzLDIyLjEzIDE3LjkyLDIxLjY4MjI4NDcgMTcuOTIsMjEuMTMgQzE3LjkxOTk3MjYsMjAuNTgxNTk3IDE4LjM2MTYyNDUsMjAuMTM1NDg0IDE4LjkxLDIwLjEzIFoiIGlkPSJTaGFwZSIgZmlsbD0iIzdDODdBNSIgb3BhY2l0eT0iMC41IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOS40MjAwMDAsIDIxLjEzMDAwMCkgcm90YXRlKC0xODAuMDAwMDAwKSB0cmFuc2xhdGUoLTE5LjQyMDAwMCwgLTIxLjEzMDAwMCkgIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik04LjIzLDE3LjUgTDUsMTcuNSBDNC43MjM4NTc2MywxNy41IDQuNSwxNy4yNzYxNDI0IDQuNSwxNyBMNC41LDE0LjUgTDEwLjUsMTQuNSBMOC42NSwxNy4yOCBDOC41NTQ2Njk2MSwxNy40MTc5MDgyIDguMzk3NjUwMDYsMTcuNTAwMTU2NiA4LjIzLDE3LjUgWiIgaWQ9IlNoYXBlIiBmaWxsPSIjN0M4N0E1IiBvcGFjaXR5PSIwLjUiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTE4LjE1LDE4Ljg1IEwxNy42NSwxOS4zNSBDMTcuNTUyMzQxNiwxOS40NDQwNzU2IDE3LjQ5ODAzMzksMTkuNTc0NDE0MiAxNy41LDE5LjcxIEwxNy41LDIwIEMxNy41LDIwLjI3NjE0MjQgMTcuMjc2MTQyNCwyMC41IDE3LDIwLjUgTDE2LjUsMjAuNSBDMTYuMjIzODU3NiwyMC41IDE2LDIwLjI3NjE0MjQgMTYsMjAgQzE2LDE5LjcyMzg1NzYgMTUuNzc2MTQyNCwxOS41IDE1LjUsMTkuNSBMMTMuNSwxOS41IEMxMy4yMjM4NTc2LDE5LjUgMTMsMTkuNzIzODU3NiAxMywyMCBDMTMsMjAuMjc2MTQyNCAxMi43NzYxNDI0LDIwLjUgMTIuNSwyMC41IEwxMiwyMC41IEMxMS43MjM4NTc2LDIwLjUgMTEuNSwyMC4yNzYxNDI0IDExLjUsMjAgTDExLjUsMTkuNzEgQzExLjUwMTk2NjEsMTkuNTc0NDE0MiAxMS40NDc2NTg0LDE5LjQ0NDA3NTYgMTEuMzUsMTkuMzUgTDEwLjg1LDE4Ljg1IEMxMC42NTgyMTY3LDE4LjY1MjE4NjMgMTAuNjU4MjE2NywxOC4zMzc4MTM3IDEwLjg1LDE4LjE0IEwxMi4zNiwxNi42NSBDMTIuNDUwMjgwMywxNi41NTI4NjE3IDEyLjU3NzM5NjEsMTYuNDk4MzgzNSAxMi43MSwxNi41IEwxNi4yOSwxNi41IEMxNi40MjI2MDM5LDE2LjQ5ODM4MzUgMTYuNTQ5NzE5NywxNi41NTI4NjE3IDE2LjY0LDE2LjY1IEwxOC4xNSwxOC4xNCBDMTguMzQxNzgzMywxOC4zMzc4MTM3IDE4LjM0MTc4MzMsMTguNjUyMTg2MyAxOC4xNSwxOC44NSBaIiBpZD0iU2hhcGUiIGZpbGw9IiM3Qzg3QTUiIG9wYWNpdHk9IjAuNSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMTAuODUsMjMuNDUgTDExLjM1LDIyLjk1IEMxMS40NDc2NTg0LDIyLjg1NTkyNDQgMTEuNTAxOTY2MSwyMi43MjU1ODU4IDExLjUsMjIuNTkgTDExLjUsMjIuMyBDMTEuNSwyMi4wMjM4NTc2IDExLjcyMzg1NzYsMjEuOCAxMiwyMS44IEwxMi41LDIxLjggQzEyLjc3NjE0MjQsMjEuOCAxMywyMi4wMjM4NTc2IDEzLDIyLjMgQzEzLDIyLjU3NjE0MjQgMTMuMjIzODU3NiwyMi44IDEzLjUsMjIuOCBMMTUuNSwyMi44IEMxNS43NzYxNDI0LDIyLjggMTYsMjIuNTc2MTQyNCAxNiwyMi4zIEMxNiwyMi4wMjM4NTc2IDE2LjIyMzg1NzYsMjEuOCAxNi41LDIxLjggTDE3LDIxLjggQzE3LjI3NjE0MjQsMjEuOCAxNy41LDIyLjAyMzg1NzYgMTcuNSwyMi4zIEwxNy41LDIyLjU5IEMxNy40OTgwMzM5LDIyLjcyNTU4NTggMTcuNTUyMzQxNiwyMi44NTU5MjQ0IDE3LjY1LDIyLjk1IEwxOC4xNSwyMy40NSBDMTguMzQwNTcxNCwyMy42NDQ0MjE4IDE4LjM0MDU3MTQsMjMuOTU1NTc4MiAxOC4xNSwyNC4xNSBMMTYuNjQsMjUuNjUgQzE2LjU0OTcxOTcsMjUuNzQ3MTM4MyAxNi40MjI2MDM5LDI1LjgwMTYxNjUgMTYuMjksMjUuOCBMMTIuNzEsMjUuOCBDMTIuNTc3Mzk2MSwyNS44MDE2MTY1IDEyLjQ1MDI4MDMsMjUuNzQ3MTM4MyAxMi4zNiwyNS42NSBMMTAuODUsMjQuMTUgQzEwLjY1OTQyODYsMjMuOTU1NTc4MiAxMC42NTk0Mjg2LDIzLjY0NDQyMTggMTAuODUsMjMuNDUgWiIgaWQ9IlNoYXBlIiBmaWxsPSIjN0M4N0E1IiBvcGFjaXR5PSIwLjUiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTIxLjUsMjcuNSBMMjYuNSwyNy41IEwyNi41LDMxLjUgQzI2LjUsMzIuMDUyMjg0NyAyNi4wNTIyODQ3LDMyLjUgMjUuNSwzMi41IEwyMS41LDMyLjUgTDIxLjUsMjcuNSBaIiBpZD0iU2hhcGUiIHN0cm9rZT0iI0NDNEMyMyIgZmlsbD0iI0YxNUEyOSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48L3BhdGg+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=";
/**
 * String with Ev3 expected pairing pin.
 * @readonly
 */

const Ev3PairingPin = "1234";
/**
 * A maximum number of BT message sends per second, to be enforced by the rate limiter.
 * @type {number}
 */

const BTSendRateMax = 40;
/**
 * Enum for Ev3 parameter encodings of various argument and return values.
 * Found in the 'EV3 Firmware Developer Kit', section4, page 9, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 *
 * The format for these values is:
 * 0xxxxxxx for Short Format
 * 1ttt-bbb for Long Format
 *
 * @readonly
 * @enum {number}
 */

const Ev3Encoding = {
  ONE_BYTE: 0x81,
  // = 0b1000-001, "1 byte to follow"
  TWO_BYTES: 0x82,
  // = 0b1000-010, "2 bytes to follow"
  FOUR_BYTES: 0x83,
  // = 0b1000-011, "4 bytes to follow"
  GLOBAL_VARIABLE_ONE_BYTE: 0xe1,
  // = 0b1110-001, "1 byte to follow"
  GLOBAL_CONSTANT_INDEX_0: 0x20,
  // = 0b00100000
  GLOBAL_VARIABLE_INDEX_0: 0x60 // = 0b01100000

};
/**
 * Enum for Ev3 direct command types.
 * Found in the 'EV3 Communication Developer Kit', section 4, page 24, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Command = {
  DIRECT_COMMAND_REPLY: 0x00,
  DIRECT_COMMAND_NO_REPLY: 0x80,
  DIRECT_REPLY: 0x02
};
/**
 * Enum for Ev3 commands opcodes.
 * Found in the 'EV3 Firmware Developer Kit', section 4, page 10, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Opcode = {
  OPOUTPUT_STEP_SPEED: 0xae,
  OPOUTPUT_TIME_SPEED: 0xaf,
  OPOUTPUT_STOP: 0xa3,
  OPOUTPUT_RESET: 0xa2,
  OPOUTPUT_STEP_SYNC: 0xb0,
  OPOUTPUT_TIME_SYNC: 0xb1,
  OPOUTPUT_GET_COUNT: 0xb3,
  OPSOUND: 0x94,
  OPSOUND_CMD_TONE: 1,
  OPSOUND_CMD_STOP: 0,
  OPINPUT_DEVICE_LIST: 0x98,
  OPINPUT_READSI: 0x9d
};
/**
 * Enum for Ev3 values used as arguments to various opcodes.
 * Found in the 'EV3 Firmware Developer Kit', section4, page 10-onwards, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Args = {
  LAYER: 0,
  // always 0, chained EV3s not supported
  COAST: 0,
  BRAKE: 1,
  RAMP: 50,
  // time in milliseconds
  DO_NOT_CHANGE_TYPE: 0,
  MAX_DEVICES: 32 // 'Normally 32' from pg. 46

};
/**
 * Enum for Ev3 device type numbers.
 * Found in the 'EV3 Firmware Developer Kit', section 5, page 100, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {string}
 */

const Ev3Device = {
  29: "color",
  30: "ultrasonic",
  32: "gyro",
  16: "touch",
  8: "mediumMotor",
  7: "largeMotor",
  126: "none",
  125: "none"
};
/**
 * Enum for Ev3 device modes.
 * Found in the 'EV3 Firmware Developer Kit', section 5, page 100, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Mode = {
  touch: 0,
  // touch
  color: 1,
  // ambient
  ultrasonic: 1,
  // inch
  none: 0
};
/**
 * Enum for Ev3 device labels used in the Scratch blocks/UI.
 * @readonly
 * @enum {string}
 */

const Ev3Label = {
  touch: "button",
  color: "brightness",
  ultrasonic: "distance"
};
/**
 * Manage power, direction, and timers for one EV3 motor.
 */

class EV3Motor {
  /**
   * Construct a EV3 Motor instance, which could be of type 'largeMotor' or
   * 'mediumMotor'.
   *
   * @param {EV3} parent - the EV3 peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   * @param {string} type - the type of motor (i.e. 'largeMotor' or 'mediumMotor').
   */
  constructor(parent, index, type) {
    /**
     * The EV3 peripheral which owns this motor.
     * @type {EV3}
     * @private
     */
    this._parent = parent;
    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */

    this._index = index;
    /**
     * The type of EV3 motor this could be: 'largeMotor' or 'mediumMotor'.
     * @type {string}
     * @private
     */

    this._type = type;
    /**
     * This motor's current direction: 1 for "clockwise" or -1 for "counterclockwise"
     * @type {number}
     * @private
     */

    this._direction = 1;
    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */

    this._power = 50;
    /**
     * This motor's current position, in the range [0,360].
     * @type {number}
     * @private
     */

    this._position = 0;
    /**
     * An ID for the current coast command, to help override multiple coast
     * commands sent in succession.
     * @type {number}
     * @private
     */

    this._commandID = null;
    /**
     * A delay, in milliseconds, to add to coasting, to make sure that a brake
     * first takes effect if one was sent.
     * @type {number}
     * @private
     */

    this._coastDelay = 1000;
  }
  /**
   * @return {string} - this motor's type: 'largeMotor' or 'mediumMotor'
   */


  get type() {
    return this._type;
  }
  /**
   * @param {string} value - this motor's new type: 'largeMotor' or 'mediumMotor'
   */


  set type(value) {
    this._type = value;
  }
  /**
   * @return {int} - this motor's current direction: 1 for "clockwise" or -1 for "counterclockwise"
   */


  get direction() {
    return this._direction;
  }
  /**
   * @param {int} value - this motor's new direction: 1 for "clockwise" or -1 for "counterclockwise"
   */


  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }
  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */


  get power() {
    return this._power;
  }
  /**
   * @param {int} value - this motor's new power level, in the range [0,100].
   */


  set power(value) {
    this._power = value;
  }
  /**
   * @return {int} - this motor's current position, in the range [-inf,inf].
   */


  get position() {
    return this._position;
  }
  /**
   * @param {int} array - this motor's new position, in the range [0,360].
   */


  set position(array) {
    // tachoValue from Paula
    let value = array[0] + array[1] * 256 + array[2] * 256 * 256 + array[3] * 256 * 256 * 256;

    if (value > 0x7fffffff) {
      value = value - 0x100000000;
    }

    this._position = value;
  }
  /**
   * Turn this motor on for a specific duration.
   * Found in the 'EV3 Firmware Developer Kit', page 56, at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
   *
   * Opcode arguments:
   * (Data8) LAYER  Specify chain layer number [0 - 3]
   * (Data8) NOS  Output bit field [0x00  0x0F]
   * (Data8) SPEED  Power level, [-100  100]
   * (Data32) STEP1  Time in milliseconds for ramp up
   * (Data32) STEP2  Time in milliseconds for continues run
   * (Data32) STEP3  Time in milliseconds for ramp down
   * (Data8) BRAKE - Specify break level [0: Float, 1: Break]
   *
   * @param {number} milliseconds - run the motor for this long.
   */


  turnOnFor(milliseconds) {
    if (this._power === 0) return;

    const port = this._portMask(this._index);

    let n = milliseconds;
    let speed = this._power * this._direction;
    const ramp = Ev3Args.RAMP;
    let byteCommand = [];
    byteCommand[0] = Ev3Opcode.OPOUTPUT_TIME_SPEED; // If speed is less than zero, make it positive and multiply the input
    // value by -1

    if (speed < 0) {
      speed = -1 * speed;
      n = -1 * n;
    } // If the input value is less than 0


    const dir = n < 0 ? 0x100 - speed : speed; // step negative or positive

    n = Math.abs(n); // Setup motor run duration and ramping behavior

    let rampup = ramp;
    let rampdown = ramp;
    let run = n - ramp * 2;

    if (run < 0) {
      rampup = Math.floor(n / 2);
      run = 0;
      rampdown = n - rampup;
    } // Generate motor command values


    const runcmd = this._runValues(run);

    byteCommand = byteCommand.concat([Ev3Args.LAYER, port, Ev3Encoding.ONE_BYTE, dir & 0xff, Ev3Encoding.ONE_BYTE, rampup]).concat(runcmd.concat([Ev3Encoding.ONE_BYTE, rampdown, Ev3Args.BRAKE]));

    const cmd = this._parent.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, byteCommand);

    this._parent.send(cmd);

    this.coastAfter(milliseconds);
  }
  /**
   * Set the motor to coast after a specified amount of time.
   * @param {number} time - the time in milliseconds.
   */


  coastAfter(time) {
    if (this._power === 0) return; // Set the motor command id to check before starting coast

    console.warn("index:", Utility.uid());
    const commandId = Utility.uid();
    this._commandID = commandId; // Send coast message

    setTimeout(() => {
      // Do not send coast if another motor command changed the command id.
      if (this._commandID === commandId) {
        this.coast();
        this._commandID = null;
      }
    }, time + this._coastDelay); // add a delay so the brake takes effect
  }
  /**
   * Set the motor to coast.
   */


  coast() {
    if (this._power === 0) return;

    const cmd = this._parent.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPOUTPUT_STOP, Ev3Args.LAYER, this._portMask(this._index), // port output bit field
    Ev3Args.COAST]);

    this._parent.send(cmd, false); // don't use rate limiter to ensure motor stops

  }
  /**
   * Generate motor run values for a given input.
   * @param  {number} run - run input.
   * @return {array} - run values as a byte array.
   */


  _runValues(run) {
    // If run duration is less than max 16-bit integer
    if (run < 0x7fff) {
      return [Ev3Encoding.TWO_BYTES, run & 0xff, run >> 8 & 0xff];
    } // Run forever


    return [Ev3Encoding.FOUR_BYTES, run & 0xff, run >> 8 & 0xff, run >> 16 & 0xff, run >> 24 & 0xff];
  }
  /**
   * Return a port value for the EV3 that is in the format for 'output bit field'
   * as 1/2/4/8, generally needed for motor ports, instead of the typical 0/1/2/3.
   * The documentation in the 'EV3 Firmware Developer Kit' for motor port arguments
   * is sometimes mistaken, but we believe motor ports are mostly addressed this way.
   * @param {number} port - the port number to convert to an 'output bit field'.
   * @return {number} - the converted port number.
   */


  _portMask(port) {
    return Math.pow(2, port);
  }

}

class EV3 {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    this._runtime.on("PROJECT_STOP_ALL", this.stopAll.bind(this));
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * A list of the names of the sensors connected in ports 1,2,3,4.
     * @type {string[]}
     * @private
     */

    this._sensorPorts = [];
    /**
     * A list of the names of the motors connected in ports A,B,C,D.
     * @type {string[]}
     * @private
     */

    this._motorPorts = [];
    /**
     * The state of all sensor values.
     * @type {string[]}
     * @private
     */

    this._sensors = {
      distance: 0,
      brightness: 0,
      buttons: [0, 0, 0, 0]
    };
    /**
     * The motors which this EV3 could possibly have connected.
     * @type {string[]}
     * @private
     */

    this._motors = [null, null, null, null];
    /**
     * The polling interval, in milliseconds.
     * @type {number}
     * @private
     */

    this._pollingInterval = 150;
    /**
     * The polling interval ID.
     * @type {number}
     * @private
     */

    this._pollingIntervalID = null;
    /**
     * The counter keeping track of polling cycles.
     * @type {string[]}
     * @private
     */

    this._pollingCounter = 0;
    /**
     * The Bluetooth socket connection for reading/writing peripheral data.
     * @type {BT}
     * @private
     */

    this._bt = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * A rate limiter utility, to help limit the rate at which we send BT messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */


    this._rateLimiter = new RateLimiter(BTSendRateMax);
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._pollValues = this._pollValues.bind(this);
  }

  get distance() {
    let value = this._sensors.distance > 100 ? 100 : this._sensors.distance;
    value = value < 0 ? 0 : value;
    value = Math.round(100 * value) / 100;
    return value;
  }

  get brightness() {
    return this._sensors.brightness;
  }
  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the zero-based index of the desired motor.
   * @return {EV3Motor} - the EV3Motor instance, if any, at that index.
   */


  motor(index) {
    return this._motors[index];
  }

  isButtonPressed(port) {
    return this._sensors.buttons[port] === 1;
  }

  beep(freq, time) {
    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPSOUND, Ev3Opcode.OPSOUND_CMD_TONE, Ev3Encoding.ONE_BYTE, 2, Ev3Encoding.TWO_BYTES, freq, freq >> 8, Ev3Encoding.TWO_BYTES, time, time >> 8]);
    this.send(cmd);
  }

  stopAll() {
    this.stopAllMotors();
    this.stopSound();
  }

  stopSound() {
    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPSOUND, Ev3Opcode.OPSOUND_CMD_STOP]);
    this.send(cmd, false); // don't use rate limiter to ensure sound stops
  }

  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        motor.coast();
      }
    });
  }
  /**
   * Called by the runtime when user wants to scan for an EV3 peripheral.
   */


  scan() {
    if (this._bt) {
      this._bt.disconnect();
    }

    this._bt = new BT(this._runtime, this._extensionId, {
      majorDeviceClass: 8,
      minorDeviceClass: 1
    }, this._onConnect, this.reset, this._onMessage);
  }
  /**
   * Called by the runtime when user wants to connect to a certain EV3 peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._bt) {
      this._bt.connectPeripheral(id, Ev3PairingPin);
    }
  }
  /**
   * Called by the runtime when user wants to disconnect from the EV3 peripheral.
   */


  disconnect() {
    if (this._bt) {
      this._bt.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    this._sensorPorts = [];
    this._motorPorts = [];
    this._sensors = {
      distance: 0,
      brightness: 0,
      buttons: [0, 0, 0, 0]
    };
    this._motors = [null, null, null, null];

    if (this._pollingIntervalID) {
      window.clearInterval(this._pollingIntervalID);
      this._pollingIntervalID = null;
    }
  }
  /**
   * Called by the runtime to detect whether the EV3 peripheral is connected.
   * @return {boolean} - the connected state.
   */


  isConnected() {
    let connected = false;

    if (this._bt) {
      connected = this._bt.isConnected();
    }

    return connected;
  }
  /**
   * Send a message to the peripheral BT socket.
   * @param {Uint8Array} message - the message to send.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the send operation.
   */


  send(message, useLimiter = true) {
    if (!this.isConnected()) return Promise.resolve();

    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }

    return this._bt.sendMessage({
      message: Utility.uint8ArrayToBase64(message),
      encoding: "base64"
    });
  }
  /**
   * Genrates direct commands that are sent to the EV3 as a single or compounded byte arrays.
   * See 'EV3 Communication Developer Kit', section 4, page 24 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
   *
   * Direct commands are one of two types:
   * DIRECT_COMMAND_NO_REPLY = a direct command where no reply is expected
   * DIRECT_COMMAND_REPLY = a direct command where a reply is expected, and the
   * number and length of returned values needs to be specified.
   *
   * The direct command byte array sent takes the following format:
   * Byte 0 - 1: Command size, Little Endian. Command size not including these 2 bytes
   * Byte 2 - 3: Message counter, Little Endian. Forth running counter
   * Byte 4:     Command type. Either DIRECT_COMMAND_REPLY or DIRECT_COMMAND_NO_REPLY
   * Byte 5 - 6: Reservation (allocation) of global and local variables using a compressed format
   *             (globals reserved in byte 5 and the 2 lsb of byte 6, locals reserved in the upper
   *             6 bits of byte 6)  see documentation for more details.
   * Byte 7 - n: Byte codes as a single command or compound commands (I.e. more commands composed
   *             as a small program)
   *
   * @param {number} type - the direct command type.
   * @param {string} byteCommands - a compound array of EV3 Opcode + arguments.
   * @param {number} allocation - the allocation of global and local vars needed for replies.
   * @return {array} - generated complete command byte array, with header and compounded commands.
   */


  generateCommand(type, byteCommands, allocation = 0) {
    // Header (Bytes 0 - 6)
    let command = [];
    command[2] = 0; // Message counter unused for now

    command[3] = 0; // Message counter unused for now

    command[4] = type;
    command[5] = allocation & 0xff;
    command[6] = allocation >> 8 && 0xff; // Bytecodes (Bytes 7 - n)

    command = command.concat(byteCommands); // Calculate command length minus first two header bytes

    const len = command.length - 2;
    command[0] = len & 0xff;
    command[1] = len >> 8 && 0xff;
    return command;
  }
  /**
   * When the EV3 peripheral connects, start polling for sensor and motor values.
   * @private
   */


  _onConnect() {
    this._pollingIntervalID = window.setInterval(this._pollValues, this._pollingInterval);
  }
  /**
   * Poll the EV3 for sensor and motor input values, based on the list of
   * known connected sensors and motors. This is sent as many compound commands
   * in a direct command, with a reply expected.
   *
   * See 'EV3 Firmware Developer Kit', section 4.8, page 46, at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for a list of polling/input device commands and their arguments.
   *
   * @private
   */


  _pollValues() {
    if (!this.isConnected()) {
      window.clearInterval(this._pollingIntervalID);
      return;
    }

    const cmds = []; // compound command

    let allocation = 0;
    let sensorCount = 0; // Reset the list of devices every 20 counts

    if (this._pollingCounter % 20 === 0) {
      // GET DEVICE LIST
      cmds[0] = Ev3Opcode.OPINPUT_DEVICE_LIST;
      cmds[1] = Ev3Encoding.ONE_BYTE;
      cmds[2] = Ev3Args.MAX_DEVICES;
      cmds[3] = Ev3Encoding.GLOBAL_VARIABLE_INDEX_0;
      cmds[4] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
      cmds[5] = Ev3Encoding.GLOBAL_CONSTANT_INDEX_0; // Command and payload lengths

      allocation = 33;
      this._updateDevices = true;
    } else {
      // GET SENSOR VALUES FOR CONNECTED SENSORS
      let index = 0;

      for (let i = 0; i < 4; i++) {
        if (this._sensorPorts[i] !== "none") {
          cmds[index + 0] = Ev3Opcode.OPINPUT_READSI;
          cmds[index + 1] = Ev3Args.LAYER;
          cmds[index + 2] = i; // PORT

          cmds[index + 3] = Ev3Args.DO_NOT_CHANGE_TYPE;
          cmds[index + 4] = Ev3Mode[this._sensorPorts[i]];
          cmds[index + 5] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
          cmds[index + 6] = sensorCount * 4; // GLOBAL INDEX

          index += 7;
        }

        sensorCount++;
      } // GET MOTOR POSITION VALUES, EVEN IF NO MOTOR PRESENT


      for (let i = 0; i < 4; i++) {
        cmds[index + 0] = Ev3Opcode.OPOUTPUT_GET_COUNT;
        cmds[index + 1] = Ev3Args.LAYER;
        cmds[index + 2] = i; // PORT (incorrectly specified as 'Output bit field' in LEGO docs)

        cmds[index + 3] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
        cmds[index + 4] = sensorCount * 4; // GLOBAL INDEX

        index += 5;
        sensorCount++;
      } // Command and payload lengths


      allocation = sensorCount * 4;
    }

    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_REPLY, cmds, allocation);
    this.send(cmd);
    this._pollingCounter++;
  }
  /**
   * Message handler for incoming EV3 reply messages, either a list of connected
   * devices (sensors and motors) or the values of the connected sensors and motors.
   *
   * See 'EV3 Communication Developer Kit', section 4.1, page 24 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for more details on direct reply formats.
   *
   * The direct reply byte array sent takes the following format:
   * Byte 0  1: Reply size, Little Endian. Reply size not including these 2 bytes
   * Byte 2  3: Message counter, Little Endian. Equals the Direct Command
   * Byte 4:     Reply type. Either DIRECT_REPLY or DIRECT_REPLY_ERROR
   * Byte 5 - n: Resonse buffer. I.e. the content of the by the Command reserved global variables.
   *             I.e. if the command reserved 64 bytes, these bytes will be placed in the reply
   *             packet as the bytes 5 to 68.
   *
   * See 'EV3 Firmware Developer Kit', section 4.8, page 56 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for direct response buffer formats for various commands.
   *
   * @param {object} params - incoming message parameters
   * @private
   */


  _onMessage(params) {
    const message = params.message;
    const data = Utility.base64ToUint8Array(message);

    if (data[4] !== Ev3Command.DIRECT_REPLY) {
      return;
    }

    if (this._updateDevices) {
      // PARSE DEVICE LIST
      for (let i = 0; i < 4; i++) {
        const deviceType = Ev3Device[data[i + 5]]; // if returned device type is null, use 'none'

        this._sensorPorts[i] = deviceType ? deviceType : "none";
      }

      for (let i = 0; i < 4; i++) {
        const deviceType = Ev3Device[data[i + 21]]; // if returned device type is null, use 'none'

        this._motorPorts[i] = deviceType ? deviceType : "none";
      }

      for (let m = 0; m < 4; m++) {
        const type = this._motorPorts[m];

        if (type !== "none" && !this._motors[m]) {
          // add new motor if don't already have one
          this._motors[m] = new EV3Motor(this, m, type);
        }

        if (type === "none" && this._motors[m]) {
          // clear old motor
          this._motors[m] = null;
        }
      }

      this._updateDevices = false; // eslint-disable-next-line no-undefined
    } else if (!this._sensorPorts.includes(undefined) && !this._motorPorts.includes(undefined)) {
      // PARSE SENSOR VALUES
      let offset = 5; // start reading sensor values at byte 5

      for (let i = 0; i < 4; i++) {
        // array 2 float
        const buffer = new Uint8Array([data[offset], data[offset + 1], data[offset + 2], data[offset + 3]]).buffer;
        const view = new DataView(buffer);
        const value = view.getFloat32(0, true);

        if (Ev3Label[this._sensorPorts[i]] === "button") {
          // Read a button value per port
          this._sensors.buttons[i] = value ? value : 0;
        } else if (Ev3Label[this._sensorPorts[i]]) {
          // if valid
          // Read brightness / distance values and set to 0 if null
          this._sensors[Ev3Label[this._sensorPorts[i]]] = value ? value : 0;
        }

        offset += 4;
      } // PARSE MOTOR POSITION VALUES, EVEN IF NO MOTOR PRESENT


      for (let i = 0; i < 4; i++) {
        const positionArray = [data[offset], data[offset + 1], data[offset + 2], data[offset + 3]];

        if (this._motors[i]) {
          this._motors[i].position = positionArray;
        }

        offset += 4;
      }
    }
  }

}
/**
 * Enum for motor port names.
 * Note: if changed, will break compatibility with previously saved projects.
 * @readonly
 * @enum {string}
 */


const Ev3MotorMenu = ["A", "B", "C", "D"];
/**
 * Enum for sensor port names.
 * Note: if changed, will break compatibility with previously saved projects.
 * @readonly
 * @enum {string}
 */

const Ev3SensorMenu = ["1", "2", "3", "4"];

class Scratch3Ev3Blocks {
  /**
   * The ID of the extension.
   * @return {string} the id
   */
  static get EXTENSION_ID() {
    return "ev3";
  }
  /**
   * Creates a new instance of the EV3 extension.
   * @param  {object} runtime VM runtime
   * @constructor
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new EV3 peripheral instance

    this._peripheral = new EV3(this.runtime, Scratch3Ev3Blocks.EXTENSION_ID);
    this._playNoteForPicker = this._playNoteForPicker.bind(this);
    this.runtime.on("PLAY_NOTE", this._playNoteForPicker);
  }
  /**
   * Define the EV3 extension.
   * @return {object} Extension description.
   */


  getInfo() {
    return {
      id: Scratch3Ev3Blocks.EXTENSION_ID,
      name: "LEGO EV3",
      blockIconURI: blockIconURI,
      showStatusButton: true,
      blocks: [{
        opcode: "motorTurnClockwise",
        text: formatMessage({
          id: "ev3.motorTurnClockwise",
          default: "motor [PORT] turn this way for [TIME] seconds",
          description: "turn a motor clockwise for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "motorPorts",
            defaultValue: 0
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: "motorTurnCounterClockwise",
        text: formatMessage({
          id: "ev3.motorTurnCounterClockwise",
          default: "motor [PORT] turn that way for [TIME] seconds",
          description: "turn a motor counter-clockwise for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "motorPorts",
            defaultValue: 0
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: "motorSetPower",
        text: formatMessage({
          id: "ev3.motorSetPower",
          default: "motor [PORT] set power [POWER] %",
          description: "set a motor's power to some value"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "motorPorts",
            defaultValue: 0
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: "getMotorPosition",
        text: formatMessage({
          id: "ev3.getMotorPosition",
          default: "motor [PORT] position",
          description: "get the measured degrees a motor has turned"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "motorPorts",
            defaultValue: 0
          }
        }
      }, {
        opcode: "whenButtonPressed",
        text: formatMessage({
          id: "ev3.whenButtonPressed",
          default: "when button [PORT] pressed",
          description: "when a button connected to a port is pressed"
        }),
        blockType: BlockType.HAT,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "sensorPorts",
            defaultValue: 0
          }
        }
      }, {
        opcode: "whenDistanceLessThan",
        text: formatMessage({
          id: "ev3.whenDistanceLessThan",
          default: "when distance < [DISTANCE]",
          description: "when the value measured by the distance sensor is less than some value"
        }),
        blockType: BlockType.HAT,
        arguments: {
          DISTANCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 5
          }
        }
      }, {
        opcode: "whenBrightnessLessThan",
        text: formatMessage({
          id: "ev3.whenBrightnessLessThan",
          default: "when brightness < [DISTANCE]",
          description: "when value measured by brightness sensor is less than some value"
        }),
        blockType: BlockType.HAT,
        arguments: {
          DISTANCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: "buttonPressed",
        text: formatMessage({
          id: "ev3.buttonPressed",
          default: "button [PORT] pressed?",
          description: "is a button on some port pressed?"
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "sensorPorts",
            defaultValue: 0
          }
        }
      }, {
        opcode: "getDistance",
        text: formatMessage({
          id: "ev3.getDistance",
          default: "distance",
          description: "gets measured distance"
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: "getBrightness",
        text: formatMessage({
          id: "ev3.getBrightness",
          default: "brightness",
          description: "gets measured brightness"
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: "beep",
        text: formatMessage({
          id: "ev3.beepNote",
          default: "beep note [NOTE] for [TIME] secs",
          description: "play some note on EV3 for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          NOTE: {
            type: ArgumentType.NOTE,
            defaultValue: 60
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.5
          }
        }
      }],
      menus: {
        motorPorts: {
          acceptReporters: true,
          items: this._formatMenu(Ev3MotorMenu)
        },
        sensorPorts: {
          acceptReporters: true,
          items: this._formatMenu(Ev3SensorMenu)
        }
      }
    };
  }

  motorTurnClockwise(args) {
    const port = Utility.toNumber(args.PORT);
    let time = Utility.toNumber(args.TIME) * 1000;
    time = Utility.clamp(time, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(port, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) {
          motor.direction = 1;
          motor.turnOnFor(time);
        }
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, time);
    });
  }

  motorTurnCounterClockwise(args) {
    const port = Utility.toNumber(args.PORT);
    let time = Utility.toNumber(args.TIME) * 1000;
    time = Utility.clamp(time, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(port, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) {
          motor.direction = -1;
          motor.turnOnFor(time);
        }
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, time);
    });
  }

  motorSetPower(args) {
    const port = Utility.toNumber(args.PORT);
    const power = Utility.clamp(Utility.toNumber(args.POWER), 0, 100);

    this._forEachMotor(port, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.power = power;
      }
    });
  }

  getMotorPosition(args) {
    const port = Utility.toNumber(args.PORT);

    if (![0, 1, 2, 3].includes(port)) {
      return;
    }

    const motor = this._peripheral.motor(port);

    let position = 0;

    if (motor) {
      position = Utility.wrapClamp(motor.position, 0, 360);
    }

    return position;
  }

  whenButtonPressed(args) {
    const port = Utility.toNumber(args.PORT);

    if (![0, 1, 2, 3].includes(port)) {
      return;
    }

    return this._peripheral.isButtonPressed(port);
  }

  whenDistanceLessThan(args) {
    const distance = Utility.clamp(Utility.toNumber(args.DISTANCE), 0, 100);
    return this._peripheral.distance < distance;
  }

  whenBrightnessLessThan(args) {
    const brightness = Utility.clamp(Utility.toNumber(args.DISTANCE), 0, 100);
    return this._peripheral.brightness < brightness;
  }

  buttonPressed(args) {
    const port = Utility.toNumber(args.PORT);

    if (![0, 1, 2, 3].includes(port)) {
      return;
    }

    return this._peripheral.isButtonPressed(port);
  }

  getDistance() {
    return this._peripheral.distance;
  }

  getBrightness() {
    return this._peripheral.brightness;
  }

  _playNoteForPicker(note, category) {
    if (category !== this.getInfo().name) return;
    this.beep({
      NOTE: note,
      TIME: 0.25
    });
  }

  beep(args) {
    const note = Utility.clamp(Utility.toNumber(args.NOTE), 47, 99); // valid EV3 sounds

    let time = Utility.toNumber(args.TIME) * 1000;
    time = Utility.clamp(time, 0, 3000);

    if (time === 0) {
      return; // don't send a beep time of 0
    }

    return new Promise(resolve => {
      // https://en.wikipedia.org/wiki/MIDI_tuning_standard#Frequency_values
      const freq = Math.pow(2, (note - 69 + 12) / 12) * 440;

      this._peripheral.beep(freq, time); // Run for some time even when no piezo is connected.


      setTimeout(resolve, time);
    });
  }
  /**
   * Call a callback for each motor indexed by the provided motor ID.
   *
   * Note: This way of looping through motors is currently unnecessary, but could be
   * useful if an 'all motors' option is added in the future (see WeDo2 extension).
   *
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */


  _forEachMotor(motorID, callback) {
    let motors;

    switch (motorID) {
      case 0:
        motors = [0];
        break;

      case 1:
        motors = [1];
        break;

      case 2:
        motors = [2];
        break;

      case 3:
        motors = [3];
        break;

      default:
        console.warn(`Invalid motor ID: ${motorID}`);
        motors = [];
        break;
    }

    for (const index of motors) {
      callback(index);
    }
  }
  /**
   * Formats menus into a format suitable for block menus, and loading previously
   * saved projects:
   * [
   *   {
   *    text: label,
   *    value: index
   *   },
   *   {
   *    text: label,
   *    value: index
   *   },
   *   etc...
   * ]
   *
   * @param {array} menu - a menu to format.
   * @return {object} - a formatted menu as an object.
   * @private
   */


  _formatMenu(menu) {
    const m = [];

    for (let i = 0; i < menu.length; i++) {
      const obj = {};
      obj.text = menu[i];
      obj.value = i.toString();
      m.push(obj);
    }

    return m;
  }

}

module.exports = Scratch3Ev3Blocks;

/***/ }),

/***/ "./src/extensions/scratch3_makeymakey/index.js":
/*!*****************************************************!*\
  !*** ./src/extensions/scratch3_makeymakey/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MCA0MCI+PHN0eWxlPi5zdDJ7ZmlsbDpyZWR9LnN0M3tmaWxsOiNlMGUwZTB9LnN0NHtmaWxsOm5vbmU7c3Ryb2tlOiM2NjY7c3Ryb2tlLXdpZHRoOi41O3N0cm9rZS1taXRlcmxpbWl0OjEwfTwvc3R5bGU+PHBhdGggZD0iTTM1IDI4SDVhMSAxIDAgMCAxLTEtMVYxMmMwLS42LjQtMSAxLTFoMzBjLjUgMCAxIC40IDEgMXYxNWMwIC41LS41IDEtMSAxeiIgZmlsbD0iI2ZmZiIgaWQ9IkxheWVyXzYiLz48ZyBpZD0iTGF5ZXJfNCI+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQgMjVoMzJ2Mi43SDR6TTEzIDI0aC0yLjJhMSAxIDAgMCAxLTEtMXYtOS43YzAtLjYuNC0xIDEtMUgxM2MuNiAwIDEgLjQgMSAxVjIzYzAgLjYtLjUgMS0xIDF6Ii8+PHBhdGggY2xhc3M9InN0MiIgZD0iTTYuMSAxOS4zdi0yLjJjMC0uNS40LTEgMS0xaDkuN2MuNSAwIDEgLjUgMSAxdjIuMmMwIC41LS41IDEtMSAxSDcuMWExIDEgMCAwIDEtMS0xeiIvPjxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjIyLjgiIGN5PSIxOC4yIiByPSIzLjQiLz48Y2lyY2xlIGNsYXNzPSJzdDIiIGN4PSIzMC42IiBjeT0iMTguMiIgcj0iMy40Ii8+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQuMiAyN2gzMS45di43SDQuMnoiLz48L2c+PGcgaWQ9IkxheWVyXzUiPjxjaXJjbGUgY2xhc3M9InN0MyIgY3g9IjIyLjgiIGN5PSIxOC4yIiByPSIyLjMiLz48Y2lyY2xlIGNsYXNzPSJzdDMiIGN4PSIzMC42IiBjeT0iMTguMiIgcj0iMi4zIi8+PHBhdGggY2xhc3M9InN0MyIgZD0iTTEyLjUgMjIuOWgtMS4yYy0uMyAwLS41LS4yLS41LS41VjE0YzAtLjMuMi0uNS41LS41aDEuMmMuMyAwIC41LjIuNS41djguNGMwIC4zLS4yLjUtLjUuNXoiLz48cGF0aCBjbGFzcz0ic3QzIiBkPSJNNy4yIDE4Ljd2LTEuMmMwLS4zLjItLjUuNS0uNWg4LjRjLjMgMCAuNS4yLjUuNXYxLjJjMCAuMy0uMi41LS41LjVINy43Yy0uMyAwLS41LS4yLS41LS41ek00IDI2aDMydjJINHoiLz48L2c+PGcgaWQ9IkxheWVyXzMiPjxwYXRoIGNsYXNzPSJzdDQiIGQ9Ik0zNS4yIDI3LjlINC44YTEgMSAwIDAgMS0xLTFWMTIuMWMwLS42LjUtMSAxLTFoMzAuNWMuNSAwIDEgLjQgMSAxVjI3YTEgMSAwIDAgMS0xLjEuOXoiLz48cGF0aCBjbGFzcz0ic3Q0IiBkPSJNMzUuMiAyNy45SDQuOGExIDEgMCAwIDEtMS0xVjEyLjFjMC0uNi41LTEgMS0xaDMwLjVjLjUgMCAxIC40IDEgMVYyN2ExIDEgMCAwIDEtMS4xLjl6Ii8+PC9nPjwvc3ZnPg==";
/**
 * Length of the buffer to store key presses for the "when keys pressed in order" hat
 * @type {number}
 */

const KEY_BUFFER_LENGTH = 100;
/**
 * Timeout in milliseconds to reset the completed flag for a sequence.
 * @type {number}
 */

const SEQUENCE_HAT_TIMEOUT = 100;
/**
 * An id for the space key on a keyboard.
 */

const KEY_ID_SPACE = "SPACE";
/**
 * An id for the left arrow key on a keyboard.
 */

const KEY_ID_LEFT = "LEFT";
/**
 * An id for the right arrow key on a keyboard.
 */

const KEY_ID_RIGHT = "RIGHT";
/**
 * An id for the up arrow key on a keyboard.
 */

const KEY_ID_UP = "UP";
/**
 * An id for the down arrow key on a keyboard.
 */

const KEY_ID_DOWN = "DOWN";
/**
 * Names used by keyboard io for keys used in scratch.
 * @enum {string}
 */

const SCRATCH_KEY_NAME = {
  [KEY_ID_SPACE]: "space",
  [KEY_ID_LEFT]: "left arrow",
  [KEY_ID_UP]: "up arrow",
  [KEY_ID_RIGHT]: "right arrow",
  [KEY_ID_DOWN]: "down arrow"
};
/**
 * Class for the makey makey blocks in Scratch 3.0
 * @constructor
 */

class Scratch3MakeyMakeyBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * A toggle that alternates true and false each frame, so that an
     * edge-triggered hat can trigger on every other frame.
     * @type {boolean}
     */

    this.frameToggle = false; // Set an interval that toggles the frameToggle every frame.

    setInterval(() => {
      this.frameToggle = !this.frameToggle;
    }, this.runtime.currentStepTime);
    this.keyPressed = this.keyPressed.bind(this);
    this.runtime.on("KEY_PRESSED", this.keyPressed);
    this._clearkeyPressBuffer = this._clearkeyPressBuffer.bind(this);
    this.runtime.on("PROJECT_STOP_ALL", this._clearkeyPressBuffer);
    /*
     * An object containing a set of sequence objects.
     * These are the key sequences currently being detected by the "when
     * keys pressed in order" hat block. Each sequence is keyed by its
     * string representation (the sequence's value in the menu, which is a
     * string of KEY_IDs separated by spaces). Each sequence object
     * has an array property (an array of KEY_IDs) and a boolean
     * completed property that is true when the sequence has just been
     * pressed.
     * @type {object}
     */

    this.sequences = {};
    /*
     * An array of the key codes of recently pressed keys.
     * @type {array}
     */

    this.keyPressBuffer = [];
  }
  /*
   * Localized short-form names of the space bar and arrow keys, for use in the
   * displayed menu items of the "when keys pressed in order" block.
   * @type {object}
   */


  get KEY_TEXT_SHORT() {
    return {
      [KEY_ID_SPACE]: formatMessage({
        id: "makeymakey.spaceKey",
        default: "space",
        description: "The space key on a computer keyboard."
      }),
      [KEY_ID_LEFT]: formatMessage({
        id: "makeymakey.leftArrowShort",
        default: "left",
        description: "Short name for the left arrow key on a computer keyboard."
      }),
      [KEY_ID_UP]: formatMessage({
        id: "makeymakey.upArrowShort",
        default: "up",
        description: "Short name for the up arrow key on a computer keyboard."
      }),
      [KEY_ID_RIGHT]: formatMessage({
        id: "makeymakey.rightArrowShort",
        default: "right",
        description: "Short name for the right arrow key on a computer keyboard."
      }),
      [KEY_ID_DOWN]: formatMessage({
        id: "makeymakey.downArrowShort",
        default: "down",
        description: "Short name for the down arrow key on a computer keyboard."
      })
    };
  }
  /*
   * An array of strings of KEY_IDs representing the default set of
   * key sequences for use by the "when keys pressed in order" block.
   * @type {array}
   */


  get DEFAULT_SEQUENCES() {
    return [`${KEY_ID_LEFT} ${KEY_ID_UP} ${KEY_ID_RIGHT}`, `${KEY_ID_RIGHT} ${KEY_ID_UP} ${KEY_ID_LEFT}`, `${KEY_ID_LEFT} ${KEY_ID_RIGHT}`, `${KEY_ID_RIGHT} ${KEY_ID_LEFT}`, `${KEY_ID_UP} ${KEY_ID_DOWN}`, `${KEY_ID_DOWN} ${KEY_ID_UP}`, `${KEY_ID_UP} ${KEY_ID_RIGHT} ${KEY_ID_DOWN} ${KEY_ID_LEFT}`, `${KEY_ID_UP} ${KEY_ID_LEFT} ${KEY_ID_DOWN} ${KEY_ID_RIGHT}`, `${KEY_ID_UP} ${KEY_ID_UP} ${KEY_ID_DOWN} ${KEY_ID_DOWN} ` + `${KEY_ID_LEFT} ${KEY_ID_RIGHT} ${KEY_ID_LEFT} ${KEY_ID_RIGHT}`];
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: "makeymakey",
      name: "Makey Makey",
      blockIconURI: blockIconURI,
      blocks: [{
        opcode: "whenMakeyKeyPressed",
        text: formatMessage({
          id: "makeymakey.whenKeyPressed",
          default: "when [KEY] key pressed",
          description: "when a keyboard key is pressed"
        }),
        blockType: BlockType.HAT,
        arguments: {
          KEY: {
            type: ArgumentType.STRING,
            menu: "KEY",
            defaultValue: KEY_ID_SPACE
          }
        }
      }, {
        opcode: "whenCodePressed",
        text: formatMessage({
          id: "makeymakey.whenKeysPressedInOrder",
          default: "when [SEQUENCE] pressed in order",
          description: "when a sequence of keyboard keys is pressed in a specific order"
        }),
        blockType: BlockType.HAT,
        arguments: {
          SEQUENCE: {
            type: ArgumentType.STRING,
            menu: "SEQUENCE",
            defaultValue: this.DEFAULT_SEQUENCES[0]
          }
        }
      }],
      menus: {
        KEY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "makeymakey.spaceKey",
              default: "space",
              description: "The space key on a computer keyboard."
            }),
            value: KEY_ID_SPACE
          }, {
            text: formatMessage({
              id: "makeymakey.upArrow",
              default: "up arrow",
              description: "The up arrow key on a computer keyboard."
            }),
            value: KEY_ID_UP
          }, {
            text: formatMessage({
              id: "makeymakey.downArrow",
              default: "down arrow",
              description: "The down arrow key on a computer keyboard."
            }),
            value: KEY_ID_DOWN
          }, {
            text: formatMessage({
              id: "makeymakey.rightArrow",
              default: "right arrow",
              description: "The right arrow key on a computer keyboard."
            }),
            value: KEY_ID_RIGHT
          }, {
            text: formatMessage({
              id: "makeymakey.leftArrow",
              default: "left arrow",
              description: "The left arrow key on a computer keyboard."
            }),
            value: KEY_ID_LEFT
          }, {
            text: "w",
            value: "w"
          }, {
            text: "a",
            value: "a"
          }, {
            text: "s",
            value: "s"
          }, {
            text: "d",
            value: "d"
          }, {
            text: "f",
            value: "f"
          }, {
            text: "g",
            value: "g"
          }]
        },
        SEQUENCE: {
          acceptReporters: true,
          items: this.buildSequenceMenu(this.DEFAULT_SEQUENCES)
        }
      }
    };
  }
  /*
   * Build the menu of key sequences.
   * @param {array} sequencesArray an array of strings of KEY_IDs.
   * @returns {array} an array of objects with text and value properties.
   */


  buildSequenceMenu(sequencesArray) {
    return sequencesArray.map(str => this.getMenuItemForSequenceString(str));
  }
  /*
   * Create a menu item for a sequence string.
   * @param {string} sequenceString a string of KEY_IDs.
   * @return {object} an object with text and value properties.
   */


  getMenuItemForSequenceString(sequenceString) {
    let sequenceArray = sequenceString.split(" ");
    sequenceArray = sequenceArray.map(str => this.KEY_TEXT_SHORT[str]);
    return {
      text: sequenceArray.join(" "),
      value: sequenceString
    };
  }
  /*
   * Check whether a keyboard key is currently pressed.
   * Also, toggle the results of the test on alternate frames, so that the
   * hat block fires repeatedly.
   * @param {object} args - the block arguments.
   * @property {number} KEY - a key code.
   * @param {object} util - utility object provided by the runtime.
   */


  whenMakeyKeyPressed(args, util) {
    let key = args.KEY; // Convert the key arg, if it is a KEY_ID, to the key name used by
    // the Keyboard io module.

    if (SCRATCH_KEY_NAME[args.KEY]) {
      key = SCRATCH_KEY_NAME[args.KEY];
    }

    const isDown = util.ioQuery("keyboard", "getKeyIsDown", [key]);
    return isDown && this.frameToggle;
  }
  /*
   * A function called on the KEY_PRESSED event, to update the key press
   * buffer and check if any of the key sequences have been completed.
   * @param {string} key A scratch key name.
   */


  keyPressed(key) {
    // Store only the first word of the Scratch key name, so that e.g. when
    // "left arrow" is pressed, we store "LEFT", which matches KEY_ID_LEFT
    key = key.split(" ")[0];
    key = key.toUpperCase();
    this.keyPressBuffer.push(key); // Keep the buffer under the length limit

    if (this.keyPressBuffer.length > KEY_BUFFER_LENGTH) {
      this.keyPressBuffer.shift();
    } // Check the buffer for each sequence in use


    for (const str in this.sequences) {
      const arr = this.sequences[str].array; // Bail out if we don't have enough presses for this sequence

      if (this.keyPressBuffer.length < arr.length) {
        continue;
      }

      let missFlag = false; // Slice the buffer to the length of the sequence we're checking

      const bufferSegment = this.keyPressBuffer.slice(-1 * arr.length);

      for (let i = 0; i < arr.length; i++) {
        if (arr[i] !== bufferSegment[i]) {
          missFlag = true;
        }
      } // If the miss flag is false, the sequence matched the buffer


      if (!missFlag) {
        this.sequences[str].completed = true; // Clear the completed flag after a timeout. This is necessary because
        // the hat is edge-triggered (not event triggered). Multiple hats
        // may be checking the same sequence, so this timeout gives them enough
        // time to all trigger before resetting the flag.

        setTimeout(() => {
          this.sequences[str].completed = false;
        }, SEQUENCE_HAT_TIMEOUT);
      }
    }
  }
  /**
   * Clear the key press buffer.
   */


  _clearkeyPressBuffer() {
    this.keyPressBuffer = [];
  }
  /*
   * Add a key sequence to the set currently being checked on each key press.
   * @param {string} sequenceString a string of space-separated KEY_IDs.
   * @param {array} sequenceArray an array of KEY_IDs.
   */


  addSequence(sequenceString, sequenceArray) {
    // If we already have this sequence string, return.
    if (this.sequences.hasOwnProperty(sequenceString)) {
      return;
    }

    this.sequences[sequenceString] = {
      array: sequenceArray,
      completed: false
    };
  }
  /*
   * Check whether a key sequence was recently completed.
   * @param {object} args The block arguments.
   * @property {number} SEQUENCE A string of KEY_IDs.
   */


  whenCodePressed(args) {
    const sequenceString = String(args.SEQUENCE).toUpperCase();
    const sequenceArray = sequenceString.split(" ");

    if (sequenceArray.length < 2) {
      return;
    }

    this.addSequence(sequenceString, sequenceArray);
    return this.sequences[sequenceString].completed;
  }

}

module.exports = Scratch3MakeyMakeyBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_microbit/index.js":
/*!***************************************************!*\
  !*** ./src/extensions/scratch3_microbit/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");
/**
 * Icon png to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAKcElEQVR42u2cfXAU9RnHv7u3L3d7l9yR5PIGXO7MkQKaYiCUWqJhFGvRMk4JZXSc8aXVaSmiYlthVHQEW99FxiIdrVY6teiMdoa+ICqhIqgQAsjwMgYDOQKXl7uY17u9293b3f5x5JKYe8+FJGSfvzbP/n77e/azz+95nt9v90KoqgpN0hdSQ6AB1ABqADWAmmgANYAaQA2gJhpADeBEE2q8GPLaWzu/CslyiY4k9dOn5uijtXGd7+jWkaReVpT3Hrhv6d0awEFC07rgD+ZeYYnXprhwigUAvjj0zbjxQCLebozT7iDzK1ZUWCru2K7L//6MVC8ue45Blz8n6rlQ815QtuohOlXiEdy/AUqPa6y59Mkh6Q1345GNja6m7pHEQKNl3t0704EXat4L6fSOmOeEI1vHKzwAyNJR9MPFpRUPOu0ONm2A0xatWaTLm5WfDrzvAppA8AbiG03fC8CQNkDKZK2YrPAuRrhpifJERsuYywveJc7CqcIDMAyeLm82dEXzw39I/qjXkpr3QuW9lxfAdOABGAKPslWDnbsy7Jl8BxTeM3SqmO0gaA5U6c3jymup0YSn9JyLee67wpTfBQAQjmyF3HFqiJcRtDECjy5dAmbmcgQPvjjxl3Lx4IVjnD/5cE1zkWtyP34VBGcdKLJnLgc9cznk1kMXFdzEn8KJ4KUqqsSHvcxWDf7j1UM8UPr6/YgHhhX8xAaYaXgAIB7fBnbuSrBzV8aNgarEQ/z6/YkLcDTg9V9XlXjQtuqoU1TpcUHlvZDOfDiuyh5qPMCLrJ1bDw3EuUtx81N/BH3pjQBJQ2HMF5V6iKfeRchVm9kkMtrwxmSdobeA9daBde8GwVlBcFYofS1Jw0vaAy9HeJHQwBUPzIBvGxDc92Rmp/BowJs10wkAONfsBs8HAAAltqngOAO8HZ3o6OiMqcvLy4E1Lwc8H8C5ZndMXdLJa/qNacNLCDBw/O8nFUNWxp/64+tWAwBefe1tHKg7CgC4/9d3ori4EHv3HcDrb26PqVt2602ovvaHaGlpw+8ffSamLqXYmya8jG8mpFy6iGLkWLh4HAwG4+r6j4VBfaPpLgU8IMGO9MLqW2pYQ9aQokuR5dgXIwCC1CUcNMj3hpdvLAdSF54EYpCHooRA0Swomo2pC0kCQpIAkqTA6LmYupgxL0X7m78+aG10NXVkpIwxsAwWXncDCESHLkohfPbpbiT6ZFPPZQ9fC0e58Wi6wTDj6UbT/rQAyiERS2pW4Kc3LQDLRO8miCEAKj7d83FcTxyLJJJJ+9MCqKoq9HomMrgkSThxsgEcZ8AMpwMkSYJlKDA0DVUFiHGWRDJp/4jXwqIo4uFHnkZXdw8AYGbZFXhs3WqQJDkhkkim7E8KoMlkxKbnn8DBunrwUli3e8/+yOAA0HjmHDq7upGXm5PUoDUr7hmWRB5Zt3FYwoime+vtd/H6G9uGJIxouniSyP6H7v8FystnY80jGzIA0MihsMAKu20aTp3JzFb6WCWRuDUvHwByw8cOhw2FBVaYjNzIAba1e3Hfb9aiq7MTNStuBwAsvr4KO3d9GnmKztIS5EyxTJiVSDT7p04tipx/9MnnYc7ORlu7NzMxsK3di5AkDHgGw2DTC+uHBeGJshJJZL/fxyMQEDKbRAiCQDAoQhBDYBkKNE2j4uqrhpUBoiSBIMZfEhkN+1NeiWSqEB2rlUg69md0JRIQRHy86z8jXsqNVRLJlP0jqgNJXXgAgjbCcONmCHUvQ+44NWG2s/rtH5Mt/ciToo0wLH4JBGO6LLazRiJk2vBYy4gHHw/bWSN+LZBKEhkMjzn/CaSiKgQOvJDyFB7L7axUJWNJZDA8IhQA1boPin7KZbMSGfUYyFx9b3hXg/cCsoBA2Z0AoYOaxlcC4+mdyCUDKBzanLFBJ3USyaRMuiSSKZmUSSSTMimTCABUlblRU9kAZ0E39p+eii21c+EL0jHbOwu6sfaWgyjND//U4oP6MmzZnfi79XT7mfQSNi7bh0JzOLG19XBY/89r49pYVebGqhuOosDsh1+gsWV3BXYdd2Q+BlaVuXFv9bHgkSbzk+vfcVRyjHhi47J9cftsXLYf7T36Ix8cLHlo6ydlv6qpPI2qssRZcuOy/Wjp4k5s+2zG+offKqtcUt6kJtNv7S0H0RtkvEufXTB/6bML5je2Wy7UVDbEbF9o9mPDsv2oP5v75vbPS26rP5u3fdXiozDppcwDrKlswOlWy9E//DX09Mt/azh8zzNM1RybF86C7pheVGD240CDeX3NWtfml94Rt+0+Mf3Lm8qbEnpfgdmPs+3G9+564vTT//pM/GrHYduWRP0AYOEMN/5S61xT92Vtfd2XtfWb/vu91fHALyxzw9tnkB/cTD5w+2Ou9375HHtfa7exM5mxRpKFaafdQQKgAcDERs98/foLHrXdaXfoABi8vczhWO2/28/TRR5z2h00gKymNl1ton79oigq6bQ7dE67Q+ew9mb1h4FYYwVESgLAXLSRa+3mWpIdK+UYuPiq89f8+XfT/+ftZQ4vLm9ZmUyfdcsv1M2fWfRaUCK8i8vdK1u6ktuAWPWTsztm24o/cnnYHUsrWzd1+fVJ9XtqxbG3XzFdNcPTawjcueibpxK1t+X26f/9R8a953jub4typOvm2b1XnvUmv8JKWMZcaZffX3XDERRP8cGaFRjWxtPLoZvXY4oxgPBNEsgxBhCUKEzL6Ru+JydS8Ak0giKFgESDJFQoKmCgQzAwIfQEWETzmoBIwd2VNaStu8uEHGO4Buz06zHHFv0dRkefAZ1+PQx0KNK2eIoPLCUj2zDc275qzgcBFWv+cf3IyxgTK2KOzQufEM5kfpGF12eGPSf8DXN+No/87HDWiwYYALw+M6ym8AscAxO++X7xCTRM7EDQzht0Da8v/NWo1dQDAxNCocUXs+303IGHdaptOmYXnh/SLlZbV+fwnwJm6UXEm/ojqgM/PFmJQ81OPHfrtqT7bN23BE8seTflYLvz5DwYGQHLKz5Puo/XZ8aLtT+D1dSDuxbsGQIymmz48DbwIguOESJOcce8XaO3oVpZ8k3Em5KVVAAMFnuOB9as1MbimCBunn04vBmR40ls29Wfgxf1KMn1gBdY+MXUCvK4ANvPndpLzrLzALjBN2VPwrDBksgLYkn1jBMp90nVY2++8vAw3RlPeLNYVZSPAEgjKWP6ZCn4lF+gMdnE08spQb73RQB9aXtgo6tJcNodf8rWz3L//Br340UW3sExEkXrFFKSSUVHqkRfkJZ8QSZk5gS6hw9H+GyDQAclSs41BVmSUIn+toAKIUTJskKoQUknCxKlkISKb/sM0NMyyVAhXW+AlYosfgOgQlUJVadTSUWBKoQoudvPioPbenq5oIUTaRUqenhWKi3oyVIUqKpKREoLggDhF6hQb4CV9LRM9rctMPN6glChp2SdTqeSskwoAECSKnG61fzFR/XsGu+FhmONriYl7TImsjoYKJyZSeB8CoBQo6spqU8TCO1fgE7gDVUNoCYaQA2gBlADqAHURAOoAdQAagA10QCOgfwfNp/hXbfBMCAAAAAASUVORK5CYII=";
/**
 * Enum for micro:bit BLE command protocol.
 * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md
 * @readonly
 * @enum {number}
 */

const BLECommand = {
  CMD_PIN_CONFIG: 0x80,
  CMD_DISPLAY_TEXT: 0x81,
  CMD_DISPLAY_LED: 0x82
};
/**
 * A time interval to wait (in milliseconds) before reporting to the BLE socket
 * that data has stopped coming from the peripheral.
 */

const BLETimeout = 4500;
/**
 * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
 * @type {number}
 */

const BLESendInterval = 100;
/**
 * A string to report to the BLE socket when the micro:bit has stopped receiving data.
 * @type {string}
 */

const BLEDataStoppedError = "micro:bit extension stopped receiving data";
/**
 * Enum for micro:bit protocol.
 * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md
 * @readonly
 * @enum {string}
 */

const BLEUUID = {
  service: 0xf005,
  rxChar: "5261da01-fa7e-42ab-850b-7c80220097cc",
  txChar: "5261da02-fa7e-42ab-850b-7c80220097cc"
};
/**
 * Manage communication with a MicroBit peripheral over a Scrath Link client socket.
 */

class MicroBit {
  /**
   * Construct a MicroBit communication object.
   * @param {Runtime} runtime - the Scratch 3.0 runtime
   * @param {string} extensionId - the id of the extension
   */
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;
    /**
     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */

    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      buttonA: 0,
      buttonB: 0,
      touchPins: [0, 0, 0],
      gestureState: 0,
      ledMatrixState: new Uint8Array(5)
    };
    /**
     * The most recently received value for each gesture.
     * @type {Object.<string, Object>}
     * @private
     */

    this._gestures = {
      moving: false,
      move: {
        active: false,
        timeout: false
      },
      shake: {
        active: false,
        timeout: false
      },
      jump: {
        active: false,
        timeout: false
      }
    };
    /**
     * Interval ID for data reading timeout.
     * @type {number}
     * @private
     */

    this._timeoutID = null;
    /**
     * A flag that is true while we are busy sending data to the BLE socket.
     * @type {boolean}
     * @private
     */

    this._busy = false;
    /**
     * ID for a timeout which is used to clear the busy flag if it has been
     * true for a long time.
     */

    this._busyTimeoutID = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
  }
  /**
   * @param {string} text - the text to display.
   * @return {Promise} - a Promise that resolves when writing to peripheral.
   */


  displayText(text) {
    const output = new Uint8Array(text.length);

    for (let i = 0; i < text.length; i++) {
      output[i] = text.charCodeAt(i);
    }

    return this.send(BLECommand.CMD_DISPLAY_TEXT, output);
  }
  /**
   * @param {Uint8Array} matrix - the matrix to display.
   * @return {Promise} - a Promise that resolves when writing to peripheral.
   */


  displayMatrix(matrix) {
    return this.send(BLECommand.CMD_DISPLAY_LED, matrix);
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */


  get tiltX() {
    return this._sensors.tiltX;
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */


  get tiltY() {
    return this._sensors.tiltY;
  }
  /**
   * @return {boolean} - the latest value received for the A button.
   */


  get buttonA() {
    return this._sensors.buttonA;
  }
  /**
   * @return {boolean} - the latest value received for the B button.
   */


  get buttonB() {
    return this._sensors.buttonB;
  }
  /**
   * @return {number} - the latest value received for the motion gesture states.
   */


  get gestureState() {
    return this._sensors.gestureState;
  }
  /**
   * @return {Uint8Array} - the current state of the 5x5 LED matrix.
   */


  get ledMatrixState() {
    return this._sensors.ledMatrixState;
  }
  /**
   * Called by the runtime when user wants to scan for a peripheral.
   */


  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BLEUUID.service]
      }]
    }, this._onConnect, this.reset);
  }
  /**
   * Called by the runtime when user wants to connect to a certain peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }
  /**
   * Disconnect from the micro:bit.
   */


  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    if (this._timeoutID) {
      window.clearTimeout(this._timeoutID);
      this._timeoutID = null;
    }
  }
  /**
   * Return true if connected to the micro:bit.
   * @return {boolean} - whether the micro:bit is connected.
   */


  isConnected() {
    let connected = false;

    if (this._ble) {
      connected = this._ble.isConnected();
    }

    return connected;
  }
  /**
   * Send a message to the peripheral BLE socket.
   * @param {number} command - the BLE command hex.
   * @param {Uint8Array} message - the message to write
   */


  send(command, message) {
    if (!this.isConnected()) return;
    if (this._busy) return; // Set a busy flag so that while we are sending a message and waiting for
    // the response, additional messages are ignored.

    this._busy = true; // Set a timeout after which to reset the busy flag. This is used in case
    // a BLE message was sent for which we never received a response, because
    // e.g. the peripheral was turned off after the message was sent. We reset
    // the busy flag after a while so that it is possible to try again later.

    this._busyTimeoutID = window.setTimeout(() => {
      this._busy = false;
    }, 5000);
    const output = new Uint8Array(message.length + 1);
    output[0] = command; // attach command to beginning of message

    for (let i = 0; i < message.length; i++) {
      output[i + 1] = message[i];
    }

    const data = Utility.uint8ArrayToBase64(output);

    this._ble.write(BLEUUID.service, BLEUUID.txChar, data, "base64", true).then(() => {
      this._busy = false;
      window.clearTimeout(this._busyTimeoutID);
    });
  }
  /**
   * Starts reading data from peripheral after BLE has connected to it.
   * @private
   */


  _onConnect() {
    this._ble.read(BLEUUID.service, BLEUUID.rxChar, true, this._onMessage);

    this._timeoutID = window.setTimeout(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
  }
  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */


  _onMessage(base64) {
    // parse data
    const data = Utility.base64ToUint8Array(base64);
    this._sensors.tiltX = data[1] | data[0] << 8;
    if (this._sensors.tiltX > 1 << 15) this._sensors.tiltX -= 1 << 16;
    this._sensors.tiltY = data[3] | data[2] << 8;
    if (this._sensors.tiltY > 1 << 15) this._sensors.tiltY -= 1 << 16;
    this._sensors.buttonA = data[4];
    this._sensors.buttonB = data[5];
    this._sensors.touchPins[0] = data[6];
    this._sensors.touchPins[1] = data[7];
    this._sensors.touchPins[2] = data[8];
    this._sensors.gestureState = data[9]; // cancel disconnect timeout and start a new one

    window.clearTimeout(this._timeoutID);
    this._timeoutID = window.setTimeout(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
  }
  /**
   * @param {number} pin - the pin to check touch state.
   * @return {number} - the latest value received for the touch pin states.
   * @private
   */


  _checkPinState(pin) {
    return this._sensors.touchPins[pin];
  }

}
/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */


const MicroBitTiltDirection = {
  FRONT: "front",
  BACK: "back",
  LEFT: "left",
  RIGHT: "right",
  ANY: "any"
};
/**
 * Enum for micro:bit gestures.
 * @readonly
 * @enum {string}
 */

const MicroBitGestures = {
  MOVED: "moved",
  SHAKEN: "shaken",
  JUMPED: "jumped"
};
/**
 * Enum for micro:bit buttons.
 * @readonly
 * @enum {string}
 */

const MicroBitButtons = {
  A: "A",
  B: "B",
  ANY: "any"
};
/**
 * Enum for micro:bit pin states.
 * @readonly
 * @enum {string}
 */

const MicroBitPinState = {
  ON: "on",
  OFF: "off"
};
/**
 * Scratch 3.0 blocks to interact with a MicroBit peripheral.
 */

class Scratch3MicroBitBlocks {
  /**
   * @return {string} - the name of this extension.
   */
  static get EXTENSION_NAME() {
    return "micro:bit";
  }
  /**
   * @return {string} - the ID of this extension.
   */


  static get EXTENSION_ID() {
    return "microbit";
  }
  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */


  static get TILT_THRESHOLD() {
    return 15;
  }
  /**
   * @return {array} - text and values for each buttons menu element
   */


  get BUTTONS_MENU() {
    return [{
      text: "A",
      value: MicroBitButtons.A
    }, {
      text: "B",
      value: MicroBitButtons.B
    }, {
      text: formatMessage({
        id: "microbit.buttonsMenu.any",
        default: "any",
        description: 'label for "any" element in button picker for micro:bit extension'
      }),
      value: MicroBitButtons.ANY
    }];
  }
  /**
   * @return {array} - text and values for each gestures menu element
   */


  get GESTURES_MENU() {
    return [{
      text: formatMessage({
        id: "microbit.gesturesMenu.moved",
        default: "moved",
        description: "label for moved gesture in gesture picker for micro:bit extension"
      }),
      value: MicroBitGestures.MOVED
    }, {
      text: formatMessage({
        id: "microbit.gesturesMenu.shaken",
        default: "shaken",
        description: "label for shaken gesture in gesture picker for micro:bit extension"
      }),
      value: MicroBitGestures.SHAKEN
    }, {
      text: formatMessage({
        id: "microbit.gesturesMenu.jumped",
        default: "jumped",
        description: "label for jumped gesture in gesture picker for micro:bit extension"
      }),
      value: MicroBitGestures.JUMPED
    }];
  }
  /**
   * @return {array} - text and values for each pin state menu element
   */


  get PIN_STATE_MENU() {
    return [{
      text: formatMessage({
        id: "microbit.pinStateMenu.on",
        default: "on",
        description: "label for on element in pin state picker for micro:bit extension"
      }),
      value: MicroBitPinState.ON
    }, {
      text: formatMessage({
        id: "microbit.pinStateMenu.off",
        default: "off",
        description: "label for off element in pin state picker for micro:bit extension"
      }),
      value: MicroBitPinState.OFF
    }];
  }
  /**
   * @return {array} - text and values for each tilt direction menu element
   */


  get TILT_DIRECTION_MENU() {
    return [{
      text: formatMessage({
        id: "microbit.tiltDirectionMenu.front",
        default: "front",
        description: "label for front element in tilt direction picker for micro:bit extension"
      }),
      value: MicroBitTiltDirection.FRONT
    }, {
      text: formatMessage({
        id: "microbit.tiltDirectionMenu.back",
        default: "back",
        description: "label for back element in tilt direction picker for micro:bit extension"
      }),
      value: MicroBitTiltDirection.BACK
    }, {
      text: formatMessage({
        id: "microbit.tiltDirectionMenu.left",
        default: "left",
        description: "label for left element in tilt direction picker for micro:bit extension"
      }),
      value: MicroBitTiltDirection.LEFT
    }, {
      text: formatMessage({
        id: "microbit.tiltDirectionMenu.right",
        default: "right",
        description: "label for right element in tilt direction picker for micro:bit extension"
      }),
      value: MicroBitTiltDirection.RIGHT
    }];
  }
  /**
   * @return {array} - text and values for each tilt direction (plus "any") menu element
   */


  get TILT_DIRECTION_ANY_MENU() {
    return [...this.TILT_DIRECTION_MENU, {
      text: formatMessage({
        id: "microbit.tiltDirectionMenu.any",
        default: "any",
        description: "label for any direction element in tilt direction picker for micro:bit extension"
      }),
      value: MicroBitTiltDirection.ANY
    }];
  }
  /**
   * Construct a set of MicroBit blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new MicroBit peripheral instance

    this._peripheral = new MicroBit(this.runtime, Scratch3MicroBitBlocks.EXTENSION_ID);
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: Scratch3MicroBitBlocks.EXTENSION_ID,
      name: Scratch3MicroBitBlocks.EXTENSION_NAME,
      blockIconURI: blockIconURI,
      showStatusButton: true,
      blocks: [{
        opcode: "whenButtonPressed",
        text: formatMessage({
          id: "microbit.whenButtonPressed",
          default: "when [BTN] button pressed",
          description: "when the selected button on the micro:bit is pressed"
        }),
        blockType: BlockType.HAT,
        arguments: {
          BTN: {
            type: ArgumentType.STRING,
            menu: "buttons",
            defaultValue: MicroBitButtons.A
          }
        }
      }, {
        opcode: "isButtonPressed",
        text: formatMessage({
          id: "microbit.isButtonPressed",
          default: "[BTN] button pressed?",
          description: "is the selected button on the micro:bit pressed?"
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          BTN: {
            type: ArgumentType.STRING,
            menu: "buttons",
            defaultValue: MicroBitButtons.A
          }
        }
      }, "---", {
        opcode: "whenGesture",
        text: formatMessage({
          id: "microbit.whenGesture",
          default: "when [GESTURE]",
          description: "when the selected gesture is detected by the micro:bit"
        }),
        blockType: BlockType.HAT,
        arguments: {
          GESTURE: {
            type: ArgumentType.STRING,
            menu: "gestures",
            defaultValue: MicroBitGestures.MOVED
          }
        }
      }, "---", {
        opcode: "displaySymbol",
        text: formatMessage({
          id: "microbit.displaySymbol",
          default: "display [MATRIX]",
          description: "display a pattern on the micro:bit display"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MATRIX: {
            type: ArgumentType.MATRIX,
            defaultValue: "0101010101100010101000100"
          }
        }
      }, {
        opcode: "displayText",
        text: formatMessage({
          id: "microbit.displayText",
          default: "display text [TEXT]",
          description: "display text on the micro:bit display"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          TEXT: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: "microbit.defaultTextToDisplay",
              default: "Hello!",
              description: `default text to display.
                                IMPORTANT - the micro:bit only supports letters a-z, A-Z.
                                Please substitute a default word in your language
                                that can be written with those characters,
                                substitute non-accented characters or leave it as "Hello!".
                                Check the micro:bit site documentation for details`
            })
          }
        }
      }, {
        opcode: "displayClear",
        text: formatMessage({
          id: "microbit.clearDisplay",
          default: "clear display",
          description: "display nothing on the micro:bit display"
        }),
        blockType: BlockType.COMMAND
      }, "---", {
        opcode: "whenTilted",
        text: formatMessage({
          id: "microbit.whenTilted",
          default: "when tilted [DIRECTION]",
          description: "when the micro:bit is tilted in a direction"
        }),
        blockType: BlockType.HAT,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: "tiltDirectionAny",
            defaultValue: MicroBitTiltDirection.ANY
          }
        }
      }, {
        opcode: "isTilted",
        text: formatMessage({
          id: "microbit.isTilted",
          default: "tilted [DIRECTION]?",
          description: "is the micro:bit is tilted in a direction?"
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: "tiltDirectionAny",
            defaultValue: MicroBitTiltDirection.ANY
          }
        }
      }, {
        opcode: "getTiltAngle",
        text: formatMessage({
          id: "microbit.tiltAngle",
          default: "tilt angle [DIRECTION]",
          description: "how much the micro:bit is tilted in a direction"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: "tiltDirection",
            defaultValue: MicroBitTiltDirection.FRONT
          }
        }
      }, "---", {
        opcode: "whenPinConnected",
        text: formatMessage({
          id: "microbit.whenPinConnected",
          default: "when pin [PIN] connected",
          description: "when the pin detects a connection to Earth/Ground"
        }),
        blockType: BlockType.HAT,
        arguments: {
          PIN: {
            type: ArgumentType.STRING,
            menu: "touchPins",
            defaultValue: "0"
          }
        }
      }],
      menus: {
        buttons: {
          acceptReporters: true,
          items: this.BUTTONS_MENU
        },
        gestures: {
          acceptReporters: true,
          items: this.GESTURES_MENU
        },
        pinState: {
          acceptReporters: true,
          items: this.PIN_STATE_MENU
        },
        tiltDirection: {
          acceptReporters: true,
          items: this.TILT_DIRECTION_MENU
        },
        tiltDirectionAny: {
          acceptReporters: true,
          items: this.TILT_DIRECTION_ANY_MENU
        },
        touchPins: {
          acceptReporters: true,
          items: ["0", "1", "2"]
        }
      }
    };
  }
  /**
   * Test whether the A or B button is pressed
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the button is pressed.
   */


  whenButtonPressed(args) {
    if (args.BTN === "any") {
      return this._peripheral.buttonA | this._peripheral.buttonB;
    } else if (args.BTN === "A") {
      return this._peripheral.buttonA;
    } else if (args.BTN === "B") {
      return this._peripheral.buttonB;
    }

    return false;
  }
  /**
   * Test whether the A or B button is pressed
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the button is pressed.
   */


  isButtonPressed(args) {
    if (args.BTN === "any") {
      return (this._peripheral.buttonA | this._peripheral.buttonB) !== 0;
    } else if (args.BTN === "A") {
      return this._peripheral.buttonA !== 0;
    } else if (args.BTN === "B") {
      return this._peripheral.buttonB !== 0;
    }

    return false;
  }
  /**
   * Test whether the micro:bit is moving
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the micro:bit is moving.
   */


  whenGesture(args) {
    const gesture = String(args.GESTURE);

    if (gesture === "moved") {
      return this._peripheral.gestureState >> 2 & 1;
    } else if (gesture === "shaken") {
      return this._peripheral.gestureState & 1;
    } else if (gesture === "jumped") {
      return this._peripheral.gestureState >> 1 & 1;
    }

    return false;
  }
  /**
   * Display a predefined symbol on the 5x5 LED matrix.
   * @param {object} args - the block's arguments.
   * @return {Promise} - a Promise that resolves after a tick.
   */


  displaySymbol(args) {
    const symbol = String(args.MATRIX).replace(/\s/g, "");

    const reducer = (accumulator, c, index) => {
      const value = c === "0" ? accumulator : accumulator + Math.pow(2, index);
      return value;
    };

    const hex = symbol.split("").reduce(reducer, 0);

    if (hex !== null) {
      this._peripheral.ledMatrixState[0] = hex & 0x1f;
      this._peripheral.ledMatrixState[1] = hex >> 5 & 0x1f;
      this._peripheral.ledMatrixState[2] = hex >> 10 & 0x1f;
      this._peripheral.ledMatrixState[3] = hex >> 15 & 0x1f;
      this._peripheral.ledMatrixState[4] = hex >> 20 & 0x1f;

      this._peripheral.displayMatrix(this._peripheral.ledMatrixState);
    }

    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Display text on the 5x5 LED matrix.
   * @param {object} args - the block's arguments.
   * @return {Promise} - a Promise that resolves after the text is done printing.
   * Note the limit is 19 characters
   * The print time is calculated by multiplying the number of horizontal pixels
   * by the default scroll delay of 120ms.
   * The number of horizontal pixels = 6px for each character in the string,
   * 1px before the string, and 5px after the string.
   */


  displayText(args) {
    const text = String(args.TEXT).substring(0, 19);
    if (text.length > 0) this._peripheral.displayText(text);
    const yieldDelay = 120 * (6 * text.length + 6);
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, yieldDelay);
    });
  }
  /**
   * Turn all 5x5 matrix LEDs off.
   * @return {Promise} - a Promise that resolves after a tick.
   */


  displayClear() {
    for (let i = 0; i < 5; i++) {
      this._peripheral.ledMatrixState[i] = 0;
    }

    this._peripheral.displayMatrix(this._peripheral.ledMatrixState);

    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  whenTilted(args) {
    return this._isTilted(args.DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  isTilted(args) {
    return this._isTilted(args.DIRECTION);
  }
  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the direction (front, back, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
   */


  getTiltAngle(args) {
    return this._getTiltAngle(args.DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */


  _isTilted(direction) {
    switch (direction) {
      case MicroBitTiltDirection.ANY:
        return Math.abs(this._peripheral.tiltX / 10) >= Scratch3MicroBitBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY / 10) >= Scratch3MicroBitBlocks.TILT_THRESHOLD;

      default:
        return this._getTiltAngle(direction) >= Scratch3MicroBitBlocks.TILT_THRESHOLD;
    }
  }
  /**
   * @param {TiltDirection} direction - the direction (front, back, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */


  _getTiltAngle(direction) {
    switch (direction) {
      case MicroBitTiltDirection.FRONT:
        return Math.round(this._peripheral.tiltY / -10);

      case MicroBitTiltDirection.BACK:
        return Math.round(this._peripheral.tiltY / 10);

      case MicroBitTiltDirection.LEFT:
        return Math.round(this._peripheral.tiltX / -10);

      case MicroBitTiltDirection.RIGHT:
        return Math.round(this._peripheral.tiltX / 10);

      default:
        console.warn(`Unknown tilt direction in _getTiltAngle: ${direction}`);
    }
  }
  /**
   * @param {object} args - the block's arguments.
   * @return {boolean} - the touch pin state.
   * @private
   */


  whenPinConnected(args) {
    const pin = parseInt(args.PIN, 10);
    if (isNaN(pin)) return;
    if (pin < 0 || pin > 2) return false;
    return this._peripheral._checkPinState(pin);
  }

}

module.exports = Scratch3MicroBitBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_text2speech/index.js":
/*!******************************************************!*\
  !*** ./src/extensions/scratch3_text2speech/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const nets = __webpack_require__(/*! nets */ "./node_modules/nets/index.js");

const languageNames = __webpack_require__(/*! scratch-translate-extension-languages */ "./node_modules/scratch-translate-extension-languages/languages.json");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const menuIconURI = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1RleHQtdG8tU3BlZWNoLU1lbnU8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZyBpZD0iRXh0ZW5zaW9ucy9Tb2Z0d2FyZS9UZXh0LXRvLVNwZWVjaC1NZW51IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0idGV4dDJzcGVlY2giIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIuMDAwMDAwLCAyLjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyI+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik01Ljc1LDguODM0NjcxNzMgQzUuNzUsOC4zMjY5NjM0NCA1LjAwMzAwNzI3LDguMDQyMjEzNzEgNC41NTYyODAxMiw4LjQ0NDE0OTk5IEwzLjIwNjI4MDEyLDkuNTI1MzU3MDIgQzIuNjk2NzMzNzgsOS45MzM0NDk2OCAyLjAzNzQ4Njc1LDEwLjE2NTg3ODggMS4zNSwxMC4xNjU4Nzg4IEwxLjE1LDEwLjE2NTg3ODggQzAuNjMyNTk2MTY1LDEwLjE2NTg3ODggMC4yNSwxMC41MTA2MDAyIDAuMjUsMTAuOTUyMDM1NSBMMC4yNSwxMy4wNjkzOTkzIEMwLjI1LDEzLjUxMDgzNDYgMC42MzI1OTYxNjUsMTMuODU1NTU2IDEuMTUsMTMuODU1NTU2IEwxLjM1LDEzLjg1NTU1NiBDMi4wNzg3Nzg0MSwxMy44NTU1NTYgMi43MjY4NjE2MSwxNC4wNjY3NjM2IDMuMjU5ODYwNDksMTQuNDk5IEw0LjU1OTIwMTQ3LDE1LjU3OTY2MDggQzUuMDEzMDkyNzYsMTUuOTU0NTM5NiA1Ljc1LDE1LjY3MzYzNDQgNS43NSwxNS4xNDE3MTI4IEw1Ljc1LDguODM0NjcxNzMgWiIgaWQ9InNwZWFrZXIiIHN0cm9rZS1vcGFjaXR5PSIwLjE1IiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBmaWxsPSIjNEQ0RDREIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMC43MDQ4MzEzLDggQzkuNzkwNjc0NjgsOS4xMzExNDg0NyA4LjMwNjYxODQsOS43MTQyODU3MSA3LjgzMzMzMzMzLDkuNzE0Mjg1NzEgQzcuODMzMzMzMzMsOS43MTQyODU3MSA3LjUsOS43MTQyODU3MSA3LjUsOS4zODA5NTIzOCBDNy41LDkuMDg1MjI2ODQgOC4wNjIyMDE2OCw4LjkwMTk0MTY0IDguMTg5MDYwNjcsNy41Njc1NDA1OCBDNi44ODk5Njk5MSw2LjkwNjc5MDA1IDYsNS41NTczMjY4MyA2LDQgQzYsMS43OTA4NjEgNy43OTA4NjEsNC4wNTgxMjI1MWUtMTYgMTAsMCBMMTIsMCBDMTQuMjA5MTM5LC00LjA1ODEyMjUxZS0xNiAxNiwxLjc5MDg2MSAxNiw0IEMxNiw2LjIwOTEzOSAxNC4yMDkxMzksOCAxMiw4IEwxMC43MDQ4MzEzLDggWiIgaWQ9InNwZWVjaCIgZmlsbD0iIzBFQkQ4QyI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+";
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const blockIconURI = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1RleHQtdG8tU3BlZWNoLUJsb2NrPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IkV4dGVuc2lvbnMvU29mdHdhcmUvVGV4dC10by1TcGVlY2gtQmxvY2siIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1vcGFjaXR5PSIwLjE1Ij4KICAgICAgICA8ZyBpZD0idGV4dDJzcGVlY2giIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQuMDAwMDAwLCA0LjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyIgc3Ryb2tlPSIjMDAwMDAwIj4KICAgICAgICAgICAgPHBhdGggZD0iTTExLjUsMTcuNjY5MzQzNSBDMTEuNSwxNi42NTM5MjY5IDEwLjAwNjAxNDUsMTYuMDg0NDI3NCA5LjExMjU2MDI0LDE2Ljg4ODMgTDYuNDEyNTYwMjQsMTkuMDUwNzE0IEM1LjM5MzQ2NzU1LDE5Ljg2Njg5OTQgNC4wNzQ5NzM1MSwyMC4zMzE3NTc1IDIuNywyMC4zMzE3NTc1IEwyLjMsMjAuMzMxNzU3NSBDMS4yNjUxOTIzMywyMC4zMzE3NTc1IDAuNSwyMS4wMjEyMDAzIDAuNSwyMS45MDQwNzEgTDAuNSwyNi4xMzg3OTg2IEMwLjUsMjcuMDIxNjY5MyAxLjI2NTE5MjMzLDI3LjcxMTExMiAyLjMsMjcuNzExMTEyIEwyLjcsMjcuNzExMTEyIEM0LjE1NzU1NjgyLDI3LjcxMTExMiA1LjQ1MzcyMzIyLDI4LjEzMzUyNzEgNi41MTk3MjA5OCwyOC45OTggTDkuMTE4NDAyOTMsMzEuMTU5MzIxNiBDMTAuMDI2MTg1NSwzMS45MDkwNzkzIDExLjUsMzEuMzQ3MjY4OSAxMS41LDMwLjI4MzQyNTUgTDExLjUsMTcuNjY5MzQzNSBaIiBpZD0ic3BlYWtlciIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMjEuNjQzNjA2NiwxNi41IEMxOS45NzcwMDk5LDE4LjQzNzAyMzQgMTcuMTA1MDI3NSwxOS45Mjg1NzE0IDE1LjY2NjY2NjcsMTkuOTI4NTcxNCBDMTUuNTEyNjM5NywxOS45Mjg1NzE0IDE1LjMxNjYyOTIsMTkuODk1OTAzIDE1LjEwOTcyNjUsMTkuNzkyNDUxNyBDMTQuNzM3NjAzOSwxOS42MDYzOTA0IDE0LjUsMTkuMjQ5OTg0NiAxNC41LDE4Ljc2MTkwNDggQzE0LjUsMTguNjU2ODA0MSAxNC41MTcwNTU1LDE4LjU1NDUwNzYgMTQuNTQ5NDQ2NywxOC40NTQwODQ0IEMxNC42MjU3NTQ1LDE4LjIxNzUwNjMgMTUuMTczNTcyMSwxNy40Njc1MzEgMTUuMjc3MjA3MSwxNy4yODA5ODgxIEMxNS41NDYzNTI2LDE2Ljc5NjUyNjEgMTUuNzM5MDI1LDE2LjIwNjM1NjEgMTUuODQzMjg5MSwxNS40MTYwMDM0IEMxMy4xODk3MDA1LDEzLjkyNjgzNjkgMTEuNSwxMS4xMTM5NjY4IDExLjUsOCBDMTEuNSwzLjMwNTU3OTYzIDE1LjMwNTU3OTYsLTAuNSAyMCwtMC41IEwyNCwtMC41IEMyOC42OTQ0MjA0LC0wLjUgMzIuNSwzLjMwNTU3OTYzIDMyLjUsOCBDMzIuNSwxMi42OTQ0MjA0IDI4LjY5NDQyMDQsMTYuNSAyNCwxNi41IEwyMS42NDM2MDY2LDE2LjUgWiIgaWQ9InNwZWVjaCIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+";
/**
 * The url of the synthesis server.
 * @type {string}
 */

const SERVER_HOST = "https://synthesis-service.scratch.mit.edu";
/**
 * How long to wait in ms before timing out requests to synthesis server.
 * @type {int}
 */

const SERVER_TIMEOUT = 10000; // 10 seconds

/**
 * Volume for playback of speech sounds, as a percentage.
 * @type {number}
 */

const SPEECH_VOLUME = 250;
/**
 * An id for one of the voices.
 */

const ALTO_ID = "ALTO";
/**
 * An id for one of the voices.
 */

const TENOR_ID = "TENOR";
/**
 * An id for one of the voices.
 */

const SQUEAK_ID = "SQUEAK";
/**
 * An id for one of the voices.
 */

const GIANT_ID = "GIANT";
/**
 * An id for one of the voices.
 */

const KITTEN_ID = "KITTEN";
/**
 * Playback rate for the tenor voice, for cases where we have only a female gender voice.
 */

const FEMALE_TENOR_RATE = 0.89; // -2 semitones

/**
 * Playback rate for the giant voice, for cases where we have only a female gender voice.
 */

const FEMALE_GIANT_RATE = 0.79; // -4 semitones

/**
 * Language ids. The value for each language id is a valid Scratch locale.
 */

const ARABIC_ID = "ar";
const CHINESE_ID = "zh-cn";
const DANISH_ID = "da";
const DUTCH_ID = "nl";
const ENGLISH_ID = "en";
const FRENCH_ID = "fr";
const GERMAN_ID = "de";
const HINDI_ID = "hi";
const ICELANDIC_ID = "is";
const ITALIAN_ID = "it";
const JAPANESE_ID = "ja";
const KOREAN_ID = "ko";
const NORWEGIAN_ID = "nb";
const POLISH_ID = "pl";
const PORTUGUESE_BR_ID = "pt-br";
const PORTUGUESE_ID = "pt";
const ROMANIAN_ID = "ro";
const RUSSIAN_ID = "ru";
const SPANISH_ID = "es";
const SPANISH_419_ID = "es-419";
const SWEDISH_ID = "sv";
const TURKISH_ID = "tr";
const WELSH_ID = "cy";
/**
 * Class for the text2speech blocks.
 * @constructor
 */

class Scratch3Text2SpeechBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * Map of soundPlayers by sound id.
     * @type {Map<string, SoundPlayer>}
     */

    this._soundPlayers = new Map();
    this._stopAllSpeech = this._stopAllSpeech.bind(this);

    if (this.runtime) {
      this.runtime.on("PROJECT_STOP_ALL", this._stopAllSpeech);
    }

    this._onTargetCreated = this._onTargetCreated.bind(this);

    if (this.runtime) {
      runtime.on("targetWasCreated", this._onTargetCreated);
    }
    /**
     * A list of all Scratch locales that are supported by the extension.
     * @type {Array}
     */


    this._supportedLocales = this._getSupportedLocales();
  }
  /**
   * An object with info for each voice.
   */


  get VOICE_INFO() {
    return {
      [ALTO_ID]: {
        name: formatMessage({
          id: "text2speech.alto",
          default: "alto",
          description: "Name for a voice with ambiguous gender."
        }),
        gender: "female",
        playbackRate: 1
      },
      [TENOR_ID]: {
        name: formatMessage({
          id: "text2speech.tenor",
          default: "tenor",
          description: "Name for a voice with ambiguous gender."
        }),
        gender: "male",
        playbackRate: 1
      },
      [SQUEAK_ID]: {
        name: formatMessage({
          id: "text2speech.squeak",
          default: "squeak",
          description: "Name for a funny voice with a high pitch."
        }),
        gender: "female",
        playbackRate: 1.19 // +3 semitones

      },
      [GIANT_ID]: {
        name: formatMessage({
          id: "text2speech.giant",
          default: "giant",
          description: "Name for a funny voice with a low pitch."
        }),
        gender: "male",
        playbackRate: 0.84 // -3 semitones

      },
      [KITTEN_ID]: {
        name: formatMessage({
          id: "text2speech.kitten",
          default: "kitten",
          description: "A baby cat."
        }),
        gender: "female",
        playbackRate: 1.41 // +6 semitones

      }
    };
  }
  /**
   * An object with information for each language.
   *
   * A note on the different sets of locales referred to in this extension:
   *
   * SCRATCH LOCALE
   *      Set by the editor, and used to store the language state in the project.
   *      Listed in l10n: https://github.com/LLK/scratch-l10n/blob/master/src/supported-locales.js
   * SUPPORTED LOCALE
   *      A Scratch locale that has a corresponding extension locale.
   * EXTENSION LOCALE
   *      A locale corresponding to one of the available spoken languages
   *      in the extension. There can be multiple supported locales for a single
   *      extension locale. For example, for both written versions of chinese,
   *      zh-cn and zh-tw, we use a single spoken language (Mandarin). So there
   *      are two supported locales, with a single extension locale.
   * SPEECH SYNTH LOCALE
   *      A different locale code system, used by our speech synthesis service.
   *      Each extension locale has a speech synth locale.
   */


  get LANGUAGE_INFO() {
    return {
      [ARABIC_ID]: {
        name: "Arabic",
        locales: ["ar"],
        speechSynthLocale: "arb",
        singleGender: true
      },
      [CHINESE_ID]: {
        name: "Chinese (Mandarin)",
        locales: ["zh-cn", "zh-tw"],
        speechSynthLocale: "cmn-CN",
        singleGender: true
      },
      [DANISH_ID]: {
        name: "Danish",
        locales: ["da"],
        speechSynthLocale: "da-DK"
      },
      [DUTCH_ID]: {
        name: "Dutch",
        locales: ["nl"],
        speechSynthLocale: "nl-NL"
      },
      [ENGLISH_ID]: {
        name: "English",
        locales: ["en"],
        speechSynthLocale: "en-US"
      },
      [FRENCH_ID]: {
        name: "French",
        locales: ["fr"],
        speechSynthLocale: "fr-FR"
      },
      [GERMAN_ID]: {
        name: "German",
        locales: ["de"],
        speechSynthLocale: "de-DE"
      },
      [HINDI_ID]: {
        name: "Hindi",
        locales: ["hi"],
        speechSynthLocale: "hi-IN",
        singleGender: true
      },
      [ICELANDIC_ID]: {
        name: "Icelandic",
        locales: ["is"],
        speechSynthLocale: "is-IS"
      },
      [ITALIAN_ID]: {
        name: "Italian",
        locales: ["it"],
        speechSynthLocale: "it-IT"
      },
      [JAPANESE_ID]: {
        name: "Japanese",
        locales: ["ja", "ja-hira"],
        speechSynthLocale: "ja-JP"
      },
      [KOREAN_ID]: {
        name: "Korean",
        locales: ["ko"],
        speechSynthLocale: "ko-KR",
        singleGender: true
      },
      [NORWEGIAN_ID]: {
        name: "Norwegian",
        locales: ["nb", "nn"],
        speechSynthLocale: "nb-NO",
        singleGender: true
      },
      [POLISH_ID]: {
        name: "Polish",
        locales: ["pl"],
        speechSynthLocale: "pl-PL"
      },
      [PORTUGUESE_BR_ID]: {
        name: "Portuguese (Brazilian)",
        locales: ["pt-br"],
        speechSynthLocale: "pt-BR"
      },
      [PORTUGUESE_ID]: {
        name: "Portuguese (European)",
        locales: ["pt"],
        speechSynthLocale: "pt-PT"
      },
      [ROMANIAN_ID]: {
        name: "Romanian",
        locales: ["ro"],
        speechSynthLocale: "ro-RO",
        singleGender: true
      },
      [RUSSIAN_ID]: {
        name: "Russian",
        locales: ["ru"],
        speechSynthLocale: "ru-RU"
      },
      [SPANISH_ID]: {
        name: "Spanish (European)",
        locales: ["es"],
        speechSynthLocale: "es-ES"
      },
      [SPANISH_419_ID]: {
        name: "Spanish (Latin American)",
        locales: ["es-419"],
        speechSynthLocale: "es-US"
      },
      [SWEDISH_ID]: {
        name: "Swedish",
        locales: ["sv"],
        speechSynthLocale: "sv-SE",
        singleGender: true
      },
      [TURKISH_ID]: {
        name: "Turkish",
        locales: ["tr"],
        speechSynthLocale: "tr-TR",
        singleGender: true
      },
      [WELSH_ID]: {
        name: "Welsh",
        locales: ["cy"],
        speechSynthLocale: "cy-GB",
        singleGender: true
      }
    };
  }
  /**
   * The key to load & store a target's text2speech state.
   * @return {string} The key.
   */


  static get STATE_KEY() {
    return "Scratch.text2speech";
  }
  /**
   * The default state, to be used when a target has no existing state.
   * @type {Text2SpeechState}
   */


  static get DEFAULT_TEXT2SPEECH_STATE() {
    return {
      voiceId: ALTO_ID
    };
  }
  /**
   * A default language to use for speech synthesis.
   * @type {string}
   */


  get DEFAULT_LANGUAGE() {
    return ENGLISH_ID;
  }
  /**
   * @param {Target} target - collect  state for this target.
   * @returns {Text2SpeechState} the mutable state associated with that target. This will be created if necessary.
   * @private
   */


  _getState(target) {
    let state = target.getCustomState(Scratch3Text2SpeechBlocks.STATE_KEY);

    if (!state) {
      state = Utility.cloneSimple(Scratch3Text2SpeechBlocks.DEFAULT_TEXT2SPEECH_STATE);
      target.setCustomState(Scratch3Text2SpeechBlocks.STATE_KEY, state);
    }

    return state;
  }
  /**
   * When a Target is cloned, clone the state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const state = sourceTarget.getCustomState(Scratch3Text2SpeechBlocks.STATE_KEY);

      if (state) {
        newTarget.setCustomState(Scratch3Text2SpeechBlocks.STATE_KEY, Utility.cloneSimple(state));
      }
    }
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    // Only localize the default input to the "speak" block if we are in a
    // supported language.
    let defaultTextToSpeak = "hello";

    if (this.isSupportedLanguage(this.getEditorLanguage())) {
      defaultTextToSpeak = formatMessage({
        id: "text2speech.defaultTextToSpeak",
        default: "hello",
        description: "hello: the default text to speak"
      });
    }

    return {
      id: "text2speech",
      name: formatMessage({
        id: "text2speech.categoryName",
        default: "Text to Speech",
        description: "Name of the Text to Speech extension."
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        opcode: "speakAndWait",
        text: formatMessage({
          id: "text2speech.speakAndWaitBlock",
          default: "speak [WORDS]",
          description: "Speak some words."
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          WORDS: {
            type: ArgumentType.STRING,
            defaultValue: defaultTextToSpeak
          }
        }
      }, {
        opcode: "setVoice",
        text: formatMessage({
          id: "text2speech.setVoiceBlock",
          default: "set voice to [VOICE]",
          description: "Set the voice for speech synthesis."
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          VOICE: {
            type: ArgumentType.STRING,
            menu: "voices",
            defaultValue: ALTO_ID
          }
        }
      }, {
        opcode: "setLanguage",
        text: formatMessage({
          id: "text2speech.setLanguageBlock",
          default: "set language to [LANGUAGE]",
          description: "Set the language for speech synthesis."
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          LANGUAGE: {
            type: ArgumentType.STRING,
            menu: "languages",
            defaultValue: this.getCurrentLanguage()
          }
        }
      }],
      menus: {
        voices: {
          acceptReporters: true,
          items: this.getVoiceMenu()
        },
        languages: {
          acceptReporters: true,
          items: this.getLanguageMenu()
        }
      }
    };
  }
  /**
   * Get the language code currently set in the editor, or fall back to the
   * browser locale.
   * @return {string} a Scratch locale code.
   */


  getEditorLanguage() {
    const locale = formatMessage.setup().locale || navigator.language || navigator.userLanguage || this.DEFAULT_LANGUAGE;
    return locale.toLowerCase();
  }
  /**
   * Get the language code currently set for the extension.
   * @returns {string} a Scratch locale code.
   */


  getCurrentLanguage() {
    const stage = this.runtime.getTargetForStage();
    if (!stage) return this.DEFAULT_LANGUAGE; // If no language has been set, set it to the editor locale (or default).

    if (!stage.textToSpeechLanguage) {
      this.setCurrentLanguage(this.getEditorLanguage());
    }

    return stage.textToSpeechLanguage;
  }
  /**
   * Set the language code for the extension.
   * It is stored in the stage so it can be saved and loaded with the project.
   * @param {string} locale a locale code.
   */


  setCurrentLanguage(locale) {
    const stage = this.runtime.getTargetForStage();
    if (!stage) return;

    if (this.isSupportedLanguage(locale)) {
      stage.textToSpeechLanguage = this._getExtensionLocaleForSupportedLocale(locale);
    } // Support language names dropped onto the menu via reporter block
    // such as a variable containing a language name (in any language),
    // or the translate extension's language reporter.


    const localeForDroppedName = languageNames.nameMap[locale.toLowerCase()];

    if (localeForDroppedName && this.isSupportedLanguage(localeForDroppedName)) {
      stage.textToSpeechLanguage = this._getExtensionLocaleForSupportedLocale(localeForDroppedName);
    } // If the language is null, set it to the default language.
    // This can occur e.g. if the extension was loaded with the editor
    // set to a language that is not in the list.


    if (!stage.textToSpeechLanguage) {
      stage.textToSpeechLanguage = this.DEFAULT_LANGUAGE;
    }
  }
  /**
   * Get the extension locale for a supported locale, or null.
   * @param {string} locale a locale code.
   * @returns {?string} a locale supported by the extension.
   */


  _getExtensionLocaleForSupportedLocale(locale) {
    for (const lang in this.LANGUAGE_INFO) {
      if (this.LANGUAGE_INFO[lang].locales.includes(locale)) {
        return lang;
      }
    }

    console.error(`cannot find extension locale for locale ${locale}`);
  }
  /**
   * Get the locale code used by the speech synthesis server corresponding to
   * the current language code set for the extension.
   * @returns {string} a speech synthesis locale.
   */


  _getSpeechSynthLocale() {
    let speechSynthLocale = this.LANGUAGE_INFO[this.DEFAULT_LANGUAGE].speechSynthLocale;

    if (this.LANGUAGE_INFO[this.getCurrentLanguage()]) {
      speechSynthLocale = this.LANGUAGE_INFO[this.getCurrentLanguage()].speechSynthLocale;
    }

    return speechSynthLocale;
  }
  /**
   * Get an array of the locales supported by this extension.
   * @returns {Array} An array of locale strings.
   */


  _getSupportedLocales() {
    return Object.keys(this.LANGUAGE_INFO).reduce((acc, lang) => acc.concat(this.LANGUAGE_INFO[lang].locales), []);
  }
  /**
   * Check if a Scratch language code is in the list of supported languages for the
   * speech synthesis service.
   * @param {string} languageCode the language code to check.
   * @returns {boolean} true if the language code is supported.
   */


  isSupportedLanguage(languageCode) {
    return this._supportedLocales.includes(languageCode);
  }
  /**
   * Get the menu of voices for the "set voice" block.
   * @return {array} the text and value for each menu item.
   */


  getVoiceMenu() {
    return Object.keys(this.VOICE_INFO).map(voiceId => ({
      text: this.VOICE_INFO[voiceId].name,
      value: voiceId
    }));
  }
  /**
   * Get the localized menu of languages for the "set language" block.
   * For each language:
   *   if there is a custom translated spoken language name, use that;
   *   otherwise use the translation in the languageNames menuMap;
   *   otherwise fall back to the untranslated name in LANGUAGE_INFO.
   * @return {array} the text and value for each menu item.
   */


  getLanguageMenu() {
    const editorLanguage = this.getEditorLanguage(); // Get the array of localized language names

    const localizedNameMap = {};
    let nameArray = languageNames.menuMap[editorLanguage];

    if (nameArray) {
      // Also get any localized names of spoken languages
      let spokenNameArray = [];

      if (languageNames.spokenLanguages) {
        spokenNameArray = languageNames.spokenLanguages[editorLanguage];
        nameArray = nameArray.concat(spokenNameArray);
      } // Create a map of language code to localized name
      // The localized spoken language names have been concatenated onto
      // the end of the name array, so the result of the forEach below is
      // when there is both a written language name (e.g. 'Chinese
      // (simplified)') and a spoken language name (e.g. 'Chinese
      // (Mandarin)', we always use the spoken version.


      nameArray.forEach(lang => {
        localizedNameMap[lang.code] = lang.name;
      });
    }

    return Object.keys(this.LANGUAGE_INFO).map(key => {
      let name = this.LANGUAGE_INFO[key].name;
      const localizedName = localizedNameMap[key];

      if (localizedName) {
        name = localizedName;
      } // Uppercase the first character of the name


      name = name.charAt(0).toUpperCase() + name.slice(1);
      return {
        text: name,
        value: key
      };
    });
  }
  /**
   * Set the voice for speech synthesis for this sprite.
   * @param  {object} args Block arguments
   * @param {object} util Utility object provided by the runtime.
   */


  setVoice(args, util) {
    const state = this._getState(util.target);

    let voice = args.VOICE; // If the arg is a dropped number, treat it as a voice index

    let voiceNum = parseInt(voice, 10);

    if (!isNaN(voiceNum)) {
      voiceNum -= 1; // Treat dropped args as one-indexed

      voiceNum = Utility.wrapClamp(voiceNum, 0, Object.keys(this.VOICE_INFO).length - 1);
      voice = Object.keys(this.VOICE_INFO)[voiceNum];
    } // Only set the voice if the arg is a valid voice id.


    if (Object.keys(this.VOICE_INFO).includes(voice)) {
      state.voiceId = voice;
    }
  }
  /**
   * Set the language for speech synthesis.
   * @param  {object} args Block arguments
   */


  setLanguage(args) {
    this.setCurrentLanguage(args.LANGUAGE);
  }
  /**
   * Stop all currently playing speech sounds.
   */


  _stopAllSpeech() {
    this._soundPlayers.forEach(player => {
      player.stop();
    });
  }
  /**
   * Convert the provided text into a sound file and then play the file.
   * @param  {object} args Block arguments
   * @param {object} util Utility object provided by the runtime.
   * @return {Promise} A promise that resolves after playing the sound
   */


  speakAndWait(args, util) {
    // Cast input to string
    let words = String(args.WORDS);

    let locale = this._getSpeechSynthLocale();

    const state = this._getState(util.target);

    let gender = this.VOICE_INFO[state.voiceId].gender;
    let playbackRate = this.VOICE_INFO[state.voiceId].playbackRate; // Special case for voices where the synthesis service only provides a
    // single gender voice. In that case, always request the female voice,
    // and set special playback rates for the tenor and giant voices.

    if (this.LANGUAGE_INFO[this.getCurrentLanguage()].singleGender) {
      gender = "female";

      if (state.voiceId === TENOR_ID) {
        playbackRate = FEMALE_TENOR_RATE;
      }

      if (state.voiceId === GIANT_ID) {
        playbackRate = FEMALE_GIANT_RATE;
      }
    }

    if (state.voiceId === KITTEN_ID) {
      words = words.replace(/\S+/g, "meow");
      locale = this.LANGUAGE_INFO[this.DEFAULT_LANGUAGE].speechSynthLocale;
    } // Build up URL


    let path = `${SERVER_HOST}/synth`;
    path += `?locale=${locale}`;
    path += `&gender=${gender}`;
    path += `&text=${encodeURIComponent(words.substring(0, 128))}`; // Perform HTTP request to get audio file

    return new Promise(resolve => {
      nets({
        url: path,
        timeout: SERVER_TIMEOUT
      }, (err, res, body) => {
        if (err) {
          console.warn(err);
          return resolve();
        }

        if (res.statusCode !== 200) {
          console.warn(res.statusCode);
          return resolve();
        } // Play the sound


        const sound = {
          data: {
            buffer: body.buffer
          }
        };
        this.runtime.audioEngine.decodeSoundPlayer(sound).then(soundPlayer => {
          this._soundPlayers.set(soundPlayer.id, soundPlayer);

          soundPlayer.setPlaybackRate(playbackRate); // Increase the volume

          const engine = this.runtime.audioEngine;
          const chain = engine.createEffectChain();
          chain.set("volume", SPEECH_VOLUME);
          soundPlayer.connect(chain);
          soundPlayer.play();
          soundPlayer.on("stop", () => {
            this._soundPlayers.delete(soundPlayer.id);

            resolve();
          });
        });
      });
    });
  }

}

module.exports = Scratch3Text2SpeechBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_translate/index.js":
/*!****************************************************!*\
  !*** ./src/extensions/scratch3_translate/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const nets = __webpack_require__(/*! nets */ "./node_modules/nets/index.js");

const languageNames = __webpack_require__(/*! scratch-translate-extension-languages */ "./node_modules/scratch-translate-extension-languages/languages.json");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const menuIconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAGAklEQVRYhe1YbUxTVxh+rh02o0KtkOEgKA4U4yeRWCdgxDoxCnH6h22iqSz76aasZlnijzkTBlvS4TJ/LGaJsmiyESe4hAVJvMJGxwQhLKECcRWkpWNZERs6Ctb2Lm97C/fe3n6Jyfzhk5y09z3nPPe57znnPe85DMdxeJ6x6LlW90LgM8BLchR1dXUZeXl5b3Ect+ppXsEwzHBfX98PVVVVY0GbmjW2AdgpaFYP4JxTZ+iLyCVdJFeuXNmdn59fn56enrFkyRIsWhSfk30+H1wuF+x2+1hPT4++oqLiJi/wEoA8AJslXSqdOsOlmARWV1dnlpeXd2ZnZ2fEK0xOqMViGWtoaNh++vRpa9CuZo1ZAJokQlc5dYYROR6RCq1WW56WlhZV3H0H8O9sZIHEQVzEKbTzQooBPBCYz4TlET4oFIosGtZoOHUN+Ph61GYgLuIU2tSscSmAYwAeCcx6NWs8o2aNxVKOkEUi9R55qv428Ng7b3viA/6eAs7dmrctVgD6bYBKGZ6LB4mrk7F/whcmokApfh8BWu6G2mc8ADsktuWmAbtzozGiLUJdu9QQVSC98JUkYNgBfPsboH4Z+GhPoK62FZiaAU7sCrTZmB5VHM3BPjVrrARwUVL1B4CD0vYxLVV68YFNQIICcLrn7SROtTjwEbGIE4iksFIpEVfs1BkeSdvGFUsObAz8Gm8CNTcC/49q42EIEbkLwKfhxCGWIRZC/zrQ/ifgcAWMK5YB+zc8nUBeZFuUORmfQIp/PsHGM/04YMta5oPT6cTs7Cw8Ho+oj9vtzmloaCgPZQtApVI96ejo6K2trR3lOM4nrRftJCzLfq3T6Y7LCfvuNtDL7wepfKgkTz6ZdeHdzePYlq30xz2lUintHhH0UbQ12my2+oKCguMcx7mE7aOHmWHgsxvzzzQP3ysMxMfzt2bxKmNHyZblSE5OjktYEImJidBoNFCr1frOzs5khmHe4Thubp8SCVQoFBwNUUJCwpyNwsfyZGBDOvB2fuCZQAH56KYJKJUpTy1OCOJYvXr1ocbGxjIAPwarRKvYZrNdn5iYEHV8LRW4cBj4oHheXBDT09PPRFwQxKXRaIQpmVjgkSNHfrFardcmJydjIqSMRehtOfzjmMTZmm/8hf5HAnF5vV7RVicSyHGcR6vVHh4YGPjKYrFMkTelq5JAH0B1MzMzUT+iu6cfdwfv+wv9jxchgZomaEFBwcmcnJxVY2NjXQqFQlQ/Pj6O/v7+s2az+U2Hw9Ec7X3tHXfm/v/c2hG3wLCruLm5+VBGRoY2mJGQJ0nc4ODgqZKSkjqKWSzL7olEPjJqx4PRv5CaqvE/OxyTflvWitj3xbBbnUql2kRxjYTRcA4MDHR1d3frguJiIW//NeC9/SVF2LplvcgWK8J6sKWl5UuVSrXO4/HYHj58+FNZWVkLx3HT8Rz0u3vN/t8Ho3aRaH3FgYULrKmpodT8jeBzvDcQ3T1m/5D6RXX0zNmn3TP+uq356xcmkE/NTwLoc+oMTXGpA3CnN7Bi99Hw5s8PL4mlulgFys5BXlwbn4I3qlnjsXgFBr22f+8OrFub7S/79u4Q1cWCEA8KxAmPhRfVrBFy51cK1nJnj+/rvwix0eqVswu5pJDzoPTMKhSZJzQolUoLZSLPCsRFnEI6OYE7I7xPdGYoKiq6YLVaByllWiiIg7iIM5rAYBouBB2yq5w6g+iATWGnqampZGhoqItiJSUP4YrcR9CQUh31JQ7iIk5hm7AXmPxdip5/dNIUCnduYBgm8fLly9tzc3NLwzlSqVTuW7NmzVphQkubwL179+xdXV3HKisrTVJxiJKwnuGHVM2XNjVrPCh3h8IT3+SLLKqrq+tKS0uvrly5UksJKvjsJSkpKd3r9TrkxCGSBxHwIoWXc7zAIOiIOOLUGULOsNHAMIzSZDJ9npmZeSIlJcWfTdPQm0ym8zqd7n257hGPnXxYyePv8py8mVb40ji1+UGZUmFh4Yetra1bzGbzteHh4SlKQNxu961wff7XS3Sau/w0c4VLQF7c8i8IAP4DcHKth/4Ur7MAAAAASUVORK5CYII=";
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const blockIconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAN+UlEQVR4Ae1ce2xT1xn/Tkhq4hqHJKRLDAlQGI+GUfFc14HaLmxuGd0ab93GgK6Vmm01y9BUsaU0RfyRFTakaRHq3So6jVapWEUxa9dRuU8x6IAGCoO6wa1KXiSQOE9jkjivO/2u7yWOuff6XvvekFb5SUdx7ON7v/vz9zrnO+cwnudpAokjZYK75DBBYJKYIDBJTBCYJCYITBJfOgIZYzbGWA5jLJ8xNm/z5s334a/4P1omYyzNsPt9WdIYxhiUId/j8azPz89fY7VaF6ampjqi+4TD4Qvd3d0f7t+/fx/HcTVE1M7z/EBS99VDoCikTWzWMdTgYSLqIaIQGs/zwzKyOaqrq1+aOnVqUUZGBqWnp5PFYqG0tDQaHh6mvr4+GhwcpFAoJLSenp4P9+7dW8Zx3Fme5zsTFSxVa0eovtPpnL1ly5YfzJgxw2WxWBYketNEAO25dOmSp7Ky8iBjrFbmoW12u70oOzubMjMzR32QkpJCVqtVeG2322lgYIACgcDK0tLS1+6+++4yxpiH5/krCQkGDYzXiCi3qqrKXVNTE7x48SLf0dHB9/X18WMF3Av3xL0hA2SBTNFyE9E8v9/PX758WbNUuCa+4/F4ymKvp7XF1UDGWK7H43m0sLBwZ05Ozg2/7lgApoiGe3d2dk5ZsWLFcx6Px84Y2xelOcHW1taXiOiRcDgsaJ2gljab0GDKscD1Jk2ahHd3ejwePOtenufb9TySKoEw26qqKhfIy83NFdT/ZiP6oauqqoKMsf2iObeuXr26vKKiwpOVlTXFbrfb8/LyFubk5KyBu1H68aVnGh4e3uZ2u08yxo7pCixKqgrX4XQ6l8JkoOrjDZAJskFGyBolt0UMcGhgJ19yP2rm3dDQwJ85c+akXlNWI9B++PDh38PvjFdANsgIWVUfksheUVHxfZDY3d0t+zT9/f2CP3S73feJWYZFC4FqJmxDtJ06daphRnuiluhrDqJbLcZcD7JBRiJ6Dj5Qrg9jDHfLhlm3tbUdslgsj8i5IvhI+MpNmzaVLlq0yCN+9wMiCvA8H1KSQY1AK3yHFP6ThfcTouePEaVNItrzI6LbpiR/TcgmplOyQmLE4XQ6C3fv3v0y+iEQIbggjZELKiB2+vTpxXl5ecUIRD6fr/nQoUNuxtjbPM/3yN1DLREWPsNNjUBNC9HgMFEKI2q5asglo2VTeo7sioqKP6anpwtBZObMmZSfny9LHokRG5+jn8PhoFtuucVRXFzMQdmVZPiyTyakIblGBqE3/QKZIBLDQafTmavUT/NIRA3XwkSlB4jaFD3FCPqHiJ5+Xb3PNBvRnoeN85UYyiUCmDHg9XoVn8wQDTxRR9RxjQjxLl4DgfH64Fq4pgEY6OjoONTe3q6bRPTH9zBmFsfgsjBEA4vmE/kuE30eiPzfN0B0WYyJGelEWQpx6FJXhNC0FKIcG9Fk0TUVZEWuaQBad+zYUbF79+6FjY2NC+DfpBGKGkBeY2MjBYPBC2VlZU9g1sZUAoFf3zvyGia9/u8RbRrmiSofvrG/1IeEaEn0/E+NkmQEmLVhjPmIaAMisRYSo8nbunXrBq/X6+N5PqzU35QgAt8177bI655+ovPNN/Z50xeJyIyIlswwQ4oI8PAgAWSAFJCjZM56ySMzo/DP7iJKTSEaGibi/jP6M2jfwbNEQzzRpBSin68yS4oItJCYCHlkJoEYcWSKvu9KkOjwxyOf7T9F1DsQ0b6CTGOS6niQIxEJNSVBHhnpA+Xwm28RPfOvSAL9t+NEy2cShcJEr5+P+EcQ+PT9ZkowGiBF8olIsMPhcBFmrnt7e4Voi4Chhzwym0BoYWFexAcODBGVvUbU3RshbxIjWrdobLQvGhKJXq+3xO12z1q3bt2aN9544x2O45A4Neshj8wmENjmJHr8ZaJQ/0iizcRk+fFvmn13eYgk1TLGWjiOwxQWKY1148H0oRwiMohiUYky8Oz3zL5zfIA0qSV6DdM18NWPiF4+FXnNogh84h9EW9cQ3TV7pC+ceVTVTNPooa5OGLLMYkgmE0fcqp8STCPwYhvRn94jauqKBBHJbOED4Q8xAtn1FtH8rxA9WUSUNthJiQy5Zs2aRX6/35usvBqqfrJQrAujmu/3+/3z5s3TJQgCxsEzRP9riuSAUsBYXhCJysCWVyP+EHkgiA0Hr9D9Xw3S/QuJJlvShIlSca4vASr0A5MG0Piuri68vnr69OmyjRs3aip1GqaByPNePRuZCMDwTSIuPY1oy32jTfWFDUQvniB67RzRta4rtDwvSN8tJBrnVT9ZGEIgpupf+C/RgGh90CpMEKwtJFq/XH5aCiOVb0zvpH+fipD3Baj6yUKNQIEOqLcWU4IPx9ANGue6k+iBQvX5PPi6lHD7dc0bD+RJgCxDQ0O0bNmyXU6n8wRjrFsxsKhUshznzp2r0VrSbAny/OcB7eU7VMdQBfuiV/3U8sAQohIcqxZgRHH7NO2/MlIVEitr4xVRVT+bkoiqBCKkIyp1dia8eEkRiHokVtbGK+JV/VQJhM17vd5ahPRAIICZCkMfU8r3xipVSQQaqn7qURjRB0u/ENIRleBYb0aaEQ+Btk4qfXLnqF7bn/oF3bFgjun3jjsWRh7kcrn2VVdXb25pablaW1uLXOl6xWo84LD36A1SHDl6akwk05QHgkTkQwjpsQsstSa/V65cGeUGMIbFMMwIyJFVfdpHj2zopVut6YbcQwmaZ2Ngzl6v9+zatWv/sHjx4u9UVlYKAzMUoOMB5HV1dV09cODAQ/NFOJ1OpxEPAKJ6evtueB/vnTrtM+IWqtA1nYXAwvM81GgAi3CUFi5KQKBobm4WyDt48OCm8vLy93me/xQNSmjEAxw5NqJ91vTJQpNQ/dE4I5AikwxWjuPWZGVlFWM9shLgI+vr6zHDcoHjuAdF8gwN5dd6eulUFEkrlhUKTQI+Q4AxE4lMqOasWrXqafg9uRREquiDvKamppe2bdv2kz179pwwmjyS8X3Lly4SWjSqT38s/2WDkMhkggUBJHbsCuIQndH6+/ubjxw58ju32/0eXKCeCUo9iDbfadMyr2sfzFjyi4ffOkZrnatNoi8xAoX1JjabrRhDnehZZBDn9/v3uFyuV+ItTEwWdQ3NVN9w+fpVViwdMV0QeeTYaeF1W1un0HdWgcNoEQQkYsJd27dvfxa+7dKlS9TQ0NBcV1d36OTJk5sLCwtXuVwujuf5WjPJIxnzvWf18uuvY834TZk80Sjo1kBxdPLp4sWLizBnKr4NewnqLQkmg1gCy575s+LVkOo8UWKOHAlV5cSAgGmadnG/WWCsyZPL/ZSAvmaNTHRroLho2xFdlGaMXRSDxZiQGJvf3bHgdtl+n1y4OOo70WZuFHQRCPKwaHvXrl1/sVqtK7EsYs6cOdsee+yxd8vLy3+Lir/ZJCKvi879Zhbk0fanfinb91dP7hSCCEXlhDnTjJ0M0WzCEnlYZ5eZmbly7ty5woLs2bNnYzxchPfxuaihpiE2r7tnlbJWRUdmMikn1ERgNHl2u33UIkUM5fA/3h8LEpHXRWPFskWKfWNNNva7RkDLZkNF8iTgf7yPFaDoh9VPZpnzvVEaZ7VOVjVJ5H4/fOjbRoswGnG2SIG8pSgu1dXV8UNDQ6pFGHyOfugv7mFT3C5FRHNRVBrLbbN6AdkgI2RNZK+cLvIkyJCYonB9XVW/mwHIBhkhayJVuWxEWyWzVYJkzjabbcGOHTvKUbBT6Kqr6nczANkgo9o2BzVWbEhVMGWllbzrF01JIXwPU16IMwrdTK36JQuxbHEVMiZEoNPpFKaaE62axSPd7KpfMoAskAmyQUa12STFKOz1egODg4PN9fX1Dqxb0TJ1LwG/HuYEg8Hgu5i9Ueo3Hqt+kB3k+Xy+p8QVWqrmoZbGtGOrJ3YrNjc3O6StonhAOTKx4h21D0xvYTYa6+0wOlHb5UMjBat9WMiDtShdXV1TvkjL21TPjcEpQJiB5jhOWM28ZMkSV0FBQTG2gsoBJU/MQp8/f/5tt9v9gZ5F20Yeq4LJXlhNPEjaRjELLEWz1eaYNR57AlWwYTs88iJsj5cDFgxhWz2218fbhq90ToN4zgF+obk4ykRvk7b2azn+JGabf754b9m0S3ceqPCAuTiYAQc0KAGCR53tIgklHQKh6RyCZFr0+QhNTU1x81f0OX78uMe0c2Ni0I7jknDiTzAYxNEiN3SA6VgsFmGV57lz50oDgcA7fr9f2ErQ0dFxlTH2ERE1mVUnwVwlY+z9lpaWB0tKSv4aDocXwOUo+VOkW6FQqJjjOI94gpG+FfsJmFk2TvqB6iudgCGZBzJ5aCsaRif4ztGjR19M9NfWKadl3bp1d+J+uG9bW5uiNra2tkojjpm675OgcLkSiXqGYjBvcWw5z2wC+RGf6uA4bqPP52v67LPPZImMGvPqliuhNdKxqUdvb+8UrJFRW6VAN2Epm+gmmhlj/ySiDzwez4/nz59f2tnZ6ZCOhEJqhvQFlUa1nFUJCS8ylxYcud3umpKSkl2hUGilJFRqaipNnjz5+hEjyLOwoa+7u1tKrk2t2MnIKmygYYzhBI5XqqqqHpgzZ84au93+dRwqgRQGlUaxzqMLSR/AKJ4Gme12uxeuX7/+0YyMjJWxORxGND09PTWNjY3vuFyu/UTUaFYQ0SizRcwOpIU0Q2JVUf8Pa6C/AZGZYuqSL+VkYh6H/3OQS46F7xvLNnGSeZKYOMU3SUwQmCQmCEwSEwQmiQkCkwER/R+aET3lwEIlXgAAAABJRU5ErkJggg==";
/**
 * The url of the translate server.
 * @type {string}
 */

const serverURL = "https://translate-service.scratch.mit.edu/";
/**
 * How long to wait in ms before timing out requests to translate server.
 * @type {int}
 */

const serverTimeoutMs = 10000; // 10 seconds (chosen arbitrarily).

/**
 * Class for the translate block in Scratch 3.0.
 * @constructor
 */

class Scratch3TranslateBlocks {
  constructor() {
    /**
     * Language code of the viewer, based on their locale.
     * @type {string}
     * @private
     */
    this._viewerLanguageCode = this.getViewerLanguageCode();
    /**
     * List of supported language name and language code pairs, for use in the block menu.
     * Filled in by getInfo so it is updated when the interface language changes.
     * @type {Array.<object.<string, string>>}
     * @private
     */

    this._supportedLanguages = [];
    /**
     * A randomly selected language code, for use as the default value in the language menu.
     * Properly filled in getInfo so it is updated when the interface languages changes.
     * @type {string}
     * @private
     */

    this._randomLanguageCode = "en";
    /**
     * The result from the most recent translation.
     * @type {string}
     * @private
     */

    this._translateResult = "";
    /**
     * The language of the text most recently translated.
     * @type {string}
     * @private
     */

    this._lastLangTranslated = "";
    /**
     * The text most recently translated.
     * @type {string}
     * @private
     */

    this._lastTextTranslated = "";
  }
  /**
   * The key to load & store a target's translate state.
   * @return {string} The key.
   */


  static get STATE_KEY() {
    return "Scratch.translate";
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    this._supportedLanguages = this._getSupportedLanguages(this.getViewerLanguageCode());
    this._randomLanguageCode = this._supportedLanguages[Math.floor(Math.random() * this._supportedLanguages.length)].value;
    return {
      id: "translate",
      name: formatMessage({
        id: "translate.categoryName",
        default: "Translate",
        description: "Name of extension that adds translate blocks"
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        opcode: "getTranslate",
        text: formatMessage({
          id: "translate.translateBlock",
          default: "translate [WORDS] to [LANGUAGE]",
          description: "translate some text to a different language"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          WORDS: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: "translate.defaultTextToTranslate",
              default: "hello",
              description: "hello: the default text to translate"
            })
          },
          LANGUAGE: {
            type: ArgumentType.STRING,
            menu: "languages",
            defaultValue: this._randomLanguageCode
          }
        }
      }, {
        opcode: "getViewerLanguage",
        text: formatMessage({
          id: "translate.viewerLanguage",
          default: "language",
          description: "the languge of the project viewer"
        }),
        blockType: BlockType.REPORTER,
        arguments: {}
      }],
      menus: {
        languages: {
          acceptReporters: true,
          items: this._supportedLanguages
        }
      }
    };
  }
  /**
   * Computes a list of language code and name pairs for the given language.
   * @param {string} code The language code to get the list of language pairs
   * @return {Array.<object.<string, string>>} An array of languge name and
   *   language code pairs.
   * @private
   */


  _getSupportedLanguages(code) {
    return languageNames.menuMap[code].map(entry => {
      const obj = {
        text: entry.name,
        value: entry.code
      };
      return obj;
    });
  }
  /**
   * Get the human readable language value for the reporter block.
   * @return {string} the language name of the project viewer.
   */


  getViewerLanguage() {
    this._viewerLanguageCode = this.getViewerLanguageCode();
    const names = languageNames.menuMap[this._viewerLanguageCode];
    let langNameObj = names.find(obj => obj.code === this._viewerLanguageCode); // If we don't have a name entry yet, try looking it up via the Google langauge
    // code instead of Scratch's (e.g. for es-419 we look up es to get espanol)

    if (!langNameObj && languageNames.scratchToGoogleMap[this._viewerLanguageCode]) {
      const lookupCode = languageNames.scratchToGoogleMap[this._viewerLanguageCode];
      langNameObj = names.find(obj => obj.code === lookupCode);
    }

    let langName = this._viewerLanguageCode;

    if (langNameObj) {
      langName = langNameObj.name;
    }

    return langName;
  }
  /**
   * Get the viewer's language code.
   * @return {string} the language code.
   */


  getViewerLanguageCode() {
    const locale = formatMessage.setup().locale;
    const viewerLanguages = [locale].concat(navigator.languages);
    const languageKeys = Object.keys(languageNames.menuMap); // Return the first entry in viewerLanguages that matches
    // one of the available language keys.

    const languageCode = viewerLanguages.reduce((acc, lang) => {
      if (acc) {
        return acc;
      }

      if (languageKeys.indexOf(lang.toLowerCase()) > -1) {
        return lang;
      }

      return acc;
    }, "") || "en";
    return languageCode.toLowerCase();
  }
  /**
   * Get a language code from a block argument. The arg can be a language code
   * or a language name, written in any language.
   * @param  {object} arg A block argument.
   * @return {string} A language code.
   */


  getLanguageCodeFromArg(arg) {
    const languageArg = String(arg).toLowerCase(); // Check if the arg matches a language code in the menu.

    if (languageNames.menuMap.hasOwnProperty(languageArg)) {
      return languageArg;
    } // Check for a dropped-in language name, and convert to a language code.


    if (languageNames.nameMap.hasOwnProperty(languageArg)) {
      return languageNames.nameMap[languageArg];
    } // There are some languages we launched in the language menu that Scratch did not
    // end up launching in. In order to keep projects that may have had that menu item
    // working, check for those language codes and let them through.
    // Examples: 'ab', 'hi'.


    if (languageNames.previouslySupported.indexOf(languageArg) !== -1) {
      return languageArg;
    } // Default to English.


    return "en";
  }
  /**
   * Translates the text in the translate block to the language specified in the menu.
   * @param {object} args - the block arguments.
   * @return {Promise} - a promise that resolves after the response from the translate server.
   */


  getTranslate(args) {
    // Don't remake the request if we already have the value.
    if (this._lastTextTranslated === args.WORDS && this._lastLangTranslated === args.LANGUAGE) {
      return this._translateResult;
    }

    const lang = this.getLanguageCodeFromArg(args.LANGUAGE);
    let urlBase = `${serverURL}translate?language=`;
    urlBase += lang;
    urlBase += "&text=";
    urlBase += encodeURIComponent(args.WORDS);
    const tempThis = this;
    const translatePromise = new Promise(resolve => {
      nets({
        url: urlBase,
        timeout: serverTimeoutMs
      }, (err, res, body) => {
        if (err) {
          console.warn(`error fetching translate result! ${res}`);
          resolve("");
          return "";
        }

        const translated = JSON.parse(body).result;
        tempThis._translateResult = translated; // Cache what we just translated so we don't keep making the
        // same call over and over.

        tempThis._lastTextTranslated = args.WORDS;
        tempThis._lastLangTranslated = args.LANGUAGE;
        resolve(translated);
        return translated;
      });
    });
    translatePromise.then(translatedText => translatedText);
    return translatePromise;
  }

}

module.exports = Scratch3TranslateBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_video_sensing/index.js":
/*!********************************************************!*\
  !*** ./src/extensions/scratch3_video_sensing/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Runtime = __webpack_require__(/*! ../../engine/runtime */ "./src/engine/runtime.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const Video = __webpack_require__(/*! ../../io/video */ "./src/io/video.js");

const VideoMotion = __webpack_require__(/*! ./library */ "./src/extensions/scratch3_video_sensing/library.js");
/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const menuIconURI = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctTWVudTwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxnIGlkPSJFeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctTWVudSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9InZpZGVvLW1vdGlvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDUuMDAwMDAwKSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjMEVCRDhDIiBvcGFjaXR5PSIwLjI1IiBjeD0iMTYiIGN5PSI4IiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjMEVCRDhDIiBvcGFjaXR5PSIwLjUiIGN4PSIxNiIgY3k9IjYiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLUNvcHkiIGZpbGw9IiMwRUJEOEMiIG9wYWNpdHk9IjAuNzUiIGN4PSIxNiIgY3k9IjQiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsIiBmaWxsPSIjMEVCRDhDIiBjeD0iMTYiIGN5PSIyIiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgPHBhdGggZD0iTTExLjMzNTk3MzksMi4yMDk3ODgyNSBMOC4yNSw0LjIwOTk1NjQ5IEw4LjI1LDMuMDUgQzguMjUsMi4wNDQ4ODIyNyA3LjQ2ODU5MDMxLDEuMjUgNi41LDEuMjUgTDIuMDUsMS4yNSBDMS4wMzgwNzExOSwxLjI1IDAuMjUsMi4wMzgwNzExOSAwLjI1LDMuMDUgTDAuMjUsNyBDMC4yNSw3Ljk2MzY5OTM3IDEuMDQyMjQ5MTksOC43NTU5NDg1NiAyLjA1LDguOCBMNi41LDguOCBDNy40NTA4MzAwOSw4LjggOC4yNSw3Ljk3MzI3MjUgOC4yNSw3IEw4LjI1LDUuODU4NDUyNDEgTDguNjI4NjIzOTQsNi4wODU2MjY3NyBMMTEuNDI2Nzc2Nyw3Ljc3MzIyMzMgQzExLjQzNjg5NDMsNy43ODMzNDA5MSAxMS40NzU3NjU1LDcuOCAxMS41LDcuOCBDMTEuNjMzNDkzMiw3LjggMTEuNzUsNy42OTEyNjAzNCAxMS43NSw3LjU1IEwxMS43NSwyLjQgQzExLjc1LDIuNDE4MzgyNjkgMTEuNzIxOTAyOSwyLjM1MjgyMjgyIDExLjY4NTYyNjgsMi4yNzg2MjM5NCBDMTEuNjEyOTUyOCwyLjE1NzUwMDY5IDExLjQ3MDc5NjgsMi4xMjkwNjk1IDExLjMzNTk3MzksMi4yMDk3ODgyNSBaIiBpZD0idmlkZW9fMzdfIiBzdHJva2Utb3BhY2l0eT0iMC4xNSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNSIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+";
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const blockIconURI = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctQmxvY2s8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZyBpZD0iRXh0ZW5zaW9ucy9Tb2Z0d2FyZS9WaWRlby1TZW5zaW5nLUJsb2NrIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2Utb3BhY2l0eT0iMC4xNSI+CiAgICAgICAgPGcgaWQ9InZpZGVvLW1vdGlvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwLjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyIgc3Ryb2tlPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjRkZGRkZGIiBvcGFjaXR5PSIwLjI1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGN4PSIzMiIgY3k9IjE2IiByPSI0LjUiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLUNvcHkiIGZpbGw9IiNGRkZGRkYiIG9wYWNpdHk9IjAuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjeD0iMzIiIGN5PSIxMiIgcj0iNC41Ij48L2NpcmNsZT4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjRkZGRkZGIiBvcGFjaXR5PSIwLjc1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGN4PSIzMiIgY3k9IjgiIHI9IjQuNSI+PC9jaXJjbGU+CiAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgY3g9IjMyIiBjeT0iNCIgcj0iNC41Ij48L2NpcmNsZT4KICAgICAgICAgICAgPHBhdGggZD0iTTIyLjY3MTk0NzcsNC40MTk1NzY0OSBMMTYuNSw4LjQxOTkxMjk4IEwxNi41LDYuMSBDMTYuNSw0LjA4OTc2NDU0IDE0LjkzNzE4MDYsMi41IDEzLDIuNSBMNC4xLDIuNSBDMi4wNzYxNDIzNywyLjUgMC41LDQuMDc2MTQyMzcgMC41LDYuMSBMMC41LDE0IEMwLjUsMTUuOTI3Mzk4NyAyLjA4NDQ5ODM5LDE3LjUxMTg5NzEgNC4xLDE3LjYgTDEzLDE3LjYgQzE0LjkwMTY2MDIsMTcuNiAxNi41LDE1Ljk0NjU0NSAxNi41LDE0IEwxNi41LDExLjcxNjkwNDggTDIyLjc1NzI0NzksMTUuNDcxMjUzNSBMMjIuODUzNTUzNCwxNS41NDY0NDY2IEMyMi44NzM3ODg2LDE1LjU2NjY4MTggMjIuOTUxNTMxLDE1LjYgMjMsMTUuNiBDMjMuMjY2OTg2NSwxNS42IDIzLjUsMTUuMzgyNTIwNyAyMy41LDE1LjEgTDIzLjUsNC44IEMyMy41LDQuODM2NzY1MzggMjMuNDQzODA1OCw0LjcwNTY0NTYzIDIzLjM3MTI1MzUsNC41NTcyNDc4OCBDMjMuMjI1OTA1Niw0LjMxNTAwMTM5IDIyLjk0MTU5MzcsNC4yNTgxMzg5OSAyMi42NzE5NDc3LDQuNDE5NTc2NDkgWiIgaWQ9InZpZGVvXzM3XyIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+";
/**
 * Sensor attribute video sensor block should report.
 * @readonly
 * @enum {string}
 */

const SensingAttribute = {
  /** The amount of motion. */
  MOTION: "motion",

  /** The direction of the motion. */
  DIRECTION: "direction"
};
/**
 * Subject video sensor block should report for.
 * @readonly
 * @enum {string}
 */

const SensingSubject = {
  /** The sensor traits of the whole stage. */
  STAGE: "Stage",

  /** The senosr traits of the area overlapped by this sprite. */
  SPRITE: "this sprite"
};
/**
 * States the video sensing activity can be set to.
 * @readonly
 * @enum {string}
 */

const VideoState = {
  /** Video turned off. */
  OFF: "off",

  /** Video turned on with default y axis mirroring. */
  ON: "on",

  /** Video turned on without default y axis mirroring. */
  ON_FLIPPED: "on-flipped"
};
/**
 * Class for the motion-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */

class Scratch3VideoSensingBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The motion detection algoritm used to power the motion amount and
     * direction values.
     * @type {VideoMotion}
     */

    this.detect = new VideoMotion();
    /**
     * The last millisecond epoch timestamp that the video stream was
     * analyzed.
     * @type {number}
     */

    this._lastUpdate = null;
    /**
     * A flag to determine if this extension has been installed in a project.
     * It is set to false the first time getInfo is run.
     * @type {boolean}
     */

    this.firstInstall = true;

    if (this.runtime.ioDevices) {
      // Configure the video device with values from globally stored locations.
      this.runtime.on(Runtime.PROJECT_LOADED, this.updateVideoDisplay.bind(this)); // Clear target motion state values when the project starts.

      this.runtime.on(Runtime.PROJECT_RUN_START, this.reset.bind(this)); // Kick off looping the analysis logic.

      this._loop();
    }
  }
  /**
   * After analyzing a frame the amount of milliseconds until another frame
   * is analyzed.
   * @type {number}
   */


  static get INTERVAL() {
    return 33;
  }
  /**
   * Dimensions the video stream is analyzed at after its rendered to the
   * sample canvas.
   * @type {Array.<number>}
   */


  static get DIMENSIONS() {
    return [480, 360];
  }
  /**
   * The key to load & store a target's motion-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.videoSensing";
  }
  /**
   * The default motion-related state, to be used when a target has no existing motion state.
   * @type {MotionState}
   */


  static get DEFAULT_MOTION_STATE() {
    return {
      motionFrameNumber: 0,
      motionAmount: 0,
      motionDirection: 0
    };
  }
  /**
   * The transparency setting of the video preview stored in a value
   * accessible by any object connected to the virtual machine.
   * @type {number}
   */


  get globalVideoTransparency() {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      return stage.videoTransparency;
    }

    return 50;
  }

  set globalVideoTransparency(transparency) {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      stage.videoTransparency = transparency;
    }

    return transparency;
  }
  /**
   * The video state of the video preview stored in a value accessible by any
   * object connected to the virtual machine.
   * @type {number}
   */


  get globalVideoState() {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      return stage.videoState;
    } // Though the default value for the stage is normally 'on', we need to default
    // to 'off' here to prevent the video device from briefly activating
    // while waiting for stage targets to be installed that say it should be off


    return VideoState.OFF;
  }

  set globalVideoState(state) {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      stage.videoState = state;
    }

    return state;
  }
  /**
   * Get the latest values for video transparency and state,
   * and set the video device to use them.
   */


  updateVideoDisplay() {
    this.setVideoTransparency({
      TRANSPARENCY: this.globalVideoTransparency
    });
    this.videoToggle({
      VIDEO_STATE: this.globalVideoState
    });
  }
  /**
   * Reset the extension's data motion detection data. This will clear out
   * for example old frames, so the first analyzed frame will not be compared
   * against a frame from before reset was called.
   */


  reset() {
    this.detect.reset();
    const targets = this.runtime.targets;

    for (let i = 0; i < targets.length; i++) {
      const state = targets[i].getCustomState(Scratch3VideoSensingBlocks.STATE_KEY);

      if (state) {
        state.motionAmount = 0;
        state.motionDirection = 0;
      }
    }
  }
  /**
   * Occasionally step a loop to sample the video, stamp it to the preview
   * skin, and add a TypedArray copy of the canvas's pixel data.
   * @private
   */


  _loop() {
    setTimeout(this._loop.bind(this), Math.max(this.runtime.currentStepTime, Scratch3VideoSensingBlocks.INTERVAL)); // Add frame to detector

    const time = Date.now();

    if (this._lastUpdate === null) {
      this._lastUpdate = time;
    }

    const offset = time - this._lastUpdate;

    if (offset > Scratch3VideoSensingBlocks.INTERVAL) {
      const frame = this.runtime.ioDevices.video.getFrame({
        format: Video.FORMAT_IMAGE_DATA,
        dimensions: Scratch3VideoSensingBlocks.DIMENSIONS
      });

      if (frame) {
        this._lastUpdate = time;
        this.detect.addFrame(frame.data);
      }
    }
  }
  /**
   * Create data for a menu in scratch-blocks format, consisting of an array
   * of objects with text and value properties. The text is a translated
   * string, and the value is one-indexed.
   * @param {object[]} info - An array of info objects each having a name
   *   property.
   * @return {array} - An array of objects with text and value properties.
   * @private
   */


  _buildMenu(info) {
    return info.map((entry, index) => {
      const obj = {};
      obj.text = entry.name;
      obj.value = entry.value || String(index + 1);
      return obj;
    });
  }
  /**
   * @param {Target} target - collect motion state for this target.
   * @returns {MotionState} the mutable motion state associated with that
   *   target. This will be created if necessary.
   * @private
   */


  _getMotionState(target) {
    let motionState = target.getCustomState(Scratch3VideoSensingBlocks.STATE_KEY);

    if (!motionState) {
      motionState = Utility.cloneSimple(Scratch3VideoSensingBlocks.DEFAULT_MOTION_STATE);
      target.setCustomState(Scratch3VideoSensingBlocks.STATE_KEY, motionState);
    }

    return motionState;
  }

  static get SensingAttribute() {
    return SensingAttribute;
  }
  /**
   * An array of choices of whether a reporter should return the frame's
   * motion amount or direction.
   * @type {object[]}
   * @param {string} name - the translatable name to display in sensor
   *   attribute menu
   * @param {string} value - the serializable value of the attribute
   */


  get ATTRIBUTE_INFO() {
    return [{
      name: formatMessage({
        id: "videoSensing.motion",
        default: "motion",
        description: 'Attribute for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingAttribute.MOTION
    }, {
      name: formatMessage({
        id: "videoSensing.direction",
        default: "direction",
        description: 'Attribute for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingAttribute.DIRECTION
    }];
  }

  static get SensingSubject() {
    return SensingSubject;
  }
  /**
   * An array of info about the subject choices.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the subject menu
   * @param {string} value - the serializable value of the subject
   */


  get SUBJECT_INFO() {
    return [{
      name: formatMessage({
        id: "videoSensing.sprite",
        default: "sprite",
        description: 'Subject for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingSubject.SPRITE
    }, {
      name: formatMessage({
        id: "videoSensing.stage",
        default: "stage",
        description: 'Subject for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingSubject.STAGE
    }];
  }
  /**
   * States the video sensing activity can be set to.
   * @readonly
   * @enum {string}
   */


  static get VideoState() {
    return VideoState;
  }
  /**
   * An array of info on video state options for the "turn video [STATE]" block.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the video state menu
   * @param {string} value - the serializable value stored in the block
   */


  get VIDEO_STATE_INFO() {
    return [{
      name: formatMessage({
        id: "videoSensing.off",
        default: "off",
        description: 'Option for the "turn video [STATE]" block'
      }),
      value: VideoState.OFF
    }, {
      name: formatMessage({
        id: "videoSensing.on",
        default: "on",
        description: 'Option for the "turn video [STATE]" block'
      }),
      value: VideoState.ON
    }, {
      name: formatMessage({
        id: "videoSensing.onFlipped",
        default: "on flipped",
        description: 'Option for the "turn video [STATE]" block that causes the video to be flipped' + " horizontally (reversed as in a mirror)"
      }),
      value: VideoState.ON_FLIPPED
    }];
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    // Set the video display properties to defaults the first time
    // getInfo is run. This turns on the video device when it is
    // first added to a project, and is overwritten by a PROJECT_LOADED
    // event listener that later calls updateVideoDisplay
    if (this.firstInstall) {
      this.globalVideoState = VideoState.ON;
      this.globalVideoTransparency = 50;
      this.updateVideoDisplay();
      this.firstInstall = false;
    } // Return extension definition


    return {
      id: "videoSensing",
      name: formatMessage({
        id: "videoSensing.categoryName",
        default: "Video Sensing",
        description: "Label for the video sensing extension category"
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        // @todo this hat needs to be set itself to restart existing
        // threads like Scratch 2's behaviour.
        opcode: "whenMotionGreaterThan",
        text: formatMessage({
          id: "videoSensing.whenMotionGreaterThan",
          default: "when video motion > [REFERENCE]",
          description: "Event that triggers when the amount of motion is greater than [REFERENCE]"
        }),
        blockType: BlockType.HAT,
        arguments: {
          REFERENCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 10
          }
        }
      }, {
        opcode: "videoOn",
        blockType: BlockType.REPORTER,
        text: formatMessage({
          id: "videoSensing.videoOn",
          default: "video [ATTRIBUTE] on [SUBJECT]",
          description: "Reporter that returns the amount of [ATTRIBUTE] for the selected [SUBJECT]"
        }),
        arguments: {
          ATTRIBUTE: {
            type: ArgumentType.NUMBER,
            menu: "ATTRIBUTE",
            defaultValue: SensingAttribute.MOTION
          },
          SUBJECT: {
            type: ArgumentType.NUMBER,
            menu: "SUBJECT",
            defaultValue: SensingSubject.SPRITE
          }
        }
      }, {
        opcode: "videoToggle",
        text: formatMessage({
          id: "videoSensing.videoToggle",
          default: "turn video [VIDEO_STATE]",
          description: "Controls display of the video preview layer"
        }),
        arguments: {
          VIDEO_STATE: {
            type: ArgumentType.NUMBER,
            menu: "VIDEO_STATE",
            defaultValue: VideoState.ON
          }
        }
      }, {
        opcode: "setVideoTransparency",
        text: formatMessage({
          id: "videoSensing.setVideoTransparency",
          default: "set video transparency to [TRANSPARENCY]",
          description: "Controls transparency of the video preview layer"
        }),
        arguments: {
          TRANSPARENCY: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }],
      menus: {
        ATTRIBUTE: {
          acceptReporters: true,
          items: this._buildMenu(this.ATTRIBUTE_INFO)
        },
        SUBJECT: {
          acceptReporters: true,
          items: this._buildMenu(this.SUBJECT_INFO)
        },
        VIDEO_STATE: {
          acceptReporters: true,
          items: this._buildMenu(this.VIDEO_STATE_INFO)
        }
      }
    };
  }
  /**
   * Analyze a part of the frame that a target overlaps.
   * @param {Target} target - a target to determine where to analyze
   * @returns {MotionState} the motion state for the given target
   */


  _analyzeLocalMotion(target) {
    const drawable = this.runtime.renderer._allDrawables[target.drawableID];

    const state = this._getMotionState(target);

    this.detect.getLocalMotion(drawable, state);
    return state;
  }
  /**
   * A scratch reporter block handle that analyzes the last two frames and
   * depending on the arguments, returns the motion or direction for the
   * whole stage or just the target sprite.
   * @param {object} args - the block arguments
   * @param {BlockUtility} util - the block utility
   * @returns {number} the motion amount or direction of the stage or sprite
   */


  videoOn(args, util) {
    this.detect.analyzeFrame();
    let state = this.detect;

    if (args.SUBJECT === SensingSubject.SPRITE) {
      state = this._analyzeLocalMotion(util.target);
    }

    if (args.ATTRIBUTE === SensingAttribute.MOTION) {
      return state.motionAmount;
    }

    return state.motionDirection;
  }
  /**
   * A scratch hat block edge handle that analyzes the last two frames where
   * the target sprite overlaps and if it has more motion than the given
   * reference value.
   * @param {object} args - the block arguments
   * @param {BlockUtility} util - the block utility
   * @returns {boolean} true if the sprite overlaps more motion than the
   *   reference
   */


  whenMotionGreaterThan(args, util) {
    this.detect.analyzeFrame();

    const state = this._analyzeLocalMotion(util.target);

    return state.motionAmount > Number(args.REFERENCE);
  }
  /**
   * A scratch command block handle that configures the video state from
   * passed arguments.
   * @param {object} args - the block arguments
   * @param {VideoState} args.VIDEO_STATE - the video state to set the device to
   */


  videoToggle(args) {
    const state = args.VIDEO_STATE;
    this.globalVideoState = state;

    if (state === VideoState.OFF) {
      this.runtime.ioDevices.video.disableVideo();
    } else {
      this.runtime.ioDevices.video.enableVideo(); // Mirror if state is ON. Do not mirror if state is ON_FLIPPED.

      this.runtime.ioDevices.video.mirror = state === VideoState.ON;
    }
  }
  /**
   * A scratch command block handle that configures the video preview's
   * transparency from passed arguments.
   * @param {object} args - the block arguments
   * @param {number} args.TRANSPARENCY - the transparency to set the video
   *   preview to
   */


  setVideoTransparency(args) {
    const transparency = Utility.toNumber(args.TRANSPARENCY);
    this.globalVideoTransparency = transparency;
    this.runtime.ioDevices.video.setPreviewGhost(transparency);
  }

}

module.exports = Scratch3VideoSensingBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_video_sensing/library.js":
/*!**********************************************************!*\
  !*** ./src/extensions/scratch3_video_sensing/library.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @file library.js
 *
 * Tony Hwang and John Maloney, January 2011
 * Michael "Z" Goddard, March 2018
 *
 * Video motion sensing primitives.
 */
const {
  motionVector,
  scratchAtan2
} = __webpack_require__(/*! ./math */ "./src/extensions/scratch3_video_sensing/math.js");
/**
 * The width of the intended resolution to analyze for motion.
 * @type {number}
 */


const WIDTH = 480;
/**
 * The height of the intended resolution to analyze for motion.
 * @type {number}
 */

const HEIGHT = 360;
/**
 * A constant value to scale the magnitude of the x and y components called u
 * and v. This creates the motionAmount value.
 *
 * Old note: chosen empirically to give a range of roughly 0-100
 *
 * @type {number}
 */

const AMOUNT_SCALE = 100;
/**
 * A constant value to scale the magnitude of the x and y components called u
 * and v in the local motion derivative. This creates the motionAmount value on
 * a target's motion state.
 *
 * Old note: note 2e-4 * activePixelNum is an experimentally tuned threshold
 * for my logitech Pro 9000 webcam - TTH
 *
 * @type {number}
 */

const LOCAL_AMOUNT_SCALE = AMOUNT_SCALE * 2e-4;
/**
 * The motion amount must be higher than the THRESHOLD to calculate a new
 * direction value.
 * @type {number}
 */

const THRESHOLD = 10;
/**
 * The size of the radius of the window of summarized values when considering
 * the motion inside the full resolution of the sample.
 * @type {number}
 */

const WINSIZE = 8;
/**
 * A ceiling for the motionAmount stored to a local target's motion state. The
 * motionAmount is not allowed to be larger than LOCAL_MAX_AMOUNT.
 * @type {number}
 */

const LOCAL_MAX_AMOUNT = 100;
/**
 * The motion amount for a target's local motion must be higher than the
 * LOCAL_THRESHOLD to calculate a new direction value.
 * @type {number}
 */

const LOCAL_THRESHOLD = THRESHOLD / 3;
/**
 * Store the necessary image pixel data to compares frames of a video and
 * detect an amount and direction of motion in the full sample or in a
 * specified area.
 * @constructor
 */

class VideoMotion {
  constructor() {
    /**
     * The number of frames that have been added from a source.
     * @type {number}
     */
    this.frameNumber = 0;
    /**
     * The frameNumber last analyzed.
     * @type {number}
     */

    this.lastAnalyzedFrame = 0;
    /**
     * The amount of motion detected in the current frame.
     * @type {number}
     */

    this.motionAmount = 0;
    /**
     * The direction the motion detected in the frame is general moving in.
     * @type {number}
     */

    this.motionDirection = 0;
    /**
     * A copy of the current frame's pixel values. A index of the array is
     * represented in RGBA. The lowest byte is red. The next is green. The
     * next is blue. And the last is the alpha value of that pixel.
     * @type {Uint32Array}
     */

    this.curr = null;
    /**
     * A copy of the last frame's pixel values.
     * @type {Uint32Array}
     */

    this.prev = null;
    /**
     * A buffer for holding one component of a pixel's full value twice.
     * One for the current value. And one for the last value.
     * @type {number}
     */

    this._arrays = new ArrayBuffer(WIDTH * HEIGHT * 2 * 1);
    /**
     * A clamped uint8 view of _arrays. One component of each index of the
     * curr member is copied into this array.
     * @type {number}
     */

    this._curr = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 0 * 1, WIDTH * HEIGHT);
    /**
     * A clamped uint8 view of _arrays. One component of each index of the
     * prev member is copied into this array.
     * @type {number}
     */

    this._prev = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 1 * 1, WIDTH * HEIGHT);
  }
  /**
   * Reset internal state so future frame analysis does not consider values
   * from before this method was called.
   */


  reset() {
    this.frameNumber = 0;
    this.lastAnalyzedFrame = 0;
    this.motionAmount = this.motionDirection = 0;
    this.prev = this.curr = null;
  }
  /**
   * Add a frame to be next analyzed. The passed array represent a pixel with
   * each index in the RGBA format.
   * @param {Uint32Array} source - a source frame of pixels to copy
   */


  addFrame(source) {
    this.frameNumber++; // Swap curr to prev.

    this.prev = this.curr; // Create a clone of the array so any modifications made to the source
    // array do not affect the work done in here.

    this.curr = new Uint32Array(source.buffer.slice(0)); // Swap _prev and _curr. Copy one of the color components of the new
    // array into _curr overwriting what was the old _prev data.

    const _tmp = this._prev;
    this._prev = this._curr;
    this._curr = _tmp;

    for (let i = 0; i < this.curr.length; i++) {
      this._curr[i] = this.curr[i] & 0xff;
    }
  }
  /**
   * Analyze the current frame against the previous frame determining the
   * amount of motion and direction of the motion.
   */


  analyzeFrame() {
    if (!this.curr || !this.prev) {
      this.motionAmount = this.motionDirection = -1; // Don't have two frames to analyze yet

      return;
    } // Return early if new data has not been received.


    if (this.lastAnalyzedFrame === this.frameNumber) {
      return;
    }

    this.lastAnalyzedFrame = this.frameNumber;
    const {
      _curr: curr,
      _prev: prev
    } = this;
    const winStep = WINSIZE * 2 + 1;
    const wmax = WIDTH - WINSIZE - 1;
    const hmax = HEIGHT - WINSIZE - 1; // Accumulate 2d motion vectors from groups of pixels and average it
    // later.

    let uu = 0;
    let vv = 0;
    let n = 0; // Iterate over groups of cells building up the components to determine
    // a motion vector for each cell instead of the whole frame to avoid
    // integer overflows.

    for (let i = WINSIZE + 1; i < hmax; i += winStep) {
      for (let j = WINSIZE + 1; j < wmax; j += winStep) {
        let A2 = 0;
        let A1B2 = 0;
        let B1 = 0;
        let C1 = 0;
        let C2 = 0; // This is a performance critical math region.

        let address = (i - WINSIZE) * WIDTH + j - WINSIZE;
        let nextAddress = address + winStep;
        const maxAddress = (i + WINSIZE) * WIDTH + j + WINSIZE;

        for (; address <= maxAddress; address += WIDTH - winStep, nextAddress += WIDTH) {
          for (; address <= nextAddress; address += 1) {
            // The difference in color between the last frame and
            // the current frame.
            const gradT = prev[address] - curr[address]; // The difference between the pixel to the left and the
            // pixel to the right.

            const gradX = curr[address - 1] - curr[address + 1]; // The difference between the pixel above and the pixel
            // below.

            const gradY = curr[address - WIDTH] - curr[address + WIDTH]; // Add the combined values of this pixel to previously
            // considered pixels.

            A2 += gradX * gradX;
            A1B2 += gradX * gradY;
            B1 += gradY * gradY;
            C2 += gradX * gradT;
            C1 += gradY * gradT;
          }
        } // Use the accumalated values from the for loop to determine a
        // motion direction.


        const {
          u,
          v
        } = motionVector(A2, A1B2, B1, C2, C1); // If u and v are within negative winStep to positive winStep,
        // add them to a sum that will later be averaged.

        if (-winStep < u && u < winStep && -winStep < v && v < winStep) {
          uu += u;
          vv += v;
          n++;
        }
      }
    } // Average the summed vector values of all of the motion groups.


    uu /= n;
    vv /= n; // Scale the magnitude of the averaged UV vector.

    this.motionAmount = Math.round(AMOUNT_SCALE * Math.hypot(uu, vv));

    if (this.motionAmount > THRESHOLD) {
      // Scratch direction
      this.motionDirection = scratchAtan2(vv, uu);
    }
  }
  /**
   * Build motion amount and direction values based on stored current and
   * previous frame that overlaps a given drawable.
   * @param {Drawable} drawable - touchable and bounded drawable to build motion for
   * @param {MotionState} state - state to store built values to
   */


  getLocalMotion(drawable, state) {
    if (!this.curr || !this.prev) {
      state.motionAmount = state.motionDirection = -1; // Don't have two frames to analyze yet

      return;
    } // Skip if the current frame has already been considered for this state.


    if (state.motionFrameNumber !== this.frameNumber) {
      const {
        _prev: prev,
        _curr: curr
      } = this; // The public APIs for Renderer#isTouching manage keeping the matrix and
      // silhouette up-to-date, which is needed for drawable#isTouching to work (used below)

      drawable.updateMatrix();
      if (drawable.skin) drawable.skin.updateSilhouette(); // Restrict the region the amount and direction are built from to
      // the area of the current frame overlapped by the given drawable's
      // bounding box.

      const boundingRect = drawable.getFastBounds(); // Transform the bounding box from scratch space to a space from 0,
      // 0 to WIDTH, HEIGHT.

      const xmin = Math.max(Math.floor(boundingRect.left + WIDTH / 2), 1);
      const xmax = Math.min(Math.floor(boundingRect.right + WIDTH / 2), WIDTH - 1);
      const ymin = Math.max(Math.floor(HEIGHT / 2 - boundingRect.top), 1);
      const ymax = Math.min(Math.floor(HEIGHT / 2 - boundingRect.bottom), HEIGHT - 1);
      let A2 = 0;
      let A1B2 = 0;
      let B1 = 0;
      let C1 = 0;
      let C2 = 0;
      let scaleFactor = 0;
      const position = [0, 0, 0]; // This is a performance critical math region.

      for (let i = ymin; i < ymax; i++) {
        for (let j = xmin; j < xmax; j++) {
          // i and j are in a coordinate planning ranging from 0 to
          // HEIGHT and 0 to WIDTH. Transform that into Scratch's
          // range of HEIGHT / 2 to -HEIGHT / 2 and -WIDTH / 2 to
          // WIDTH / 2;
          position[0] = j - WIDTH / 2;
          position[1] = HEIGHT / 2 - i; // Consider only pixels in the drawable that can touch the
          // edge or other drawables. Empty space in the current skin
          // is skipped.

          if (drawable.isTouching(position)) {
            const address = i * WIDTH + j; // The difference in color between the last frame and
            // the current frame.

            const gradT = prev[address] - curr[address]; // The difference between the pixel to the left and the
            // pixel to the right.

            const gradX = curr[address - 1] - curr[address + 1]; // The difference between the pixel above and the pixel
            // below.

            const gradY = curr[address - WIDTH] - curr[address + WIDTH]; // Add the combined values of this pixel to previously
            // considered pixels.

            A2 += gradX * gradX;
            A1B2 += gradX * gradY;
            B1 += gradY * gradY;
            C2 += gradX * gradT;
            C1 += gradY * gradT;
            scaleFactor++;
          }
        }
      } // Use the accumalated values from the for loop to determine a
      // motion direction.


      let {
        u,
        v
      } = motionVector(A2, A1B2, B1, C2, C1);
      let activePixelNum = 0;

      if (scaleFactor) {
        // Store the area of the sprite in pixels
        activePixelNum = scaleFactor;
        scaleFactor /= 2 * WINSIZE * 2 * WINSIZE;
        u = u / scaleFactor;
        v = v / scaleFactor;
      } // Scale the magnitude of the averaged UV vector and the number of
      // overlapping drawable pixels.


      state.motionAmount = Math.round(LOCAL_AMOUNT_SCALE * activePixelNum * Math.hypot(u, v));

      if (state.motionAmount > LOCAL_MAX_AMOUNT) {
        // Clip all magnitudes greater than 100.
        state.motionAmount = LOCAL_MAX_AMOUNT;
      }

      if (state.motionAmount > LOCAL_THRESHOLD) {
        // Scratch direction.
        state.motionDirection = scratchAtan2(v, u);
      } // Skip future calls on this state until a new frame is added.


      state.motionFrameNumber = this.frameNumber;
    }
  }

}

module.exports = VideoMotion;

/***/ }),

/***/ "./src/extensions/scratch3_video_sensing/math.js":
/*!*******************************************************!*\
  !*** ./src/extensions/scratch3_video_sensing/math.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A constant value helping to transform a value in radians to degrees.
 * @type {number}
 */
const TO_DEGREE = 180 / Math.PI;
/**
 * A object reused to save on memory allocation returning u and v vector from
 * motionVector.
 * @type {UV}
 */

const _motionVectorOut = {
  u: 0,
  v: 0
};
/**
 * Determine a motion vector combinations of the color component difference on
 * the x axis, y axis, and temporal axis.
 * @param {number} A2 - a sum of x axis squared
 * @param {number} A1B2 - a sum of x axis times y axis
 * @param {number} B1 - a sum of y axis squared
 * @param {number} C2 - a sum of x axis times temporal axis
 * @param {number} C1 - a sum of y axis times temporal axis
 * @param {UV} out - optional object to store return UV info in
 * @returns {UV} a uv vector representing the motion for the given input
 */

const motionVector = function (A2, A1B2, B1, C2, C1, out = _motionVectorOut) {
  // Compare sums of X * Y and sums of X squared and Y squared.
  const delta = A1B2 * A1B2 - A2 * B1;

  if (delta) {
    // System is not singular - solving by Kramer method.
    const deltaX = -(C1 * A1B2 - C2 * B1);
    const deltaY = -(A1B2 * C2 - A2 * C1);
    const Idelta = 8 / delta;
    out.u = deltaX * Idelta;
    out.v = deltaY * Idelta;
  } else {
    // Singular system - find optical flow in gradient direction.
    const Norm = (A1B2 + A2) * (A1B2 + A2) + (B1 + A1B2) * (B1 + A1B2);

    if (Norm) {
      const IGradNorm = 8 / Norm;
      const temp = -(C1 + C2) * IGradNorm;
      out.u = (A1B2 + A2) * temp;
      out.v = (B1 + A1B2) * temp;
    } else {
      out.u = 0;
      out.v = 0;
    }
  }

  return out;
};
/**
 * Translate an angle in degrees with the range -180 to 180 rotated to
 * Scratch's reference angle.
 * @param {number} degrees - angle in range -180 to 180
 * @returns {number} angle from Scratch's reference angle
 */


const scratchDegrees = function (degrees) {
  return (degrees + 270) % 360 - 180;
};
/**
 * Get the angle of the y and x component of a 2d vector in degrees in
 * Scratch's coordinate plane.
 * @param {number} y - the y component of a 2d vector
 * @param {number} x - the x component of a 2d vector
 * @returns {number} angle in degrees in Scratch's coordinate plane
 */


const scratchAtan2 = function (y, x) {
  return scratchDegrees(Math.atan2(y, x) * TO_DEGREE);
};

module.exports = {
  motionVector,
  scratchDegrees,
  scratchAtan2
};

/***/ }),

/***/ "./src/extensions/scratch3_wedo2/index.js":
/*!************************************************!*\
  !*** ./src/extensions/scratch3_wedo2/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");

const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const iconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAF8klEQVR4Ae2cbWxTVRjH/7ctbVc2tyEMNpWBk0VIkLcEjSAQgglTE5HEaKqJi1E/mbCP/dJA0kQbvzgTQ0Ki2T7V6AeYGoEPLJmGKPiyzZDwEpYJCHSbQIcbdLvres1zOa13Xbvdu2eTDp9fst329Lnn5XfPPfece7tphmFAmDkuccdDBDIRgUxEIBMRyEQEMhGBTEQgExHIRAQyEYFMRCATEchEBDIRgUxEIBMRyEQEMhGBTEQgExHIxMPNIByNVQBoBUDb7kgo2KTS9wBoUmFNkVCwW6U3A1gP4JJKHwxHY/S+WcW2RkLBVhV7AMAOAIMAGlWstbyOSCh4QMU2Uoy1PBVL+a7IqZu1vOZIKNg20/azBarGvKxebw9HY22RULADwBFLTBcATQnZl4lVEimN4ssteXQrQfstebQpmW1q30xshyqvxRLbofYnYW9ZYgeV8C5LLOWlzbTxM3ouHI7GPgSwWx3Z0syBSBku6IYnlTbM+uQenJQaMnKHDaqAFnDrcCFbl3G1defEjas0a4N/Vz10OybyvapfrSX1sjpo+WIz0ME7QL3djgtHPTAcjb2mepw/b2ZaGh5NL5RnofR8R99dIC5fHusK5JsrCUpm7TSx21XvbcwTNwnbAsPR2GcA3qaG+H0LsHlDPZ7fca/ujZ+cRW9/Em5vCXzlNVhQUjFpf/3OTSRvXkKJz43Xt1bh1S1LUeq/5+njQ9/iVmLIfL1ieRU2b1iFtavztXNu6TrTi8PfnYI67WdPoOp5przV9Y8iuHdb9rOW9uumPI+vDIElddBckztPOqVn5X36Xj1WVQeynx1sOWbK83jc2PviM/dFXIYNax9H55leXLoyYHsfWwI14JCRRx7x5ckBU1oheYQ+1G9u39lVM0Hej7+cR7w/Yb7e9+5LqChfaLvixcK088BwNNZkAOV02ubK6+odwt3RcfOULSSPGEveG48bNj08If3kqXPmdtO6unkpDzYn0u/TLxrzcumJJ80Ut79sygzoFF6/siw75mUYupOEpmnY0/A0pw33FTsCa+hX5oJhZXgkZb5zub2O20CnL7EwkPeCPm+wI7CEBvi5wuOZ36tJW7X3uGXJXAgxk8P4eNpRPEvgskqfuR0Z/BNGejxvDM3/5gs0pboWv+motqybCc+tqUCzz43kaBJ/X+2eMjZ3ClNsjIzo5ioknXZ2b4AlkKYltLJoaY9jOJm/B0KJbtg4c4F/XOmH3+dF9dLKbBo1OD6QQGV56YQ55ODtO0jcHkZ1VSX8/n9nB9S7RkZ1rFy+NG8ZR9s70TeQQKDEh7vJUdt1Y9/OopXFB2/WcbMpyOexE9mlFS21aLlHMmKHfzBl0QT/hV2bzM9oLXv0xG8YGR0zpdLEn6RT2k+/XjDzoLX2G3u3TZBLUyral/Z5qCyAK1f/sl2/or+IWNel1Eji3MWrpjyCZHWqdNrSe6ieSHFERl4mP+q5GehgHGvvRGal5XI5uzU47f3A/R99YTgdF2wXrmkolr9ToZ5NvTjT4yOhoC2T057CJM/r9WDxoqmXa07R9THcuDVcMO8bt4ag6ynULKvkFjWBTLl0ugZKvNlyqLeSQKfYGgOpgXt2b5zVhlzrS+Dr451YvKg0b95txztxvS8xZ+VuXFuLJ5+oNgV+9c3PuHDxGs6cu+w4v//9RJo6x5bN9UgbBo4cPY1U6j+cSD8orFvzGFYuX4KxsRQGbth6FCICc9m5dY05HtN46AQRqPB5PWjY+ZT5RnMwkxGBFh5ZVmle9Z3MrGbjwfqccrC1vajrV7QCaVCfS6qrJj96nQlFK5CujPRT7MgYyEQEMhGBTGwJpAW4kJ9pBbo0zbx70X7y7AOv8HxP3LyB4YTpb2cZBt2iqL3QEwf9zDbX+waLca439QMeC7a+YBmOxugLiM/OTt2yaOoMoO+H6LOcNwf6xusrthsh/7mIh1yFmYhAJiKQiQhkIgKZiEAmIpCJCGQiApmIQCYikIkIZCICmYhAJiKQiQhkIgKZiEAmIpCJCGQiAjkA+AeOwQKMcWZqHgAAAABJRU5ErkJggg==";
/**
 * A list of WeDo 2.0 BLE service UUIDs.
 * @enum
 */

const BLEService = {
  DEVICE_SERVICE: "00001523-1212-efde-1523-785feabcd123",
  IO_SERVICE: "00004f0e-1212-efde-1523-785feabcd123"
};
/**
 * A list of WeDo 2.0 BLE characteristic UUIDs.
 *
 * Characteristics on DEVICE_SERVICE:
 * - ATTACHED_IO
 *
 * Characteristics on IO_SERVICE:
 * - INPUT_VALUES
 * - INPUT_COMMAND
 * - OUTPUT_COMMAND
 *
 * @enum
 */

const BLECharacteristic = {
  ATTACHED_IO: "00001527-1212-efde-1523-785feabcd123",
  LOW_VOLTAGE_ALERT: "00001528-1212-efde-1523-785feabcd123",
  INPUT_VALUES: "00001560-1212-efde-1523-785feabcd123",
  INPUT_COMMAND: "00001563-1212-efde-1523-785feabcd123",
  OUTPUT_COMMAND: "00001565-1212-efde-1523-785feabcd123"
};
/**
 * A time interval to wait (in milliseconds) in between battery check calls.
 * @type {number}
 */

const BLEBatteryCheckInterval = 5000;
/**
 * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
 * @type {number}
 */

const BLESendInterval = 100;
/**
 * A maximum number of BLE message sends per second, to be enforced by the rate limiter.
 * @type {number}
 */

const BLESendRateMax = 20;
/**
 * Enum for WeDo 2.0 sensor and output types.
 * @readonly
 * @enum {number}
 */

const WeDo2Device = {
  MOTOR: 1,
  PIEZO: 22,
  LED: 23,
  TILT: 34,
  DISTANCE: 35
};
/**
 * Enum for connection/port ids assigned to internal WeDo 2.0 output devices.
 * @readonly
 * @enum {number}
 */
// TODO: Check for these more accurately at startup?

const WeDo2ConnectID = {
  LED: 6,
  PIEZO: 5
};
/**
 * Enum for ids for various output commands on the WeDo 2.0.
 * @readonly
 * @enum {number}
 */

const WeDo2Command = {
  MOTOR_POWER: 1,
  PLAY_TONE: 2,
  STOP_TONE: 3,
  WRITE_RGB: 4,
  SET_VOLUME: 255
};
/**
 * Enum for modes for input sensors on the WeDo 2.0.
 * @enum {number}
 */

const WeDo2Mode = {
  TILT: 0,
  // angle
  DISTANCE: 0,
  // detect
  LED: 1 // RGB

};
/**
 * Enum for units for input sensors on the WeDo 2.0.
 *
 * 0 = raw
 * 1 = percent
 *
 * @enum {number}
 */

const WeDo2Unit = {
  TILT: 0,
  DISTANCE: 1,
  LED: 0
};
/**
 * Manage power, direction, and timers for one WeDo 2.0 motor.
 */

class WeDo2Motor {
  /**
   * Construct a WeDo 2.0 Motor instance.
   * @param {WeDo2} parent - the WeDo 2.0 peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   */
  constructor(parent, index) {
    /**
     * The WeDo 2.0 peripheral which owns this motor.
     * @type {WeDo2}
     * @private
     */
    this._parent = parent;
    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */

    this._index = index;
    /**
     * This motor's current direction: 1 for "this way" or -1 for "that way"
     * @type {number}
     * @private
     */

    this._direction = 1;
    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */

    this._power = 100;
    /**
     * Is this motor currently moving?
     * @type {boolean}
     * @private
     */

    this._isOn = false;
    /**
     * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for
     * the end-of-action handler. Cancel this when changing plans.
     * @type {Object}
     * @private
     */

    this._pendingTimeoutId = null;
    /**
     * The starting time for the pending timeout.
     * @type {Object}
     * @private
     */

    this._pendingTimeoutStartTime = null;
    /**
     * The delay/duration of the pending timeout.
     * @type {Object}
     * @private
     */

    this._pendingTimeoutDelay = null;
    this.startBraking = this.startBraking.bind(this);
    this.turnOff = this.turnOff.bind(this);
  }
  /**
   * @return {number} - the duration of active braking after a call to startBraking(). Afterward, turn the motor off.
   * @constructor
   */


  static get BRAKE_TIME_MS() {
    return 1000;
  }
  /**
   * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
   */


  get direction() {
    return this._direction;
  }
  /**
   * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
   */


  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }
  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */


  get power() {
    return this._power;
  }
  /**
   * @param {int} value - this motor's new power level, in the range [0,100].
   */


  set power(value) {
    const p = Math.max(0, Math.min(value, 100)); // Lego Wedo 2.0 hub only turns motors at power range [30 - 100], so
    // map value from [0 - 100] to [30 - 100].

    if (p === 0) {
      this._power = 0;
    } else {
      const delta = 100 / p;
      this._power = 30 + 70 / delta;
    }
  }
  /**
   * @return {boolean} - true if this motor is currently moving, false if this motor is off or braking.
   */


  get isOn() {
    return this._isOn;
  }
  /**
   * @return {boolean} - time, in milliseconds, of when the pending timeout began.
   */


  get pendingTimeoutStartTime() {
    return this._pendingTimeoutStartTime;
  }
  /**
   * @return {boolean} - delay, in milliseconds, of the pending timeout.
   */


  get pendingTimeoutDelay() {
    return this._pendingTimeoutDelay;
  }
  /**
   * Turn this motor on indefinitely.
   */


  turnOn() {
    if (this._power === 0) return;

    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [this._power * this._direction] // power in range 0-100
    );

    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);

    this._isOn = true;

    this._clearTimeout();
  }
  /**
   * Turn this motor on for a specific duration.
   * @param {number} milliseconds - run the motor for this long.
   */


  turnOnFor(milliseconds) {
    if (this._power === 0) return;
    milliseconds = Math.max(0, milliseconds);
    this.turnOn();

    this._setNewTimeout(this.startBraking, milliseconds);
  }
  /**
   * Start active braking on this motor. After a short time, the motor will turn off.
   */


  startBraking() {
    if (this._power === 0) return;

    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [127] // 127 = break
    );

    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);

    this._isOn = false;

    this._setNewTimeout(this.turnOff, WeDo2Motor.BRAKE_TIME_MS);
  }
  /**
   * Turn this motor off.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   */


  turnOff(useLimiter = true) {
    if (this._power === 0) return;

    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [0] // 0 = stop
    );

    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd, useLimiter);

    this._isOn = false;
  }
  /**
   * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.
   * @private
   */


  _clearTimeout() {
    if (this._pendingTimeoutId !== null) {
      clearTimeout(this._pendingTimeoutId);
      this._pendingTimeoutId = null;
      this._pendingTimeoutStartTime = null;
      this._pendingTimeoutDelay = null;
    }
  }
  /**
   * Set a new motor action timeout, after clearing an existing one if necessary.
   * @param {Function} callback - to be called at the end of the timeout.
   * @param {int} delay - wait this many milliseconds before calling the callback.
   * @private
   */


  _setNewTimeout(callback, delay) {
    this._clearTimeout();

    const timeoutID = setTimeout(() => {
      if (this._pendingTimeoutId === timeoutID) {
        this._pendingTimeoutId = null;
        this._pendingTimeoutStartTime = null;
        this._pendingTimeoutDelay = null;
      }

      callback();
    }, delay);
    this._pendingTimeoutId = timeoutID;
    this._pendingTimeoutStartTime = Date.now();
    this._pendingTimeoutDelay = delay;
  }

}
/**
 * Manage communication with a WeDo 2.0 peripheral over a Bluetooth Low Energy client socket.
 */


class WeDo2 {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    this._runtime.on("PROJECT_STOP_ALL", this.stopAll.bind(this));
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * A list of the ids of the motors or sensors in ports 1 and 2.
     * @type {string[]}
     * @private
     */

    this._ports = ["none", "none"];
    /**
     * The motors which this WeDo 2.0 could possibly have.
     * @type {WeDo2Motor[]}
     * @private
     */

    this._motors = [null, null];
    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */

    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      distance: 0
    };
    /**
     * The Bluetooth connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * A rate limiter utility, to help limit the rate at which we send BLE messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */


    this._rateLimiter = new RateLimiter(BLESendRateMax);
    /**
     * An interval id for the battery check interval.
     * @type {number}
     * @private
     */

    this._batteryLevelIntervalId = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._checkBatteryLevel = this._checkBatteryLevel.bind(this);
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */


  get tiltX() {
    return this._sensors.tiltX;
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */


  get tiltY() {
    return this._sensors.tiltY;
  }
  /**
   * @return {number} - the latest value received from the distance sensor.
   */


  get distance() {
    return this._sensors.distance;
  }
  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the zero-based index of the desired motor.
   * @return {WeDo2Motor} - the WeDo2Motor instance, if any, at that index.
   */


  motor(index) {
    return this._motors[index];
  }
  /**
   * Stop all the motors that are currently running.
   */


  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        // Send the motor off command without using the rate limiter.
        // This allows the stop button to stop motors even if we are
        // otherwise flooded with commands.
        motor.turnOff(false);
      }
    });
  }
  /**
   * Set the WeDo 2.0 peripheral's LED to a specific color.
   * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.
   * @return {Promise} - a promise of the completion of the set led send operation.
   */


  setLED(inputRGB) {
    const rgb = [inputRGB >> 16 & 0x000000ff, inputRGB >> 8 & 0x000000ff, inputRGB & 0x000000ff];
    const cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, rgb);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }
  /**
   * Sets the input mode of the LED to RGB.
   * @return {Promise} - a promise returned by the send operation.
   */


  setLEDMode() {
    const cmd = this.generateInputCommand(WeDo2ConnectID.LED, WeDo2Device.LED, WeDo2Mode.LED, 0, WeDo2Unit.LED, false);
    return this.send(BLECharacteristic.INPUT_COMMAND, cmd);
  }
  /**
   * Switch off the LED on the WeDo 2.0.
   * @return {Promise} - a promise of the completion of the stop led send operation.
   */


  stopLED() {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, [0, 0, 0]);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }
  /**
   * Play a tone from the WeDo 2.0 peripheral for a specific amount of time.
   * @param {int} tone - the pitch of the tone, in Hz.
   * @param {int} milliseconds - the duration of the note, in milliseconds.
   * @return {Promise} - a promise of the completion of the play tone send operation.
   */


  playTone(tone, milliseconds) {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.PLAY_TONE, [tone, tone >> 8, milliseconds, milliseconds >> 8]);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }
  /**
   * Stop the tone playing from the WeDo 2.0 peripheral, if any.
   * @return {Promise} - a promise that the command sent.
   */


  stopTone() {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.STOP_TONE); // Send this command without using the rate limiter, because it is
    // only triggered by the stop button.

    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd, false);
  }
  /**
   * Stop the tone playing and motors on the WeDo 2.0 peripheral.
   */


  stopAll() {
    if (!this.isConnected()) return;
    this.stopTone();
    this.stopAllMotors();
  }
  /**
   * Called by the runtime when user wants to scan for a WeDo 2.0 peripheral.
   */


  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BLEService.DEVICE_SERVICE]
      }],
      optionalServices: [BLEService.IO_SERVICE]
    }, this._onConnect, this.reset);
  }
  /**
   * Called by the runtime when user wants to connect to a certain WeDo 2.0 peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }
  /**
   * Disconnects from the current BLE socket.
   */


  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    this._ports = ["none", "none"];
    this._motors = [null, null];
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      distance: 0
    };

    if (this._batteryLevelIntervalId) {
      window.clearInterval(this._batteryLevelIntervalId);
      this._batteryLevelIntervalId = null;
    }
  }
  /**
   * Called by the runtime to detect whether the WeDo 2.0 peripheral is connected.
   * @return {boolean} - the connected state.
   */


  isConnected() {
    let connected = false;

    if (this._ble) {
      connected = this._ble.isConnected();
    }

    return connected;
  }
  /**
   * Write a message to the WeDo 2.0 peripheral BLE socket.
   * @param {number} uuid - the UUID of the characteristic to write to
   * @param {Array} message - the message to write.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the write operation
   */


  send(uuid, message, useLimiter = true) {
    if (!this.isConnected()) return Promise.resolve();

    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }

    return this._ble.write(BLEService.IO_SERVICE, uuid, Utility.uint8ArrayToBase64(message), "base64");
  }
  /**
   * Generate a WeDo 2.0 'Output Command' in the byte array format
   * (CONNECT ID, COMMAND ID, NUMBER OF BYTES, VALUES ...).
   *
   * This sends a command to the WeDo 2.0 to actuate the specified outputs.
   *
   * @param  {number} connectID - the port (Connect ID) to send a command to.
   * @param  {number} commandID - the id of the byte command.
   * @param  {array}  values    - the list of values to write to the command.
   * @return {array}            - a generated output command.
   */


  generateOutputCommand(connectID, commandID, values = null) {
    let command = [connectID, commandID];

    if (values) {
      command = command.concat(values.length).concat(values);
    }

    return command;
  }
  /**
   * Generate a WeDo 2.0 'Input Command' in the byte array format
   * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),
   * UNIT, NOTIFICATIONS ENABLED).
   *
   * This sends a command to the WeDo 2.0 that sets that input format
   * of the specified inputs and sets value change notifications.
   *
   * @param  {number}  connectID           - the port (Connect ID) to send a command to.
   * @param  {number}  type                - the type of input sensor.
   * @param  {number}  mode                - the mode of the input sensor.
   * @param  {number}  delta               - the delta change needed to trigger notification.
   * @param  {array}   units               - the unit of the input sensor value.
   * @param  {boolean} enableNotifications - whether to enable notifications.
   * @return {array}                       - a generated input command.
   */


  generateInputCommand(connectID, type, mode, delta, units, enableNotifications) {
    const command = [1, // Command ID = 1 = "Sensor Format"
    2, // Command Type = 2 = "Write"
    connectID, type, mode, delta, 0, // Delta Interval Byte 2
    0, // Delta Interval Byte 3
    0, // Delta Interval Byte 4
    units, enableNotifications ? 1 : 0];
    return command;
  }
  /**
   * Sets LED mode and initial color and starts reading data from peripheral after BLE has connected.
   * @private
   */


  _onConnect() {
    this.setLEDMode();
    this.setLED(0x0000ff);

    this._ble.startNotifications(BLEService.DEVICE_SERVICE, BLECharacteristic.ATTACHED_IO, this._onMessage);

    this._batteryLevelIntervalId = window.setInterval(this._checkBatteryLevel, BLEBatteryCheckInterval);
  }
  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */


  _onMessage(base64) {
    const data = Utility.base64ToUint8Array(base64); // log.info(data);

    /**
     * If first byte of data is '1' or '2', then either clear the
     * sensor present in ports 1 or 2 or set their format.
     *
     * If first byte of data is anything else, read incoming sensor value.
     */

    switch (data[0]) {
      case 1:
      case 2:
        {
          const connectID = data[0];

          if (data[1] === 0) {
            // clear sensor or motor
            this._clearPort(connectID);
          } else {
            // register sensor or motor
            this._registerSensorOrMotor(connectID, data[3]);
          }

          break;
        }

      default:
        {
          // read incoming sensor value
          const connectID = data[1];
          const type = this._ports[connectID - 1];

          if (type === WeDo2Device.DISTANCE) {
            this._sensors.distance = data[2];
          }

          if (type === WeDo2Device.TILT) {
            this._sensors.tiltX = data[2];
            this._sensors.tiltY = data[3];
          }

          break;
        }
    }
  }
  /**
   * Check the battery level on the WeDo 2.0. If the WeDo 2.0 has disconnected
   * for some reason, the BLE socket will get an error back and automatically
   * close the socket.
   */


  _checkBatteryLevel() {
    this._ble.read(BLEService.DEVICE_SERVICE, BLECharacteristic.LOW_VOLTAGE_ALERT, false);
  }
  /**
   * Register a new sensor or motor connected at a port.  Store the type of
   * sensor or motor internally, and then register for notifications on input
   * values if it is a sensor.
   * @param {number} connectID - the port to register a sensor or motor on.
   * @param {number} type - the type ID of the sensor or motor
   * @private
   */


  _registerSensorOrMotor(connectID, type) {
    // Record which port is connected to what type of device
    this._ports[connectID - 1] = type; // Record motor port

    if (type === WeDo2Device.MOTOR) {
      this._motors[connectID - 1] = new WeDo2Motor(this, connectID - 1);
    } else {
      // Set input format for tilt or distance sensor
      const typeString = type === WeDo2Device.DISTANCE ? "DISTANCE" : "TILT";
      const cmd = this.generateInputCommand(connectID, type, WeDo2Mode[typeString], 1, WeDo2Unit[typeString], true);
      this.send(BLECharacteristic.INPUT_COMMAND, cmd);

      this._ble.startNotifications(BLEService.IO_SERVICE, BLECharacteristic.INPUT_VALUES, this._onMessage);
    }
  }
  /**
   * Clear the sensor or motor present at port 1 or 2.
   * @param {number} connectID - the port to clear.
   * @private
   */


  _clearPort(connectID) {
    const type = this._ports[connectID - 1];

    if (type === WeDo2Device.TILT) {
      this._sensors.tiltX = this._sensors.tiltY = 0;
    }

    if (type === WeDo2Device.DISTANCE) {
      this._sensors.distance = 0;
    }

    this._ports[connectID - 1] = "none";
    this._motors[connectID - 1] = null;
  }

}
/**
 * Enum for motor specification.
 * @readonly
 * @enum {string}
 */


const WeDo2MotorLabel = {
  DEFAULT: "motor",
  A: "motor A",
  B: "motor B",
  ALL: "all motors"
};
/**
 * Enum for motor direction specification.
 * @readonly
 * @enum {string}
 */

const WeDo2MotorDirection = {
  FORWARD: "this way",
  BACKWARD: "that way",
  REVERSE: "reverse"
};
/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */

const WeDo2TiltDirection = {
  UP: "up",
  DOWN: "down",
  LEFT: "left",
  RIGHT: "right",
  ANY: "any"
};
/**
 * Scratch 3.0 blocks to interact with a LEGO WeDo 2.0 peripheral.
 */

class Scratch3WeDo2Blocks {
  /**
   * @return {string} - the ID of this extension.
   */
  static get EXTENSION_ID() {
    return "wedo2";
  }
  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */


  static get TILT_THRESHOLD() {
    return 15;
  }
  /**
   * Construct a set of WeDo 2.0 blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new WeDo 2.0 peripheral instance

    this._peripheral = new WeDo2(this.runtime, Scratch3WeDo2Blocks.EXTENSION_ID);
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: Scratch3WeDo2Blocks.EXTENSION_ID,
      name: "WeDo 2.0",
      blockIconURI: iconURI,
      showStatusButton: true,
      blocks: [{
        opcode: "motorOnFor",
        text: formatMessage({
          id: "wedo2.motorOnFor",
          default: "turn [MOTOR_ID] on for [DURATION] seconds",
          description: "turn a motor on for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: "motorOn",
        text: formatMessage({
          id: "wedo2.motorOn",
          default: "turn [MOTOR_ID] on",
          description: "turn a motor on indefinitely"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: WeDo2MotorLabel.DEFAULT
          }
        }
      }, {
        opcode: "motorOff",
        text: formatMessage({
          id: "wedo2.motorOff",
          default: "turn [MOTOR_ID] off",
          description: "turn a motor off"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: WeDo2MotorLabel.DEFAULT
          }
        }
      }, {
        opcode: "startMotorPower",
        text: formatMessage({
          id: "wedo2.startMotorPower",
          default: "set [MOTOR_ID] power to [POWER]",
          description: "set the motor's power and turn it on"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: "setMotorDirection",
        text: formatMessage({
          id: "wedo2.setMotorDirection",
          default: "set [MOTOR_ID] direction to [MOTOR_DIRECTION]",
          description: "set the motor's turn direction"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          MOTOR_DIRECTION: {
            type: ArgumentType.STRING,
            menu: "MOTOR_DIRECTION",
            defaultValue: WeDo2MotorDirection.FORWARD
          }
        }
      }, {
        opcode: "setLightHue",
        text: formatMessage({
          id: "wedo2.setLightHue",
          default: "set light color to [HUE]",
          description: "set the LED color"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: "playNoteFor",
        text: formatMessage({
          id: "wedo2.playNoteFor",
          default: "play note [NOTE] for [DURATION] seconds",
          description: "play a certain note for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          NOTE: {
            type: ArgumentType.NUMBER,
            // TODO: ArgumentType.MIDI_NOTE?
            defaultValue: 60
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.5
          }
        },
        hideFromPalette: true
      }, {
        opcode: "whenDistance",
        text: formatMessage({
          id: "wedo2.whenDistance",
          default: "when distance [OP] [REFERENCE]",
          description: "check for when distance is < or > than reference"
        }),
        blockType: BlockType.HAT,
        arguments: {
          OP: {
            type: ArgumentType.STRING,
            menu: "OP",
            defaultValue: "<"
          },
          REFERENCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: "whenTilted",
        text: formatMessage({
          id: "wedo2.whenTilted",
          default: "when tilted [TILT_DIRECTION_ANY]",
          description: "check when tilted in a certain direction"
        }),
        func: "isTilted",
        blockType: BlockType.HAT,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: "TILT_DIRECTION_ANY",
            defaultValue: WeDo2TiltDirection.ANY
          }
        }
      }, {
        opcode: "getDistance",
        text: formatMessage({
          id: "wedo2.getDistance",
          default: "distance",
          description: "the value returned by the distance sensor"
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: "isTilted",
        text: formatMessage({
          id: "wedo2.isTilted",
          default: "tilted [TILT_DIRECTION_ANY]?",
          description: "whether the tilt sensor is tilted"
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: "TILT_DIRECTION_ANY",
            defaultValue: WeDo2TiltDirection.ANY
          }
        }
      }, {
        opcode: "getTiltAngle",
        text: formatMessage({
          id: "wedo2.getTiltAngle",
          default: "tilt angle [TILT_DIRECTION]",
          description: "the angle returned by the tilt sensor"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          TILT_DIRECTION: {
            type: ArgumentType.STRING,
            menu: "TILT_DIRECTION",
            defaultValue: WeDo2TiltDirection.UP
          }
        }
      }],
      menus: {
        MOTOR_ID: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "wedo2.motorId.default",
              default: "motor",
              description: "label for motor element in motor menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorLabel.DEFAULT
          }, {
            text: formatMessage({
              id: "wedo2.motorId.a",
              default: "motor A",
              description: "label for motor A element in motor menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorLabel.A
          }, {
            text: formatMessage({
              id: "wedo2.motorId.b",
              default: "motor B",
              description: "label for motor B element in motor menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorLabel.B
          }, {
            text: formatMessage({
              id: "wedo2.motorId.all",
              default: "all motors",
              description: "label for all motors element in motor menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorLabel.ALL
          }]
        },
        MOTOR_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "wedo2.motorDirection.forward",
              default: "this way",
              description: "label for forward element in motor direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorDirection.FORWARD
          }, {
            text: formatMessage({
              id: "wedo2.motorDirection.backward",
              default: "that way",
              description: "label for backward element in motor direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorDirection.BACKWARD
          }, {
            text: formatMessage({
              id: "wedo2.motorDirection.reverse",
              default: "reverse",
              description: "label for reverse element in motor direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorDirection.REVERSE
          }]
        },
        TILT_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "wedo2.tiltDirection.up",
              default: "up",
              description: "label for up element in tilt direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2TiltDirection.UP
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.down",
              default: "down",
              description: "label for down element in tilt direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2TiltDirection.DOWN
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.left",
              default: "left",
              description: "label for left element in tilt direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2TiltDirection.LEFT
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.right",
              default: "right",
              description: "label for right element in tilt direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2TiltDirection.RIGHT
          }]
        },
        TILT_DIRECTION_ANY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "wedo2.tiltDirection.up",
              default: "up"
            }),
            value: WeDo2TiltDirection.UP
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.down",
              default: "down"
            }),
            value: WeDo2TiltDirection.DOWN
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.left",
              default: "left"
            }),
            value: WeDo2TiltDirection.LEFT
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.right",
              default: "right"
            }),
            value: WeDo2TiltDirection.RIGHT
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.any",
              default: "any",
              description: "label for any element in tilt direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2TiltDirection.ANY
          }]
        },
        OP: {
          acceptReporters: true,
          items: ["<", ">"]
        }
      }
    };
  }
  /**
   * Turn specified motor(s) on for a specified duration.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} DURATION - the amount of time to run the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  motorOnFor(args) {
    // TODO: cast args.MOTOR_ID?
    let durationMS = Utility.toNumber(args.DURATION) * 1000;
    durationMS = Utility.clamp(durationMS, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(args.MOTOR_ID, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) {
          motor.turnOnFor(durationMS);
        }
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, durationMS);
    });
  }
  /**
   * Turn specified motor(s) on indefinitely.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOn(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.turnOn();
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOff(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.turnOff();
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {int} POWER - the new power level for the motor(s).
   * @return {Promise} - a Promise that resolves after some delay.
   */


  startMotorPower(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.power = Utility.clamp(Utility.toNumber(args.POWER), 0, 100);
        motor.turnOn();
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Set the direction of rotation for specified motor(s).
   * If the direction is 'reverse' the motor(s) will be reversed individually.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).
   * @return {Promise} - a Promise that resolves after some delay.
   */


  setMotorDirection(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        switch (args.MOTOR_DIRECTION) {
          case WeDo2MotorDirection.FORWARD:
            motor.direction = 1;
            break;

          case WeDo2MotorDirection.BACKWARD:
            motor.direction = -1;
            break;

          case WeDo2MotorDirection.REVERSE:
            motor.direction = -motor.direction;
            break;

          default:
            console.warn(`Unknown motor direction in setMotorDirection: ${args.DIRECTION}`);
            break;
        } // keep the motor on if it's running, and update the pending timeout if needed


        if (motor.isOn) {
          if (motor.pendingTimeoutDelay) {
            motor.turnOnFor(motor.pendingTimeoutStartTime + motor.pendingTimeoutDelay - Date.now());
          } else {
            motor.turnOn();
          }
        }
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Set the LED's hue.
   * @param {object} args - the block's arguments.
   * @property {number} HUE - the hue to set, in the range [0,100].
   * @return {Promise} - a Promise that resolves after some delay.
   */


  setLightHue(args) {
    // Convert from [0,100] to [0,360]
    let inputHue = Utility.toNumber(args.HUE);
    inputHue = Utility.wrapClamp(inputHue, 0, 100);
    const hue = inputHue * 360 / 100;
    const rgbObject = Utility.hsvToRgb({
      h: hue,
      s: 1,
      v: 1
    });
    const rgbDecimal = color.rgbToDecimal(rgbObject);

    this._peripheral.setLED(rgbDecimal);

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Make the WeDo 2.0 peripheral play a MIDI note for the specified duration.
   * @param {object} args - the block's arguments.
   * @property {number} NOTE - the MIDI note to play.
   * @property {number} DURATION - the duration of the note, in seconds.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  playNoteFor(args) {
    let durationMS = Utility.toNumber(args.DURATION) * 1000;
    durationMS = Utility.clamp(durationMS, 0, 3000);
    const note = Utility.clamp(Utility.toNumber(args.NOTE), 25, 125); // valid WeDo 2.0 sounds

    if (durationMS === 0) return; // WeDo 2.0 plays duration '0' forever

    return new Promise(resolve => {
      const tone = this._noteToTone(note);

      this._peripheral.playTone(tone, durationMS); // Run for some time even when no piezo is connected


      setTimeout(resolve, durationMS);
    });
  }
  /**
   * Compare the distance sensor's value to a reference.
   * @param {object} args - the block's arguments.
   * @property {string} OP - the comparison operation: '<' or '>'.
   * @property {number} REFERENCE - the value to compare against.
   * @return {boolean} - the result of the comparison, or false on error.
   */


  whenDistance(args) {
    switch (args.OP) {
      case "<":
        return this._peripheral.distance < Utility.toNumber(args.REFERENCE);

      case ">":
        return this._peripheral.distance > Utility.toNumber(args.REFERENCE);

      default:
        console.warn(`Unknown comparison operator in whenDistance: ${args.OP}`);
        return false;
    }
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  whenTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * @return {number} - the distance sensor's value, scaled to the [0,100] range.
   */


  getDistance() {
    return this._peripheral.distance;
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  isTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   */


  getTiltAngle(args) {
    return this._getTiltAngle(args.TILT_DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */


  _isTilted(direction) {
    switch (direction) {
      case WeDo2TiltDirection.ANY:
        return this._getTiltAngle(WeDo2TiltDirection.UP) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.DOWN) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.LEFT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.RIGHT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;

      default:
        return this._getTiltAngle(direction) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;
    }
  }
  /**
   * @param {TiltDirection} direction - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */


  _getTiltAngle(direction) {
    switch (direction) {
      case WeDo2TiltDirection.UP:
        return this._peripheral.tiltY > 45 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;

      case WeDo2TiltDirection.DOWN:
        return this._peripheral.tiltY > 45 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;

      case WeDo2TiltDirection.LEFT:
        return this._peripheral.tiltX > 45 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;

      case WeDo2TiltDirection.RIGHT:
        return this._peripheral.tiltX > 45 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;

      default:
        console.warn(`Unknown tilt direction in _getTiltAngle: ${direction}`);
    }
  }
  /**
   * Call a callback for each motor indexed by the provided motor ID.
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */


  _forEachMotor(motorID, callback) {
    let motors;

    switch (motorID) {
      case WeDo2MotorLabel.A:
        motors = [0];
        break;

      case WeDo2MotorLabel.B:
        motors = [1];
        break;

      case WeDo2MotorLabel.ALL:
      case WeDo2MotorLabel.DEFAULT:
        motors = [0, 1];
        break;

      default:
        console.warn(`Invalid motor ID: ${motorID}`);
        motors = [];
        break;
    }

    for (const index of motors) {
      callback(index);
    }
  }
  /**
   * @param {number} midiNote - the MIDI note value to convert.
   * @return {number} - the frequency, in Hz, corresponding to that MIDI note value.
   * @private
   */


  _noteToTone(midiNote) {
    // Note that MIDI note 69 is A4, 440 Hz
    return 440 * Math.pow(2, (midiNote - 69) / 12);
  }

}

module.exports = Scratch3WeDo2Blocks;

/***/ }),

/***/ "./src/import/load-costume.js":
/*!************************************!*\
  !*** ./src/import/load-costume.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const loadVector_ = function (costume, runtime, rotationCenter, optVersion) {
  return new Promise(resolve => {
    let svgString = costume.asset.decodeText(); // SVG RendererScratch 2

    if (optVersion && optVersion === 2 && !runtime.v2SvgAdapter) {
      console.error("No V2 SVG adapter present; SVGs may not render correctly.");
    } else if (optVersion && optVersion === 2 && runtime.v2SvgAdapter) {
      runtime.v2SvgAdapter.loadString(svgString, true
      /* fromVersion2 */
      );
      svgString = runtime.v2SvgAdapter.toString(); // 

      const storage = runtime.storage;
      costume.asset.encodeTextData(svgString, storage.DataFormat.SVG, true);
      costume.assetId = costume.asset.assetId;
      costume.md5 = `${costume.assetId}.${costume.dataFormat}`;
    } // rotationCentercreateSVGSkin


    costume.skinId = runtime.renderer.createSVGSkin(svgString, rotationCenter);
    costume.size = runtime.renderer.getSkinSize(costume.skinId); // rotationCenter

    if (!rotationCenter) {
      rotationCenter = runtime.renderer.getSkinRotationCenter(costume.skinId);
      costume.rotationCenterX = rotationCenter[0];
      costume.rotationCenterY = rotationCenter[1];
      costume.bitmapResolution = 1;
    }

    resolve(costume);
  });
};

const canvasPool = function () {
  /**
   * ..
   */
  class CanvasPool {
    constructor() {
      console.log("load-costume.js class CanvasPool");
      this.pool = [];
      this.clearSoon = null;
    }
    /**
     *VM.
     */


    clear() {
      if (!this.clearSoon) {
        this.clearSoon = new Promise(resolve => setTimeout(resolve, 1000)).then(() => {
          this.pool.length = 0;
          this.clearSoon = null;
        });
      }
    }
    /**
     *  .
     * @returns {HTMLCanvasElement} A canvas element.
     */


    create() {
      return this.pool.pop() || document.createElement("canvas");
    }
    /**
     * .
     * @param {HTMLCanvasElement} canvas A canvas element.
     */


    release(canvas) {
      this.clear();
      this.pool.push(canvas);
    }

  }

  return new CanvasPool();
}();
/**
 * 
 * bitmapResolution 1bitmapResolution 2Scratch 3
 * Scratch 1.4
 * @param {!object} costume - .
 * @param {!Runtime} runtime - v2BitmapAdapter
 * @param {?object} rotationCenter - . .
 * @property {number} costume.bitmapResolution - .
 * @returns {?Promise} - a promise which will resolve to an object {canvas, rotationCenter, assetMatchesBase},
 *     or reject on error.
 *     assetMatchesBasetrue false
 */


const fetchBitmapCanvas_ = function (costume, runtime, rotationCenter) {
  console.log("load-costume.js fetchBitmapCanvas_", costume, runtime, rotationCenter);
  if (!costume || !costume.asset) return Promise.reject("Costume load failed. Assets were missing.");
  if (!runtime.v2BitmapAdapter) return Promise.reject("No V2 Bitmap adapter present.");
  return Promise.all([costume.asset, costume.textLayerAsset].map(asset => {
    if (!asset) return null;
    if (typeof createImageBitmap !== "undefined") return createImageBitmap(new Blob([asset.data], {
      type: asset.assetType.contentType
    }));
    return new Promise((resolve, reject) => {
      const image = new Image();

      image.onload = function () {
        resolve(image);
        image.onload = null;
        image.onerror = null;
      };

      image.onerror = function () {
        reject("Costume load failed. Asset could not be read.");
        image.onload = null;
        image.onerror = null;
      };

      image.src = asset.encodeDataURI();
    });
  })).then(([baseImageElement, textImageElement]) => {
    const mergeCanvas = canvasPool.create();
    const scale = costume.bitmapResolution === 1 ? 2 : 1;
    mergeCanvas.width = baseImageElement.width;
    mergeCanvas.height = baseImageElement.height;
    const ctx = mergeCanvas.getContext("2d");
    ctx.drawImage(baseImageElement, 0, 0);
    if (textImageElement) ctx.drawImage(textImageElement, 0, 0); // Track the canvas we merged the bitmaps onto separately from the
    // canvas that we receive from resize if scale is not 1. We know
    // resize treats mergeCanvas as read only data. We don't know when
    // resize may use or modify the canvas. So we'll only release the
    // mergeCanvas back into the canvas pool. Reusing the canvas from
    // resize may cause errors.

    let canvas = mergeCanvas;
    if (scale !== 1) canvas = runtime.v2BitmapAdapter.resize(mergeCanvas, canvas.width * scale, canvas.height * scale); // By scaling, we've converted it to bitmap resolution 2

    if (rotationCenter) {
      rotationCenter[0] = rotationCenter[0] * scale;
      rotationCenter[1] = rotationCenter[1] * scale;
      costume.rotationCenterX = rotationCenter[0];
      costume.rotationCenterY = rotationCenter[1];
    }

    costume.bitmapResolution = 2; // Clean up the costume object

    delete costume.textLayerMD5;
    delete costume.textLayerAsset;
    return {
      canvas,
      mergeCanvas,
      rotationCenter,
      // True if the asset matches the base layer; false if it required adjustment
      assetMatchesBase: scale === 1 && !textImageElement
    };
  }).catch(() => {
    // Clean up the text layer properties if it fails to load
    delete costume.textLayerMD5;
    delete costume.textLayerAsset;
  });
};

const loadBitmap_ = function (costume, runtime, _rotationCenter) {
  console.log("load-costume.js loadBitmap_", costume, runtime, _rotationCenter);
  return fetchBitmapCanvas_(costume, runtime, _rotationCenter).then(fetched => {
    const updateCostumeAsset = function (dataURI) {
      // updateCostumeAsset.
      if (!runtime.v2BitmapAdapter) return Promise.reject("No V2 Bitmap adapter present.");
      const storage = runtime.storage;
      costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, storage.DataFormat.PNG, runtime.v2BitmapAdapter.convertDataURIToBinary(dataURI), null, true // generate md5
      );
      costume.dataFormat = storage.DataFormat.PNG;
      costume.assetId = costume.asset.assetId;
      costume.md5 = `${costume.assetId}.${costume.dataFormat}`;
    };

    if (!fetched.assetMatchesBase) updateCostumeAsset(fetched.canvas.toDataURL());
    return fetched;
  }).then(({
    canvas,
    mergeCanvas,
    rotationCenter
  }) => {
    // createBitmapSkin.
    // .
    let center; // fetchBitmapCanvas22.

    if (rotationCenter) center = [rotationCenter[0] / 2, rotationCenter[1] / 2]; // TODO: fetchBitmapCanvas_.bitmapResolution2.

    costume.skinId = runtime.renderer.createBitmapSkin(canvas, costume.bitmapResolution, center);
    canvasPool.release(mergeCanvas);
    const renderSize = runtime.renderer.getSkinSize(costume.skinId);
    costume.size = [renderSize[0] * 2, renderSize[1] * 2]; // 2

    if (!rotationCenter) {
      rotationCenter = runtime.renderer.getSkinRotationCenter(costume.skinId); // 2

      costume.rotationCenterX = rotationCenter[0] * 2;
      costume.rotationCenterY = rotationCenter[1] * 2;
      costume.bitmapResolution = 2;
    }

    return costume;
  });
};
/**
 *  costume .
 * @param {!object} costume - costume.
 * @property {int} skinId - costumeID.
 * @property {number} rotationCenterX - YX.
 * @property {number} rotationCenterY - Y.
 * @property {number} [bitmapResolution] - costume.
 * @property {!Asset} costume.asset - costume.
 * @param {!Runtime} runtime - .
 * @param {?int} optVersion - 2.0or3.0..
 * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.
 */


const loadCostumeFromAsset = function (costume, runtime, optVersion) {
  console.log("vm load-costume.js loadCostumeFromAsset costume ", costume, runtime, optVersion);
  costume.assetId = costume.asset.assetId;
  const renderer = runtime.renderer;

  if (!renderer) {
    console.error("No rendering module present; cannot load costume: ", costume.name);
    return Promise.resolve(costume);
  }

  const AssetType = runtime.storage.AssetType;
  let rotationCenter; //  12.

  if (typeof costume.rotationCenterX === "number" && !isNaN(costume.rotationCenterX) && typeof costume.rotationCenterY === "number" && !isNaN(costume.rotationCenterY)) {
    rotationCenter = [costume.rotationCenterX, costume.rotationCenterY];
  }

  if (costume.asset.assetType.runtimeFormat === AssetType.ImageVector.runtimeFormat) {
    return loadVector_(costume, runtime, rotationCenter, optVersion).catch(error => {
      console.warn(`Error loading vector image: ${error.name}: ${error.message}`); // Use default asset if original fails to load

      costume.assetId = runtime.storage.defaultAssetId.ImageVector;
      costume.asset = runtime.storage.get(costume.assetId);
      costume.md5 = `${costume.assetId}.${AssetType.ImageVector.runtimeFormat}`;
      return loadVector_(costume, runtime);
    });
  }

  return loadBitmap_(costume, runtime, rotationCenter, optVersion);
};
/**
 * ..
 * @param {string} md5ext - MD5costume.
 * @param {!object} costume - costume.
 * @property {int} skinId - costumeID.
 * @property {number} rotationCenterX - YX.
 * @property {number} rotationCenterY - Y.
 * @property {number} [bitmapResolution] - costume.
 * @param {!Runtime} runtime - .
 * @param {?int} optVersion - 2.0or3.0.
 * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.
 */


const loadCostume = function (md5ext, costume, runtime, optVersion) {
  console.log("vm load-costume.js loadCostume  ", md5ext, costume, runtime, optVersion);
  const idParts = StringUtil.splitFirst(md5ext, ".");
  const md5 = idParts[0];
  const ext = idParts[1].toLowerCase();
  costume.dataFormat = ext; // Costume  

  if (costume.asset) return loadCostumeFromAsset(costume, runtime, optVersion); // costume md5 .

  if (!runtime.storage) {
    console.error("No storage module present; cannot load costume asset: ", md5ext);
    return Promise.resolve(costume);
  }

  if (!runtime.storage.defaultAssetId) {
    console.error(`No default assets found`);
    return Promise.resolve(costume);
  }

  const AssetType = runtime.storage.AssetType;
  const assetType = ext === "svg" ? AssetType.ImageVector : AssetType.ImageBitmap;
  const costumePromise = runtime.storage.load(assetType, md5, ext);

  if (!costumePromise) {
    console.error(`Couldn't fetch costume asset: ${md5ext}`);
    return;
  }

  let textLayerPromise;

  if (costume.textLayerMD5) {
    textLayerPromise = runtime.storage.load(AssetType.ImageBitmap, costume.textLayerMD5, "png");
  } else {
    textLayerPromise = Promise.resolve(null);
  }

  return Promise.all([costumePromise, textLayerPromise]).then(assetArray => {
    costume.asset = assetArray[0];
    if (assetArray[1]) costume.textLayerAsset = assetArray[1];
    console.log("vm load-costume.js loadCostume Promise.all  ", md5ext, costume, runtime, optVersion);
    return loadCostumeFromAsset(costume, runtime, optVersion);
  });
};

module.exports = {
  loadCostume,
  loadCostumeFromAsset
};

/***/ }),

/***/ "./src/import/load-sound.js":
/*!**********************************!*\
  !*** ./src/import/load-sound.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");
/**
 * Initialize a sound from an asset asynchronously.
 * @param {!object} sound - the Scratch sound object.
 * @property {string} md5 - the MD5 and extension of the sound to be loaded.
 * @property {Buffer} data - sound data will be written here once loaded.
 * @param {!Asset} soundAsset - the asset loaded from storage.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {SoundBank} soundBank - Scratch Audio SoundBank to add sounds to.
 * @returns {!Promise} - a promise which will resolve to the sound when ready.
 */


const loadSoundFromAsset = function (sound, soundAsset, runtime, soundBank) {
  sound.assetId = soundAsset.assetId;

  if (!runtime.audioEngine) {
    console.error("No audio engine present; cannot load sound asset: ", sound.md5);
    return Promise.resolve(sound);
  }

  return runtime.audioEngine.decodeSoundPlayer(Object.assign({}, sound, {
    data: soundAsset.data
  })).then(soundPlayer => {
    sound.soundId = soundPlayer.id; // 

    const soundBuffer = soundPlayer.buffer;
    sound.rate = soundBuffer.sampleRate;
    sound.sampleCount = soundBuffer.length;

    if (soundBank !== null) {
      soundBank.addSoundPlayer(soundPlayer);
    }

    return sound;
  });
};
/**
 * Load a sound's asset into memory asynchronously.
 * @param {!object} sound - the Scratch sound object.
 * @property {string} md5 - the MD5 and extension of the sound to be loaded.
 * @property {Buffer} data - sound data will be written here once loaded.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {SoundBank} soundBank - Scratch Audio SoundBank to add sounds to.
 * @returns {!Promise} - a promise which will resolve to the sound when ready.
 */


const loadSound = function (sound, runtime, soundBank) {
  if (!runtime.storage) {
    console.error("No storage module present; cannot load sound asset: ", sound.md5);
    return Promise.resolve(sound);
  }

  const idParts = StringUtil.splitFirst(sound.md5, ".");
  const md5 = idParts[0];
  const ext = idParts[1].toLowerCase();
  sound.dataFormat = ext;
  return (sound.asset && Promise.resolve(sound.asset) || runtime.storage.load(runtime.storage.AssetType.Sound, md5, ext)).then(soundAsset => {
    sound.asset = soundAsset;
    return loadSoundFromAsset(sound, soundAsset, runtime, soundBank);
  });
};

module.exports = {
  loadSound,
  loadSoundFromAsset
};

/***/ }),

/***/ "./src/index.js-exposed":
/*!******************************!*\
  !*** ./src/index.js-exposed ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["VirtualMachine"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib!./index.js */ "./node_modules/babel-loader/lib/index.js!./src/index.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/io/ble.js":
/*!***********************!*\
  !*** ./src/io/ble.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const JSONRPC = __webpack_require__(/*! ../util/jsonrpc */ "./src/util/jsonrpc.js");

class BLE extends JSONRPC {
  /**
   * A BLE peripheral socket object.  It handles connecting, over web sockets, to
   * BLE peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this socket.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   */
  constructor(runtime, extensionId, peripheralOptions, connectCallback, resetCallback = null) {
    super();
    this._socket = runtime.getScratchLinkSocket('BLE');

    this._socket.setOnOpen(this.requestPeripheral.bind(this));

    this._socket.setOnClose(this.handleDisconnectError.bind(this));

    this._socket.setOnError(this._handleRequestError.bind(this));

    this._socket.setHandleMessage(this._handleMessage.bind(this));

    this._sendMessage = this._socket.sendMessage.bind(this._socket);
    this._availablePeripherals = {};
    this._connectCallback = connectCallback;
    this._connected = false;
    this._characteristicDidChangeCallback = null;
    this._resetCallback = resetCallback;
    this._discoverTimeoutID = null;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._runtime = runtime;

    this._socket.open();
  }
  /**
   * Request connection to the peripheral.
   * If the web socket is not yet open, request when the socket promise resolves.
   */


  requestPeripheral() {
    this._availablePeripherals = {};

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
    this.sendRemoteRequest('discover', this._peripheralOptions).catch(e => {
      this._handleRequestError(e);
    });
  }
  /**
   * Try connecting to the input peripheral id, and then call the connect
   * callback if connection is successful.
   * @param {number} id - the id of the peripheral to connect to
   */


  connectPeripheral(id) {
    this.sendRemoteRequest('connect', {
      peripheralId: id
    }).then(() => {
      this._connected = true;

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);

      this._connectCallback();
    }).catch(e => {
      this._handleRequestError(e);
    });
  }
  /**
   * Close the websocket.
   */


  disconnect() {
    if (this._connected) {
      this._connected = false;
    }

    if (this._socket.isOpen()) {
      this._socket.close();
    }

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    } // Sets connection status icon to orange


    this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
  }
  /**
   * @return {bool} whether the peripheral is connected.
   */


  isConnected() {
    return this._connected;
  }
  /**
   * Start receiving notifications from the specified ble service.
   * @param {number} serviceId - the ble service to read.
   * @param {number} characteristicId - the ble characteristic to get notifications from.
   * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
   * @return {Promise} - a promise from the remote startNotifications request.
   */


  startNotifications(serviceId, characteristicId, onCharacteristicChanged = null) {
    const params = {
      serviceId,
      characteristicId
    };
    this._characteristicDidChangeCallback = onCharacteristicChanged;
    return this.sendRemoteRequest('startNotifications', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Read from the specified ble service.
   * @param {number} serviceId - the ble service to read.
   * @param {number} characteristicId - the ble characteristic to read.
   * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
   * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
   * @return {Promise} - a promise from the remote read request.
   */


  read(serviceId, characteristicId, optStartNotifications = false, onCharacteristicChanged = null) {
    const params = {
      serviceId,
      characteristicId
    };

    if (optStartNotifications) {
      params.startNotifications = true;
    }

    if (onCharacteristicChanged) {
      this._characteristicDidChangeCallback = onCharacteristicChanged;
    }

    return this.sendRemoteRequest('read', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Write data to the specified ble service.
   * @param {number} serviceId - the ble service to write.
   * @param {number} characteristicId - the ble characteristic to write.
   * @param {string} message - the message to send.
   * @param {string} encoding - the message encoding type.
   * @param {boolean} withResponse - if true, resolve after peripheral's response.
   * @return {Promise} - a promise from the remote send request.
   */


  write(serviceId, characteristicId, message, encoding = null, withResponse = null) {
    const params = {
      serviceId,
      characteristicId,
      message
    };

    if (encoding) {
      params.encoding = encoding;
    }

    if (withResponse !== null) {
      params.withResponse = withResponse;
    }

    return this.sendRemoteRequest('write', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Handle a received call from the socket.
   * @param {string} method - a received method label.
   * @param {object} params - a received list of parameters.
   * @return {object} - optional return value.
   */


  didReceiveCall(method, params) {
    switch (method) {
      case 'didDiscoverPeripheral':
        this._availablePeripherals[params.peripheralId] = params;

        this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);

        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        break;

      case 'characteristicDidChange':
        if (this._characteristicDidChangeCallback) {
          this._characteristicDidChangeCallback(params.message);
        }

        break;

      case 'ping':
        return 42;
    }
  }
  /**
   * Handle an error resulting from losing connection to a peripheral.
   *
   * This could be due to:
   * - battery depletion
   * - going out of bluetooth range
   * - being powered down
   *
   * Disconnect the socket, and if the extension using this socket has a
   * reset callback, call it. Finally, emit an error to the runtime.
   */


  handleDisconnectError()
  /* e */
  {
    // log.error(`BLE error: ${JSON.stringify(e)}`);
    if (!this._connected) return;
    this.disconnect();

    if (this._resetCallback) {
      this._resetCallback();
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
      message: `Scratch lost connection to`,
      extensionId: this._extensionId
    });
  }

  _handleRequestError()
  /* e */
  {
    // log.error(`BLE error: ${JSON.stringify(e)}`);
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
      message: `Scratch lost connection to`,
      extensionId: this._extensionId
    });
  }

  _handleDiscoverTimeout() {
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
  }

}

module.exports = BLE;

/***/ }),

/***/ "./src/io/bt.js":
/*!**********************!*\
  !*** ./src/io/bt.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const JSONRPC = __webpack_require__(/*! ../util/jsonrpc */ "./src/util/jsonrpc.js");

class BT extends JSONRPC {
  /**
   * A BT peripheral socket object.  It handles connecting, over web sockets, to
   * BT peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this socket.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   * @param {object} messageCallback - a callback for message sending.
   */
  constructor(runtime, extensionId, peripheralOptions, connectCallback, resetCallback = null, messageCallback) {
    super();
    this._socket = runtime.getScratchLinkSocket('BT');

    this._socket.setOnOpen(this.requestPeripheral.bind(this));

    this._socket.setOnError(this._handleRequestError.bind(this));

    this._socket.setOnClose(this.handleDisconnectError.bind(this));

    this._socket.setHandleMessage(this._handleMessage.bind(this));

    this._sendMessage = this._socket.sendMessage.bind(this._socket);
    this._availablePeripherals = {};
    this._connectCallback = connectCallback;
    this._connected = false;
    this._characteristicDidChangeCallback = null;
    this._resetCallback = resetCallback;
    this._discoverTimeoutID = null;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._messageCallback = messageCallback;
    this._runtime = runtime;

    this._socket.open();
  }
  /**
   * Request connection to the peripheral.
   * If the web socket is not yet open, request when the socket promise resolves.
   */


  requestPeripheral() {
    this._availablePeripherals = {};

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
    this.sendRemoteRequest('discover', this._peripheralOptions).catch(e => this._handleRequestError(e));
  }
  /**
   * Try connecting to the input peripheral id, and then call the connect
   * callback if connection is successful.
   * @param {number} id - the id of the peripheral to connect to
   * @param {string} pin - an optional pin for pairing
   */


  connectPeripheral(id, pin = null) {
    const params = {
      peripheralId: id
    };

    if (pin) {
      params.pin = pin;
    }

    this.sendRemoteRequest('connect', params).then(() => {
      this._connected = true;

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);

      this._connectCallback();
    }).catch(e => {
      this._handleRequestError(e);
    });
  }
  /**
   * Close the websocket.
   */


  disconnect() {
    if (this._connected) {
      this._connected = false;
    }

    if (this._socket.isOpen()) {
      this._socket.close();
    }

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    } // Sets connection status icon to orange


    this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
  }
  /**
   * @return {bool} whether the peripheral is connected.
   */


  isConnected() {
    return this._connected;
  }

  sendMessage(options) {
    return this.sendRemoteRequest('send', options).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Handle a received call from the socket.
   * @param {string} method - a received method label.
   * @param {object} params - a received list of parameters.
   * @return {object} - optional return value.
   */


  didReceiveCall(method, params) {
    // TODO: Add peripheral 'undiscover' handling
    switch (method) {
      case 'didDiscoverPeripheral':
        this._availablePeripherals[params.peripheralId] = params;

        this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);

        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        break;

      case 'didReceiveMessage':
        this._messageCallback(params); // TODO: refine?


        break;

      default:
        return 'nah';
    }
  }
  /**
   * Handle an error resulting from losing connection to a peripheral.
   *
   * This could be due to:
   * - battery depletion
   * - going out of bluetooth range
   * - being powered down
   *
   * Disconnect the socket, and if the extension using this socket has a
   * reset callback, call it. Finally, emit an error to the runtime.
   */


  handleDisconnectError()
  /* e */
  {
    // log.error(`BT error: ${JSON.stringify(e)}`);
    if (!this._connected) return;
    this.disconnect();

    if (this._resetCallback) {
      this._resetCallback();
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
      message: `Scratch lost connection to`,
      extensionId: this._extensionId
    });
  }

  _handleRequestError()
  /* e */
  {
    // log.error(`BT error: ${JSON.stringify(e)}`);
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
      message: `Scratch lost connection to`,
      extensionId: this._extensionId
    });
  }

  _handleDiscoverTimeout() {
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
  }

}

module.exports = BT;

/***/ }),

/***/ "./src/io/clock.js":
/*!*************************!*\
  !*** ./src/io/clock.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

class Clock {
  constructor(runtime) {
    this._projectTimer = new Timer({
      now: () => runtime.currentMSecs
    });

    this._projectTimer.start();

    this._pausedTime = null;
    this._paused = false;
    /**
     * Reference to the owning Runtime.
     * @type{!Runtime}
     */

    this.runtime = runtime;
  }

  projectTimer() {
    if (this._paused) {
      return this._pausedTime / 1000;
    }

    return this._projectTimer.timeElapsed() / 1000;
  }

  pause() {
    this._paused = true;
    this._pausedTime = this._projectTimer.timeElapsed();
  }

  resume() {
    this._paused = false;

    const dt = this._projectTimer.timeElapsed() - this._pausedTime;

    this._projectTimer.startTime += dt;
  }

  resetProjectTimer() {
    this._projectTimer.start();
  }

}

module.exports = Clock;

/***/ }),

/***/ "./src/io/cloud.js":
/*!*************************!*\
  !*** ./src/io/cloud.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

class Cloud {
  /**
   * @typedef updateVariable
   * @param {string} name The name of the cloud variable to update on the server
   * @param {(string | number)} value The value to update the cloud variable with.
   */

  /**
   * A cloud data provider, responsible for managing the connection to the
   * cloud data server and for posting data about cloud data activity to
   * this IO device.
   * @typedef {object} CloudProvider
   * @property {updateVariable} updateVariable A function which sends a cloud variable
   * update to the cloud data server.
   * @property {Function} requestCloseConnection A function which closes
   * the connection to the cloud data server.
   */

  /**
   * Part of a cloud io data post indicating a cloud variable update.
   * @typedef {object} VarUpdateData
   * @property {string} name The name of the variable to update
   * @property {(number | string)} value The scalar value to update the variable with
   */

  /**
   * A cloud io data post message.
   * @typedef {object} CloudIOData
   * @property {VarUpdateData} varUpdate A {@link VarUpdateData} message indicating
   * a cloud variable update
   */

  /**
   * Cloud IO Device responsible for sending and receiving messages from
   * cloud provider (mananging the cloud server connection) and interacting
   * with cloud variables in the current project.
   * @param {Runtime} runtime The runtime context for this cloud io device.
   */
  constructor(runtime) {
    /**
     * Reference to the cloud data provider, responsible for mananging
     * the web socket connection to the cloud data server.
     * @type {?CloudProvider}
     */
    this.provider = null;
    /**
     * Reference to the runtime that owns this cloud io device.
     * @type {!Runtime}
     */

    this.runtime = runtime;
    /**
     * Reference to the stage target which owns the cloud variables
     * in the project.
     * @type {?Target}
     */

    this.stage = null;
  }
  /**
   * Set a reference to the cloud data provider.
   * @param {CloudProvider} provider The cloud data provider
   */


  setProvider(provider) {
    this.provider = provider;
  }
  /**
   * Set a reference to the stage target which owns the
   * cloud variables in the project.
   * @param {Target} stage The stage target
   */


  setStage(stage) {
    this.stage = stage;
  }
  /**
   * Handle incoming data to this io device.
   * @param {CloudIOData} data The {@link CloudIOData} object to process
   */


  postData(data) {
    if (data.varUpdate) {
      this.updateCloudVariable(data.varUpdate);
    }
  }

  requestCreateVariable(variable) {
    if (this.runtime.canAddCloudVariable()) {
      if (this.provider) {
        this.provider.createVariable(variable.name, variable.value); // We'll set the cloud flag and update the
        // cloud variable limit when we actually
        // get a confirmation from the cloud data server
      }
    } // TODO else track creation for later

  }
  /**
   * Request the cloud data provider to update the given variable with
   * the given value. Does nothing if this io device does not have a provider set.
   * @param {string} name The name of the variable to update
   * @param {string | number} value The value to update the variable with
   */


  requestUpdateVariable(name, value) {
    if (this.provider) {
      this.provider.updateVariable(name, value);
    }
  }
  /**
   * Request the cloud data provider to rename the variable with the given name
   * to the given new name. Does nothing if this io device does not have a provider set.
   * @param {string} oldName The name of the variable to rename
   * @param {string | number} newName The new name for the variable
   */


  requestRenameVariable(oldName, newName) {
    if (this.provider) {
      this.provider.renameVariable(oldName, newName);
    }
  }
  /**
   * Request the cloud data provider to delete the variable with the given name
   * Does nothing if this io device does not have a provider set.
   * @param {string} name The name of the variable to delete
   */


  requestDeleteVariable(name) {
    if (this.provider) {
      this.provider.deleteVariable(name);
    }
  }
  /**
   * Update a cloud variable in the runtime based on the message received
   * from the cloud provider.
   * @param {VarData} varUpdate A {@link VarData} object describing
   * a cloud variable update received from the cloud data provider.
   */


  updateCloudVariable(varUpdate) {
    const varName = varUpdate.name;
    const variable = this.stage.lookupVariableByNameAndType(varName, Variable.SCALAR_TYPE);

    if (!variable || !variable.isCloud) {
      console.warn(`Received an update for a cloud variable that does not exist: ${varName}`);
      return;
    }

    variable.value = varUpdate.value;
  }
  /**
   * Request the cloud data provider to close the web socket connection and
   * clear this io device of references to the cloud data provider and the
   * stage.
   */


  clear() {
    if (!this.provider) return;
    this.provider.requestCloseConnection();
    this.provider = null;
    this.stage = null;
  }

}

module.exports = Cloud;

/***/ }),

/***/ "./src/io/keyboard.js":
/*!****************************!*\
  !*** ./src/io/keyboard.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Names used internally for keys used in scratch, also known as "scratch keys".
 * @enum {string}
 */
const KEY_NAME = {
  SPACE: "space",
  LEFT: "left arrow",
  UP: "up arrow",
  RIGHT: "right arrow",
  DOWN: "down arrow",
  ENTER: "enter"
};
/**
 * An array of the names of scratch keys.
 * @type {Array<string>}
 */

const KEY_NAME_LIST = Object.keys(KEY_NAME).map(name => KEY_NAME[name]);

class Keyboard {
  constructor(runtime) {
    /**
     * List of currently pressed scratch keys.
     * A scratch key is:
     * A key you can press on a keyboard, excluding modifier keys.
     * An uppercase string of length one;
     *     except for special key names for arrow keys and space (e.g. 'left arrow').
     * Can be a non-english unicode letter like:      .
     * @type{Array.<string>}
     */
    this._keysPressed = [];
    /**
     * Reference to the owning Runtime.
     * Can be used, for example, to activate hats.
     * @type{!Runtime}
     */

    this.runtime = runtime;
  }
  /**
   * Convert from a keyboard event key name to a Scratch key name.
   * @param  {string} keyString the input key string.
   * @return {string} the corresponding Scratch key, or an empty string.
   */


  _keyStringToScratchKey(keyString) {
    keyString = String(keyString); // Convert space and arrow keys to their Scratch key names.

    switch (keyString) {
      case " ":
        return KEY_NAME.SPACE;

      case "ArrowLeft":
      case "Left":
        return KEY_NAME.LEFT;

      case "ArrowUp":
      case "Up":
        return KEY_NAME.UP;

      case "Right":
      case "ArrowRight":
        return KEY_NAME.RIGHT;

      case "Down":
      case "ArrowDown":
        return KEY_NAME.DOWN;

      case "Enter":
        return KEY_NAME.ENTER;
    } // Ignore modifier keys


    if (keyString.length > 1) {
      return "";
    }

    return keyString.toUpperCase();
  }
  /**
   * Convert from a block argument to a Scratch key name.
   * @param  {string} keyArg the input arg.
   * @return {string} the corresponding Scratch key.
   */


  _keyArgToScratchKey(keyArg) {
    // If a number was dropped in, try to convert from ASCII to Scratch key.
    if (typeof keyArg === "number") {
      // Check for the ASCII range containing numbers, some punctuation,
      // and uppercase letters.
      if (keyArg >= 48 && keyArg <= 90) {
        return String.fromCharCode(keyArg);
      }

      switch (keyArg) {
        case 32:
          return KEY_NAME.SPACE;

        case 37:
          return KEY_NAME.LEFT;

        case 38:
          return KEY_NAME.UP;

        case 39:
          return KEY_NAME.RIGHT;

        case 40:
          return KEY_NAME.DOWN;
      }
    }

    keyArg = String(keyArg); // If the arg matches a special key name, return it.

    if (KEY_NAME_LIST.includes(keyArg)) {
      return keyArg;
    } // Use only the first character.


    if (keyArg.length > 1) {
      keyArg = keyArg[0];
    } // Check for the space character.


    if (keyArg === " ") {
      return KEY_NAME.SPACE;
    }

    return keyArg.toUpperCase();
  }
  /**
   * Keyboard DOM event handler.
   * @param  {object} data Data from DOM event.
   */


  postData(data) {
    if (!data.key) return;

    const scratchKey = this._keyStringToScratchKey(data.key);

    if (scratchKey === "") return;

    const index = this._keysPressed.indexOf(scratchKey);

    if (data.isDown) {
      this.runtime.emit("KEY_PRESSED", scratchKey); // If not already present, add to the list.

      if (index < 0) {
        this._keysPressed.push(scratchKey);
      }
    } else if (index > -1) {
      // If already present, remove from the list.
      this._keysPressed.splice(index, 1);
    }
  }
  /**
   * Get key down state for a specified key.
   * @param  {Any} keyArg key argument.
   * @return {boolean} Is the specified key down?
   */


  getKeyIsDown(keyArg) {
    if (keyArg === "any") {
      return this._keysPressed.length > 0;
    }

    const scratchKey = this._keyArgToScratchKey(keyArg);

    return this._keysPressed.indexOf(scratchKey) > -1;
  }

}

module.exports = Keyboard;

/***/ }),

/***/ "./src/io/mouse.js":
/*!*************************!*\
  !*** ./src/io/mouse.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

class Mouse {
  constructor(runtime) {
    this._x = 0;
    this._y = 0;
    this._isDown = false;
    /**
     * Reference to the owning Runtime.
     * Can be used, for example, to activate hats.
     * @type{!Runtime}
     */

    this.runtime = runtime;
  }
  /**
   * Activate "event_whenthisspriteclicked" hats.
   * @param  {Target} target to trigger hats on.
   * @private
   */


  _activateClickHats(target) {
    // Activate both "this sprite clicked" and "stage clicked"
    // They were separated into two opcodes for labeling,
    // but should act the same way.
    // Intentionally not checking isStage to make it work when sharing blocks.
    // @todo the blocks should be converted from one to another when shared
    this.runtime.startHats("event_whenthisspriteclicked", null, target);
    this.runtime.startHats("event_whenstageclicked", null, target);
  }
  /**
   * Find a target by XY location
   * @param  {number} x X position to be sent to the renderer.
   * @param  {number} y Y position to be sent to the renderer.
   * @return {Target} the target at that location
   * @private
   */


  _pickTarget(x, y) {
    if (this.runtime.renderer) {
      const drawableID = this.runtime.renderer.pick(x, y);

      for (let i = 0; i < this.runtime.targets.length; i++) {
        const target = this.runtime.targets[i];

        if (target.hasOwnProperty("drawableID") && target.drawableID === drawableID) {
          return target;
        }
      }
    } // Return the stage if no target was found


    return this.runtime.getTargetForStage();
  }
  /**
   * Mouse DOM event handler.
   * @param  {object} data Data from DOM event.
   */


  postData(data) {
    if (data.x) {
      this._clientX = data.x;
      this._scratchX = Math.round(Utility.clamp(480 * (data.x / data.canvasWidth - 0.5), -240, 240));
    }

    if (data.y) {
      this._clientY = data.y;
      this._scratchY = Math.round(Utility.clamp(-360 * (data.y / data.canvasHeight - 0.5), -180, 180));
    }

    if (typeof data.isDown !== "undefined") {
      const previousDownState = this._isDown;
      this._isDown = data.isDown; // Do not trigger if down state has not changed

      if (previousDownState === this._isDown) return; // Never trigger click hats at the end of a drag

      if (data.wasDragged) return; // Do not activate click hats for clicks outside canvas bounds

      if (!(data.x > 0 && data.x < data.canvasWidth && data.y > 0 && data.y < data.canvasHeight)) return;

      const target = this._pickTarget(data.x, data.y);

      const isNewMouseDown = !previousDownState && this._isDown;
      const isNewMouseUp = previousDownState && !this._isDown; // Draggable targets start click hats on mouse up.
      // Non-draggable targets start click hats on mouse down.

      if (target.draggable && isNewMouseUp) {
        this._activateClickHats(target);
      } else if (!target.draggable && isNewMouseDown) {
        this._activateClickHats(target);
      }
    }
  }
  /**
   * Get the X position of the mouse in client coordinates.
   * @return {number} Non-clamped X position of the mouse cursor.
   */


  getClientX() {
    return this._clientX;
  }
  /**
   * Get the Y position of the mouse in client coordinates.
   * @return {number} Non-clamped Y position of the mouse cursor.
   */


  getClientY() {
    return this._clientY;
  }
  /**
   * Get the X position of the mouse in scratch coordinates.
   * @return {number} Clamped and integer rounded X position of the mouse cursor.
   */


  getScratchX() {
    return this._scratchX;
  }
  /**
   * Get the Y position of the mouse in scratch coordinates.
   * @return {number} Clamped and integer rounded Y position of the mouse cursor.
   */


  getScratchY() {
    return this._scratchY;
  }
  /**
   * Get the down state of the mouse.
   * @return {boolean} Is the mouse down?
   */


  getIsDown() {
    return this._isDown;
  }

}

module.exports = Mouse;

/***/ }),

/***/ "./src/io/mouseWheel.js":
/*!******************************!*\
  !*** ./src/io/mouseWheel.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

class MouseWheel {
  constructor(runtime) {
    /**
     * Reference to the owning Runtime.
     * @type{!Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Mouse wheel DOM event handler.
   * @param  {object} data Data from DOM event.
   */


  postData(data) {
    const matchFields = {};

    if (data.deltaY < 0) {
      matchFields.KEY_OPTION = 'up arrow';
    } else if (data.deltaY > 0) {
      matchFields.KEY_OPTION = 'down arrow';
    } else {
      return;
    }

    this.runtime.startHats('event_whenkeypressed', matchFields);
  }

}

module.exports = MouseWheel;

/***/ }),

/***/ "./src/io/userData.js":
/*!****************************!*\
  !*** ./src/io/userData.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

class UserData {
  constructor() {
    this._username = "";
  }
  /**
   * 
   * @param {object} data ioDevice.
   * @property {!string} username .
   */


  postData(data) {
    this._username = data.username;
  }
  /**
   *  postData.
   * @returns {!string} 
   */


  getUsername() {
    return this._username;
  }

}

module.exports = UserData;

/***/ }),

/***/ "./src/io/video.js":
/*!*************************!*\
  !*** ./src/io/video.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

class Video {
  constructor(runtime) {
    this.runtime = runtime;
    /**
     * @typedef VideoProvider
     * @property {Function} enableVideo - Requests camera access from the user, and upon success,
     * enables the video feed
     * @property {Function} disableVideo - Turns off the video feed
     * @property {Function} getFrame - Return frame data from the video feed in
     * specified dimensions, format, and mirroring.
     */

    this.provider = null;
    /**
     * Id representing a Scratch Renderer skin the video is rendered to for
     * previewing.
     * @type {number}
     */

    this._skinId = -1;
    /**
     * Id for a drawable using the video's skin that will render as a video
     * preview.
     * @type {Drawable}
     */

    this._drawable = -1;
    /**
     * Store the last state of the video transparency ghost effect
     * @type {number}
     */

    this._ghost = 0;
    /**
     * Store a flag that allows the preview to be forced transparent.
     * @type {number}
     */

    this._forceTransparentPreview = false;
  }

  static get FORMAT_IMAGE_DATA() {
    return 'image-data';
  }

  static get FORMAT_CANVAS() {
    return 'canvas';
  }
  /**
   * Dimensions the video stream is analyzed at after its rendered to the
   * sample canvas.
   * @type {Array.<number>}
   */


  static get DIMENSIONS() {
    return [480, 360];
  }
  /**
   * Order preview drawable is inserted at in the renderer.
   * @type {number}
   */


  static get ORDER() {
    return 1;
  }
  /**
   * Set a video provider for this device. A default implementation of
   * a video provider can be found in scratch-gui/src/lib/video/video-provider
   * @param {VideoProvider} provider - Video provider to use
   */


  setProvider(provider) {
    this.provider = provider;
  }
  /**
   * Request video be enabled.  Sets up video, creates video skin and enables preview.
   *
   * ioDevices.video.requestVideo()
   *
   * @return {Promise.<Video>} resolves a promise to this IO device when video is ready.
   */


  enableVideo() {
    if (!this.provider) return null;
    return this.provider.enableVideo().then(() => this._setupPreview());
  }
  /**
   * Disable video stream (turn video off)
   * @return {void}
   */


  disableVideo() {
    this._disablePreview();

    if (!this.provider) return null;
    this.provider.disableVideo();
  }
  /**
   * Return frame data from the video feed in a specified dimensions, format, and mirroring.
   *
   * @param {object} frameInfo A descriptor of the frame you would like to receive.
   * @param {Array.<number>} frameInfo.dimensions [width, height] array of numbers.  Defaults to [480,360]
   * @param {boolean} frameInfo.mirror If you specificly want a mirror/non-mirror frame, defaults to the global
   *                                   mirror state (ioDevices.video.mirror)
   * @param {string} frameInfo.format Requested video format, available formats are 'image-data' and 'canvas'.
   * @param {number} frameInfo.cacheTimeout Will reuse previous image data if the time since capture is less than
   *                                        the cacheTimeout.  Defaults to 16ms.
   *
   * @return {ArrayBuffer|Canvas|string|null} Frame data in requested format, null when errors.
   */


  getFrame({
    dimensions = Video.DIMENSIONS,
    mirror = this.mirror,
    format = Video.FORMAT_IMAGE_DATA,
    cacheTimeout = this._frameCacheTimeout
  }) {
    if (this.provider) return this.provider.getFrame({
      dimensions,
      mirror,
      format,
      cacheTimeout
    });
    return null;
  }
  /**
   * Set the preview ghost effect
   * @param {number} ghost from 0 (visible) to 100 (invisible) - ghost effect
   */


  setPreviewGhost(ghost) {
    this._ghost = ghost; // Confirm that the default value has been changed to a valid id for the drawable

    if (this._drawable !== -1) {
      this.runtime.renderer.updateDrawableProperties(this._drawable, {
        ghost: this._forceTransparentPreview ? 100 : ghost
      });
    }
  }

  _disablePreview() {
    if (this._skinId !== -1) {
      this.runtime.renderer.updateBitmapSkin(this._skinId, new ImageData(...Video.DIMENSIONS), 1);
      this.runtime.renderer.updateDrawableProperties(this._drawable, {
        visible: false
      });
    }

    this._renderPreviewFrame = null;
  }

  _setupPreview() {
    const {
      renderer
    } = this.runtime;
    if (!renderer) return;

    if (this._skinId === -1 && this._drawable === -1) {
      this._skinId = renderer.createBitmapSkin(new ImageData(...Video.DIMENSIONS), 1);
      this._drawable = renderer.createDrawable(StageLayering.VIDEO_LAYER);
      renderer.updateDrawableProperties(this._drawable, {
        skinId: this._skinId
      });
    } // if we haven't already created and started a preview frame render loop, do so


    if (!this._renderPreviewFrame) {
      renderer.updateDrawableProperties(this._drawable, {
        ghost: this._forceTransparentPreview ? 100 : this._ghost,
        visible: true
      });

      this._renderPreviewFrame = () => {
        clearTimeout(this._renderPreviewTimeout);

        if (!this._renderPreviewFrame) {
          return;
        }

        this._renderPreviewTimeout = setTimeout(this._renderPreviewFrame, this.runtime.currentStepTime);
        const imageData = this.getFrame({
          format: Video.FORMAT_IMAGE_DATA,
          cacheTimeout: this.runtime.currentStepTime
        });

        if (!imageData) {
          renderer.updateBitmapSkin(this._skinId, new ImageData(...Video.DIMENSIONS), 1);
          return;
        }

        renderer.updateBitmapSkin(this._skinId, imageData, 1);
        this.runtime.requestRedraw();
      };

      this._renderPreviewFrame();
    }
  }

  get videoReady() {
    if (this.provider) return this.provider.videoReady;
    return false;
  }
  /**
   * Method implemented by all IO devices to allow external changes.
   * The only change available externally is hiding the preview, used e.g. to
   * prevent drawing the preview into project thumbnails.
   * @param {object} - data passed to this IO device.
   * @property {boolean} forceTransparentPreview - whether the preview should be forced transparent.
   */


  postData({
    forceTransparentPreview
  }) {
    this._forceTransparentPreview = forceTransparentPreview; // Setting the ghost to the current value will pick up the forceTransparentPreview
    // flag and override the current ghost. The complexity is to prevent blocks
    // from overriding forceTransparentPreview

    this.setPreviewGhost(this._ghost);
  }

}

module.exports = Video;

/***/ }),

/***/ "./src/parser/index.js":
/*!*****************************!*\
  !*** ./src/parser/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {const JSZip = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");
/**  2020.12.20 */


const unzip = function (input, isSprite) {
  console.warn("unzip:", input, isSprite);
  return JSZip.loadAsync(input).then(function (zip) {
    // jsonzipfilespriteproject json
    const file = isSprite ? zip.file(/^([^/]*\/)?sprite\.json$/)[0] : zip.file(/^([^/]*\/)?project\.json$/)[0];

    if (file) {
      return file.async("string").then(function (project) {
        return callback(null, [project, zip]);
      });
    }

    return callback("project.json: json");
  }).catch(function (err) {
    return callback(`project.json: ${JSON.stringify(err)}`);
  });
};
/**
 * @function 
 * @param {*} data (JSON)
 * @param {*} isMaterial 
 */


const unpack = function (data, isMaterial) {
  //   console.warn("unpack", data, isMaterial);
  return new Promise((resolve, reject) => {
    // data
    if (typeof data === "string") return resolve([data, null]); // bufferbuffer

    if (!Buffer.isBuffer(data)) data = new Buffer(data); // buffer()

    let signature = data.slice(0, 3).join(" ");
    let isLegacy = false;
    let isZip = false;
    if (signature.indexOf("83 99 114") === 0) isLegacy = true;
    if (signature.indexOf("80 75") === 0) isZip = true;
    if (isLegacy) return reject([null, "2.x"]);
    if (!isZip && !isLegacy) return resolve([data.toString("utf-8"), null]);

    if (isZip) {
      console.warn(","); // zip

      unzip(data, isMaterial);
    }
  });
};
/**
 * @function 
 * @param data JSON
 */


const parse = function (data) {
  //   console.warn("parse", data);
  return new Promise((resolve, reject) => {
    // JSON
    try {
      resolve(JSON.parse(data.replace(/\\b|\\u0008/g, "")));
    } catch (e) {
      reject(e.toString());
    }
  });
};
/**
 * @function 
 * @param {*} data 
 */


const validate = function (data) {
  //   console.warn("validate", data, isMaterial);
  return new Promise((resolve, reject) => {
    // data.meta.semver2
    if (data.meta.semver && data.meta.semver.indexOf("2") > -1) {
      data.projectVersion = 2;
      return resolve(data, null);
    }

    if (data.meta.semver && data.meta.semver.indexOf("3") > -1) {
      data.projectVersion = 3;
      return resolve(data, null);
    }

    reject({
      validationError: "SB2SB3."
    });
  });
};
/**
 * Scratch Scratch.
 * @param {Buffer | string} data 
 * @param {boolean} isMaterial false;true
 */


module.exports = function (data, isMaterial) {
  //   console.warn("index.js", data, isMaterial);
  return unpack(data, isMaterial).then(unpackedProject => {
    console.warn(":", unpackedProject);
    return parse(unpackedProject[0]).then(res => validate(res).then(ress => ress));
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/serialization/deserialize-assets.js":
/*!*************************************************!*\
  !*** ./src/serialization/deserialize-assets.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const JSZip = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");
/**
 * .
 * @param {object} sound sb3
 * @param {Runtime} runtime T
 * @param {JSZip} zip zip`sound`
 * @param {string} assetFileName 
 * (sb2 files have filenames of the form [int].[ext],
 * sb3 files have filenames of the form [md5].[ext])
 * @return {Promise} .
 */


const deserializeSound = function (sound, runtime, zip, assetFileName) {
  const fileName = assetFileName ? assetFileName : sound.md5;
  const storage = runtime.storage;

  if (!storage) {
    console.error("No storage module present; cannot load sound asset: ", fileName);
    return Promise.resolve(null);
  }

  if (!zip) {
    // Zip will not be provided if loading project json from server
    return Promise.resolve(null);
  }

  let soundFile = zip.file(fileName);

  if (!soundFile) {
    // look for assetfile in a flat list of files, or in a folder
    const fileMatch = new RegExp(`^([^/]*/)?${fileName}$`);
    soundFile = zip.file(fileMatch)[0]; // use first matching file
  }

  if (!soundFile) {
    console.error(`Could not find sound file associated with the ${sound.name} sound.`);
    return Promise.resolve(null);
  }

  if (!JSZip.support.uint8array) {
    console.error("JSZip uint8array is not supported in this browser.");
    return Promise.resolve(null);
  }

  const dataFormat = sound.dataFormat.toLowerCase() === "mp3" ? storage.DataFormat.MP3 : storage.DataFormat.WAV;
  return soundFile.async("uint8array").then(data => storage.createAsset(storage.AssetType.Sound, dataFormat, data, null, true)).then(asset => {
    sound.asset = asset;
    sound.assetId = asset.assetId;
    sound.md5 = `${asset.assetId}.${asset.dataFormat}`;
  });
};
/**
 * .
 * @param {object} costume sb3
 * @param {Runtime} runtime 
 * @param {JSZip} zip zip`costume`
 * @param {string} assetFileName Optional file name for the given asset
 * (sb2 files have filenames of the form [int].[ext],
 * sb3 files have filenames of the form [md5].[ext])
 * @param {string} textLayerFileName Optional file name for the given asset's text layer (sb2 only; files have filenames of the form [int].png)
 * @return {Promise} Promise that resolves after the described costume has been stored into the runtime storage cache, the costume was already stored, or an error has occurred.
 */


const deserializeCostume = function (costume, runtime, zip, assetFileName, textLayerFileName) {
  console.log(".js");
  const storage = runtime.storage;
  const assetId = costume.assetId;
  const fileName = assetFileName ? assetFileName : `${assetId}.${costume.dataFormat}`;

  if (!storage) {
    console.error("No storage module present; cannot load costume asset: ", fileName);
    return Promise.resolve(null);
  }

  if (costume.asset) {
    // 
    // @todo 
    return Promise.resolve(storage.createAsset(costume.asset.assetType, costume.asset.dataFormat, new Uint8Array(Object.keys(costume.asset.data).map(key => costume.asset.data[key])), null, true)).then(asset => {
      costume.asset = asset;
      costume.assetId = asset.assetId;
      costume.md5 = `${asset.assetId}.${asset.dataFormat}`;
    });
  } // json


  if (!zip) return Promise.resolve(null);
  let costumeFile = zip.file(fileName);

  if (!costumeFile) {
    // 
    const fileMatch = new RegExp(`^([^/]*/)?${fileName}$`);
    costumeFile = zip.file(fileMatch)[0]; // use the first matched file
  }

  if (!costumeFile) {
    console.error(`Could not find costume file associated with the ${costume.name} costume.`);
    return Promise.resolve(null);
  }

  let assetType = null;
  const costumeFormat = costume.dataFormat.toLowerCase();

  if (costumeFormat === "svg") {
    assetType = storage.AssetType.ImageVector;
  } else if (["png", "bmp", "jpeg", "jpg", "gif"].indexOf(costumeFormat) >= 0) {
    assetType = storage.AssetType.ImageBitmap;
  } else {
    console.error(`Unexpected file format for costume: ${costumeFormat}`);
  }

  if (!JSZip.support.uint8array) {
    console.error("JSZip uint8array is not supported in this browser.");
    return Promise.resolve(null);
  } // textLayerMD5 exists if there is a text layer, which is a png of text from Scratch 1.4
  // that was opened in Scratch 2.0. In this case, set costume.textLayerAsset.


  let textLayerFilePromise;

  if (costume.textLayerMD5) {
    const textLayerFile = zip.file(textLayerFileName);

    if (!textLayerFile) {
      console.error(`Could not find text layer file associated with the ${costume.name} costume.`);
      return Promise.resolve(null);
    }

    textLayerFilePromise = textLayerFile.async("uint8array").then(data => storage.createAsset(storage.AssetType.ImageBitmap, "png", data, costume.textLayerMD5)).then(asset => {
      costume.textLayerAsset = asset;
    });
  } else {
    textLayerFilePromise = Promise.resolve(null);
  }

  return Promise.all([textLayerFilePromise, costumeFile.async("uint8array").then(data => storage.createAsset(assetType, // TODO eventually we want to map non-png's to their actual file types?
  costumeFormat, data, null, true)).then(asset => {
    costume.asset = asset;
    costume.assetId = asset.assetId;
    costume.md5 = `${asset.assetId}.${asset.dataFormat}`;
  })]);
};

module.exports = {
  deserializeSound,
  deserializeCostume
};

/***/ }),

/***/ "./src/serialization/sb2.js":
/*!**********************************!*\
  !*** ./src/serialization/sb2.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * Partial implementation of an SB2 JSON importer.
 * Parses provided JSON and then generates all needed
 * scratch-vm runtime structures.
 */
const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");

const RenderedTarget = __webpack_require__(/*! ../sprites/rendered-target */ "./src/sprites/rendered-target.js");

const Sprite = __webpack_require__(/*! ../sprites/sprite */ "./src/sprites/sprite.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const specMap = __webpack_require__(/*! ./sb2_specmap */ "./src/serialization/sb2_specmap.js");

const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const MonitorRecord = __webpack_require__(/*! ../engine/monitor-record */ "./src/engine/monitor-record.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

const {
  loadCostume
} = __webpack_require__(/*! ../import/load-costume.js */ "./src/import/load-costume.js");

const {
  loadSound
} = __webpack_require__(/*! ../import/load-sound.js */ "./src/import/load-sound.js");

const {
  deserializeCostume,
  deserializeSound
} = __webpack_require__(/*! ./deserialize-assets.js */ "./src/serialization/deserialize-assets.js"); // Constants used during deserialization of an SB2 file


const CORE_EXTENSIONS = ["argument", "control", "data", "event", "looks", "math", "motion", "operator", "procedures", "sensing", "sound"]; // Adjust script coordinates to account for
// larger block size in scratch-blocks.
// @todo: Determine more precisely the right formulas here.

const WORKSPACE_X_SCALE = 1.5;
const WORKSPACE_Y_SCALE = 2.2;
/**
 * Convert a Scratch 2.0 procedure string (e.g., "my_procedure %s %b %n")
 * into an argument map. This allows us to provide the expected inputs
 * to a mutated procedure call.
 * @param {string} procCode Scratch 2.0 procedure string.
 * @return {object} Argument map compatible with those in sb2specmap.
 */

const parseProcedureArgMap = function (procCode) {
  const argMap = [{} // First item in list is op string.
  ];
  const INPUT_PREFIX = "input";
  let inputCount = 0; // Split by %n, %b, %s.

  const parts = procCode.split(/(?=[^\\]%[nbs])/);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].trim();

    if (part.substring(0, 1) === "%") {
      const argType = part.substring(1, 2);
      const arg = {
        type: "input",
        inputName: INPUT_PREFIX + inputCount++
      };

      if (argType === "n") {
        arg.inputOp = "math_number";
      } else if (argType === "s") {
        arg.inputOp = "text";
      } else if (argType === "b") {
        arg.inputOp = "boolean";
      }

      argMap.push(arg);
    }
  }

  return argMap;
};
/**
 * Generate a list of "argument IDs" for procdefs and caller mutations.
 * IDs just end up being `input0`, `input1`, ... which is good enough.
 * @param {string} procCode Scratch 2.0 procedure string.
 * @return {Array.<string>} Array of argument id strings.
 */


const parseProcedureArgIds = function (procCode) {
  return parseProcedureArgMap(procCode).map(arg => arg.inputName).filter(name => name); // Filter out unnamed inputs which are labels
};
/**
 * Flatten a block tree into a block list.
 * Children are temporarily stored on the `block.children` property.
 * @param {Array.<object>} blocks list generated by `parseBlockList`.
 * @return {Array.<object>} Flattened list to be passed to `blocks.createBlock`.
 */


const flatten = function (blocks) {
  let finalBlocks = [];

  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    finalBlocks.push(block);

    if (block.children) {
      finalBlocks = finalBlocks.concat(flatten(block.children));
    }

    delete block.children;
  }

  return finalBlocks;
};
/**
 * Parse any list of blocks from SB2 JSON into a list of VM-format blocks.
 * Could be used to parse a top-level script,
 * a list of blocks in a branch (e.g., in forever),
 * or a list of blocks in an argument (e.g., move [pick random...]).
 * @param {Array.<object>} blockList SB2 JSON-format block list.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retreive a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {ParseState} parseState - info on the state of parsing beyond the current block.
 * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.
 * They are indexed in this object by the sb2 flattened block list index indicating
 * which block they should attach to.
 * @param {int} commentIndex The current index of the top block in this list if it were in a flattened
 * list of all blocks for the target
 * @return {Array<Array.<object>|int>} Tuple where first item is the Scratch VM-format block list, and
 * second item is the updated comment index
 */


const parseBlockList = function (blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {
  const resultingList = [];
  let previousBlock = null; // For setting next.

  for (let i = 0; i < blockList.length; i++) {
    const block = blockList[i]; // eslint-disable-next-line no-use-before-define

    const parsedBlockAndComments = parseBlock(block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
    const parsedBlock = parsedBlockAndComments[0]; // Update commentIndex

    commentIndex = parsedBlockAndComments[1];
    if (!parsedBlock) continue;

    if (previousBlock) {
      parsedBlock.parent = previousBlock.id;
      previousBlock.next = parsedBlock.id;
    }

    previousBlock = parsedBlock;
    resultingList.push(parsedBlock);
  }

  return [resultingList, commentIndex];
};
/**
 * Parse a Scratch object's scripts into VM blocks.
 * This should only handle top-level scripts that include X, Y coordinates.
 * @param {!object} scripts Scripts object from SB2 JSON.
 * @param {!Blocks} blocks Blocks object to load parsed blocks into.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retreive a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {object} comments Comments that need to be attached to the blocks that need to be parsed
 */


const parseScripts = function (scripts, blocks, addBroadcastMsg, getVariableId, extensions, comments) {
  // Keep track of the index of the current script being
  // parsed in order to attach block comments correctly
  let scriptIndexForComment = 0;

  for (let i = 0; i < scripts.length; i++) {
    const script = scripts[i];
    const scriptX = script[0];
    const scriptY = script[1];
    const blockList = script[2];
    const parseState = {};
    const [parsedBlockList, newCommentIndex] = parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, scriptIndexForComment);
    scriptIndexForComment = newCommentIndex;

    if (parsedBlockList[0]) {
      parsedBlockList[0].x = scriptX * WORKSPACE_X_SCALE;
      parsedBlockList[0].y = scriptY * WORKSPACE_Y_SCALE;
      parsedBlockList[0].topLevel = true;
      parsedBlockList[0].parent = null;
    } // Flatten children and create add the blocks.


    const convertedBlocks = flatten(parsedBlockList);

    for (let j = 0; j < convertedBlocks.length; j++) {
      blocks.createBlock(convertedBlocks[j]);
    }
  }
};
/**
 * Create a callback for assigning fixed IDs to imported variables
 * Generator stores the global variable mapping in a closure
 * @param {!string} targetId the id of the target to scope the variable to
 * @return {string} variable ID
 */


const generateVariableIdGetter = function () {
  let globalVariableNameMap = {};

  const namer = (targetId, name, type) => `${targetId}-${StringUtil.replaceUnsafeChars(name)}-${type}`;

  return function (targetId, topLevel) {
    // Reset the global variable map if topLevel
    if (topLevel) globalVariableNameMap = {};
    return function (name, type) {
      if (topLevel) {
        // Store the name/id pair in the globalVariableNameMap
        globalVariableNameMap[`${name}-${type}`] = namer(targetId, name, type);
        return globalVariableNameMap[`${name}-${type}`];
      } // Not top-level, so first check the global name map


      if (globalVariableNameMap[`${name}-${type}`]) return globalVariableNameMap[`${name}-${type}`];
      return namer(targetId, name, type);
    };
  };
}();

const globalBroadcastMsgStateGenerator = function () {
  let broadcastMsgNameMap = {};
  const allBroadcastFields = [];
  console.warn("sb2:", Utility.uid());
  const emptyStringName = Utility.uid();
  return function (topLevel) {
    if (topLevel) broadcastMsgNameMap = {};
    return {
      broadcastMsgMapUpdater: function (name, field) {
        name = name.toLowerCase();

        if (name === "") {
          name = emptyStringName;
        }

        broadcastMsgNameMap[name] = `broadcastMsgId-${StringUtil.replaceUnsafeChars(name)}`;
        allBroadcastFields.push(field);
        return broadcastMsgNameMap[name];
      },
      globalBroadcastMsgs: broadcastMsgNameMap,
      allBroadcastFields: allBroadcastFields,
      emptyMsgName: emptyStringName
    };
  };
}();
/**
 * Parse a single monitor object and create all its in-memory VM objects.
 *
 * It is important that monitors are parsed last,
 * - after all sprite targets have finished parsing, and
 * - after the rest of the stage has finished parsing.
 *
 * It is specifically important that all the scripts in the project
 * have been parsed and all the relevant targets exist, have uids,
 * and have their variables initialized.
 * Calling this function before these things are true, will result in
 * undefined behavior.
 * @param {!object} object - From-JSON "Monitor object"
 * @param {!Runtime} runtime - (in/out) Runtime object to load monitor info into.
 * @param {!Array.<Target>} targets - Targets have already been parsed.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 */


const parseMonitorObject = (object, runtime, targets, extensions) => {
  // If we can't find the block in the spec map, ignore it.
  // This happens for things like Lego Wedo 1.0 monitors.
  const mapped = specMap[object.cmd];

  if (!mapped) {
    console.warn(`Could not find monitor block with opcode: ${object.cmd}`);
    return;
  } // In scratch 2.0, there are two monitors that now correspond to extension
  // blocks (tempo and video motion/direction). In the case of the
  // video motion/direction block, this reporter is not monitorable in Scratch 3.0.
  // In the case of the tempo block, we should import it and load the music extension
  // only when the monitor is actually visible.


  const opcode = specMap[object.cmd].opcode;
  const extIndex = opcode.indexOf("_");
  const extID = opcode.substring(0, extIndex);

  if (extID === "videoSensing") {
    return;
  } else if (CORE_EXTENSIONS.indexOf(extID) === -1 && extID !== "" && !extensions.extensionIDs.has(extID) && !object.visible) {
    // Don't import this monitor if it refers to a non-core extension that
    // doesn't exist anywhere else in the project and it isn't visible.
    // This should only apply to the tempo block at this point since
    // there are no other sb2 blocks that are now extension monitors.
    return;
  }

  let target = null; // List blocks don't come in with their target name set.
  // Find the target by searching for a target with matching variable name/type.

  if (!object.hasOwnProperty("target")) {
    for (let i = 0; i < targets.length; i++) {
      const currTarget = targets[i];
      const listVariables = Object.keys(currTarget.variables).filter(key => {
        const variable = currTarget.variables[key];
        return variable.type === Variable.LIST_TYPE && variable.name === object.listName;
      });

      if (listVariables.length > 0) {
        target = currTarget; // Keep this target for later use

        object.target = currTarget.getName(); // Set target name to normalize with other monitors
      }
    }
  } // Get the target for this monitor, if not gotten above.


  target = target || targets.filter(t => t.getName() === object.target)[0];
  if (!target) throw new Error("Cannot create monitor for target that cannot be found by name"); // Create var id getter to make block naming/parsing easier, variables already created.

  const getVariableId = generateVariableIdGetter(target.id, false); // eslint-disable-next-line no-use-before-define

  const [block, _] = parseBlock([object.cmd, object.param], // Scratch 2 monitor blocks only have one param.
  null, // `addBroadcastMsg`, not needed for monitor blocks.
  getVariableId, extensions, {}, null, // `comments`, not needed for monitor blocks
  null // `commentIndex`, not needed for monitor blocks
  ); // Monitor blocks have special IDs to match the toolbox obtained from the getId
  // function in the runtime.monitorBlocksInfo. Variable monitors, however,
  // get their IDs from the variable id they reference.

  if (object.cmd === "getVar:") {
    block.id = getVariableId(object.param, Variable.SCALAR_TYPE);
  } else if (object.cmd === "contentsOfList:") {
    block.id = getVariableId(object.param, Variable.LIST_TYPE);
  } else if (runtime.monitorBlockInfo.hasOwnProperty(block.opcode)) {
    block.id = runtime.monitorBlockInfo[block.opcode].getId(target.id, block.fields);
  } else {
    // If the opcode can't be found in the runtime monitorBlockInfo,
    // then default to using the block opcode as the id instead.
    // This is for extension monitors, and assumes that extension monitors
    // cannot be sprite specific.
    block.id = block.opcode;
  } // Block needs a targetId if it is targetting something other than the stage


  block.targetId = target.isStage ? null : target.id; // Property required for running monitored blocks.

  block.isMonitored = object.visible;
  const existingMonitorBlock = runtime.monitorBlocks._blocks[block.id];

  if (existingMonitorBlock) {
    // A monitor block already exists if the toolbox has been loaded and
    // the monitor block is not target specific (because the block gets recycled).
    // Update the existing block with the relevant monitor information.
    existingMonitorBlock.isMonitored = object.visible;
    existingMonitorBlock.targetId = block.targetId;
  } else {
    // Blocks can be created with children, flatten and add to monitorBlocks.
    const newBlocks = flatten([block]);

    for (let i = 0; i < newBlocks.length; i++) {
      runtime.monitorBlocks.createBlock(newBlocks[i]);
    }
  } // Convert numbered mode into strings for better understandability.


  switch (object.mode) {
    case 1:
      object.mode = "default";
      break;

    case 2:
      object.mode = "large";
      break;

    case 3:
      object.mode = "slider";
      break;
  } // Create a monitor record for the runtime's monitorState


  runtime.requestAddMonitor(MonitorRecord({
    id: block.id,
    targetId: block.targetId,
    spriteName: block.targetId ? object.target : null,
    opcode: block.opcode,
    params: runtime.monitorBlocks._getBlockParams(block),
    value: "",
    mode: object.mode,
    sliderMin: object.sliderMin,
    sliderMax: object.sliderMax,
    isDiscrete: object.isDiscrete,
    x: object.x,
    y: object.y,
    width: object.width,
    height: object.height,
    visible: object.visible
  }));
};
/**
 * Parse the assets of a single "Scratch object" and load them. This
 * preprocesses objects to support loading the data for those assets over a
 * network while the objects are further processed into Blocks, Sprites, and a
 * list of needed Extensions.
 * @param {!object} object - From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime - Runtime object to load all structures into.
 * @param {boolean} topLevel - Whether this is the top-level object (stage).
 * @param {?object} zip - Optional zipped assets for local file import
 * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank,children:object}}
 *   Object of arrays of promises and child objects for asset objects used in
 *   Sprites. As well as a SoundBank for the sound assets. null for unsupported
 *   objects.
 */


const parseScratchAssets = function (object, runtime, topLevel, zip) {
  if (!object.hasOwnProperty("objName")) {
    // Skip parsing monitors. Or any other objects missing objName.
    return null;
  }

  const assets = {
    costumePromises: [],
    soundPromises: [],
    soundBank: runtime.audioEngine && runtime.audioEngine.createBank(),
    children: []
  }; // Costumes from JSON.

  const costumePromises = assets.costumePromises;

  if (object.hasOwnProperty("costumes")) {
    for (let i = 0; i < object.costumes.length; i++) {
      const costumeSource = object.costumes[i];
      const bitmapResolution = costumeSource.bitmapResolution || 1;
      const costume = {
        name: costumeSource.costumeName,
        bitmapResolution: bitmapResolution,
        rotationCenterX: topLevel ? 240 * bitmapResolution : costumeSource.rotationCenterX,
        rotationCenterY: topLevel ? 180 * bitmapResolution : costumeSource.rotationCenterY,
        // TODO we eventually want this next property to be called
        // md5ext to reflect what it actually contains, however this
        // will be a very extensive change across many repositories
        // and should be done carefully and altogether
        md5: costumeSource.baseLayerMD5,
        skinId: null
      };
      const md5ext = costumeSource.baseLayerMD5;
      const idParts = StringUtil.splitFirst(md5ext, ".");
      const md5 = idParts[0];
      let ext;

      if (idParts.length === 2 && idParts[1]) {
        ext = idParts[1];
      } else {
        // Default to 'png' if baseLayerMD5 is not formatted correctly
        ext = "png"; // Fix costume md5 for later

        costume.md5 = `${costume.md5}.${ext}`;
      }

      costume.dataFormat = ext;
      costume.assetId = md5;

      if (costumeSource.textLayerMD5) {
        costume.textLayerMD5 = StringUtil.splitFirst(costumeSource.textLayerMD5, ".")[0];
      } // If there is no internet connection, or if the asset is not in storage
      // for some reason, and we are doing a local .sb2 import, (e.g. zip is provided)
      // the file name of the costume should be the baseLayerID followed by the file ext


      const assetFileName = `${costumeSource.baseLayerID}.${ext}`;
      const textLayerFileName = costumeSource.textLayerID ? `${costumeSource.textLayerID}.png` : null;
      costumePromises.push(deserializeCostume(costume, runtime, zip, assetFileName, textLayerFileName).then(() => loadCostume(costume.md5, costume, runtime, 2
      /* optVersion */
      )));
    }
  } // Sounds from JSON


  const {
    soundBank,
    soundPromises
  } = assets;

  if (object.hasOwnProperty("sounds")) {
    for (let s = 0; s < object.sounds.length; s++) {
      const soundSource = object.sounds[s];
      const sound = {
        name: soundSource.soundName,
        format: soundSource.format,
        rate: soundSource.rate,
        sampleCount: soundSource.sampleCount,
        // TODO we eventually want this next property to be called
        // md5ext to reflect what it actually contains, however this
        // will be a very extensive change across many repositories
        // and should be done carefully and altogether
        // (for example, the audio engine currently relies on this
        // property to be named 'md5')
        md5: soundSource.md5,
        data: null
      };
      const md5ext = soundSource.md5;
      const idParts = StringUtil.splitFirst(md5ext, ".");
      const md5 = idParts[0];
      const ext = idParts[1].toLowerCase();
      sound.dataFormat = ext;
      sound.assetId = md5; // If there is no internet connection, or if the asset is not in storage
      // for some reason, and we are doing a local .sb2 import, (e.g. zip is provided)
      // the file name of the sound should be the soundID (provided from the project.json)
      // followed by the file ext

      const assetFileName = `${soundSource.soundID}.${ext}`;
      soundPromises.push(deserializeSound(sound, runtime, zip, assetFileName).then(() => loadSound(sound, runtime, soundBank)));
    }
  } // The stage will have child objects; recursively process them.


  const childrenAssets = assets.children;

  if (object.children) {
    for (let m = 0; m < object.children.length; m++) {
      childrenAssets.push(parseScratchAssets(object.children[m], runtime, false, zip));
    }
  }

  return assets;
};
/**
 * Parse a single "Scratch object" and create all its in-memory VM objects.
 * TODO: parse the "info" section, especially "savedExtensions"
 * @param {!object} object - From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime - Runtime object to load all structures into.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {boolean} topLevel - Whether this is the top-level object (stage).
 * @param {?object} zip - Optional zipped assets for local file import
 * @param {object} assets - Promises for assets of this scratch object grouped
 *   into costumes and sounds
 * @return {!Promise.<Array.<Target>>} Promise for the loaded targets when ready, or null for unsupported objects.
 */


const parseScratchObject = function (object, runtime, extensions, topLevel, zip, assets) {
  if (!object.hasOwnProperty("objName")) {
    if (object.hasOwnProperty("listName")) {
      // Shim these objects so they can be processed as monitors
      object.cmd = "contentsOfList:";
      object.param = object.listName;
      object.mode = "list";
    } // Defer parsing monitors until targets are all parsed


    object.deferredMonitor = true;
    return Promise.resolve(object);
  } // Blocks container for this object.


  const blocks = new Blocks(runtime); // @todo: For now, load all Scratch objects (stage/sprites) as a Sprite.

  const sprite = new Sprite(blocks, runtime); // Sprite/stage name from JSON.

  if (object.hasOwnProperty("objName")) {
    if (topLevel && object.objName !== "Stage") {
      for (const child of object.children) {
        if (!child.hasOwnProperty("objName") && child.target === object.objName) {
          child.target = "Stage";
        }
      }

      object.objName = "Stage";
    }

    sprite.name = object.objName;
  } // Costumes from JSON.


  const costumePromises = assets.costumePromises; // Sounds from JSON

  const {
    soundBank,
    soundPromises
  } = assets; // Create the first clone, and load its run-state from JSON.

  const target = sprite.createClone(topLevel ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);
  const getVariableId = generateVariableIdGetter(target.id, topLevel);
  const globalBroadcastMsgObj = globalBroadcastMsgStateGenerator(topLevel);
  const addBroadcastMsg = globalBroadcastMsgObj.broadcastMsgMapUpdater; // Load target properties from JSON.

  if (object.hasOwnProperty("variables")) {
    for (let j = 0; j < object.variables.length; j++) {
      const variable = object.variables[j]; // A variable is a cloud variable if:
      // - the project says it's a cloud variable, and
      // - it's a stage variable, and
      // - the runtime can support another cloud variable

      const isCloud = variable.isPersistent && topLevel && runtime.canAddCloudVariable();
      const newVariable = new Variable(getVariableId(variable.name, Variable.SCALAR_TYPE), variable.name, Variable.SCALAR_TYPE, isCloud);
      if (isCloud) runtime.addCloudVariable();
      newVariable.value = variable.value;
      target.variables[newVariable.id] = newVariable;
    }
  } // If included, parse any and all comments on the object (this includes top-level
  // workspace comments as well as comments attached to specific blocks)


  const blockComments = {};

  if (object.hasOwnProperty("scriptComments")) {
    const comments = object.scriptComments.map(commentDesc => {
      const [commentX, commentY, commentWidth, commentHeight, commentFullSize, flattenedBlockIndex, commentText] = commentDesc;
      const isBlockComment = commentDesc[5] >= 0;
      const newComment = new Comment(null, // generate a new id for this comment
      commentText, // text content of sb2 comment
      // Only serialize x & y position of comment if it's a workspace comment
      // If it's a block comment, we'll let scratch-blocks handle positioning
      isBlockComment ? null : commentX * WORKSPACE_X_SCALE, isBlockComment ? null : commentY * WORKSPACE_Y_SCALE, commentWidth * WORKSPACE_X_SCALE, commentHeight * WORKSPACE_Y_SCALE, !commentFullSize);

      if (isBlockComment) {
        // commentDesc[5] refers to the index of the block that this
        // comment is attached to --  in a flattened version of the
        // scripts array.
        // If commentDesc[5] is -1, this is a workspace comment (we don't need to do anything
        // extra at this point), otherwise temporarily save the flattened script array
        // index as the blockId property of the new comment. We will
        // change this to refer to the actual block id of the corresponding
        // block when that block gets created
        newComment.blockId = flattenedBlockIndex; // Add this comment to the block comments object with its script index
        // as the key

        if (blockComments.hasOwnProperty(flattenedBlockIndex)) {
          blockComments[flattenedBlockIndex].push(newComment);
        } else {
          blockComments[flattenedBlockIndex] = [newComment];
        }
      }

      return newComment;
    }); // Add all the comments that were just created to the target.comments,
    // referenced by id

    comments.forEach(comment => {
      target.comments[comment.id] = comment;
    });
  } // If included, parse any and all scripts/blocks on the object.


  if (object.hasOwnProperty("scripts")) {
    parseScripts(object.scripts, blocks, addBroadcastMsg, getVariableId, extensions, blockComments);
  } // If there are any comments referring to a numerical block ID, make them
  // workspace comments. These are comments that were originally created as
  // block comments, detached from the block, and then had the associated
  // block deleted.
  // These comments should be imported as workspace comments
  // by making their blockIDs (which currently refer to non-existing blocks)
  // null (See #1452).


  for (const commentIndex in blockComments) {
    const currBlockComments = blockComments[commentIndex];
    currBlockComments.forEach(c => {
      if (typeof c.blockId === "number") {
        c.blockId = null;
      }
    });
  } // Update stage specific blocks (e.g. sprite clicked <=> stage clicked)


  blocks.updateTargetSpecificBlocks(topLevel); // topLevel = isStage

  if (object.hasOwnProperty("lists")) {
    for (let k = 0; k < object.lists.length; k++) {
      const list = object.lists[k];
      const newVariable = new Variable(getVariableId(list.listName, Variable.LIST_TYPE), list.listName, Variable.LIST_TYPE, false);
      newVariable.value = list.contents;
      target.variables[newVariable.id] = newVariable;
    }
  }

  if (object.hasOwnProperty("scratchX")) {
    target.x = object.scratchX;
  }

  if (object.hasOwnProperty("scratchY")) {
    target.y = object.scratchY;
  }

  if (object.hasOwnProperty("direction")) {
    target.direction = object.direction;
  }

  if (object.hasOwnProperty("isDraggable")) {
    target.draggable = object.isDraggable;
  }

  if (object.hasOwnProperty("scale")) {
    // SB2 stores as 1.0 = 100%; we use % in the VM.
    target.size = object.scale * 100;
  }

  if (object.hasOwnProperty("visible")) {
    target.visible = object.visible;
  }

  if (object.hasOwnProperty("currentCostumeIndex")) {
    // Current costume index can sometimes be a floating
    // point number, use Math.floor to come up with an appropriate index
    // and clamp it to the actual number of costumes the object has for good measure.
    target.currentCostume = Utility.clamp(Math.floor(object.currentCostumeIndex), 0, object.costumes.length - 1);
  }

  if (object.hasOwnProperty("rotationStyle")) {
    if (object.rotationStyle === "none") {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
    } else if (object.rotationStyle === "leftRight") {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
    } else if (object.rotationStyle === "normal") {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    }
  }

  if (object.hasOwnProperty("tempoBPM")) {
    target.tempo = object.tempoBPM;
  }

  if (object.hasOwnProperty("videoAlpha")) {
    // SB2 stores alpha as opacity, where 1.0 is opaque.
    // We convert to a percentage, and invert it so 100% is full transparency.
    target.videoTransparency = 100 - 100 * object.videoAlpha;
  }

  if (object.hasOwnProperty("info")) {
    if (object.info.hasOwnProperty("videoOn")) {
      if (object.info.videoOn) {
        target.videoState = RenderedTarget.VIDEO_STATE.ON;
      } else {
        target.videoState = RenderedTarget.VIDEO_STATE.OFF;
      }
    }
  }

  if (object.hasOwnProperty("indexInLibrary")) {
    // Temporarily store the 'indexInLibrary' property from the sb2 file
    // so that we can correctly order sprites in the target pane.
    // This will be deleted after we are done parsing and ordering the targets list.
    target.targetPaneOrder = object.indexInLibrary;
  }

  target.isStage = topLevel;
  Promise.all(costumePromises).then(costumes => {
    sprite.costumes = costumes;
  });
  Promise.all(soundPromises).then(sounds => {
    sprite.sounds = sounds; // Make sure if soundBank is undefined, sprite.soundBank is then null.

    sprite.soundBank = soundBank || null;
  }); // The stage will have child objects; recursively process them.

  const childrenPromises = [];

  if (object.children) {
    for (let m = 0; m < object.children.length; m++) {
      childrenPromises.push(parseScratchObject(object.children[m], runtime, extensions, false, zip, assets.children[m]));
    }
  }

  return Promise.all(costumePromises.concat(soundPromises)).then(() => Promise.all(childrenPromises).then(children => {
    // Need create broadcast msgs as variables after
    // all other targets have finished processing.
    if (target.isStage) {
      const allBroadcastMsgs = globalBroadcastMsgObj.globalBroadcastMsgs;
      const allBroadcastMsgFields = globalBroadcastMsgObj.allBroadcastFields;
      const oldEmptyMsgName = globalBroadcastMsgObj.emptyMsgName;

      if (allBroadcastMsgs[oldEmptyMsgName]) {
        // Find a fresh 'messageN'
        let currIndex = 1;

        while (allBroadcastMsgs[`message${currIndex}`]) {
          currIndex += 1;
        }

        const newEmptyMsgName = `message${currIndex}`; // Add the new empty message name to the broadcast message
        // name map, and assign it the old id.
        // Then, delete the old entry in map.

        allBroadcastMsgs[newEmptyMsgName] = allBroadcastMsgs[oldEmptyMsgName];
        delete allBroadcastMsgs[oldEmptyMsgName]; // Now update all the broadcast message fields with
        // the new empty message name.

        for (let i = 0; i < allBroadcastMsgFields.length; i++) {
          if (allBroadcastMsgFields[i].value === "") {
            allBroadcastMsgFields[i].value = newEmptyMsgName;
          }
        }
      } // Traverse the broadcast message name map and create
      // broadcast messages as variables on the stage (which is this
      // target).


      for (const msgName in allBroadcastMsgs) {
        const msgId = allBroadcastMsgs[msgName];
        const newMsg = new Variable(msgId, msgName, Variable.BROADCAST_MESSAGE_TYPE, false);
        target.variables[newMsg.id] = newMsg;
      }
    }

    let targets = [target];
    const deferredMonitors = [];

    for (let n = 0; n < children.length; n++) {
      if (children[n]) {
        if (children[n].deferredMonitor) {
          deferredMonitors.push(children[n]);
        } else {
          targets = targets.concat(children[n]);
        }
      }
    } // It is important that monitors are parsed last
    // - after all sprite targets have finished parsing
    // - and this is the last thing that happens in the stage parsing
    // It is specifically important that all the scripts in the project
    // have been parsed and all the relevant targets exist, have uids,
    // and have their variables initialized.


    for (let n = 0; n < deferredMonitors.length; n++) {
      parseMonitorObject(deferredMonitors[n], runtime, targets, extensions);
    }

    return targets;
  }));
};

const reorderParsedTargets = function (targets) {
  // Reorder parsed targets based on the temporary targetPaneOrder property
  // and then delete it.
  const reordered = targets.map((t, index) => {
    t.layerOrder = index;
    return t;
  }).sort((a, b) => a.targetPaneOrder - b.targetPaneOrder); // Delete the temporary target pane ordering since we shouldn't need it anymore.

  reordered.forEach(t => {
    delete t.targetPaneOrder;
  });
  return reordered;
};
/**
 * Top-level handler. Parse provided JSON,
 * and process the top-level object (the stage object).
 * @param {!object} json SB2-format JSON to load.
 * @param {!Runtime} runtime Runtime object to load all structures into.
 * @param {boolean=} optForceSprite If set, treat as sprite (Sprite2).
 * @param {?object} zip Optional zipped assets for local file import
 * @return {Promise.<ImportedProject>} Promise that resolves to the loaded targets when ready.
 */


const sb2import = function (json, runtime, optForceSprite, zip) {
  const extensions = {
    extensionIDs: new Set(),
    extensionURLs: new Map()
  };
  return Promise.resolve(parseScratchAssets(json, runtime, !optForceSprite, zip)) // Force this promise to wait for the next loop in the js tick. Let
  // storage have some time to send off asset requests.
  .then(assets => Promise.resolve(assets)).then(assets => parseScratchObject(json, runtime, extensions, !optForceSprite, zip, assets)).then(reorderParsedTargets).then(targets => ({
    targets,
    extensions
  }));
};
/**
 * Given the sb2 block, inspect the specmap for a translation method or object.
 * @param {!object} block a sb2 formatted block
 * @return {object} specmap block to parse this opcode
 */


const specMapBlock = function (block) {
  const opcode = block[0];
  const mapped = opcode && specMap[opcode];

  if (!mapped) {
    console.warn(`Couldn't find SB2 block: ${opcode}`);
    return null;
  }

  if (typeof mapped === "function") {
    return mapped(block);
  }

  return mapped;
};
/**
 * Parse a single SB2 JSON-formatted block and its children.
 * @param {!object} sb2block SB2 JSON-formatted block.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retrieve a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {ParseState} parseState - info on the state of parsing beyond the current block.
 * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.
 * They are indexed in this object by the sb2 flattened block list index indicating
 * which block they should attach to.
 * @param {int} commentIndex The comment index for the block to be parsed if it were in a flattened
 * list of all blocks for the target
 * @return {Array.<object|int>} Tuple where first item is the Scratch VM-format block (or null if unsupported object),
 * and second item is the updated comment index (after this block and its children are parsed)
 */


const parseBlock = function (sb2block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {
  const commentsForParsedBlock = comments && typeof commentIndex === "number" && !isNaN(commentIndex) ? comments[commentIndex] : null;
  const blockMetadata = specMapBlock(sb2block);

  if (!blockMetadata) {
    // No block opcode found, exclude this block, increment the commentIndex,
    // make all block comments into workspace comments and send them to zero/zero
    // to prevent serialization issues.
    if (commentsForParsedBlock) {
      commentsForParsedBlock.forEach(comment => {
        comment.blockId = null;
        comment.x = comment.y = 0;
      });
    }

    return [null, commentIndex + 1];
  }

  const oldOpcode = sb2block[0]; // If the block is from an extension, record it.

  const index = blockMetadata.opcode.indexOf("_");
  const prefix = blockMetadata.opcode.substring(0, index);

  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {
    if (prefix !== "") extensions.extensionIDs.add(prefix);
  } // Block skeleton.


  const activeBlock = {
    id: Utility.uid(),
    // Generate a new block unique ID.
    opcode: blockMetadata.opcode,
    // Converted, e.g. "motion_movesteps".
    inputs: {},
    // Inputs to this block and the blocks they point to.
    fields: {},
    // Fields on this block and their values.
    next: null,
    // Next block.
    shadow: false,
    // No shadow blocks in an SB2 by default.
    children: [] // Store any generated children, flattened in `flatten`.

  }; // Attach any comments to this block..

  if (commentsForParsedBlock) {
    // Attach only the last comment to the block, make all others workspace comments
    activeBlock.comment = commentsForParsedBlock[commentsForParsedBlock.length - 1].id;
    commentsForParsedBlock.forEach(comment => {
      if (comment.id === activeBlock.comment) {
        comment.blockId = activeBlock.id;
      } else {
        // All other comments don't get a block ID and are sent back to zero.
        // This is important, because if they have `null` x/y, serialization breaks.
        comment.blockId = null;
        comment.x = comment.y = 0;
      }
    });
  }

  commentIndex++;
  const parentExpectedArg = parseState.expectedArg; // For a procedure call, generate argument map from proc string.

  if (oldOpcode === "call") {
    blockMetadata.argMap = parseProcedureArgMap(sb2block[1]);
  } // Look at the expected arguments in `blockMetadata.argMap.`
  // The basic problem here is to turn positional SB2 arguments into
  // non-positional named Scratch VM arguments.


  for (let i = 0; i < blockMetadata.argMap.length; i++) {
    const expectedArg = blockMetadata.argMap[i];
    const providedArg = sb2block[i + 1]; // (i = 0 is opcode)
    // Whether the input is obscuring a shadow.

    let shadowObscured = false; // Positional argument is an input.

    if (expectedArg.type === "input") {
      // Create a new block and input metadata.
      const inputUid = Utility.uid();
      activeBlock.inputs[expectedArg.inputName] = {
        name: expectedArg.inputName,
        block: null,
        shadow: null
      };

      if (typeof providedArg === "object" && providedArg) {
        // Block or block list occupies the input.
        let innerBlocks;
        parseState.expectedArg = expectedArg;

        if (typeof providedArg[0] === "object" && providedArg[0]) {
          // Block list occupies the input.
          [innerBlocks, commentIndex] = parseBlockList(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
        } else {
          // Single block occupies the input.
          const parsedBlockDesc = parseBlock(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
          innerBlocks = parsedBlockDesc[0] ? [parsedBlockDesc[0]] : []; // Update commentIndex

          commentIndex = parsedBlockDesc[1];
        }

        parseState.expectedArg = parentExpectedArg; // Check if innerBlocks is not an empty list.
        // An empty list indicates that all the inner blocks from the sb2 have
        // unknown opcodes and have been skipped.

        if (innerBlocks.length > 0) {
          let previousBlock = null;

          for (let j = 0; j < innerBlocks.length; j++) {
            if (j === 0) {
              innerBlocks[j].parent = activeBlock.id;
            } else {
              innerBlocks[j].parent = previousBlock;
            }

            previousBlock = innerBlocks[j].id;
          }

          activeBlock.inputs[expectedArg.inputName].block = innerBlocks[0].id;
          activeBlock.children = activeBlock.children.concat(innerBlocks);
        } // Obscures any shadow.


        shadowObscured = true;
      } // Generate a shadow block to occupy the input.


      if (!expectedArg.inputOp) {
        // Undefined inputOp. inputOp should always be defined for inputs.
        console.warn(`Unknown input operation for input ${expectedArg.inputName} of opcode ${activeBlock.opcode}.`);
        continue;
      }

      if (expectedArg.inputOp === "boolean" || expectedArg.inputOp === "substack") {
        // No editable shadow input; e.g., for a boolean.
        continue;
      } // Each shadow has a field generated for it automatically.
      // Value to be filled in the field.


      let fieldValue = providedArg; // Shadows' field names match the input name, except for these:

      let fieldName = expectedArg.inputName;

      if (expectedArg.inputOp === "math_number" || expectedArg.inputOp === "math_whole_number" || expectedArg.inputOp === "math_positive_number" || expectedArg.inputOp === "math_integer" || expectedArg.inputOp === "math_angle") {
        fieldName = "NUM"; // Fields are given Scratch 2.0 default values if obscured.

        if (shadowObscured) {
          fieldValue = 10;
        }
      } else if (expectedArg.inputOp === "text") {
        fieldName = "TEXT";

        if (shadowObscured) {
          fieldValue = "";
        }
      } else if (expectedArg.inputOp === "colour_picker") {
        // Convert SB2 color to hex.
        fieldValue = Utility.decimalToHex(providedArg);
        fieldName = "COLOUR";

        if (shadowObscured) {
          fieldValue = "#990000";
        }
      } else if (expectedArg.inputOp === "event_broadcast_menu") {
        fieldName = "BROADCAST_OPTION";

        if (shadowObscured) {
          fieldValue = "";
        }
      } else if (expectedArg.inputOp === "sensing_of_object_menu") {
        if (shadowObscured) {
          fieldValue = "_stage_";
        } else if (fieldValue === "Stage") {
          fieldValue = "_stage_";
        }
      } else if (expectedArg.inputOp === "note") {
        if (shadowObscured) {
          fieldValue = 60;
        }
      } else if (expectedArg.inputOp === "music.menu.DRUM") {
        if (shadowObscured) {
          fieldValue = 1;
        }
      } else if (expectedArg.inputOp === "music.menu.INSTRUMENT") {
        if (shadowObscured) {
          fieldValue = 1;
        }
      } else if (expectedArg.inputOp === "videoSensing.menu.ATTRIBUTE") {
        if (shadowObscured) {
          fieldValue = "motion";
        }
      } else if (expectedArg.inputOp === "videoSensing.menu.SUBJECT") {
        if (shadowObscured) {
          fieldValue = "this sprite";
        }
      } else if (expectedArg.inputOp === "videoSensing.menu.VIDEO_STATE") {
        if (shadowObscured) {
          fieldValue = "on";
        }
      } else if (shadowObscured) {
        // Filled drop-down menu.
        fieldValue = "";
      }

      const fields = {};
      fields[fieldName] = {
        name: fieldName,
        value: fieldValue
      }; // event_broadcast_menus have some extra properties to add to the
      // field and a different value than the rest

      if (expectedArg.inputOp === "event_broadcast_menu") {
        // Need to update the broadcast message name map with
        // the value of this field.
        // Also need to provide the fields[fieldName] object,
        // so that we can later update its value property, e.g.
        // if sb2 message name is empty string, we will later
        // replace this field's value with messageN
        // once we can traverse through all the existing message names
        // and come up with a fresh messageN.
        const broadcastId = addBroadcastMsg(fieldValue, fields[fieldName]);
        fields[fieldName].id = broadcastId;
        fields[fieldName].variableType = expectedArg.variableType;
      }

      activeBlock.children.push({
        id: inputUid,
        opcode: expectedArg.inputOp,
        inputs: {},
        fields: fields,
        next: null,
        topLevel: false,
        parent: activeBlock.id,
        shadow: true
      });
      activeBlock.inputs[expectedArg.inputName].shadow = inputUid; // If no block occupying the input, alias to the shadow.

      if (!activeBlock.inputs[expectedArg.inputName].block) {
        activeBlock.inputs[expectedArg.inputName].block = inputUid;
      }
    } else if (expectedArg.type === "field") {
      // Add as a field on this block.
      activeBlock.fields[expectedArg.fieldName] = {
        name: expectedArg.fieldName,
        value: providedArg
      };

      if (expectedArg.fieldName === "CURRENTMENU") {
        // In 3.0, the field value of the `sensing_current` block
        // is in all caps.
        activeBlock.fields[expectedArg.fieldName].value = providedArg.toUpperCase();

        if (providedArg === "day of week") {
          activeBlock.fields[expectedArg.fieldName].value = "DAYOFWEEK";
        }
      }

      if (expectedArg.fieldName === "VARIABLE") {
        // Add `id` property to variable fields
        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.SCALAR_TYPE);
      } else if (expectedArg.fieldName === "LIST") {
        // Add `id` property to variable fields
        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.LIST_TYPE);
      } else if (expectedArg.fieldName === "BROADCAST_OPTION") {
        // Add the name in this field to the broadcast msg name map.
        // Also need to provide the fields[fieldName] object,
        // so that we can later update its value property, e.g.
        // if sb2 message name is empty string, we will later
        // replace this field's value with messageN
        // once we can traverse through all the existing message names
        // and come up with a fresh messageN.
        const broadcastId = addBroadcastMsg(providedArg, activeBlock.fields[expectedArg.fieldName]);
        activeBlock.fields[expectedArg.fieldName].id = broadcastId;
      }

      const varType = expectedArg.variableType;

      if (typeof varType === "string") {
        activeBlock.fields[expectedArg.fieldName].variableType = varType;
      }
    }
  } // Updates for blocks that have new menus (e.g. in Looks)


  switch (oldOpcode) {
    case "comeToFront":
      activeBlock.fields.FRONT_BACK = {
        name: "FRONT_BACK",
        value: "front"
      };
      break;

    case "goBackByLayers:":
      activeBlock.fields.FORWARD_BACKWARD = {
        name: "FORWARD_BACKWARD",
        value: "backward"
      };
      break;

    case "backgroundIndex":
      activeBlock.fields.NUMBER_NAME = {
        name: "NUMBER_NAME",
        value: "number"
      };
      break;

    case "sceneName":
      activeBlock.fields.NUMBER_NAME = {
        name: "NUMBER_NAME",
        value: "name"
      };
      break;

    case "costumeIndex":
      activeBlock.fields.NUMBER_NAME = {
        name: "NUMBER_NAME",
        value: "number"
      };
      break;

    case "costumeName":
      activeBlock.fields.NUMBER_NAME = {
        name: "NUMBER_NAME",
        value: "name"
      };
      break;
  } // Special cases to generate mutations.


  if (oldOpcode === "stopScripts") {
    // Mutation for stop block: if the argument is 'other scripts',
    // the block needs a next connection.
    if (sb2block[1] === "other scripts in sprite" || sb2block[1] === "other scripts in stage") {
      activeBlock.mutation = {
        tagName: "mutation",
        hasnext: "true",
        children: []
      };
    }
  } else if (oldOpcode === "procDef") {
    // Mutation for procedure definition:
    // store all 2.0 proc data.
    const procData = sb2block.slice(1); // Create a new block and input metadata.

    const inputUid = Utility.uid();
    const inputName = "custom_block";
    activeBlock.inputs[inputName] = {
      name: inputName,
      block: inputUid,
      shadow: inputUid
    };
    activeBlock.children = [{
      id: inputUid,
      opcode: "procedures_prototype",
      inputs: {},
      fields: {},
      next: null,
      shadow: true,
      children: [],
      mutation: {
        tagName: "mutation",
        proccode: procData[0],
        // e.g., "abc %n %b %s"
        argumentnames: JSON.stringify(procData[1]),
        // e.g. ['arg1', 'arg2']
        argumentids: JSON.stringify(parseProcedureArgIds(procData[0])),
        argumentdefaults: JSON.stringify(procData[2]),
        // e.g., [1, 'abc']
        warp: procData[3],
        // Warp mode, e.g., true/false.
        children: []
      }
    }];
  } else if (oldOpcode === "call") {
    // Mutation for procedure call:
    // string for proc code (e.g., "abc %n %b %s").
    activeBlock.mutation = {
      tagName: "mutation",
      children: [],
      proccode: sb2block[1],
      argumentids: JSON.stringify(parseProcedureArgIds(sb2block[1]))
    };
  } else if (oldOpcode === "getParam") {
    let returnCode = sb2block[2]; // Ensure the returnCode is "b" if used in a boolean input.

    if (parentExpectedArg && parentExpectedArg.inputOp === "boolean" && returnCode !== "b") {
      returnCode = "b";
    } // Assign correct opcode based on the block shape.


    switch (returnCode) {
      case "r":
        activeBlock.opcode = "argument_reporter_string_number";
        break;

      case "b":
        activeBlock.opcode = "argument_reporter_boolean";
        break;
    }
  }

  return [activeBlock, commentIndex];
};

module.exports = {
  deserialize: sb2import
};

/***/ }),

/***/ "./src/serialization/sb2_specmap.js":
/*!******************************************!*\
  !*** ./src/serialization/sb2_specmap.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * The specMap below handles a few pieces of "translation" work between
 * the SB2 JSON format and the data we need to run a project
 * in the Scratch 3.0 VM.
 * Notably:
 *  - Map 2.0 and 1.4 opcodes (forward:) into 3.0-format (motion_movesteps).
 *  - Map ordered, unnamed args to unordered, named inputs and fields.
 * Keep this up-to-date as 3.0 blocks are renamed, changed, etc.
 * Originally this was generated largely by a hand-guided scripting process.
 * The relevant data lives here:
 * https://github.com/LLK/scratch-flash/blob/master/src/Specs.as
 * (for the old opcode and argument order).
 * and here:
 * https://github.com/LLK/scratch-blocks/tree/develop/blocks_vertical
 * (for the new opcodes and argument names).
 * and here:
 * https://github.com/LLK/scratch-blocks/blob/develop/tests/
 * (for the shadow blocks created for each block).
 * I started with the `commands` array in Specs.as, and discarded irrelevant
 * properties. By hand, I matched the opcode name to the 3.0 opcode.
 * Finally, I filled in the expected arguments as below.
 */
const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");
/**
 * @typedef {object} SB2SpecMap_blockInfo
 * @property {string} opcode - the Scratch 3.0 block opcode. Use 'extensionID.opcode' for extension opcodes.
 * @property {Array.<SB2SpecMap_argInfo>} argMap - metadata for this block's arguments.
 */

/**
 * @typedef {object} SB2SpecMap_argInfo
 * @property {string} type - the type of this arg (such as 'input' or 'field')
 * @property {string} inputOp - the scratch-blocks shadow type for this arg
 * @property {string} inputName - the name this argument will take when provided to the block implementation
 */

/**
 * Mapping of Scratch 2.0 opcode to Scratch 3.0 block metadata.
 * @type {object.<SB2SpecMap_blockInfo>}
 */


const specMap = {
  'forward:': {
    opcode: 'motion_movesteps',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'STEPS'
    }]
  },
  'turnRight:': {
    opcode: 'motion_turnright',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DEGREES'
    }]
  },
  'turnLeft:': {
    opcode: 'motion_turnleft',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DEGREES'
    }]
  },
  'heading:': {
    opcode: 'motion_pointindirection',
    argMap: [{
      type: 'input',
      inputOp: 'math_angle',
      inputName: 'DIRECTION'
    }]
  },
  'pointTowards:': {
    opcode: 'motion_pointtowards',
    argMap: [{
      type: 'input',
      inputOp: 'motion_pointtowards_menu',
      inputName: 'TOWARDS'
    }]
  },
  'gotoX:y:': {
    opcode: 'motion_gotoxy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'gotoSpriteOrMouse:': {
    opcode: 'motion_goto',
    argMap: [{
      type: 'input',
      inputOp: 'motion_goto_menu',
      inputName: 'TO'
    }]
  },
  'glideSecs:toX:y:elapsed:from:': {
    opcode: 'motion_glidesecstoxy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'changeXposBy:': {
    opcode: 'motion_changexby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DX'
    }]
  },
  'xpos:': {
    opcode: 'motion_setx',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }]
  },
  'changeYposBy:': {
    opcode: 'motion_changeyby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DY'
    }]
  },
  'ypos:': {
    opcode: 'motion_sety',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'bounceOffEdge': {
    opcode: 'motion_ifonedgebounce',
    argMap: []
  },
  'setRotationStyle': {
    opcode: 'motion_setrotationstyle',
    argMap: [{
      type: 'field',
      fieldName: 'STYLE'
    }]
  },
  'xpos': {
    opcode: 'motion_xposition',
    argMap: []
  },
  'ypos': {
    opcode: 'motion_yposition',
    argMap: []
  },
  'heading': {
    opcode: 'motion_direction',
    argMap: []
  },
  'scrollRight': {
    opcode: 'motion_scroll_right',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DISTANCE'
    }]
  },
  'scrollUp': {
    opcode: 'motion_scroll_up',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DISTANCE'
    }]
  },
  'scrollAlign': {
    opcode: 'motion_align_scene',
    argMap: [{
      type: 'field',
      fieldName: 'ALIGNMENT'
    }]
  },
  'xScroll': {
    opcode: 'motion_xscroll',
    argMap: []
  },
  'yScroll': {
    opcode: 'motion_yscroll',
    argMap: []
  },
  'say:duration:elapsed:from:': {
    opcode: 'looks_sayforsecs',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }]
  },
  'say:': {
    opcode: 'looks_say',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }]
  },
  'think:duration:elapsed:from:': {
    opcode: 'looks_thinkforsecs',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }]
  },
  'think:': {
    opcode: 'looks_think',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }]
  },
  'show': {
    opcode: 'looks_show',
    argMap: []
  },
  'hide': {
    opcode: 'looks_hide',
    argMap: []
  },
  'hideAll': {
    opcode: 'looks_hideallsprites',
    argMap: []
  },
  'lookLike:': {
    opcode: 'looks_switchcostumeto',
    argMap: [{
      type: 'input',
      inputOp: 'looks_costume',
      inputName: 'COSTUME'
    }]
  },
  'nextCostume': {
    opcode: 'looks_nextcostume',
    argMap: []
  },
  'startScene': {
    opcode: 'looks_switchbackdropto',
    argMap: [{
      type: 'input',
      inputOp: 'looks_backdrops',
      inputName: 'BACKDROP'
    }]
  },
  'changeGraphicEffect:by:': {
    opcode: 'looks_changeeffectby',
    argMap: [{
      type: 'field',
      fieldName: 'EFFECT'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setGraphicEffect:to:': {
    opcode: 'looks_seteffectto',
    argMap: [{
      type: 'field',
      fieldName: 'EFFECT'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VALUE'
    }]
  },
  'filterReset': {
    opcode: 'looks_cleargraphiceffects',
    argMap: []
  },
  'changeSizeBy:': {
    opcode: 'looks_changesizeby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setSizeTo:': {
    opcode: 'looks_setsizeto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'changeStretchBy:': {
    opcode: 'looks_changestretchby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setStretchTo:': {
    opcode: 'looks_setstretchto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'STRETCH'
    }]
  },
  'comeToFront': {
    opcode: 'looks_gotofrontback',
    argMap: []
  },
  'goBackByLayers:': {
    opcode: 'looks_goforwardbackwardlayers',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'NUM'
    }]
  },
  'costumeIndex': {
    opcode: 'looks_costumenumbername',
    argMap: []
  },
  'costumeName': {
    opcode: 'looks_costumenumbername',
    argMap: []
  },
  'sceneName': {
    opcode: 'looks_backdropnumbername',
    argMap: []
  },
  'scale': {
    opcode: 'looks_size',
    argMap: []
  },
  'startSceneAndWait': {
    opcode: 'looks_switchbackdroptoandwait',
    argMap: [{
      type: 'input',
      inputOp: 'looks_backdrops',
      inputName: 'BACKDROP'
    }]
  },
  'nextScene': {
    opcode: 'looks_nextbackdrop',
    argMap: []
  },
  'backgroundIndex': {
    opcode: 'looks_backdropnumbername',
    argMap: []
  },
  'playSound:': {
    opcode: 'sound_play',
    argMap: [{
      type: 'input',
      inputOp: 'sound_sounds_menu',
      inputName: 'SOUND_MENU'
    }]
  },
  'doPlaySoundAndWait': {
    opcode: 'sound_playuntildone',
    argMap: [{
      type: 'input',
      inputOp: 'sound_sounds_menu',
      inputName: 'SOUND_MENU'
    }]
  },
  'stopAllSounds': {
    opcode: 'sound_stopallsounds',
    argMap: []
  },
  'playDrum': {
    opcode: 'music_playDrumForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'music_menu_DRUM',
      inputName: 'DRUM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'drum:duration:elapsed:from:': {
    opcode: 'music_midiPlayDrumForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DRUM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'rest:elapsed:from:': {
    opcode: 'music_restForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'noteOn:duration:elapsed:from:': {
    opcode: 'music_playNoteForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'note',
      inputName: 'NOTE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'instrument:': {
    opcode: 'music_setInstrument',
    argMap: [{
      type: 'input',
      inputOp: 'music_menu_INSTRUMENT',
      inputName: 'INSTRUMENT'
    }]
  },
  'midiInstrument:': {
    opcode: 'music_midiSetInstrument',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'INSTRUMENT'
    }]
  },
  'changeVolumeBy:': {
    opcode: 'sound_changevolumeby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VOLUME'
    }]
  },
  'setVolumeTo:': {
    opcode: 'sound_setvolumeto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VOLUME'
    }]
  },
  'volume': {
    opcode: 'sound_volume',
    argMap: []
  },
  'changeTempoBy:': {
    opcode: 'music_changeTempo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TEMPO'
    }]
  },
  'setTempoTo:': {
    opcode: 'music_setTempo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TEMPO'
    }]
  },
  'tempo': {
    opcode: 'music_getTempo',
    argMap: []
  },
  'clearPenTrails': {
    opcode: 'pen_clear',
    argMap: []
  },
  'stampCostume': {
    opcode: 'pen_stamp',
    argMap: []
  },
  'putPenDown': {
    opcode: 'pen_penDown',
    argMap: []
  },
  'putPenUp': {
    opcode: 'pen_penUp',
    argMap: []
  },
  'penColor:': {
    opcode: 'pen_setPenColorToColor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }]
  },
  'changePenHueBy:': {
    opcode: 'pen_changePenHueBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'HUE'
    }]
  },
  'setPenHueTo:': {
    opcode: 'pen_setPenHueToNumber',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'HUE'
    }]
  },
  'changePenShadeBy:': {
    opcode: 'pen_changePenShadeBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SHADE'
    }]
  },
  'setPenShadeTo:': {
    opcode: 'pen_setPenShadeToNumber',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SHADE'
    }]
  },
  'changePenSizeBy:': {
    opcode: 'pen_changePenSizeBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'penSize:': {
    opcode: 'pen_setPenSizeTo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'senseVideoMotion': {
    opcode: 'videoSensing_videoOn',
    argMap: [{
      type: 'input',
      inputOp: 'videoSensing_menu_ATTRIBUTE',
      inputName: 'ATTRIBUTE'
    }, {
      type: 'input',
      inputOp: 'videoSensing_menu_SUBJECT',
      inputName: 'SUBJECT'
    }]
  },
  'whenGreenFlag': {
    opcode: 'event_whenflagclicked',
    argMap: []
  },
  'whenKeyPressed': {
    opcode: 'event_whenkeypressed',
    argMap: [{
      type: 'field',
      fieldName: 'KEY_OPTION'
    }]
  },
  'whenClicked': {
    opcode: 'event_whenthisspriteclicked',
    argMap: []
  },
  'whenSceneStarts': {
    opcode: 'event_whenbackdropswitchesto',
    argMap: [{
      type: 'field',
      fieldName: 'BACKDROP'
    }]
  },
  'whenSensorGreaterThan': ([, sensor]) => {
    if (sensor === 'video motion') {
      return {
        opcode: 'videoSensing_whenMotionGreaterThan',
        argMap: [// skip the first arg, since we converted to a video specific sensing block
        {}, {
          type: 'input',
          inputOp: 'math_number',
          inputName: 'REFERENCE'
        }]
      };
    }

    return {
      opcode: 'event_whengreaterthan',
      argMap: [{
        type: 'field',
        fieldName: 'WHENGREATERTHANMENU'
      }, {
        type: 'input',
        inputOp: 'math_number',
        inputName: 'VALUE'
      }]
    };
  },
  'whenIReceive': {
    opcode: 'event_whenbroadcastreceived',
    argMap: [{
      type: 'field',
      fieldName: 'BROADCAST_OPTION',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'broadcast:': {
    opcode: 'event_broadcast',
    argMap: [{
      type: 'input',
      inputOp: 'event_broadcast_menu',
      inputName: 'BROADCAST_INPUT',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'doBroadcastAndWait': {
    opcode: 'event_broadcastandwait',
    argMap: [{
      type: 'input',
      inputOp: 'event_broadcast_menu',
      inputName: 'BROADCAST_INPUT',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'wait:elapsed:from:': {
    opcode: 'control_wait',
    argMap: [{
      type: 'input',
      inputOp: 'math_positive_number',
      inputName: 'DURATION'
    }]
  },
  'doRepeat': {
    opcode: 'control_repeat',
    argMap: [{
      type: 'input',
      inputOp: 'math_whole_number',
      inputName: 'TIMES'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doForever': {
    opcode: 'control_forever',
    argMap: [{
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doIf': {
    opcode: 'control_if',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doIfElse': {
    opcode: 'control_if_else',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK2'
    }]
  },
  'doWaitUntil': {
    opcode: 'control_wait_until',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }]
  },
  'doUntil': {
    opcode: 'control_repeat_until',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doWhile': {
    opcode: 'control_while',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doForLoop': {
    opcode: 'control_for_each',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'VALUE'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'stopScripts': {
    opcode: 'control_stop',
    argMap: [{
      type: 'field',
      fieldName: 'STOP_OPTION'
    }]
  },
  'whenCloned': {
    opcode: 'control_start_as_clone',
    argMap: []
  },
  'createCloneOf': {
    opcode: 'control_create_clone_of',
    argMap: [{
      type: 'input',
      inputOp: 'control_create_clone_of_menu',
      inputName: 'CLONE_OPTION'
    }]
  },
  'deleteClone': {
    opcode: 'control_delete_this_clone',
    argMap: []
  },
  'COUNT': {
    opcode: 'control_get_counter',
    argMap: []
  },
  'INCR_COUNT': {
    opcode: 'control_incr_counter',
    argMap: []
  },
  'CLR_COUNT': {
    opcode: 'control_clear_counter',
    argMap: []
  },
  'warpSpeed': {
    opcode: 'control_all_at_once',
    argMap: [{
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'touching:': {
    opcode: 'sensing_touchingobject',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_touchingobjectmenu',
      inputName: 'TOUCHINGOBJECTMENU'
    }]
  },
  'touchingColor:': {
    opcode: 'sensing_touchingcolor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }]
  },
  'color:sees:': {
    opcode: 'sensing_coloristouchingcolor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }, {
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR2'
    }]
  },
  'distanceTo:': {
    opcode: 'sensing_distanceto',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_distancetomenu',
      inputName: 'DISTANCETOMENU'
    }]
  },
  'doAsk': {
    opcode: 'sensing_askandwait',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'QUESTION'
    }]
  },
  'answer': {
    opcode: 'sensing_answer',
    argMap: []
  },
  'keyPressed:': {
    opcode: 'sensing_keypressed',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_keyoptions',
      inputName: 'KEY_OPTION'
    }]
  },
  'mousePressed': {
    opcode: 'sensing_mousedown',
    argMap: []
  },
  'mouseX': {
    opcode: 'sensing_mousex',
    argMap: []
  },
  'mouseY': {
    opcode: 'sensing_mousey',
    argMap: []
  },
  'soundLevel': {
    opcode: 'sensing_loudness',
    argMap: []
  },
  'isLoud': {
    opcode: 'sensing_loud',
    argMap: []
  },
  // 'senseVideoMotion': {
  //     opcode: 'sensing_videoon',
  //     argMap: [
  //         {
  //             type: 'input',
  //             inputOp: 'sensing_videoonmenuone',
  //             inputName: 'VIDEOONMENU1'
  //         },
  //         {
  //             type: 'input',
  //             inputOp: 'sensing_videoonmenutwo',
  //             inputName: 'VIDEOONMENU2'
  //         }
  //     ]
  // },
  'setVideoState': {
    opcode: 'videoSensing_videoToggle',
    argMap: [{
      type: 'input',
      inputOp: 'videoSensing_menu_VIDEO_STATE',
      inputName: 'VIDEO_STATE'
    }]
  },
  'setVideoTransparency': {
    opcode: 'videoSensing_setVideoTransparency',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TRANSPARENCY'
    }]
  },
  'timer': {
    opcode: 'sensing_timer',
    argMap: []
  },
  'timerReset': {
    opcode: 'sensing_resettimer',
    argMap: []
  },
  'getAttribute:of:': {
    opcode: 'sensing_of',
    argMap: [{
      type: 'field',
      fieldName: 'PROPERTY'
    }, {
      type: 'input',
      inputOp: 'sensing_of_object_menu',
      inputName: 'OBJECT'
    }]
  },
  'timeAndDate': {
    opcode: 'sensing_current',
    argMap: [{
      type: 'field',
      fieldName: 'CURRENTMENU'
    }]
  },
  'timestamp': {
    opcode: 'sensing_dayssince2000',
    argMap: []
  },
  'getUserName': {
    opcode: 'sensing_username',
    argMap: []
  },
  'getUserId': {
    opcode: 'sensing_userid',
    argMap: []
  },
  '+': {
    opcode: 'operator_add',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '-': {
    opcode: 'operator_subtract',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '*': {
    opcode: 'operator_multiply',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '/': {
    opcode: 'operator_divide',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  'randomFrom:to:': {
    opcode: 'operator_random',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'FROM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TO'
    }]
  },
  '<': {
    opcode: 'operator_lt',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '=': {
    opcode: 'operator_equals',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '>': {
    opcode: 'operator_gt',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '&': {
    opcode: 'operator_and',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND2'
    }]
  },
  '|': {
    opcode: 'operator_or',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND2'
    }]
  },
  'not': {
    opcode: 'operator_not',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND'
    }]
  },
  'concatenate:with:': {
    opcode: 'operator_join',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING2'
    }]
  },
  'letter:of:': {
    opcode: 'operator_letter_of',
    argMap: [{
      type: 'input',
      inputOp: 'math_whole_number',
      inputName: 'LETTER'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING'
    }]
  },
  'stringLength:': {
    opcode: 'operator_length',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING'
    }]
  },
  '%': {
    opcode: 'operator_mod',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  'rounded': {
    opcode: 'operator_round',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM'
    }]
  },
  'computeFunction:of:': {
    opcode: 'operator_mathop',
    argMap: [{
      type: 'field',
      fieldName: 'OPERATOR'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM'
    }]
  },
  'readVariable': {
    opcode: 'data_variable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  // Scratch 2 uses this alternative variable getter opcode only in monitors,
  // blocks use the `readVariable` opcode above.
  'getVar:': {
    opcode: 'data_variable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'setVar:to:': {
    opcode: 'data_setvariableto',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'VALUE'
    }]
  },
  'changeVar:by:': {
    opcode: 'data_changevariableby',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VALUE'
    }]
  },
  'showVariable:': {
    opcode: 'data_showvariable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'hideVariable:': {
    opcode: 'data_hidevariable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'contentsOfList:': {
    opcode: 'data_listcontents',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'append:toList:': {
    opcode: 'data_addtolist',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'deleteLine:ofList:': {
    opcode: 'data_deleteoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'insert:at:ofList:': {
    opcode: 'data_insertatlist',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }, {
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'setLine:ofList:to:': {
    opcode: 'data_replaceitemoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }]
  },
  'getLine:ofList:': {
    opcode: 'data_itemoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'lineCountOfList:': {
    opcode: 'data_lengthoflist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'list:contains:': {
    opcode: 'data_listcontainsitem',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }]
  },
  'showList:': {
    opcode: 'data_showlist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'hideList:': {
    opcode: 'data_hidelist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'procDef': {
    opcode: 'procedures_definition',
    argMap: []
  },
  'getParam': {
    // Doesn't map to single opcode. Import step assigns final correct opcode.
    opcode: 'argument_reporter_string_number',
    argMap: [{
      type: 'field',
      fieldName: 'VALUE'
    }]
  },
  'call': {
    opcode: 'procedures_call',
    argMap: []
  }
};
/**
 * Add to the specMap entries for an opcode from a Scratch 2.0 extension. Two entries will be made with the same
 * metadata; this is done to support projects saved by both older and newer versions of the Scratch 2.0 editor.
 * @param {string} sb2Extension - the Scratch 2.0 name of the extension
 * @param {string} sb2Opcode - the Scratch 2.0 opcode
 * @param {SB2SpecMap_blockInfo} blockInfo - the Scratch 3.0 block info
 */

const addExtensionOp = function (sb2Extension, sb2Opcode, blockInfo) {
  /**
   * This string separates the name of an extension and the name of an opcode in more recent Scratch 2.0 projects.
   * Earlier projects used '.' as a separator, up until we added the 'LEGO WeDo 2.0' extension...
   * @type {string}
   */
  const sep = '\u001F'; // Unicode Unit Separator
  // make one entry for projects saved by recent versions of the Scratch 2.0 editor

  specMap[`${sb2Extension}${sep}${sb2Opcode}`] = blockInfo; // make a second for projects saved by older versions of the Scratch 2.0 editor

  specMap[`${sb2Extension}.${sb2Opcode}`] = blockInfo;
};

const weDo2 = 'LEGO WeDo 2.0';
addExtensionOp(weDo2, 'motorOnFor', {
  opcode: 'wedo2_motorOnFor',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'DURATION'
  }]
});
addExtensionOp(weDo2, 'motorOn', {
  opcode: 'wedo2_motorOn',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }]
});
addExtensionOp(weDo2, 'motorOff', {
  opcode: 'wedo2_motorOff',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }]
});
addExtensionOp(weDo2, 'startMotorPower', {
  opcode: 'wedo2_startMotorPower',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'POWER'
  }]
});
addExtensionOp(weDo2, 'setMotorDirection', {
  opcode: 'wedo2_setMotorDirection',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_DIRECTION',
    inputName: 'MOTOR_DIRECTION'
  }]
});
addExtensionOp(weDo2, 'setLED', {
  opcode: 'wedo2_setLightHue',
  argMap: [{
    type: 'input',
    inputOp: 'math_number',
    inputName: 'HUE'
  }]
});
addExtensionOp(weDo2, 'playNote', {
  opcode: 'wedo2_playNoteFor',
  argMap: [{
    type: 'input',
    inputOp: 'math_number',
    inputName: 'NOTE'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'DURATION'
  }]
});
addExtensionOp(weDo2, 'whenDistance', {
  opcode: 'wedo2_whenDistance',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_OP',
    inputName: 'OP'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'REFERENCE'
  }]
});
addExtensionOp(weDo2, 'whenTilted', {
  opcode: 'wedo2_whenTilted',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION_ANY',
    inputName: 'TILT_DIRECTION_ANY'
  }]
});
addExtensionOp(weDo2, 'getDistance', {
  opcode: 'wedo2_getDistance',
  argMap: []
});
addExtensionOp(weDo2, 'isTilted', {
  opcode: 'wedo2_isTilted',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION_ANY',
    inputName: 'TILT_DIRECTION_ANY'
  }]
});
addExtensionOp(weDo2, 'getTilt', {
  opcode: 'wedo2_getTiltAngle',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION',
    inputName: 'TILT_DIRECTION'
  }]
});
module.exports = specMap;

/***/ }),

/***/ "./src/serialization/sb3.js":
/*!**********************************!*\
  !*** ./src/serialization/sb3.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview SB3 SONvm.
 */
const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");

const Sprite = __webpack_require__(/*! ../sprites/sprite */ "./src/sprites/sprite.js");

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");

const MonitorRecord = __webpack_require__(/*! ../engine/monitor-record */ "./src/engine/monitor-record.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const VariableUtil = __webpack_require__(/*! ../util/variable-util */ "./src/util/variable-util.js");

const {
  loadCostume
} = __webpack_require__(/*! ../import/load-costume.js */ "./src/import/load-costume.js");

const {
  loadSound
} = __webpack_require__(/*! ../import/load-sound.js */ "./src/import/load-sound.js");

const {
  deserializeCostume,
  deserializeSound
} = __webpack_require__(/*! ./deserialize-assets.js */ "./src/serialization/deserialize-assets.js");

const hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * @typedef {object} ImportedProject
 * @property {Array.<Target>} targets - the imported Scratch 3.0 target objects.
 * @property {ImportedExtensionsInfo} extensionsInfo - the ID of each extension actually used by this project.
 */

/**
 * @typedef {object} ImportedExtensionsInfo
 * @property {Set.<string>} extensionIDs - the ID of each extension actually in use by blocks in this project.
 * @property {Map.<string, string>} extensionURLs - map of ID => URL from project metadata. May not match extensionIDs.
 */
// Constants used during serialization and deserialization

const INPUT_SAME_BLOCK_SHADOW = 1; // unobscured shadow

const INPUT_BLOCK_NO_SHADOW = 2; // no shadow

const INPUT_DIFF_BLOCK_SHADOW = 3; // obscured shadow
// There shouldn't be a case where block is null, but shadow is present...
// Constants used during deserialization of an SB3 file

const CORE_EXTENSIONS = ["argument", "colour", "control", "data", "event", "looks", "math", "motion", "operator", "procedures", "sensing", "sound"]; // Constants referring to 'primitive' blocks that are usually shadows,
// or in the case of variables and lists, appear quite often in projects
// math_number

const MATH_NUM_PRIMITIVE = 4; // there's no reason these constants can't collide
// math_positive_number

const POSITIVE_NUM_PRIMITIVE = 5; // with the above, but removing duplication for clarity
// math_whole_number

const WHOLE_NUM_PRIMITIVE = 6; // math_integer

const INTEGER_NUM_PRIMITIVE = 7; // math_angle

const ANGLE_NUM_PRIMITIVE = 8; // colour_picker

const COLOR_PICKER_PRIMITIVE = 9; // text

const TEXT_PRIMITIVE = 10; // event_broadcast_menu

const BROADCAST_PRIMITIVE = 11; // data_variable

const VAR_PRIMITIVE = 12; // data_listcontents

const LIST_PRIMITIVE = 13; // Map block opcodes to the above primitives and the name of the field we can use
// to find the value of the field

const primitiveOpcodeInfoMap = {
  math_number: [MATH_NUM_PRIMITIVE, "NUM"],
  math_positive_number: [POSITIVE_NUM_PRIMITIVE, "NUM"],
  math_whole_number: [WHOLE_NUM_PRIMITIVE, "NUM"],
  math_integer: [INTEGER_NUM_PRIMITIVE, "NUM"],
  math_angle: [ANGLE_NUM_PRIMITIVE, "NUM"],
  colour_picker: [COLOR_PICKER_PRIMITIVE, "COLOUR"],
  text: [TEXT_PRIMITIVE, "TEXT"],
  event_broadcast_menu: [BROADCAST_PRIMITIVE, "BROADCAST_OPTION"],
  data_variable: [VAR_PRIMITIVE, "VARIABLE"],
  data_listcontents: [LIST_PRIMITIVE, "LIST"]
};
/**
 * Serializes primitives described above into a more compact format
 * @param {object} block the block to serialize
 * @return {array} An array representing the information in the block,
 * or null if the given block is not one of the primitives described above.
 */

const serializePrimitiveBlock = function (block) {
  // Returns an array represeting a primitive block or null if not one of
  // the primitive types above
  if (hasOwnProperty.call(primitiveOpcodeInfoMap, block.opcode)) {
    const primitiveInfo = primitiveOpcodeInfoMap[block.opcode];
    const primitiveConstant = primitiveInfo[0];
    const fieldName = primitiveInfo[1];
    const field = block.fields[fieldName];
    const primitiveDesc = [primitiveConstant, field.value];

    if (block.opcode === "event_broadcast_menu") {
      primitiveDesc.push(field.id);
    } else if (block.opcode === "data_variable" || block.opcode === "data_listcontents") {
      primitiveDesc.push(field.id);

      if (block.topLevel) {
        primitiveDesc.push(block.x ? Math.round(block.x) : 0);
        primitiveDesc.push(block.y ? Math.round(block.y) : 0);
      }
    }

    return primitiveDesc;
  }

  return null;
};
/**
 * Serializes the inputs field of a block in a compact form using
 * constants described above to represent the relationship between the
 * inputs of this block (e.g. if there is an unobscured shadow, an obscured shadow
 * -- a block plugged into a droppable input -- or, if there is just a block).
 * Based on this relationship, serializes the ids of the block and shadow (if present)
 *
 * @param {object} inputs The inputs to serialize
 * @return {object} An object representing the serialized inputs
 */


const serializeInputs = function (inputs) {
  const obj = Object.create(null);

  for (const inputName in inputs) {
    if (!hasOwnProperty.call(inputs, inputName)) continue; // if block and shadow refer to the same block, only serialize one

    if (inputs[inputName].block === inputs[inputName].shadow) {
      // has block and shadow, and they are the same
      obj[inputName] = [INPUT_SAME_BLOCK_SHADOW, inputs[inputName].block];
    } else if (inputs[inputName].shadow === null) {
      // does not have shadow
      obj[inputName] = [INPUT_BLOCK_NO_SHADOW, inputs[inputName].block];
    } else {
      // block and shadow are both present and are different
      obj[inputName] = [INPUT_DIFF_BLOCK_SHADOW, inputs[inputName].block, inputs[inputName].shadow];
    }
  }

  return obj;
};
/**
 * Serialize the fields of a block in a more compact form.
 * @param {object} fields The fields object to serialize
 * @return {object} An object representing the serialized fields
 */


const serializeFields = function (fields) {
  const obj = Object.create(null);

  for (const fieldName in fields) {
    if (!hasOwnProperty.call(fields, fieldName)) continue;
    obj[fieldName] = [fields[fieldName].value];

    if (fields[fieldName].hasOwnProperty("id")) {
      obj[fieldName].push(fields[fieldName].id);
    }
  }

  return obj;
};
/**
 * Serialize the given block in the SB3 format with some compression of inputs,
 * fields, and primitives.
 * @param {object} block The block to serialize
 * @return {object | array} A serialized representation of the block. This is an
 * array if the block is one of the primitive types described above or an object,
 * if not.
 */


const serializeBlock = function (block) {
  const serializedPrimitive = serializePrimitiveBlock(block);
  if (serializedPrimitive) return serializedPrimitive; // If serializedPrimitive is null, proceed with serializing a non-primitive block

  const obj = Object.create(null);
  obj.opcode = block.opcode; // NOTE: this is extremely important to serialize even if null;
  // not serializing `next: null` results in strange behavior with block
  // execution

  obj.next = block.next;
  obj.parent = block.parent;
  obj.inputs = serializeInputs(block.inputs);
  obj.fields = serializeFields(block.fields);
  obj.shadow = block.shadow;

  if (block.topLevel) {
    obj.topLevel = true;
    obj.x = block.x ? Math.round(block.x) : 0;
    obj.y = block.y ? Math.round(block.y) : 0;
  } else {
    obj.topLevel = false;
  }

  if (block.mutation) {
    obj.mutation = block.mutation;
  }

  if (block.comment) {
    obj.comment = block.comment;
  }

  return obj;
};
/**
 * Compresses the serialized inputs replacing block/shadow ids that refer to
 * one of the primitives with the primitive itself. E.g.
 *
 * blocks: {
 *      aUidForMyBlock: {
 *          inputs: {
 *               MYINPUT: [1, 'aUidForAnUnobscuredShadowPrimitive']
 *          }
 *      },
 *      aUidForAnUnobscuredShadowPrimitive: [4, 10]
 *      // the above is a primitive representing a 'math_number' with value 10
 * }
 *
 * becomes:
 *
 * blocks: {
 *      aUidForMyBlock: {
 *          inputs: {
 *               MYINPUT: [1, [4, 10]]
 *          }
 *      }
 * }
 * Note: this function modifies the given blocks object in place
 * @param {object} block The block with inputs to compress
 * @param {objec} blocks The object containing all the blocks currently getting serialized
 * @return {object} The serialized block with compressed inputs
 */


const compressInputTree = function (block, blocks) {
  // This is the second pass on the block
  // so the inputs field should be an object of key - array pairs
  const serializedInputs = block.inputs;

  for (const inputName in serializedInputs) {
    // don't need to check for hasOwnProperty because of how we constructed
    // inputs
    const currInput = serializedInputs[inputName]; // traverse currInput skipping the first element, which describes whether the block
    // and shadow are the same

    for (let i = 1; i < currInput.length; i++) {
      if (!currInput[i]) continue; // need this check b/c block/shadow can be null

      const blockOrShadowID = currInput[i]; // replace element of currInput directly
      // (modifying input block directly)

      const blockOrShadow = blocks[blockOrShadowID];

      if (Array.isArray(blockOrShadow)) {
        currInput[i] = blockOrShadow; // Modifying blocks in place!

        delete blocks[blockOrShadowID];
      }
    }
  }

  return block;
};
/**
 * Get non-core extension ID for a given sb3 opcode.
 * @param {!string} opcode The opcode to examine for extension.
 * @return {?string} The extension ID, if it exists and is not a core extension.
 */


const getExtensionIdForOpcode = function (opcode) {
  const index = opcode.indexOf("_");
  const prefix = opcode.substring(0, index);

  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {
    if (prefix !== "") return prefix;
  }
};
/**
 * Serialize the given blocks object (representing all the blocks for the target
 * currently being serialized.)
 * @param {object} blocks The blocks to be serialized
 * @return {Array} An array of the serialized blocks with compressed inputs and
 * compressed primitives and the list of all extension IDs present
 * in the serialized blocks.
 */


const serializeBlocks = function (blocks) {
  const obj = Object.create(null);
  const extensionIDs = new Set();

  for (const blockID in blocks) {
    if (!blocks.hasOwnProperty(blockID)) continue;
    obj[blockID] = serializeBlock(blocks[blockID], blocks);
    const extensionID = getExtensionIdForOpcode(blocks[blockID].opcode);

    if (extensionID) {
      extensionIDs.add(extensionID);
    }
  } // once we have completed a first pass, do a second pass on block inputs


  for (const blockID in obj) {
    // don't need to do the hasOwnProperty check here since we
    // created an object that doesn't get extra properties/functions
    const serializedBlock = obj[blockID]; // caution, this function deletes parts of this object in place as
    // it's traversing it

    obj[blockID] = compressInputTree(serializedBlock, obj); // second pass on connecting primitives to serialized inputs directly
  } // Do one last pass and remove any top level shadows (these are caused by
  // a bug: LLK/scratch-vm#1011, and this pass should be removed once that is
  // completely fixed)


  for (const blockID in obj) {
    const serializedBlock = obj[blockID]; // If the current block is serialized as a primitive (e.g. it's an array
    // instead of an object), AND it is not one of the top level primitives
    // e.g. variable getter or list getter, then it should be deleted as it's
    // a shadow block, and there are no blocks that reference it, otherwise
    // they would have been compressed in the last pass)

    if (Array.isArray(serializedBlock) && [VAR_PRIMITIVE, LIST_PRIMITIVE].indexOf(serializedBlock[0]) < 0) {
      console.warn(`Found an unexpected top level primitive with block ID: ${blockID}; deleting it from serialized blocks.`);
      delete obj[blockID];
    }
  }

  return [obj, Array.from(extensionIDs)];
};
/**
 * Serialize the given costume.
 * @param {object} costume The costume to be serialized.
 * @return {object} A serialized representation of the costume.
 */


const serializeCostume = function (costume) {
  const obj = Object.create(null);
  obj.assetId = costume.assetId;
  obj.name = costume.name;
  obj.bitmapResolution = costume.bitmapResolution; // serialize this property with the name 'md5ext' because that's
  // what it's actually referring to. TODO runtime objects need to be
  // updated to actually refer to this as 'md5ext' instead of 'md5'
  // but that change should be made carefully since it is very
  // pervasive

  obj.md5ext = costume.md5;
  obj.dataFormat = costume.dataFormat.toLowerCase();
  obj.rotationCenterX = costume.rotationCenterX;
  obj.rotationCenterY = costume.rotationCenterY;
  return obj;
};
/**
 * Serialize the given sound.
 * @param {object} sound The sound to be serialized.
 * @return {object} A serialized representation of the sound.
 */


const serializeSound = function (sound) {
  const obj = Object.create(null);
  obj.assetId = sound.assetId;
  obj.name = sound.name;
  obj.dataFormat = sound.dataFormat.toLowerCase();
  obj.format = sound.format;
  obj.rate = sound.rate;
  obj.sampleCount = sound.sampleCount; // serialize this property with the name 'md5ext' because that's
  // what it's actually referring to. TODO runtime objects need to be
  // updated to actually refer to this as 'md5ext' instead of 'md5'
  // but that change should be made carefully since it is very
  // pervasive

  obj.md5ext = sound.md5;
  return obj;
};
/**
 * Serialize the given variables object.
 * @param {object} variables The variables to be serialized.
 * @return {object} A serialized representation of the variables. They get
 * separated by type to compress the representation of each given variable and
 * reduce duplicate information.
 */


const serializeVariables = function (variables) {
  const obj = Object.create(null); // separate out variables into types at the top level so we don't have
  // keep track of a type for each

  obj.variables = Object.create(null);
  obj.lists = Object.create(null);
  obj.broadcasts = Object.create(null);

  for (const varId in variables) {
    const v = variables[varId];

    if (v.type === Variable.BROADCAST_MESSAGE_TYPE) {
      obj.broadcasts[varId] = v.value; // name and value is the same for broadcast msgs

      continue;
    }

    if (v.type === Variable.LIST_TYPE) {
      obj.lists[varId] = [v.name, v.value];
      continue;
    } // otherwise should be a scalar type


    obj.variables[varId] = [v.name, v.value]; // only scalar vars have the potential to be cloud vars

    if (v.isCloud) obj.variables[varId].push(true);
  }

  return obj;
};

const serializeComments = function (comments) {
  const obj = Object.create(null);

  for (const commentId in comments) {
    if (!comments.hasOwnProperty(commentId)) continue;
    const comment = comments[commentId];
    const serializedComment = Object.create(null);
    serializedComment.blockId = comment.blockId;
    serializedComment.x = comment.x;
    serializedComment.y = comment.y;
    serializedComment.width = comment.width;
    serializedComment.height = comment.height;
    serializedComment.minimized = comment.minimized;
    serializedComment.text = comment.text;
    obj[commentId] = serializedComment;
  }

  return obj;
};
/**
 * Serialize the given target. Only serialize properties that are necessary
 * for saving and loading this target.
 * @param {object} target The target to be serialized.
 * @param {Set} extensions A set of extensions to add extension IDs to
 * @return {object} A serialized representation of the given target.
 */


const serializeTarget = function (target, extensions) {
  const obj = Object.create(null);
  let targetExtensions = [];
  obj.isStage = target.isStage;
  obj.name = obj.isStage ? "Stage" : target.name;
  const vars = serializeVariables(target.variables);
  obj.variables = vars.variables;
  obj.lists = vars.lists;
  obj.broadcasts = vars.broadcasts;
  [obj.blocks, targetExtensions] = serializeBlocks(target.blocks);
  obj.comments = serializeComments(target.comments); // TODO remove this check/patch when (#1901) is fixed

  if (target.currentCostume < 0 || target.currentCostume >= target.costumes.length) {
    console.warn(`currentCostume property for target ${target.name} is out of range`);
    target.currentCostume = Utility.clamp(target.currentCostume, 0, target.costumes.length - 1);
  }

  obj.currentCostume = target.currentCostume;
  obj.costumes = target.costumes.map(serializeCostume);
  obj.sounds = target.sounds.map(serializeSound);
  if (target.hasOwnProperty("volume")) obj.volume = target.volume;
  if (target.hasOwnProperty("layerOrder")) obj.layerOrder = target.layerOrder;

  if (obj.isStage) {
    // Only the stage should have these properties
    if (target.hasOwnProperty("tempo")) obj.tempo = target.tempo;
    if (target.hasOwnProperty("videoTransparency")) obj.videoTransparency = target.videoTransparency;
    if (target.hasOwnProperty("videoState")) obj.videoState = target.videoState;
    if (target.hasOwnProperty("textToSpeechLanguage")) obj.textToSpeechLanguage = target.textToSpeechLanguage;
  } else {
    // The stage does not need the following properties, but sprites should
    obj.visible = target.visible;
    obj.x = target.x;
    obj.y = target.y;
    obj.size = target.size;
    obj.direction = target.direction;
    obj.draggable = target.draggable;
    obj.rotationStyle = target.rotationStyle;
  } // Add found extensions to the extensions object


  targetExtensions.forEach(extensionId => {
    extensions.add(extensionId);
  });
  return obj;
};

const getSimplifiedLayerOrdering = function (targets) {
  const layerOrders = targets.map(t => t.getLayerOrder());
  return Utility.reducedSortOrdering(layerOrders);
};

const serializeMonitors = function (monitors) {
  return monitors.valueSeq().map(monitorData => {
    const serializedMonitor = {
      id: monitorData.id,
      mode: monitorData.mode,
      opcode: monitorData.opcode,
      params: monitorData.params,
      spriteName: monitorData.spriteName,
      value: monitorData.value,
      width: monitorData.width,
      height: monitorData.height,
      x: monitorData.x,
      y: monitorData.y,
      visible: monitorData.visible
    };

    if (monitorData.mode !== "list") {
      serializedMonitor.sliderMin = monitorData.sliderMin;
      serializedMonitor.sliderMax = monitorData.sliderMax;
      serializedMonitor.isDiscrete = monitorData.isDiscrete;
    }

    return serializedMonitor;
  });
};
/**
 * Serializes the specified VM runtime.
 * @param {!Runtime} runtime VM runtime instance to be serialized.
 * @param {string=} targetId Optional target id if serializing only a single target
 * @return {object} Serialized runtime instance.
 */


const serialize = function (runtime, targetId) {
  // Fetch targets
  const obj = Object.create(null); // Create extension set to hold extension ids found while serializing targets

  const extensions = new Set();
  const originalTargetsToSerialize = targetId ? [runtime.getTargetById(targetId)] : runtime.targets.filter(target => target.isOriginal);
  const layerOrdering = getSimplifiedLayerOrdering(originalTargetsToSerialize);
  const flattenedOriginalTargets = originalTargetsToSerialize.map(t => t.toJSON()); // If the renderer is attached, and we're serializing a whole project (not a sprite)
  // add a temporary layerOrder property to each target.

  if (runtime.renderer && !targetId) {
    flattenedOriginalTargets.forEach((t, index) => {
      t.layerOrder = layerOrdering[index];
    });
  }

  const serializedTargets = flattenedOriginalTargets.map(t => serializeTarget(t, extensions));

  if (targetId) {
    return serializedTargets[0];
  }

  obj.targets = serializedTargets;
  obj.monitors = serializeMonitors(runtime.getMonitorState()); // Assemble extension list

  obj.extensions = Array.from(extensions); // Assemble metadata

  const meta = Object.create(null);
  meta.semver = "3.0.0";
  meta.vm = "0.2.0"; // Attach full user agent string to metadata if available

  meta.agent = "none";
  if (typeof navigator !== "undefined") meta.agent = navigator.userAgent; // Assemble payload and return

  obj.meta = meta;
  return obj;
};
/**
 * Deserialize a block input descriptors. This is either a
 * block id or a serialized primitive, e.g. an array
 * (see serializePrimitiveBlock function).
 * @param {string | array} inputDescOrId The block input descriptor to be serialized.
 * @param {string} parentId The id of the parent block for this input block.
 * @param {boolean} isShadow Whether or not this input block is a shadow.
 * @param {object} blocks The entire blocks object currently in the process of getting serialized.
 * @return {object} The deserialized input descriptor.
 */


const deserializeInputDesc = function (inputDescOrId, parentId, isShadow, blocks) {
  if (!Array.isArray(inputDescOrId)) return inputDescOrId;
  const primitiveObj = Object.create(null);
  console.warn("sb3:", Utility.uid());
  const newId = Utility.uid();
  primitiveObj.id = newId;
  primitiveObj.next = null;
  primitiveObj.parent = parentId;
  primitiveObj.shadow = isShadow;
  primitiveObj.inputs = Object.create(null); // need a reference to parent id

  switch (inputDescOrId[0]) {
    case MATH_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = "math_number";
        primitiveObj.fields = {
          NUM: {
            name: "NUM",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case POSITIVE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = "math_positive_number";
        primitiveObj.fields = {
          NUM: {
            name: "NUM",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case WHOLE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = "math_whole_number";
        primitiveObj.fields = {
          NUM: {
            name: "NUM",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case INTEGER_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = "math_integer";
        primitiveObj.fields = {
          NUM: {
            name: "NUM",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case ANGLE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = "math_angle";
        primitiveObj.fields = {
          NUM: {
            name: "NUM",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case COLOR_PICKER_PRIMITIVE:
      {
        primitiveObj.opcode = "colour_picker";
        primitiveObj.fields = {
          COLOUR: {
            name: "COLOUR",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case TEXT_PRIMITIVE:
      {
        primitiveObj.opcode = "text";
        primitiveObj.fields = {
          TEXT: {
            name: "TEXT",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case BROADCAST_PRIMITIVE:
      {
        primitiveObj.opcode = "event_broadcast_menu";
        primitiveObj.fields = {
          BROADCAST_OPTION: {
            name: "BROADCAST_OPTION",
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.BROADCAST_MESSAGE_TYPE
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case VAR_PRIMITIVE:
      {
        primitiveObj.opcode = "data_variable";
        primitiveObj.fields = {
          VARIABLE: {
            name: "VARIABLE",
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.SCALAR_TYPE
          }
        };

        if (inputDescOrId.length > 3) {
          primitiveObj.topLevel = true;
          primitiveObj.x = inputDescOrId[3];
          primitiveObj.y = inputDescOrId[4];
        }

        break;
      }

    case LIST_PRIMITIVE:
      {
        primitiveObj.opcode = "data_listcontents";
        primitiveObj.fields = {
          LIST: {
            name: "LIST",
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.LIST_TYPE
          }
        };

        if (inputDescOrId.length > 3) {
          primitiveObj.topLevel = true;
          primitiveObj.x = inputDescOrId[3];
          primitiveObj.y = inputDescOrId[4];
        }

        break;
      }

    default:
      {
        console.error(`Found unknown primitive type during deserialization: ${JSON.stringify(inputDescOrId)}`);
        return null;
      }
  }

  blocks[newId] = primitiveObj;
  return newId;
};
/**
 * Deserialize the given block inputs.
 * @param {object} inputs The inputs to deserialize.
 * @param {string} parentId The block id of the parent block
 * @param {object} blocks The object representing the entire set of blocks currently
 * in the process of getting deserialized.
 * @return {object} The deserialized and uncompressed inputs.
 */


const deserializeInputs = function (inputs, parentId, blocks) {
  // Explicitly not using Object.create(null) here
  // because we call prototype functions later in the vm
  const obj = {};

  for (const inputName in inputs) {
    if (!hasOwnProperty.call(inputs, inputName)) continue;
    const inputDescArr = inputs[inputName]; // If this block has already been deserialized (it's not an array) skip it

    if (!Array.isArray(inputDescArr)) continue;
    let block = null;
    let shadow = null;
    const blockShadowInfo = inputDescArr[0];

    if (blockShadowInfo === INPUT_SAME_BLOCK_SHADOW) {
      // block and shadow are the same id, and only one is provided
      block = shadow = deserializeInputDesc(inputDescArr[1], parentId, true, blocks);
    } else if (blockShadowInfo === INPUT_BLOCK_NO_SHADOW) {
      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);
    } else {
      // assume INPUT_DIFF_BLOCK_SHADOW
      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);
      shadow = deserializeInputDesc(inputDescArr[2], parentId, true, blocks);
    }

    obj[inputName] = {
      name: inputName,
      block: block,
      shadow: shadow
    };
  }

  return obj;
};
/**
 * Deserialize the given block fields.
 * @param {object} fields The fields to be deserialized
 * @return {object} The deserialized and uncompressed block fields.
 */


const deserializeFields = function (fields) {
  // Explicitly not using Object.create(null) here
  // because we call prototype functions later in the vm
  const obj = {};

  for (const fieldName in fields) {
    if (!hasOwnProperty.call(fields, fieldName)) continue;
    const fieldDescArr = fields[fieldName]; // If this block has already been deserialized (it's not an array) skip it

    if (!Array.isArray(fieldDescArr)) continue;
    obj[fieldName] = {
      name: fieldName,
      value: fieldDescArr[0]
    };

    if (fieldDescArr.length > 1) {
      obj[fieldName].id = fieldDescArr[1];
    }

    if (fieldName === "BROADCAST_OPTION") {
      obj[fieldName].variableType = Variable.BROADCAST_MESSAGE_TYPE;
    } else if (fieldName === "VARIABLE") {
      obj[fieldName].variableType = Variable.SCALAR_TYPE;
    } else if (fieldName === "LIST") {
      obj[fieldName].variableType = Variable.LIST_TYPE;
    }
  }

  return obj;
};
/**
 * Covnert serialized INPUT and FIELD primitives back to hydrated block templates.
 * Should be able to deserialize a format that has already been deserialized.  The only
 * "east" path to adding new targets/code requires going through deserialize, so it should
 * work with pre-parsed deserialized blocks.
 *
 * @param {object} blocks Serialized SB3 "blocks" property of a target. Will be mutated.
 * @return {object} input is modified and returned
 */


const deserializeBlocks = function (blocks) {
  for (const blockId in blocks) {
    if (!Object.prototype.hasOwnProperty.call(blocks, blockId)) {
      continue;
    }

    const block = blocks[blockId];

    if (Array.isArray(block)) {
      // this is one of the primitives
      // delete the old entry in object.blocks and replace it w/the
      // deserialized object
      delete blocks[blockId];
      deserializeInputDesc(block, null, false, blocks);
      continue;
    }

    block.id = blockId; // add id back to block since it wasn't serialized

    block.inputs = deserializeInputs(block.inputs, blockId, blocks);
    block.fields = deserializeFields(block.fields);
  }

  return blocks;
};
/**
 * . .
 * @param {!object} object JSON.
 * @param {!Runtime} runtime .
 * @param {JSZip} zip SB3
 * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank}}
 * Sprites SoundBank null.
 */


const parseKidAssets = function (object, runtime, zip) {
  console.log("sb3.js  parseKidAssets", object, runtime, zip); // /-VM.

  if (!object.hasOwnProperty("name")) return Promise.resolve(null);
  const assets = {
    costumePromises: null,
    soundPromises: null,
    soundBank: runtime.audioEngine && runtime.audioEngine.createBank()
  }; // Costumes from JSON.

  assets.costumePromises = (object.costumes || []).map(costumeSource => {
    // @todo: .
    const costume = {
      // costumeSource
      asset: costumeSource.asset,
      assetId: costumeSource.assetId,
      skinId: null,
      name: costumeSource.name,
      bitmapResolution: costumeSource.bitmapResolution,
      rotationCenterX: costumeSource.rotationCenterX,
      rotationCenterY: costumeSource.rotationCenterY
    };
    const dataFormat = costumeSource.dataFormat || costumeSource.assetType && costumeSource.assetType.runtimeFormat || // older format
    "png"; // PNG

    const costumeMd5Ext = costumeSource.hasOwnProperty("md5ext") ? costumeSource.md5ext : `${costumeSource.assetId}.${dataFormat}`;
    costume.md5 = costumeMd5Ext;
    costume.dataFormat = dataFormat; // deserializeCostumesb3

    console.log("sb3.js parseKidAssets return", costume, runtime, zip);
    return deserializeCostume(costume, runtime, zip).then(() => loadCostume(costumeMd5Ext, costume, runtime)); // 
  }); // Sounds from JSON

  assets.soundPromises = (object.sounds || []).map(soundSource => {
    const sound = {
      assetId: soundSource.assetId,
      format: soundSource.format,
      rate: soundSource.rate,
      sampleCount: soundSource.sampleCount,
      name: soundSource.name,
      // TODO we eventually want this property to be called md5ext,
      // but there are many things relying on this particular name at the
      // moment, so this translation is very important
      md5: soundSource.md5ext,
      dataFormat: soundSource.dataFormat,
      data: null
    }; // deserializeSound should be called on the sound object we're
    // creating above instead of the source sound object, because this way
    // we're always loading the 'sb3' representation of the costume
    // any translation that needs to happen will happen in the process
    // of building up the costume object into an sb3 format

    return deserializeSound(sound, runtime, zip).then(() => loadSound(sound, runtime, assets.soundBank)); // Only attempt to load the sound after the deserialization
    // process has been completed.
  });
  console.warn("parseKidAssets", assets);
  return assets;
};
/**
 *  ScratchVM.
 * @param {!object} object From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime .
 * @param {ImportedExtensionsInfo} extensions - (in/out) .
 * @param {JSZip} zip SB3
 * @param {object} assets - Promises for assets of this scratch object grouped
 *   into costumes and sounds
 * @return {!Promise.<Target>} Promise for the target created (stage or sprite), or null for unsupported objects.
 */


const parseKidObject = function (object, runtime, extensions, zip, assets) {
  console.log("parseKidObject :", object, runtime, extensions, zip, assets);

  if (!object.hasOwnProperty("name")) {
    // Watcher/monitor - VM.
    // @todo
    return Promise.resolve(null);
  } // .


  const blocks = new Blocks(runtime); // @todo: Kid/Sprite.

  const sprite = new Sprite(blocks, runtime);
  console.log("vm sb3.js Sprite", sprite); // Sprite/stage name from JSON.

  if (object.hasOwnProperty("name")) sprite.name = object.name;

  if (object.hasOwnProperty("blocks")) {
    deserializeBlocks(object.blocks); // Take a second pass to create objects and add extensions

    for (const blockId in object.blocks) {
      if (!object.blocks.hasOwnProperty(blockId)) continue;
      const blockJSON = object.blocks[blockId];
      blocks.createBlock(blockJSON); // If the block is from an extension, record it.

      const extensionID = getExtensionIdForOpcode(blockJSON.opcode);

      if (extensionID) {
        extensions.extensionIDs.add(extensionID);
      }
    }
  } // Costumes from JSON.


  const {
    costumePromises
  } = assets; // Sounds from JSON

  const {
    soundBank,
    soundPromises
  } = assets; // JSON.

  console.log(" sprite.");
  const target = sprite.createClone(object.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER); //  from JSON.

  if (object.hasOwnProperty("tempo")) {
    target.tempo = object.tempo;
  }

  if (object.hasOwnProperty("volume")) {
    target.volume = object.volume;
  }

  if (object.hasOwnProperty("videoTransparency")) {
    target.videoTransparency = object.videoTransparency;
  }

  if (object.hasOwnProperty("videoState")) {
    target.videoState = object.videoState;
  }

  if (object.hasOwnProperty("textToSpeechLanguage")) {
    target.textToSpeechLanguage = object.textToSpeechLanguage;
  }

  if (object.hasOwnProperty("variables")) {
    for (const varId in object.variables) {
      const variable = object.variables[varId]; // A variable is a cloud variable if:
      // - the project says it's a cloud variable, and
      // - it's a stage variable, and
      // - the runtime can support another cloud variable

      const isCloud = variable.length === 3 && variable[2] && object.isStage && runtime.canAddCloudVariable();
      const newVariable = new Variable(varId, // var id is the index of the variable desc array in the variables obj
      variable[0], // name of the variable
      Variable.SCALAR_TYPE, // type of the variable
      isCloud);
      if (isCloud) runtime.addCloudVariable();
      newVariable.value = variable[1];
      target.variables[newVariable.id] = newVariable;
    }
  }

  if (object.hasOwnProperty("lists")) {
    for (const listId in object.lists) {
      const list = object.lists[listId];
      const newList = new Variable(listId, list[0], Variable.LIST_TYPE, false);
      newList.value = list[1];
      target.variables[newList.id] = newList;
    }
  }

  if (object.hasOwnProperty("broadcasts")) {
    for (const broadcastId in object.broadcasts) {
      const broadcast = object.broadcasts[broadcastId];
      const newBroadcast = new Variable(broadcastId, broadcast, Variable.BROADCAST_MESSAGE_TYPE, false); // no need to explicitly set the value, variable constructor
      // sets the value to the same as the name for broadcast msgs

      target.variables[newBroadcast.id] = newBroadcast;
    }
  }

  if (object.hasOwnProperty("comments")) {
    for (const commentId in object.comments) {
      const comment = object.comments[commentId];
      const newComment = new Comment(commentId, comment.text, comment.x, comment.y, comment.width, comment.height, comment.minimized);

      if (comment.blockId) {
        newComment.blockId = comment.blockId;
      }

      target.comments[newComment.id] = newComment;
    }
  }

  if (object.hasOwnProperty("x")) {
    target.x = object.x;
  }

  if (object.hasOwnProperty("y")) {
    target.y = object.y;
  }

  if (object.hasOwnProperty("direction")) {
    target.direction = object.direction;
  }

  if (object.hasOwnProperty("size")) {
    target.size = object.size;
  }

  if (object.hasOwnProperty("visible")) {
    target.visible = object.visible;
  }

  if (object.hasOwnProperty("currentCostume")) {
    target.currentCostume = Utility.clamp(object.currentCostume, 0, object.costumes.length - 1);
  }

  if (object.hasOwnProperty("rotationStyle")) {
    target.rotationStyle = object.rotationStyle;
  }

  if (object.hasOwnProperty("isStage")) {
    target.isStage = object.isStage;
  }

  if (object.hasOwnProperty("targetPaneOrder")) {
    // Temporarily store the 'targetPaneOrder' property
    // so that we can correctly order sprites in the target pane.
    // This will be deleted after we are done parsing and ordering the targets list.
    target.targetPaneOrder = object.targetPaneOrder;
  }

  if (object.hasOwnProperty("draggable")) {
    target.draggable = object.draggable;
  }

  Promise.all(costumePromises).then(costumes => {
    console.log("vm sb3.js Promise.all ", costumes);
    sprite.costumes = costumes;
  });
  Promise.all(soundPromises).then(sounds => {
    sprite.sounds = sounds; // Make sure if soundBank is undefined, sprite.soundBank is then null.

    sprite.soundBank = soundBank || null;
  });
  return Promise.all(costumePromises.concat(soundPromises)).then(() => target);
};

const deserializeMonitor = function (monitorData, runtime, targets, extensions) {
  // spriteNamespritetargetIdspriteID.
  if (monitorData.spriteName) {
    const filteredTargets = targets.filter(t => t.sprite.name === monitorData.spriteName);

    if (filteredTargets && filteredTargets.length > 0) {
      monitorData.targetId = filteredTargets[0].id;
    } else {
      console.warn(`Tried to deserialize sprite specific monitor ${monitorData.opcode} but could not find sprite ${monitorData.spriteName}.`);
    }
  } // Get information about this monitor, if it exists, given the monitor's opcode.
  // This will be undefined for extension blocks


  const monitorBlockInfo = runtime.monitorBlockInfo[monitorData.opcode]; // Due to a bug (see https://github.com/LLK/scratch-vm/pull/2322), renamed list monitors may have been serialized
  // with an outdated/incorrect LIST parameter. Fix it up to use the current name of the actual corresponding list.

  if (monitorData.opcode === "data_listcontents") {
    const listTarget = monitorData.targetId ? targets.find(t => t.id === monitorData.targetId) : targets.find(t => t.isStage);

    if (listTarget && Object.prototype.hasOwnProperty.call(listTarget.variables, monitorData.id)) {
      monitorData.params.LIST = listTarget.variables[monitorData.id].name;
    }
  } // Convert the serialized monitorData params into the block fields structure


  const fields = {};

  for (const paramKey in monitorData.params) {
    const field = {
      name: paramKey,
      value: monitorData.params[paramKey]
    };
    fields[paramKey] = field;
  } // Variables, lists, and non-sprite-specific monitors, including any extension
  // monitors should already have the correct monitor ID serialized in the monitorData,
  // find the correct id for all other monitors.


  if (monitorData.opcode !== "data_variable" && monitorData.opcode !== "data_listcontents" && monitorBlockInfo && monitorBlockInfo.isSpriteSpecific) {
    monitorData.id = monitorBlockInfo.getId(monitorData.targetId, fields);
  } else {
    // Replace unsafe characters in monitor ID, if there are any.
    // These would have come from projects that were originally 2.0 projects
    // that had unsafe characters in the variable name (and then the name was
    // used as part of the variable ID when importing the project).
    monitorData.id = StringUtil.replaceUnsafeChars(monitorData.id);
  } // If the runtime already has a monitor block for this monitor's id,
  // update the existing block with the relevant monitor information.


  const existingMonitorBlock = runtime.monitorBlocks._blocks[monitorData.id];

  if (existingMonitorBlock) {
    // A monitor block already exists if the toolbox has been loaded and
    // the monitor block is not target specific (because the block gets recycled).
    existingMonitorBlock.isMonitored = monitorData.visible;
    existingMonitorBlock.targetId = monitorData.targetId;
  } else {
    // If a monitor block doesn't already exist for this monitor,
    // construct a monitor block to add to the monitor blocks container
    const monitorBlock = {
      id: monitorData.id,
      opcode: monitorData.opcode,
      inputs: {},
      // Assuming that monitor blocks don't have droppable fields
      fields: fields,
      topLevel: true,
      next: null,
      parent: null,
      shadow: false,
      x: 0,
      y: 0,
      isMonitored: monitorData.visible,
      targetId: monitorData.targetId
    }; // Variables and lists have additional properties
    // stored in their fields, update this info in the
    // monitor block fields

    if (monitorData.opcode === "data_variable") {
      const field = monitorBlock.fields.VARIABLE;
      field.id = monitorData.id;
      field.variableType = Variable.SCALAR_TYPE;
    } else if (monitorData.opcode === "data_listcontents") {
      const field = monitorBlock.fields.LIST;
      field.id = monitorData.id;
      field.variableType = Variable.LIST_TYPE;
    }

    runtime.monitorBlocks.createBlock(monitorBlock); // If the block is from an extension, record it.

    const extensionID = getExtensionIdForOpcode(monitorBlock.opcode);

    if (extensionID) {
      extensions.extensionIDs.add(extensionID);
    }
  }

  runtime.requestAddMonitor(MonitorRecord(monitorData));
}; // Replace variable IDs throughout the project with
// xml-safe versions.
// This is to fix up projects imported from 2.0 where xml-unsafe names
// were getting added to the variable ids.


const replaceUnsafeCharsInVariableIds = function (targets) {
  const allVarRefs = VariableUtil.getAllVarRefsForTargets(targets, true); // Re-id the variables in the actual targets

  targets.forEach(t => {
    Object.keys(t.variables).forEach(id => {
      const newId = StringUtil.replaceUnsafeChars(id);
      if (newId === id) return;
      t.variables[id].id = newId;
      t.variables[newId] = t.variables[id];
      delete t.variables[id];
    });
  }); // Replace the IDs in the blocks refrencing variables or lists

  for (const id in allVarRefs) {
    const newId = StringUtil.replaceUnsafeChars(id);
    if (id === newId) continue; // ID was already safe, skip
    // We're calling this on the stage target because we need a
    // target to call on but this shouldn't matter because we're passing
    // in all the varRefs we want to operate on

    VariableUtil.updateVariableIdentifiers(allVarRefs[id], newId);
  }

  return targets;
};
/**
 * VM.
 * @param  {object} json - VMJSON.
 * @param  {Runtime} runtime - Runtime instance
 * @param {JSZip} zip - SB3
 * @param {boolean} isSingleSprite - true
 * @returns {Promise.<ImportedProject>} 
 */


const deserialize = function (json, runtime, zip, isSingleSprite) {
  console.log("sb3.js VM", json, runtime, zip, isSingleSprite);
  const extensions = {
    extensionIDs: new Set(),
    extensionURLs: new Map()
  }; // json, 

  const targetObjects = ((isSingleSprite ? [json] : json.targets) || []).map((t, i) => Object.assign(t, {
    targetPaneOrder: i
  })).sort((a, b) => a.layerOrder - b.layerOrder);
  const monitorObjects = json.monitors || [];
  return Promise.resolve(targetObjects.map(target => parseKidAssets(target, runtime, zip))) // js. .
  .then(assets => Promise.resolve(assets)).then(assets => Promise.all(targetObjects.map((target, index) => parseKidObject(target, runtime, extensions, zip, assets[index])))).then(targets => targets // 
  .map((t, i) => {
    // .
    // VMinstallTargets
    t.layerOrder = i;
    return t;
  }).sort((a, b) => a.targetPaneOrder - b.targetPaneOrder).map(t => {
    // 
    delete t.targetPaneOrder;
    return t;
  })).then(targets => replaceUnsafeCharsInVariableIds(targets)).then(targets => {
    monitorObjects.map(monitorDesc => deserializeMonitor(monitorDesc, runtime, targets, extensions));
    return targets;
  }).then(targets => ({
    targets,
    extensions
  }));
};

module.exports = {
  serialize: serialize,
  deserialize: deserialize,
  deserializeBlocks: deserializeBlocks,
  serializeBlocks: serializeBlocks,
  getExtensionIdForOpcode: getExtensionIdForOpcode
};

/***/ }),

/***/ "./src/sprites/rendered-target.js":
/*!****************************************!*\
  !*** ./src/sprites/rendered-target.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const Target = __webpack_require__(/*! ../engine/target */ "./src/engine/target.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");
/**
 * : instance of a sprite (clone), or the stage.
 */


class RenderedTarget extends Target {
  /**
   * @param {!Sprite} sprite Reference to the parent sprite.
   * @param {Runtime} runtime Reference to the runtime.
   * @constructor
   */
  constructor(sprite, runtime) {
    super(runtime, sprite.blocks);
    console.log("class RenderedTarget", sprite, runtime);
    /**
     * Reference to the sprite that this is a render of.
     * @type {!Sprite}
     */

    this.sprite = sprite;
    /**
     * Reference to the global renderer for this VM, if one exists.
     * @type {?RenderWebGL}
     */

    this.renderer = null;

    if (this.runtime) {
      this.renderer = this.runtime.renderer;
    }
    /**
     * ID of the drawable for this rendered target,
     * returned by the renderer, if rendered.
     * @type {?Number}
     */


    this.drawableID = null;
    /**
     * Drag state of this rendered target. If true, x/y position can't be
     * changed by blocks.
     * @type {boolean}
     */

    this.dragging = false;
    /**
     * Map of current graphic effect values.
     * @type {!Object.<string, number>}
     */

    this.effects = {
      color: 0,
      fisheye: 0,
      whirl: 0,
      pixelate: 0,
      mosaic: 0,
      brightness: 0,
      ghost: 0
    };
    /**
     * Whether this represents an "original" non-clone rendered-target for a sprite,
     * i.e., created by the editor and not clone blocks.
     * @type {boolean}
     */

    this.isOriginal = true;
    /**
     * Whether this rendered target represents the Scratch stage.
     * @type {boolean}
     */

    this.isStage = false;
    /**
     * Scratch X coordinate. Currently should range from -240 to 240.
     * @type {Number}
     */

    this.x = 0;
    /**
     * Scratch Y coordinate. Currently should range from -180 to 180.
     * @type {number}
     */

    this.y = 0;
    /**
     * Scratch direction. Currently should range from -179 to 180.
     * @type {number}
     */

    this.direction = 90;
    /**
     * Whether the rendered target is draggable on the stage
     * @type {boolean}
     */

    this.draggable = false;
    /**
     * Whether the rendered target is currently visible.
     * @type {boolean}
     */

    this.visible = true;
    /**
     * Size of rendered target as a percent of costume size.
     * @type {number}
     */

    this.size = 100;
    /**
     * Currently selected costume index.
     * @type {number}
     */

    this.currentCostume = 0;
    /**
     * Current rotation style.
     * @type {!string}
     */

    this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    /**
     * Loudness for sound playback for this target, as a percentage.
     * @type {number}
     */

    this.volume = 100;
    /**
     * Current tempo (used by the music extension).
     * This property is global to the project and stored in the stage.
     * @type {number}
     */

    this.tempo = 60;
    /**
     * The transparency of the video (used by extensions with camera input).
     * This property is global to the project and stored in the stage.
     * @type {number}
     */

    this.videoTransparency = 50;
    /**
     * The state of the video input (used by extensions with camera input).
     * This property is global to the project and stored in the stage.
     *
     * Defaults to ON. This setting does not turn the video by itself. A
     * video extension once loaded will set the video device to this
     * setting. Set to ON when a video extension is added in the editor the
     * video will start ON. If the extension is loaded as part of loading a
     * saved project the extension will see the value set when the stage
     * was loaded from the saved values including the video state.
     *
     * @type {string}
     */

    this.videoState = RenderedTarget.VIDEO_STATE.ON;
    /**
     * The language to use for speech synthesis, in the text2speech extension.
     * It is initialized to null so that on extension load, we can check for
     * this and try setting it using the editor locale.
     * @type {string}
     */

    this.textToSpeechLanguage = null;
  }
  /**
   * Create a drawable with the this.renderer.
   * @param {boolean} layerGroup The layer group this drawable should be added to
   */


  initDrawable(layerGroup) {
    if (this.renderer) {
      this.drawableID = this.renderer.createDrawable(layerGroup);
    } // If we're a clone, start the hats.


    if (!this.isOriginal) {
      this.runtime.startHats("control_start_as_clone", null, this);
    }
  }

  get audioPlayer() {
    /* eslint-disable no-console */
    console.warn("get audioPlayer deprecated, please update to use .sprite.soundBank methods");
    console.warn(new Error("stack for debug").stack);
    /* eslint-enable no-console */

    const bank = this.sprite.soundBank;
    const audioPlayerProxy = {
      playSound: soundId => bank.play(this, soundId)
    };
    Object.defineProperty(this, "audioPlayer", {
      configurable: false,
      enumerable: true,
      writable: false,
      value: audioPlayerProxy
    });
    return audioPlayerProxy;
  }
  /**
   * Initialize the audio player for this sprite or clone.
   */


  initAudio() {}
  /**
   * Event which fires when a target moves.
   * @type {string}
   */


  static get EVENT_TARGET_MOVED() {
    return "TARGET_MOVED";
  }
  /**
   * Event which fires when a target changes visually, for updating say bubbles.
   * @type {string}
   */


  static get EVENT_TARGET_VISUAL_CHANGE() {
    return "EVENT_TARGET_VISUAL_CHANGE";
  }
  /**
   * Rotation style for "all around"/spinning.
   * @type {string}
   */


  static get ROTATION_STYLE_ALL_AROUND() {
    return "all around";
  }
  /**
   * Rotation style for "left-right"/flipping.
   * @type {string}
   */


  static get ROTATION_STYLE_LEFT_RIGHT() {
    return "left-right";
  }
  /**
   * Rotation style for "no rotation."
   * @type {string}
   */


  static get ROTATION_STYLE_NONE() {
    return "don't rotate";
  }
  /**
   * Available states for video input.
   * @enum {string}
   */


  static get VIDEO_STATE() {
    return {
      OFF: "off",
      ON: "on",
      ON_FLIPPED: "on-flipped"
    };
  }
  /**
   * Set the X and Y coordinates.
   * @param {!number} x New X coordinate, in Scratch coordinates.
   * @param {!number} y New Y coordinate, in Scratch coordinates.
   * @param {?boolean} force Force setting X/Y, in case of dragging
   */


  setXY(x, y, force) {
    if (this.isStage) return;
    if (this.dragging && !force) return;
    const oldX = this.x;
    const oldY = this.y;

    if (this.renderer) {
      const position = this.renderer.getFencedPositionOfDrawable(this.drawableID, [x, y]);
      this.x = position[0];
      this.y = position[1];
      this.renderer.updateDrawablePosition(this.drawableID, position);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    } else {
      this.x = x;
      this.y = y;
    }

    this.emit(RenderedTarget.EVENT_TARGET_MOVED, this, oldX, oldY, force);
    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * .
   * @return {object<string, number>} .
   */


  _getRenderedDirectionAndScale() {
    //  this.direction this.scale
    let finalDirection = this.direction;
    let finalScale = [this.size, this.size];

    if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
      // 90.
      finalDirection = 90;
    } else if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
      // 90.
      finalDirection = 90;
      const scaleFlip = this.direction < 0 ? -1 : 1;
      finalScale = [scaleFlip * this.size, this.size];
    }

    return {
      direction: finalDirection,
      scale: finalScale
    };
  }
  /**
   * .
   * @param {!number} direction New direction.
   */


  setDirection(direction) {
    console.log(":", direction);

    if (this.isStage) {
      return;
    }

    if (!isFinite(direction)) {
      return;
    } // -179+180.


    this.direction = Utility.wrapClamp(direction, -179, 180);

    if (this.renderer) {
      // 
      const {
        direction: renderedDirection,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawableDirectionScale(this.drawableID, renderedDirection, scale);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set draggability; i.e., whether it's able to be dragged in the player
   * @param {!boolean} draggable True if should be draggable.
   */


  setDraggable(draggable) {
    if (this.isStage) return;
    this.draggable = !!draggable;
    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set visibility; i.e., whether it's shown or hidden.
   * @param {!boolean} visible True if should be shown.
   */


  setVisible(visible) {
    if (this.isStage) {
      return;
    }

    this.visible = !!visible;

    if (this.renderer) {
      this.renderer.updateDrawableVisible(this.drawableID, this.visible);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set size, as a percentage of the costume size.
   * @param {!number} size Size of rendered target, as % of costume size.
   */


  setSize(size) {
    if (this.isStage) {
      return;
    }

    if (this.renderer) {
      // Clamp to scales relative to costume and stage size.
      // See original ScratchSprite.as:setSize.
      const costumeSize = this.renderer.getCurrentSkinSize(this.drawableID);
      const origW = costumeSize[0];
      const origH = costumeSize[1];
      const minScale = Math.min(1, Math.max(5 / origW, 5 / origH));
      const maxScale = Math.min(1.5 * this.runtime.constructor.STAGE_WIDTH / origW, 1.5 * this.runtime.constructor.STAGE_HEIGHT / origH);
      this.size = Utility.clamp(size / 100, minScale, maxScale) * 100;

      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set a particular graphic effect value.
   * @param {!string} effectName Name of effect (see `RenderedTarget.prototype.effects`).
   * @param {!number} value Numerical magnitude of effect.
   */


  setEffect(effectName, value) {
    if (!this.effects.hasOwnProperty(effectName)) return;
    this.effects[effectName] = value;

    if (this.renderer) {
      this.renderer.updateDrawableEffect(this.drawableID, effectName, value);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * Clear all graphic effects on this rendered target.
   */


  clearEffects() {
    for (const effectName in this.effects) {
      if (!this.effects.hasOwnProperty(effectName)) continue;
      this.effects[effectName] = 0;
    }

    if (this.renderer) {
      for (const effectName in this.effects) {
        if (!this.effects.hasOwnProperty(effectName)) continue;
        this.renderer.updateDrawableEffect(this.drawableID, effectName, 0);
      }

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * Set the current costume.
   * @param {number} index New index of costume.
   */


  setCostume(index) {
    // Keep the costume index within possible values.
    index = Math.round(index);
    if ([Infinity, -Infinity, NaN].includes(index)) index = 0;
    this.currentCostume = Utility.wrapClamp(index, 0, this.sprite.costumes.length - 1);

    if (this.renderer) {
      const costume = this.getCostumes()[this.currentCostume];
      this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * .
   * @param {!object} costumeObject Object representing the costume.
   * @param {?int} index Index at which to add costume
   */


  addCostume(costumeObject, index) {
    console.log("render-target.js ()", costumeObject, index);
    typeof index === "number" && !isNaN(index) ? this.sprite.addCostumeAt(costumeObject, index) : this.sprite.addCostumeAt(costumeObject, this.sprite.costumes.length);
  }
  /**
   * Rename a costume, taking care to avoid duplicate names.
   * @param {int} costumeIndex - the index of the costume to be renamed.
   * @param {string} newName - the desired new name of the costume (will be modified if already in use).
   */


  renameCostume(costumeIndex, newName) {
    const usedNames = this.sprite.costumes.filter((costume, index) => costumeIndex !== index).map(costume => costume.name);
    const oldName = this.getCostumes()[costumeIndex].name;
    const newUnusedName = StringUtil.unusedName(newName, usedNames);
    this.getCostumes()[costumeIndex].name = newUnusedName;

    if (this.isStage) {
      // Since this is a backdrop, go through all targets and
      // update any blocks referencing the old backdrop name
      const targets = this.runtime.targets;

      for (let i = 0; i < targets.length; i++) {
        const currTarget = targets[i];
        currTarget.blocks.updateAssetName(oldName, newUnusedName, "backdrop");
      }
    } else {
      this.blocks.updateAssetName(oldName, newUnusedName, "costume");
    }
  }
  /**
   * Delete a costume by index.
   * @param {number} index Costume index to be deleted
   * @return {?object} The costume that was deleted or null
   * if the index was out of bounds of the costumes list or
   * this target only has one costume.
   */


  deleteCostume(index) {
    const originalCostumeCount = this.sprite.costumes.length;
    if (originalCostumeCount === 1) return null;

    if (index < 0 || index >= originalCostumeCount) {
      return null;
    }

    const deletedCostume = this.sprite.deleteCostumeAt(index);

    if (index === this.currentCostume && index === originalCostumeCount - 1) {
      this.setCostume(index - 1);
    } else if (index < this.currentCostume) {
      this.setCostume(this.currentCostume - 1);
    } else {
      this.setCostume(this.currentCostume);
    }

    this.runtime.requestTargetsUpdate(this);
    return deletedCostume;
  }
  /**
   * Add a sound, taking care to avoid duplicate names.
   * @param {!object} soundObject Object representing the sound.
   * @param {?int} index Index at which to add costume
   */


  addSound(soundObject, index) {
    const usedNames = this.sprite.sounds.map(sound => sound.name);
    soundObject.name = StringUtil.unusedName(soundObject.name, usedNames);

    if (typeof index === "number" && !isNaN(index)) {
      this.sprite.sounds.splice(index, 0, soundObject);
    } else {
      this.sprite.sounds.push(soundObject);
    }
  }
  /**
   * Rename a sound, taking care to avoid duplicate names.
   * @param {int} soundIndex - the index of the sound to be renamed.
   * @param {string} newName - the desired new name of the sound (will be modified if already in use).
   */


  renameSound(soundIndex, newName) {
    const usedNames = this.sprite.sounds.filter((sound, index) => soundIndex !== index).map(sound => sound.name);
    const oldName = this.sprite.sounds[soundIndex].name;
    const newUnusedName = StringUtil.unusedName(newName, usedNames);
    this.sprite.sounds[soundIndex].name = newUnusedName;
    this.blocks.updateAssetName(oldName, newUnusedName, "sound");
  }
  /**
   * Delete a sound by index.
   * @param {number} index Sound index to be deleted
   * @return {object} The deleted sound object, or null if no sound was deleted.
   */


  deleteSound(index) {
    // Make sure the sound index is not out of bounds
    if (index < 0 || index >= this.sprite.sounds.length) {
      return null;
    } // Delete the sound at the given index


    const deletedSound = this.sprite.sounds.splice(index, 1)[0];
    this.runtime.requestTargetsUpdate(this);
    return deletedSound;
  }
  /**
   * Update the rotation style.
   * @param {!string} rotationStyle New rotation style.
   */


  setRotationStyle(rotationStyle) {
    if (rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
    } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
    }

    if (this.renderer) {
      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Get a costume index of this rendered target, by name of the costume.
   * @param {?string} costumeName Name of a costume.
   * @return {number} Index of the named costume, or -1 if not present.
   */


  getCostumeIndexByName(costumeName) {
    for (let i = 0; i < this.sprite.costumes.length; i++) {
      if (this.getCostumes()[i].name === costumeName) {
        return i;
      }
    }

    return -1;
  }
  /**
   * Get a costume of this rendered target by id.
   * @return {object} current costume
   */


  getCurrentCostume() {
    return this.getCostumes()[this.currentCostume];
  }
  /**
   * Get full costume list
   * @return {object[]} list of costumes
   */


  getCostumes() {
    return this.sprite.costumes;
  }
  /**
   * Reorder costume list by moving costume at costumeIndex to newIndex.
   * @param {!number} costumeIndex Index of the costume to move.
   * @param {!number} newIndex New index for that costume.
   * @returns {boolean} If a change occurred (i.e. if the indices do not match)
   */


  reorderCostume(costumeIndex, newIndex) {
    newIndex = Utility.clamp(newIndex, 0, this.sprite.costumes.length - 1);
    costumeIndex = Utility.clamp(costumeIndex, 0, this.sprite.costumes.length - 1);
    if (newIndex === costumeIndex) return false;
    const currentCostume = this.getCurrentCostume();
    const costume = this.sprite.costumes[costumeIndex]; // Use the sprite method for deleting costumes because setCostume is handled manually

    this.sprite.deleteCostumeAt(costumeIndex);
    this.addCostume(costume, newIndex);
    this.currentCostume = this.getCostumeIndexByName(currentCostume.name);
    return true;
  }
  /**
   * Reorder sound list by moving sound at soundIndex to newIndex.
   * @param {!number} soundIndex Index of the sound to move.
   * @param {!number} newIndex New index for that sound.
   * @returns {boolean} If a change occurred (i.e. if the indices do not match)
   */


  reorderSound(soundIndex, newIndex) {
    newIndex = Utility.clamp(newIndex, 0, this.sprite.sounds.length - 1);
    soundIndex = Utility.clamp(soundIndex, 0, this.sprite.sounds.length - 1);
    if (newIndex === soundIndex) return false;
    const sound = this.sprite.sounds[soundIndex];
    this.deleteSound(soundIndex);
    this.addSound(sound, newIndex);
    return true;
  }
  /**
   * Get full sound list
   * @return {object[]} list of sounds
   */


  getSounds() {
    return this.sprite.sounds;
  }
  /**
   * Update all drawable properties for this rendered target.
   * Use when a batch has changed, e.g., when the drawable is first created.
   */


  updateAllDrawableProperties() {
    if (this.renderer) {
      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawablePosition(this.drawableID, [this.x, this.y]);
      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);
      this.renderer.updateDrawableVisible(this.drawableID, this.visible);
      const costume = this.getCostumes()[this.currentCostume];
      this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);

      for (const effectName in this.effects) {
        if (!this.effects.hasOwnProperty(effectName)) continue;
        this.renderer.updateDrawableEffect(this.drawableID, effectName, this.effects[effectName]);
      }

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Return the human-readable name for this rendered target, e.g., the sprite's name.
   * @override
   * @returns {string} Human-readable name.
   */


  getName() {
    return this.sprite.name;
  }
  /**
   * Return whether this rendered target is a sprite (not a clone, not the stage).
   * @return {boolean} True if not a clone and not the stage.
   */


  isSprite() {
    return !this.isStage && this.isOriginal;
  }
  /**
   * Return the rendered target's tight bounding box.
   * Includes top, left, bottom, right attributes in Scratch coordinates.
   * @return {?object} Tight bounding box, or null.
   */


  getBounds() {
    if (this.renderer) {
      return this.runtime.renderer.getBounds(this.drawableID);
    }

    return null;
  }
  /**
   * Return the bounding box around a slice of the top 8px of the rendered target.
   * Includes top, left, bottom, right attributes in Scratch coordinates.
   * @return {?object} Tight bounding box, or null.
   */


  getBoundsForBubble() {
    if (this.renderer) {
      return this.runtime.renderer.getBoundsForBubble(this.drawableID);
    }

    return null;
  }
  /**
   * Return whether this target is touching the mouse, an edge, or a sprite.
   * @param {string} requestedObject an id for mouse or edge, or a sprite name.
   * @return {boolean} True if the sprite is touching the object.
   */


  isTouchingObject(requestedObject) {
    if (requestedObject === "_mouse_") {
      if (!this.runtime.ioDevices.mouse) return false;
      const mouseX = this.runtime.ioDevices.mouse.getClientX();
      const mouseY = this.runtime.ioDevices.mouse.getClientY();
      return this.isTouchingPoint(mouseX, mouseY);
    } else if (requestedObject === "_edge_") {
      return this.isTouchingEdge();
    }

    return this.isTouchingSprite(requestedObject);
  }
  /**
   * Return whether touching a point.
   * @param {number} x X coordinate of test point.
   * @param {number} y Y coordinate of test point.
   * @return {boolean} True iff the rendered target is touching the point.
   */


  isTouchingPoint(x, y) {
    if (this.renderer) {
      return this.renderer.drawableTouching(this.drawableID, x, y);
    }

    return false;
  }
  /**
   * Return whether touching a stage edge.
   * @return {boolean} True iff the rendered target is touching the stage edge.
   */


  isTouchingEdge() {
    if (this.renderer) {
      const stageWidth = this.runtime.constructor.STAGE_WIDTH;
      const stageHeight = this.runtime.constructor.STAGE_HEIGHT;
      const bounds = this.getBounds();

      if (bounds.left < -stageWidth / 2 || bounds.right > stageWidth / 2 || bounds.top > stageHeight / 2 || bounds.bottom < -stageHeight / 2) {
        return true;
      }
    }

    return false;
  }
  /**
   * Return whether touching any of a named sprite's clones.
   * @param {string} spriteName Name of the sprite.
   * @return {boolean} True iff touching a clone of the sprite.
   */


  isTouchingSprite(spriteName) {
    spriteName = String(spriteName);
    const firstClone = this.runtime.getSpriteTargetByName(spriteName);

    if (!firstClone || !this.renderer) {
      return false;
    } // Filter out dragging targets. This means a sprite that is being dragged
    // can detect other sprites using touching <sprite>, but cannot be detected
    // by other sprites while it is being dragged. This matches Scratch 2.0 behavior.


    const drawableCandidates = firstClone.sprite.clones.filter(clone => !clone.dragging).map(clone => clone.drawableID);
    return this.renderer.isTouchingDrawables(this.drawableID, drawableCandidates);
  }
  /**
   * Return whether touching a color.
   * @param {Array.<number>} rgb [r,g,b], values between 0-255.
   * @return {Promise.<boolean>} True iff the rendered target is touching the color.
   */


  isTouchingColor(rgb) {
    if (this.renderer) {
      return this.renderer.isTouchingColor(this.drawableID, rgb);
    }

    return false;
  }
  /**
   * Return whether rendered target's color is touching a color.
   * @param {object} targetRgb {Array.<number>} [r,g,b], values between 0-255.
   * @param {object} maskRgb {Array.<number>} [r,g,b], values between 0-255.
   * @return {Promise.<boolean>} True iff the color is touching the color.
   */


  colorIsTouchingColor(targetRgb, maskRgb) {
    if (this.renderer) {
      return this.renderer.isTouchingColor(this.drawableID, targetRgb, maskRgb);
    }

    return false;
  }

  getLayerOrder() {
    if (this.renderer) {
      return this.renderer.getDrawableOrder(this.drawableID);
    }

    return null;
  }
  /**
   * Move to the front layer.
   */


  goToFront() {
    // This should only ever be used for sprites
    if (this.renderer) {
      // Let the renderer re-order the sprite based on its knowledge
      // of what layers are present
      this.renderer.setDrawableOrder(this.drawableID, Infinity, StageLayering.SPRITE_LAYER);
    }

    this.runtime.setExecutablePosition(this, Infinity);
  }
  /**
   * Move to the back layer.
   */


  goToBack() {
    // This should only ever be used for sprites
    if (this.renderer) {
      // Let the renderer re-order the sprite based on its knowledge
      // of what layers are present
      this.renderer.setDrawableOrder(this.drawableID, -Infinity, StageLayering.SPRITE_LAYER, false);
    }

    this.runtime.setExecutablePosition(this, -Infinity);
  }
  /**
   * Move forward a number of layers.
   * @param {number} nLayers How many layers to go forward.
   */


  goForwardLayers(nLayers) {
    if (this.renderer) {
      this.renderer.setDrawableOrder(this.drawableID, nLayers, StageLayering.SPRITE_LAYER, true);
    }

    this.runtime.moveExecutable(this, nLayers);
  }
  /**
   * Move backward a number of layers.
   * @param {number} nLayers How many layers to go backward.
   */


  goBackwardLayers(nLayers) {
    if (this.renderer) {
      this.renderer.setDrawableOrder(this.drawableID, -nLayers, StageLayering.SPRITE_LAYER, true);
    }

    this.runtime.moveExecutable(this, -nLayers);
  }
  /**
   * Move behind some other rendered target.
   * @param {!RenderedTarget} other Other rendered target to move behind.
   */


  goBehindOther(other) {
    if (this.renderer) {
      const otherLayer = this.renderer.setDrawableOrder(other.drawableID, 0, StageLayering.SPRITE_LAYER, true);
      this.renderer.setDrawableOrder(this.drawableID, otherLayer, StageLayering.SPRITE_LAYER);
    }

    const executionPosition = this.runtime.executableTargets.indexOf(other);
    this.runtime.setExecutablePosition(this, executionPosition);
  }
  /**
   * Keep a desired position within a fence.
   * @param {number} newX New desired X position.
   * @param {number} newY New desired Y position.
   * @param {object=} optFence Optional fence with left, right, top bottom.
   * @return {Array.<number>} Fenced X and Y coordinates.
   */


  keepInFence(newX, newY, optFence) {
    let fence = optFence;

    if (!fence) {
      fence = {
        left: -this.runtime.constructor.STAGE_WIDTH / 2,
        right: this.runtime.constructor.STAGE_WIDTH / 2,
        top: this.runtime.constructor.STAGE_HEIGHT / 2,
        bottom: -this.runtime.constructor.STAGE_HEIGHT / 2
      };
    }

    const bounds = this.getBounds();
    if (!bounds) return; // Adjust the known bounds to the target position.

    bounds.left += newX - this.x;
    bounds.right += newX - this.x;
    bounds.top += newY - this.y;
    bounds.bottom += newY - this.y; // Find how far we need to move the target position.

    let dx = 0;
    let dy = 0;

    if (bounds.left < fence.left) {
      dx += fence.left - bounds.left;
    }

    if (bounds.right > fence.right) {
      dx += fence.right - bounds.right;
    }

    if (bounds.top > fence.top) {
      dy += fence.top - bounds.top;
    }

    if (bounds.bottom < fence.bottom) {
      dy += fence.bottom - bounds.bottom;
    }

    return [newX + dx, newY + dy];
  }
  /**
   * Make a clone, copying any run-time properties.
   * If we've hit the global clone limit, returns null.
   * @return {RenderedTarget} New clone.
   */


  makeClone() {
    if (!this.runtime.clonesAvailable() || this.isStage) {
      return null; // Hit max clone limit, or this is the stage.
    }

    this.runtime.changeCloneCounter(1);
    const newClone = this.sprite.createClone(); // Copy all properties.

    newClone.x = this.x;
    newClone.y = this.y;
    newClone.direction = this.direction;
    newClone.draggable = this.draggable;
    newClone.visible = this.visible;
    newClone.size = this.size;
    newClone.currentCostume = this.currentCostume;
    newClone.rotationStyle = this.rotationStyle;
    newClone.effects = Utility.cloneSimple(this.effects);
    newClone.variables = this.duplicateVariables();
    newClone._edgeActivatedHatValues = Utility.cloneSimple(this._edgeActivatedHatValues);
    newClone.initDrawable(StageLayering.SPRITE_LAYER);
    newClone.updateAllDrawableProperties();
    return newClone;
  }
  /**
   * Make a duplicate using a duplicate sprite.
   * @return {RenderedTarget} New clone.
   */


  duplicate() {
    return this.sprite.duplicate().then(newSprite => {
      const newTarget = newSprite.createClone(); // Copy all properties.
      // @todo refactor with clone methods

      newTarget.x = (Math.random() - 0.5) * 400 / 2;
      newTarget.y = (Math.random() - 0.5) * 300 / 2;
      newTarget.direction = this.direction;
      newTarget.draggable = this.draggable;
      newTarget.visible = this.visible;
      newTarget.size = this.size;
      newTarget.currentCostume = this.currentCostume;
      newTarget.rotationStyle = this.rotationStyle;
      newTarget.effects = JSON.parse(JSON.stringify(this.effects));
      newTarget.variables = this.duplicateVariables(newTarget.blocks);
      newTarget.updateAllDrawableProperties();
      return newTarget;
    });
  }
  /**
   * Called when the project receives a "green flag."
   * For a rendered target, this clears graphic effects.
   */


  onGreenFlag() {
    this.clearEffects();
  }
  /**
   * Called when the project receives a "stop all"
   * Stop all sounds and clear graphic effects.
   */


  onStopAll() {
    this.clearEffects();
  }
  /**
   * Post/edit sprite info.
   * @param {object} data An object with sprite info data to set.
   */


  postSpriteInfo(data) {
    const force = data.hasOwnProperty("force") ? data.force : null;
    const isXChanged = data.hasOwnProperty("x");
    const isYChanged = data.hasOwnProperty("y");

    if (isXChanged || isYChanged) {
      this.setXY(isXChanged ? data.x : this.x, isYChanged ? data.y : this.y, force);
    }

    if (data.hasOwnProperty("direction")) {
      this.setDirection(data.direction);
    }

    if (data.hasOwnProperty("draggable")) {
      this.setDraggable(data.draggable);
    }

    if (data.hasOwnProperty("rotationStyle")) {
      this.setRotationStyle(data.rotationStyle);
    }

    if (data.hasOwnProperty("visible")) {
      this.setVisible(data.visible);
    }

    if (data.hasOwnProperty("size")) {
      this.setSize(data.size);
    }
  }
  /**
   * Put the sprite into the drag state. While in effect, setXY must be forced
   */


  startDrag() {
    this.dragging = true;
  }
  /**
   * Remove the sprite from the drag state.
   */


  stopDrag() {
    this.dragging = false;
  }
  /**
   * Serialize sprite info, used when emitting events about the sprite
   * @returns {object} Sprite data as a simple object
   */


  toJSON() {
    const costumes = this.getCostumes();
    return {
      id: this.id,
      name: this.getName(),
      isStage: this.isStage,
      x: this.x,
      y: this.y,
      size: this.size,
      direction: this.direction,
      draggable: this.draggable,
      currentCostume: this.currentCostume,
      costume: costumes[this.currentCostume],
      costumeCount: costumes.length,
      visible: this.visible,
      rotationStyle: this.rotationStyle,
      comments: this.comments,
      blocks: this.blocks._blocks,
      variables: this.variables,
      costumes: costumes,
      sounds: this.getSounds(),
      textToSpeechLanguage: this.textToSpeechLanguage,
      tempo: this.tempo,
      volume: this.volume,
      videoTransparency: this.videoTransparency,
      videoState: this.videoState
    };
  }
  /**
   * Dispose, destroying any run-time properties.
   */


  dispose() {
    this.runtime.changeCloneCounter(-1);
    this.runtime.stopForTarget(this);
    this.runtime.removeExecutable(this);
    this.sprite.removeClone(this);

    if (this.renderer && this.drawableID !== null) {
      this.renderer.destroyDrawable(this.drawableID, this.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
  }

}

module.exports = RenderedTarget;

/***/ }),

/***/ "./src/sprites/sprite.js":
/*!*******************************!*\
  !*** ./src/sprites/sprite.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const RenderedTarget = __webpack_require__(/*! ./rendered-target */ "./src/sprites/rendered-target.js");

const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");

const {
  loadSoundFromAsset
} = __webpack_require__(/*! ../import/load-sound */ "./src/import/load-sound.js");

const {
  loadCostumeFromAsset
} = __webpack_require__(/*! ../import/load-costume */ "./src/import/load-costume.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

class Sprite {
  /**
   * SpriteScratch.
   *  shared blocks, shared costumes, shared variables, shared sounds, etc.
   * @param {?Blocks} blocks .
   * @param {Runtime} runtime .
   * @constructor
   */
  constructor(blocks, runtime) {
    console.log("class Sprite", blocks, runtime);
    this.runtime = runtime;

    if (!blocks) {
      // Shared set of blocks for all clones.
      blocks = new Blocks(runtime);
    }

    this.blocks = blocks;
    /**
     * Human-readable name for this sprite (and all clones).
     * @type {string}
     */

    this.name = "";
    /**
     * List of costumes for this sprite.
     * Each entry is an object, e.g.,
     * {
     *      skinId: 1,
     *      name: "Costume Name",
     *      bitmapResolution: 2,
     *      rotationCenterX: 0,
     *      rotationCenterY: 0
     * }
     * @type {Array.<!Object>}
     */

    this.costumes_ = [];
    /**
     * List of sounds for this sprite.
     */

    this.sounds = [];
    /**
     * List of clones for this sprite, including the original.
     * @type {Array.<!RenderedTarget>}
     */

    this.clones = [];
    this.soundBank = null;

    if (this.runtime && this.runtime.audioEngine) {
      this.soundBank = this.runtime.audioEngine.createBank();
    }
  }
  /**
   * .
   * @param {!Array<object>} costumes .
   */


  set costumes(costumes) {
    this.costumes_ = [];

    for (const costume of costumes) {
      this.addCostumeAt(costume, this.costumes_.length);
    }
  }
  /**
   * 
   * @return {object[]} 
   */


  get costumes() {
    return this.costumes_;
  }
  /**
   * .
   * @param {!object} costumeObject .
   * @param {!int} index 
   */


  addCostumeAt(costumeObject, index) {
    console.log("vm sprite.js addCostumeAt()", costumeObject, index);
    if (!costumeObject.name) costumeObject.name = "";
    const usedNames = this.costumes_.map(costume => costume.name);
    costumeObject.name = StringUtil.unusedName(costumeObject.name, usedNames);
    this.costumes_.splice(index, 0, costumeObject);
  }
  /**
   * Delete a costume by index.
   * @param {number} index Costume index to be deleted
   * @return {?object} The deleted costume
   */


  deleteCostumeAt(index) {
    return this.costumes.splice(index, 1)[0];
  }
  /**
   * .
   * @param {string=} optLayerGroup 
   * 
   * @returns {!RenderedTarget} .
   */


  createClone(optLayerGroup) {
    console.log("createClone :", optLayerGroup);
    const newClone = new RenderedTarget(this, this.runtime);
    newClone.isOriginal = this.clones.length === 0;
    this.clones.push(newClone);
    newClone.initAudio();

    if (newClone.isOriginal) {
      // Default to the sprite layer group if optLayerGroup is not provided
      const layerGroup = typeof optLayerGroup === "string" ? optLayerGroup : StageLayering.SPRITE_LAYER;
      newClone.initDrawable(layerGroup);
      this.runtime.fireTargetWasCreated(newClone);
    } else {
      this.runtime.fireTargetWasCreated(newClone, this.clones[0]);
    }

    return newClone;
  }
  /**
   * Disconnect a clone from this sprite. The clone is unmodified.
   * In particular, the clone's dispose() method is not called.
   * @param {!RenderedTarget} clone - the clone to be removed.
   */


  removeClone(clone) {
    this.runtime.fireTargetWasRemoved(clone);
    const cloneIndex = this.clones.indexOf(clone);

    if (cloneIndex >= 0) {
      this.clones.splice(cloneIndex, 1);
    }
  }

  duplicate() {
    const newSprite = new Sprite(null, this.runtime);
    const blocksContainer = this.blocks._blocks;
    const originalBlocks = Object.keys(blocksContainer).map(key => blocksContainer[key]);
    const copiedBlocks = JSON.parse(JSON.stringify(originalBlocks));
    Utility.newBlockIds(copiedBlocks);
    copiedBlocks.forEach(block => {
      newSprite.blocks.createBlock(block);
    });
    const allNames = this.runtime.targets.map(t => t.sprite.name);
    newSprite.name = StringUtil.unusedName(this.name, allNames);
    const assetPromises = [];
    newSprite.costumes = this.costumes_.map(costume => {
      const newCostume = Object.assign({}, costume);
      assetPromises.push(loadCostumeFromAsset(newCostume, this.runtime));
      return newCostume;
    });
    newSprite.sounds = this.sounds.map(sound => {
      const newSound = Object.assign({}, sound);
      const soundAsset = sound.asset;
      assetPromises.push(loadSoundFromAsset(newSound, soundAsset, this.runtime, newSprite.soundBank));
      return newSound;
    });
    return Promise.all(assetPromises).then(() => newSprite);
  }

  dispose() {
    if (this.soundBank) {
      this.soundBank.dispose();
    }
  }

}

module.exports = Sprite;

/***/ }),

/***/ "./src/util/jsonrpc.js":
/*!*****************************!*\
  !*** ./src/util/jsonrpc.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

class JSONRPC {
  constructor() {
    this._requestID = 0;
    this._openRequests = {};
  }
  /**
   * Make an RPC request and retrieve the result.
   * @param {string} method - the remote method to call.
   * @param {object} params - the parameters to pass to the remote method.
   * @returns {Promise} - a promise for the result of the call.
   */


  sendRemoteRequest(method, params) {
    const requestID = this._requestID++;
    const promise = new Promise((resolve, reject) => {
      this._openRequests[requestID] = {
        resolve,
        reject
      };
    });

    this._sendRequest(method, params, requestID);

    return promise;
  }
  /**
   * Make an RPC notification with no expectation of a result or callback.
   * @param {string} method - the remote method to call.
   * @param {object} params - the parameters to pass to the remote method.
   */


  sendRemoteNotification(method, params) {
    this._sendRequest(method, params);
  }
  /**
   * Handle an RPC request from remote, should return a result or Promise for result, if appropriate.
   * @param {string} method - the method requested by the remote caller.
   * @param {object} params - the parameters sent with the remote caller's request.
   */


  didReceiveCall()
  /* method , params */
  {
    throw new Error('Must override didReceiveCall');
  }

  _sendMessage()
  /* jsonMessageObject */
  {
    throw new Error('Must override _sendMessage');
  }

  _sendRequest(method, params, id) {
    const request = {
      jsonrpc: '2.0',
      method,
      params
    };

    if (id !== null) {
      request.id = id;
    }

    this._sendMessage(request);
  }

  _handleMessage(json) {
    if (json.jsonrpc !== '2.0') {
      throw new Error(`Bad or missing JSON-RPC version in message: ${json}`);
    }

    if (json.hasOwnProperty('method')) {
      this._handleRequest(json);
    } else {
      this._handleResponse(json);
    }
  }

  _sendResponse(id, result, error) {
    const response = {
      jsonrpc: '2.0',
      id
    };

    if (error) {
      response.error = error;
    } else {
      response.result = result || null;
    }

    this._sendMessage(response);
  }

  _handleResponse(json) {
    const {
      result,
      error,
      id
    } = json;
    const openRequest = this._openRequests[id];
    delete this._openRequests[id];

    if (openRequest) {
      if (error) {
        openRequest.reject(error);
      } else {
        openRequest.resolve(result);
      }
    }
  }

  _handleRequest(json) {
    const {
      method,
      params,
      id
    } = json;
    const rawResult = this.didReceiveCall(method, params);

    if (id) {
      Promise.resolve(rawResult).then(result => {
        this._sendResponse(id, result);
      }, error => {
        this._sendResponse(id, null, error);
      });
    }
  }

}

module.exports = JSONRPC;

/***/ }),

/***/ "./src/util/maybe-format-message.js":
/*!******************************************!*\
  !*** ./src/util/maybe-format-message.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
/**
 *  maybeMessage formatMessage.
 * `maybeMessage`.
 * @param {*} maybeMessage - .
 * @param {object} [args] - formatMessage.
 * @param {string} [locale] - formatMessage.
 * @return {string|*} -  maybeMessage.
 */


const maybeFormatMessage = function (maybeMessage, args, locale) {
  if (maybeMessage && maybeMessage.id && maybeMessage.default) {
    return formatMessage(maybeMessage, args, locale);
  }

  return maybeMessage;
};

module.exports = maybeFormatMessage;

/***/ }),

/***/ "./src/util/rateLimiter.js":
/*!*********************************!*\
  !*** ./src/util/rateLimiter.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

class RateLimiter {
  /**
   * A utility for limiting the rate of repetitive send operations, such as
   * bluetooth messages being sent to hardware devices. It uses the token bucket
   * strategy: a counter accumulates tokens at a steady rate, and each send costs
   * a token. If no tokens remain, it's not okay to send.
   * @param {number} maxRate the maximum number of sends allowed per second
   * @constructor
   */
  constructor(maxRate) {
    /**
     * The maximum number of tokens.
     * @type {number}
     */
    this._maxTokens = maxRate;
    /**
     * The interval in milliseconds for refilling one token. It is calculated
     * so that the tokens will be filled to maximum in one second.
     * @type {number}
     */

    this._refillInterval = 1000 / maxRate;
    /**
     * The current number of tokens in the bucket.
     * @type {number}
     */

    this._count = this._maxTokens;
    this._timer = new Timer();

    this._timer.start();
    /**
     * The last time in milliseconds when the token count was updated.
     * @type {number}
     */


    this._lastUpdateTime = this._timer.timeElapsed();
  }
  /**
   * Check if it is okay to send a message, by updating the token count,
   * taking a token and then checking if we are still under the rate limit.
   * @return {boolean} true if we are under the rate limit
   */


  okayToSend() {
    // Calculate the number of tokens to refill the bucket with, based on the
    // amount of time since the last refill.
    const now = this._timer.timeElapsed();

    const timeSinceRefill = now - this._lastUpdateTime;
    const refillCount = Math.floor(timeSinceRefill / this._refillInterval); // If we're adding at least one token, reset _lastUpdateTime to now.
    // Otherwise, don't reset it so that we can continue measuring time until
    // the next refill.

    if (refillCount > 0) {
      this._lastUpdateTime = now;
    } // Refill the tokens up to the maximum


    this._count = Math.min(this._maxTokens, this._count + refillCount); // If we have at least one token, use one, and it's okay to send.

    if (this._count > 0) {
      this._count--;
      return true;
    }

    return false;
  }

}

module.exports = RateLimiter;

/***/ }),

/***/ "./src/util/scratch-link-websocket.js":
/*!********************************************!*\
  !*** ./src/util/scratch-link-websocket.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This class provides a ScratchLinkSocket implementation using WebSockets,
 * attempting to connect with the locally installed Scratch-Link.
 *
 * To connect with ScratchLink without WebSockets, you must implement all of the
 * public methods in this class.
 * - open()
 * - close()
 * - setOn[Open|Close|Error]
 * - setHandleMessage
 * - sendMessage(msgObj)
 * - isOpen()
 */
class ScratchLinkWebSocket {
  constructor(type) {
    this._type = type;
    this._onOpen = null;
    this._onClose = null;
    this._onError = null;
    this._handleMessage = null;
    this._ws = null;
  }

  open() {
    switch (this._type) {
      case 'BLE':
        this._ws = new WebSocket('wss://device-manager.scratch.mit.edu:20110/scratch/ble');
        break;

      case 'BT':
        this._ws = new WebSocket('wss://device-manager.scratch.mit.edu:20110/scratch/bt');
        break;

      default:
        throw new Error(`Unknown ScratchLink socket Type: ${this._type}`);
    }

    if (this._onOpen && this._onClose && this._onError && this._handleMessage) {
      this._ws.onopen = this._onOpen;
      this._ws.onclose = this._onClose;
      this._ws.onerror = this._onError;
    } else {
      throw new Error('Must set open, close, message and error handlers before calling open on the socket');
    }

    this._ws.onmessage = this._onMessage.bind(this);
  }

  close() {
    this._ws.close();

    this._ws = null;
  }

  sendMessage(message) {
    const messageText = JSON.stringify(message);

    this._ws.send(messageText);
  }

  setOnOpen(fn) {
    this._onOpen = fn;
  }

  setOnClose(fn) {
    this._onClose = fn;
  }

  setOnError(fn) {
    this._onError = fn;
  }

  setHandleMessage(fn) {
    this._handleMessage = fn;
  }

  isOpen() {
    return this._ws && this._ws.readyState === this._ws.OPEN;
  }

  _onMessage(e) {
    const json = JSON.parse(e.data);

    this._handleMessage(json);
  }

}

module.exports = ScratchLinkWebSocket;

/***/ }),

/***/ "./src/util/string-util.js":
/*!*********************************!*\
  !*** ./src/util/string-util.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

class StringUtil {
  static withoutTrailingDigits(s) {
    let i = s.length - 1;

    while (i >= 0 && "0123456789".indexOf(s.charAt(i)) > -1) i--;

    return s.slice(0, i + 1);
  }

  static unusedName(name, existingNames) {
    if (existingNames.indexOf(name) < 0) return name;
    name = StringUtil.withoutTrailingDigits(name);
    let i = 2;

    while (existingNames.indexOf(name + i) >= 0) i++;

    return name + i;
  }
  /**
   * Split a string on the first occurrence of a split character.
   * @param {string} text - the string to split.
   * @param {string} separator - split the text on this character.
   * @returns {string[]} - the two parts of the split string, or [text, null] if no split character found.
   * @example
   * // returns ['foo', 'tar.gz']
   * splitFirst('foo.tar.gz', '.');
   * @example
   * // returns ['foo', null]
   * splitFirst('foo', '.');
   * @example
   * // returns ['foo', '']
   * splitFirst('foo.', '.');
   */


  static splitFirst(text, separator) {
    const index = text.indexOf(separator);

    if (index >= 0) {
      return [text.substring(0, index), text.substring(index + 1)];
    }

    return [text, null];
  }
  /**
   * A customized version of JSON.stringify that sets Infinity/NaN to 0,
   * instead of the default (null).
   * Needed because null is not of type number, but Infinity/NaN are, which
   * can lead to serialization producing JSON that isn't valid based on the parser schema.
   * It is also consistent with the behavior of saving 2.0 projects.
   * This is only needed when stringifying an object for saving.
   *
   * @param {!object} obj - The object to serialize
   * @return {!string} The JSON.stringified string with Infinity/NaN replaced with 0
   */


  static stringify(obj) {
    return JSON.stringify(obj, (_key, value) => {
      if (typeof value === "number" && (value === Infinity || value === -Infinity || isNaN(value))) {
        return 0;
      }

      return value;
    });
  }
  /**
   * A function to replace unsafe characters (not allowed in XML) with safe ones. This is used
   * in cases where we're replacing non-user facing strings (e.g. variable IDs).
   * When replacing user facing strings, the Utility.xmlEscape utility function should be used
   * instead so that the user facing string does not change how it displays.
   * @param {!string | !Array.<string>} unsafe Unsafe string possibly containing unicode control characters.
   * In some cases this argument may be an array (e.g. hacked inputs from 2.0)
   * @return {string} String with control characters replaced.
   */


  static replaceUnsafeChars(unsafe) {
    if (typeof unsafe !== "string") {
      if (Array.isArray(unsafe)) {
        // This happens when we have hacked blocks from 2.0
        // See #1030
        unsafe = String(unsafe);
      } else {
        console.error("Unexpected input recieved in replaceUnsafeChars");
        return unsafe;
      }
    }

    return unsafe.replace(/[<>&'"]/g, c => {
      switch (c) {
        case "<":
          return "lt";

        case ">":
          return "gt";

        case "&":
          return "amp";

        case "'":
          return "apos";

        case '"':
          return "quot";
      }
    });
  }

}

module.exports = StringUtil;

/***/ }),

/***/ "./src/util/timer.js":
/*!***************************!*\
  !*** ./src/util/timer.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * @fileoverview
 * .
 * To use:
 * ---
 * var timer = new Timer();
 * timer.start();
 * ... pass some time ...
 * var timeDifference = timer.timeElapsed();
 * ---
 * Or, you can use the `time` and `relativeTime`
 * to do some measurement yourself.
 */
class Timer {
  constructor(nowObj = Timer.nowObj) {
    /**
     * Used to store the start time of a timer action.
     * Updated when calling `timer.start`.
     */
    this.startTime = 0;
    /**
     * Used to pass custom logic for determining the value for "now",
     * which is sometimes useful for compatibility with Scratch 2
     */

    this.nowObj = nowObj;
  }
  /**
   * Disable use of self.performance for now as it results in lower performance
   * However, instancing it like below (caching the self.performance to a local variable) negates most of the issues.
   * @type {boolean}
   */


  static get USE_PERFORMANCE() {
    return false;
  }
  /**
   * Legacy object to allow for us to call now to get the old style date time (for backwards compatibility)
   * @deprecated This is only called via the nowObj.now() if no other means is possible...
   */


  static get legacyDateCode() {
    return {
      now: function () {
        return new Date().getTime();
      }
    };
  }
  /**
   * Use this object to route all time functions through single access points.
   */


  static get nowObj() {
    if (Timer.USE_PERFORMANCE && typeof self !== "undefined" && self.performance && "now" in self.performance) {
      return self.performance;
    } else if (Date.now) {
      return Date;
    }

    return Timer.legacyDateCode;
  }
  /**
   * Return the currently known absolute time, in ms precision.
   * @returns {number} ms elapsed since 1 January 1970 00:00:00 UTC.
   */


  time() {
    return this.nowObj.now();
  }
  /**
   * Returns a time accurate relative to other times produced by this function.
   * If possible, will use sub-millisecond precision.
   * If not, will use millisecond precision.
   * Not guaranteed to produce the same absolute values per-system.
   * @returns {number} ms-scale accurate time relative to other relative times.
   */


  relativeTime() {
    return this.nowObj.now();
  }
  /**
   * Start a timer for measuring elapsed time,
   * at the most accurate precision possible.
   */


  start() {
    this.startTime = this.nowObj.now();
  }

  timeElapsed() {
    return this.nowObj.now() - this.startTime;
  }
  /**
   * Call a handler function after a specified amount of time has elapsed.
   * @param {function} handler - function to call after the timeout
   * @param {number} timeout - number of milliseconds to delay before calling the handler
   * @returns {number} - the ID of the new timeout
   */


  setTimeout(handler, timeout) {
    return global.setTimeout(handler, timeout);
  }
  /**
   * Clear a timeout from the pending timeout pool.
   * @param {number} timeoutId - the ID returned by `setTimeout()`
   * @memberof Timer
   */


  clearTimeout(timeoutId) {
    global.clearTimeout(timeoutId);
  }

}

module.exports = Timer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/util/variable-util.js":
/*!***********************************!*\
  !*** ./src/util/variable-util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

class VariableUtil {
  static _mergeVarRefObjects(accum, obj2) {
    for (const id in obj2) {
      if (accum[id]) {
        accum[id] = accum[id].concat(obj2[id]);
      } else {
        accum[id] = obj2[id];
      }
    }

    return accum;
  }
  /**
   * Get all variable/list references in the given list of targets
   * in the project.
   * @param {Array.<Target>} targets The list of targets to get the variable
   * and list references from.
   * @param {boolean} shouldIncludeBroadcast Whether to include broadcast message fields.
   * @return {object} An object with variable ids as the keys and a list of block fields referencing
   * the variable.
   */


  static getAllVarRefsForTargets(targets, shouldIncludeBroadcast) {
    return targets.map(t => t.blocks.getAllVariableAndListReferences(null, shouldIncludeBroadcast)).reduce(VariableUtil._mergeVarRefObjects, {});
  }
  /**
   * Give all variable references provided a new id and possibly new name.
   * @param {Array<object>} referencesToUpdate Context of the change, the object containing variable
   * references to update.
   * @param {string} newId ID of the variable that the old references should be replaced with
   * @param {?string} optNewName New variable name to merge with. The old
   * variable name in the references being updated should be replaced with this new name.
   * If this parameter is not provided or is '', no name change occurs.
   */


  static updateVariableIdentifiers(referencesToUpdate, newId, optNewName) {
    referencesToUpdate.map(ref => {
      ref.referencingField.id = newId;

      if (optNewName) {
        ref.referencingField.value = optNewName;
      }

      return ref;
    });
  }

}

module.exports = VariableUtil;

/***/ }),

/***/ "./src/virtual-machine.js":
/*!********************************!*\
  !*** ./src/virtual-machine.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const JSZip = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");

const Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

const centralDispatch = __webpack_require__(/*! ./dispatch/central-dispatch */ "./src/dispatch/central-dispatch.js");

const ExtensionManager = __webpack_require__(/*! ./extension-support/extension-manager */ "./src/extension-support/extension-manager.js");

const Runtime = __webpack_require__(/*! ./engine/runtime */ "./src/engine/runtime.js");

const StringUtil = __webpack_require__(/*! ./util/string-util */ "./src/util/string-util.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const Variable = __webpack_require__(/*! ./engine/variable */ "./src/engine/variable.js");

const {
  loadCostume
} = __webpack_require__(/*! ./import/load-costume.js */ "./src/import/load-costume.js");

const {
  loadSound
} = __webpack_require__(/*! ./import/load-sound.js */ "./src/import/load-sound.js");
/**
 * ('sounds' or 'costumes')
 * in the provided runtime into an array of file descriptors.
 * A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized asset.
 * @param {Runtime} runtime The runtime with the assets to be serialized
 * @param {string} assetType The type of assets to be serialized: 'sounds' | 'costumes'
 * @param {string=} optTargetId Optional target id to serialize assets for
 * @returns {Array<object>} An array of file descriptors for each asset
 */


const serializeAssets = function (runtime, assetType, optTargetId) {
  console.log("v-m.js ");
  const targets = optTargetId ? [runtime.getTargetById(optTargetId)] : runtime.targets;
  const assetDescs = [];

  for (let i = 0; i < targets.length; i++) {
    const currTarget = targets[i];
    const currAssets = currTarget.sprite[assetType];

    for (let j = 0; j < currAssets.length; j++) {
      const currAsset = currAssets[j];
      const asset = currAsset.asset;
      assetDescs.push({
        fileName: `${asset.assetId}.${asset.dataFormat}`,
        fileContent: asset.data
      });
    }
  }

  return assetDescs;
};
/**
 * Serialize all the sounds in the provided runtime or, if a target id is provided,
 * in the specified target into an array of file descriptors.
 * A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized sound.
 * @param {Runtime} runtime The runtime with the sounds to be serialized
 * @param {string=} optTargetId Optional targetid for serializing sounds of a single target
 * @returns {Array<object>} An array of file descriptors for each sound
 */


const serializeSounds = function (runtime, optTargetId) {
  return serializeAssets(runtime, "sounds", optTargetId);
};
/**
 * Serialize all the costumes in the provided runtime into an array of file
 * descriptors. A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized costume.
 * @param {Runtime} runtime The runtime with the costumes to be serialized
 * @param {string} optTargetId Optional targetid for serializing costumes of a single target
 * @returns {Array<object>} An array of file descriptors for each costume
 */


const serializeCostumes = function (runtime, optTargetId) {
  return serializeAssets(runtime, "costumes", optTargetId);
};

const RESERVED_NAMES = ["_mouse_", "_stage_", "_edge_", "_myself_", "_random_"];
const CORE_EXTENSIONS = [// 'motion',
  // 'looks',
  // 'sound',
  // 'events',
  // 'control',
  // 'sensing',
  // 'operators',
  // 'variables',
  // 'myBlocks'
];
/**
 * Handles connections between blocks, stage, and extensions.
 * 
 * @constructor
 */

class VirtualMachine extends EventEmitter {
  constructor() {
    super();
    /**
     * VM runtime, to store blocks, I/O devices, sprites/targets, etc.
     * @type {!Runtime}
     */

    this.runtime = new Runtime();
    console.log("class VirtualMachine:", this.runtime);
    centralDispatch.setService("runtime", this.runtime).catch(e => {
      console.error(`Failed to register runtime service: ${JSON.stringify(e)}`);
    });
    /**
     * The "currently editing"/selected target ID for the VM.
     * Blockly.
     * @type {Target}
     */

    this.editingTarget = null;
    /**
     * IO.
     * @type {Target}
     */

    this._dragTarget = null; // Runtime emits are passed along as VM emits.

    this.runtime.on(Runtime.SCRIPT_GLOW_ON, glowData => {
      this.emit(Runtime.SCRIPT_GLOW_ON, glowData);
    });
    this.runtime.on(Runtime.SCRIPT_GLOW_OFF, glowData => {
      this.emit(Runtime.SCRIPT_GLOW_OFF, glowData);
    });
    this.runtime.on(Runtime.BLOCK_GLOW_ON, glowData => {
      this.emit(Runtime.BLOCK_GLOW_ON, glowData);
    });
    this.runtime.on(Runtime.BLOCK_GLOW_OFF, glowData => {
      this.emit(Runtime.BLOCK_GLOW_OFF, glowData);
    });
    this.runtime.on(Runtime.PROJECT_START, () => {
      this.emit(Runtime.PROJECT_START);
    });
    this.runtime.on(Runtime.PROJECT_RUN_START, () => {
      this.emit(Runtime.PROJECT_RUN_START);
    });
    this.runtime.on(Runtime.PROJECT_RUN_STOP, () => {
      this.emit(Runtime.PROJECT_RUN_STOP);
    });
    this.runtime.on(Runtime.PROJECT_CHANGED, () => {
      this.emit(Runtime.PROJECT_CHANGED);
    });
    this.runtime.on(Runtime.VISUAL_REPORT, visualReport => {
      this.emit(Runtime.VISUAL_REPORT, visualReport);
    });
    /** targetsUpdate */

    this.runtime.on(Runtime.TARGETS_UPDATE, emitProjectChanged => {
      console.log("vm this.runtime.on(Runtime.TARGETS_UPDATE, (emitProjectChanged):", emitProjectChanged);
      this.emitTargetsUpdate(emitProjectChanged);
    });
    this.runtime.on(Runtime.MONITORS_UPDATE, monitorList => {
      this.emit(Runtime.MONITORS_UPDATE, monitorList);
    });
    this.runtime.on(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui => {
      this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);
    });
    this.runtime.on(Runtime.BLOCK_DRAG_END, (blocks, topBlockId) => {
      this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);
    });
    this.runtime.on(Runtime.EXTENSION_ADDED, categoryInfo => {
      this.emit(Runtime.EXTENSION_ADDED, categoryInfo);
    });
    this.runtime.on(Runtime.EXTENSION_FIELD_ADDED, (fieldName, fieldImplementation) => {
      this.emit(Runtime.EXTENSION_FIELD_ADDED, fieldName, fieldImplementation);
    });
    this.runtime.on(Runtime.BLOCKSINFO_UPDATE, categoryInfo => {
      this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);
    });
    this.runtime.on(Runtime.BLOCKS_NEED_UPDATE, () => {
      this.emitWorkspaceUpdate();
    });
    this.runtime.on(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE, () => {
      this.extensionManager.refreshBlocks();
    });
    this.runtime.on(Runtime.PERIPHERAL_LIST_UPDATE, info => {
      this.emit(Runtime.PERIPHERAL_LIST_UPDATE, info);
    });
    this.runtime.on(Runtime.PERIPHERAL_CONNECTED, () => this.emit(Runtime.PERIPHERAL_CONNECTED));
    this.runtime.on(Runtime.PERIPHERAL_REQUEST_ERROR, () => this.emit(Runtime.PERIPHERAL_REQUEST_ERROR));
    this.runtime.on(Runtime.PERIPHERAL_DISCONNECTED, () => this.emit(Runtime.PERIPHERAL_DISCONNECTED));
    this.runtime.on(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, data => this.emit(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, data));
    this.runtime.on(Runtime.PERIPHERAL_SCAN_TIMEOUT, () => this.emit(Runtime.PERIPHERAL_SCAN_TIMEOUT));
    this.runtime.on(Runtime.MIC_LISTENING, listening => {
      this.emit(Runtime.MIC_LISTENING, listening);
    });
    this.runtime.on(Runtime.RUNTIME_STARTED, () => {
      this.emit(Runtime.RUNTIME_STARTED);
    });
    this.runtime.on(Runtime.HAS_CLOUD_DATA_UPDATE, hasCloudData => {
      this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, hasCloudData);
    }); // 

    this.extensionManager = new ExtensionManager(this.runtime); // 

    for (const id of CORE_EXTENSIONS) {
      this.extensionManager.loadExtensionIdSync(id);
    }

    this.blockListener = this.blockListener.bind(this);
    this.flyoutBlockListener = this.flyoutBlockListener.bind(this);
    this.monitorBlockListener = this.monitorBlockListener.bind(this);
    this.variableListener = this.variableListener.bind(this);
  }
  /**
   * VM-.
   */


  start() {
    this.runtime.start();
  }
  /**
   * "Green flag" handler - .
   */


  greenFlag() {
    this.runtime.greenFlag();
  }
  /**
   * Stop all threads and running activities.
   */


  stopAll() {
    this.runtime.stopAll();
  }
  /**
   * "turbo"
   * When true, turbo mode
   * @param {boolean} turboModeOn .
   */


  setTurboMode(turboModeOn) {
    this.runtime.turboMode = !!turboModeOn;

    if (this.runtime.turboMode) {
      console.log("", Runtime.TURBO_MODE_ON);
      this.emit(Runtime.TURBO_MODE_ON);
    } else {
      console.log("", Runtime.TURBO_MODE_OFF);
      this.emit(Runtime.TURBO_MODE_OFF);
    }
  }
  /**
   * Set whether the VM is in 2.0 "compatibility mode."
   * When true, runtime2.030TPS
   * @param {boolean} compatibilityModeOn Whether compatibility mode is set.
   */


  setCompatibilityMode(compatibilityModeOn) {
    console.log(" 2.030TPS");
    this.runtime.setCompatibilityMode(!!compatibilityModeOn);
  }
  /**
   * .
   */


  clear() {
    this.runtime.dispose();
    this.editingTarget = null;
    console.warn("v-m.jsemitTargetsUpdate(false),");
    this.emitTargetsUpdate(false
    /* Don't emit project change */
    );
  }
  /**
   * Get data for playground. Data comes back in an emitted event.
   * editingTargetthreaddata
   */


  getPlaygroundData() {
    console.log("editingTargetthreaddata");
    const instance = this; // Only send back thread data for the current editingTarget.

    const threadData = this.runtime.threads.filter(thread => thread.target === instance.editingTarget); // Remove the target key, since it's a circular reference.

    const filteredThreadData = JSON.stringify(threadData, (key, value) => {
      if (key === "target" || key === "blockContainer") return;
      return value;
    }, 2);
    this.emit("playgroundData", {
      blocks: this.editingTarget.blocks,
      threads: filteredThreadData
    });
  }
  /**
   * Post I/O data to the virtual devices. runtime
   * @param {?string} device Name of virtual I/O device.
   * @param {object} data Any data object to post to the I/O device.
   */


  postIOData(device, data) {
    // console.log("runtime", device, data);
    if (this.runtime.ioDevices[device]) {
      this.runtime.ioDevices[device].postData(data);
    }
  }

  setVideoProvider(videoProvider) {
    this.runtime.ioDevices.video.setProvider(videoProvider);
  }

  setCloudProvider(cloudProvider) {
    this.runtime.ioDevices.cloud.setProvider(cloudProvider);
  }
  /**
   * Tell the specified extension to scan for a peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  scanForPeripheral(extensionId) {
    this.runtime.scanForPeripheral(extensionId);
  }
  /**
   * Connect to the extension's specified peripheral.
   * @param {string} extensionId - the id of the extension.
   * @param {number} peripheralId - the id of the peripheral.
   */


  connectPeripheral(extensionId, peripheralId) {
    this.runtime.connectPeripheral(extensionId, peripheralId);
  }
  /**
   * Disconnect from the extension's connected peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  disconnectPeripheral(extensionId) {
    this.runtime.disconnectPeripheral(extensionId);
  }
  /**
   * Returns whether the extension has a currently connected peripheral.
   * @param {string} extensionId - the id of the extension.
   * @return {boolean} - whether the extension has a connected peripheral.
   */


  getPeripheralIsConnected(extensionId) {
    return this.runtime.getPeripheralIsConnected(extensionId);
  }
  /**
   * .sb.sb2.sb3json.
   * @param {string | object} data jsonArrayBuffer.
   * @return {!Promise} Promise that resolves after targets are installed.
   */


  loadProject(data) {
    console.log("vm.js loadProject()", data); // ArrayBufferArrayBufferDataViewsJSONproject.json 

    if (typeof data === "object" && !(data instanceof ArrayBuffer) && !ArrayBuffer.isView(data)) data = JSON.stringify(data); // 

    const validate = __webpack_require__(/*! ./parser/index */ "./src/parser/index.js");

    const validationPromise = new Promise((resolve, reject) => {
      try {
        /**
         * parser
         * :(JSON)
         * :false;true
         */
        return resolve(validate(data, false));
      } catch (e) {
        // SB1File.
        return reject(e);
      }
    });
    return validationPromise.then(res => {
      console.log("validationPromise:", res); // JSON

      this.deserializeProject(res, null);
    }).then(() => {
      console.log("loadProject  runtime.emitProjectLoaded()");
      this.runtime.emitProjectLoaded();
    }).catch(error => {
      return Promise.reject(JSON.stringify(error));
    });
  }
  /**
   * Load a project from the Scratch web site, by ID.
   * projectIdstorage(storage)
   * @param {string} id - the ID of the project to download, as a string.
   */


  downloadProjectId(id) {
    const storage = this.runtime.storage;

    if (!storage) {
      console.error("No storage module present; cannot load project: ", id);
      return;
    }

    const vm = this;
    const promise = storage.load(storage.AssetType.Project, id);
    promise.then(projectAsset => {
      vm.loadProject(projectAsset.data);
    });
  }
  /**
   * 3.0,zipblob
   * @returns {string} Project in a Scratch 3.0 JSON representation.
   */


  saveProjectSb3() {
    const soundDescs = serializeSounds(this.runtime);
    const costumeDescs = serializeCostumes(this.runtime);
    const projectJson = this.toJSON(); // project.json
    // TODO want to eventually move zip creation out of here, and perhaps
    // into scratch-storage

    const zip = new JSZip(); // Put everything in a zip file

    zip.file("project.json", projectJson);

    this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);

    return zip.generateAsync({
      type: "blob",
      mimeType: "application/x.scratch.sb3",
      compression: "DEFLATE",
      compressionOptions: {
        level: 6 // Tradeoff between best speed (1) and best compression (9)

      }
    });
  }
  /*
   * @type {Array<object>} 
   */


  get assets() {
    return this.runtime.targets.reduce((acc, target) => acc.concat(target.sprite.sounds.map(sound => sound.asset)).concat(target.sprite.costumes.map(costume => costume.asset)), []);
  }

  _addFileDescsToZip(fileDescs, zip) {
    for (let i = 0; i < fileDescs.length; i++) {
      const currFileDesc = fileDescs[i];
      zip.file(currFileDesc.fileName, currFileDesc.fileContent);
    }
  }
  /**
   * Exports a sprite in the sprite3 format.
   * @param {string} targetId ID of the target to export
   * @param {string=} optZipType Optional type that the resulting
   * zip should be outputted in. Options are: base64, binarystring,
   * array, uint8array, arraybuffer, blob, or nodebuffer. Defaults to
   * blob if argument not provided.
   * See https://stuk.github.io/jszip/documentation/api_jszip/generate_async.html#type-option
   * for more information about these options.
   * @return {object} A generated zip of the sprite and its assets in the format
   * specified by optZipType or blob by default.
   */


  exportSprite(targetId, optZipType) {
    console.log("v-m.js ", targetId, optZipType);

    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    const soundDescs = serializeSounds(this.runtime, targetId);
    const costumeDescs = serializeCostumes(this.runtime, targetId);
    const spriteJson = StringUtil.stringify(sb3.serialize(this.runtime, targetId));
    const zip = new JSZip();
    zip.file("sprite.json", spriteJson);

    this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);

    return zip.generateAsync({
      type: typeof optZipType === "string" ? optZipType : "blob",
      mimeType: "application/x.scratch.sprite3",
      compression: "DEFLATE",
      compressionOptions: {
        level: 6
      }
    });
  }
  /**
   * Scratch 3.0 JSON.project.json
   * @return {string} Serialized state of the runtime.
   */


  toJSON() {
    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    return StringUtil.stringify(sb3.serialize(this.runtime));
  }
  /**
   *  JSON.
   * @param {string} projectJSON JSON.
   * @param {?JSZip} zip .
   * @returns {Promise} 2.03.03.0meta2.0schema.json
   *  deserializeproject.json
   */


  deserializeProject(projectJSON, zip) {
    console.log("vm.js deserializeProject() ", projectJSON, zip); // Clear the current runtime

    this.clear();
    const runtime = this.runtime;

    const deserializePromise = function () {
      // 
      const projectVersion = projectJSON.projectVersion;

      if (projectVersion === 2) {
        const sb2 = __webpack_require__(/*! ./serialization/sb2 */ "./src/serialization/sb2.js");

        return sb2.deserialize(projectJSON, runtime, false, zip);
      }

      if (projectVersion === 3) {
        const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

        console.log("v-m.js sb3.", projectJSON, runtime, zip);
        return sb3.deserialize(projectJSON, runtime, zip);
      }

      return Promise.reject("Unable to verify Scratch Project version.");
    };

    return deserializePromise().then(({
      targets,
      extensions
    }) => {
      console.log("installTargets", targets, extensions); // targetsinstallTargets

      this.installTargets(targets, extensions, true);
    });
  }
  /**
   * Install `deserialize` results: .
   * targets,targetsextensionextensionspromise.alltargets
   * @param {Array.<Target>} targets - 
   * @param {ImportedExtensionsInfo} extensions - 
   * @param {boolean} wholeProject - true.
   * @returns {Promise} 
   */


  installTargets(targets, extensions, wholeProject) {
    console.log("installTargets()", targets, extensions, wholeProject);
    const extensionPromises = [];
    extensions.extensionIDs.forEach(extensionID => {
      if (!this.extensionManager.isExtensionLoaded(extensionID)) {
        const extensionURL = extensions.extensionURLs.get(extensionID) || extensionID;
        extensionPromises.push(this.extensionManager.loadExtensionURL(extensionURL));
      }
    });
    targets = targets.filter(target => !!target);
    return Promise.all(extensionPromises).then(() => {
      targets.forEach(target => {
        console.warn("this.runtime.addTarget", target);
        this.runtime.addTarget(target);
        /** @type RenderedTarget */

        target.updateAllDrawableProperties(); // 

        if (target.isSprite()) this.renameSprite(target.id, target.getName());
      }); // . layerOrder.

      this.runtime.executableTargets.sort((a, b) => a.layerOrder - b.layerOrder);
      targets.forEach(target => {
        delete target.layerOrder;
      }); // .

      this.editingTarget = wholeProject && targets.length > 1 ? targets[1] : targets[0];
      if (!wholeProject) this.editingTarget.fixUpVariableReferences(); // VM.

      console.warn("v-m.js installTargets emitTargetsUpdate(false)");
      this.emitTargetsUpdate(false
      /* Don't emit project change */
      );
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(this.editingTarget);
      this.runtime.ioDevices.cloud.setStage(this.runtime.getTargetForStage());
    });
  }
  /**
   * .sprite2.sprite3 .
   * @param {string | object} input jsonArrayBuffer.
   * @return {!Promise} .
   */


  addSprite(input) {
    const errorPrefix = "Sprite Upload Error:";

    if (typeof input === "object" && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {
      // If the input is an object and not any ArrayBuffer
      // or an ArrayBuffer view (this includes all typed arrays and DataViews)
      // turn the object into a JSON string, because we suspect
      // this is a project.json as an object
      // validate expects a string or buffer as input
      // TODO not sure if we need to check that it also isn't a data view
      input = JSON.stringify(input);
    }

    const validationPromise = new Promise((resolve, reject) => {
      const validate = __webpack_require__(/*! ./parser/index */ "./src/parser/index.js"); // The second argument of true below indicates to the parser/validator
      // that the given input should be treated as a single sprite and not
      // an entire project


      validate(input, true, (error, res) => {
        if (error) return reject(error);
        resolve(res);
      });
    });
    return validationPromise.then(validatedInput => {
      const projectVersion = validatedInput[0].projectVersion;

      if (projectVersion === 2) {
        // 2.0spriteproject
        return this._addSprite2(validatedInput[0], validatedInput[1]);
      }

      if (projectVersion === 3) {
        return this._addSprite3(validatedInput[0], validatedInput[1]);
      }

      return Promise.reject(`${errorPrefix} Unable to verify sprite version.`);
    }).then(() => this.runtime.emitProjectChanged()).catch(error => {
      // Intentionally rejecting here (want errors to be handled by caller)
      if (error.hasOwnProperty("validationError")) {
        return Promise.reject(JSON.stringify(error));
      }

      return Promise.reject(`${errorPrefix} ${error}`);
    });
  }
  /**
   * 2.0spriteproject
   * @param {object} sprite Object representing 2.0 sprite to be added.
   * @param {?ArrayBuffer} zip Optional zip of assets being referenced by json
   * @returns {Promise} Promise that resolves after the sprite is added
   */


  _addSprite2(sprite, zip) {
    console.log("vm.js _addSprite2", sprite, zip); // Validate & parse

    const sb2 = __webpack_require__(/*! ./serialization/sb2 */ "./src/serialization/sb2.js");

    return sb2.deserialize(sprite, this.runtime, true, zip).then(({
      targets,
      extensions
    }) => this.installTargets(targets, extensions, false));
  }
  /**
   * Add a single sb3 sprite.
   * @param {object} sprite Object rperesenting 3.0 sprite to be added.
   * @param {?ArrayBuffer} zip Optional zip of assets being referenced by target json
   * @returns {Promise} Promise that resolves after the sprite is added
   */


  _addSprite3(sprite, zip) {
    console.log("vm.js _addSprite3", sprite, zip); // Validate & parse

    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    return sb3.deserialize(sprite, this.runtime, zip, true).then(({
      targets,
      extensions
    }) => this.installTargets(targets, extensions, false));
  }
  /**
   * @function costume
   * @param {string} md5ext - MD5costume.
   * @param {!object} costumeObject costume.
   * @property {int} skinId - costumeID.
   * @property {number} rotationCenterX - YX.
   * @property {number} rotationCenterY - Y.
   * @property {number} [bitmapResolution] - costume.
   * @param {string} optTargetId - ID.
   * @param {string} optVersion - 2sb2sb3.
   * @returns {?Promise} - a promise that resolves when the costume has been added
   */


  addCostume(md5ext, costumeObject, optTargetId, optVersion) {
    console.log("vm.js addCostume", md5ext, costumeObject, optTargetId, optVersion);
    const target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;

    if (target) {
      return loadCostume(md5ext, costumeObject, this.runtime, optVersion).then(() => {
        target.addCostume(costumeObject);
        target.setCostume(target.getCostumes().length - 1);
        this.runtime.emitProjectChanged();
      });
    } // ID rejected promise


    return Promise.reject();
  }
  /**
   * @function costume.
   * @param {string} md5ext - MD5costume.
   * @param {!object} costumeObject costume.
   * @property {int} skinId - costumeID.
   * @property {number} rotationCenterX - YX.
   * @property {number} rotationCenterY - Y.
   * @property {number} [bitmapResolution] - costume.
   * @returns {?Promise} - a promise that resolves when the costume has been added
   */


  addCostumeFromLibrary(md5ext, costumeObject) {
    console.log("v-m.js costume", md5ext, costumeObject);
    if (!this.editingTarget) return Promise.reject();
    return this.addCostume(md5ext, costumeObject, this.editingTarget.id, 2
    /* optVersion */
    );
  }
  /**
   * Duplicate the costume at the given index. Add it at that index + 1.costume
   * @param {!int} costumeIndex Index of costume to duplicate
   * @returns {?Promise} - a promise that resolves when the costume has been decoded and added
   */


  duplicateCostume(costumeIndex) {
    console.log("v-m.js costume", costumeIndex);
    const originalCostume = this.editingTarget.getCostumes()[costumeIndex];
    const clone = Object.assign({}, originalCostume);
    const md5ext = `${clone.assetId}.${clone.dataFormat}`;
    return loadCostume(md5ext, clone, this.runtime).then(() => {
      this.editingTarget.addCostume(clone, costumeIndex + 1);
      this.editingTarget.setCostume(costumeIndex + 1);
      this.emitTargetsUpdate();
    });
  }
  /**
   * Duplicate the sound at the given index. Add it at that index + 1. sound
   * @param {!int} soundIndex Index of sound to duplicate
   * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
   */


  duplicateSound(soundIndex) {
    const originalSound = this.editingTarget.getSounds()[soundIndex];
    const clone = Object.assign({}, originalSound);
    return loadSound(clone, this.runtime, this.editingTarget.sprite.soundBank).then(() => {
      this.editingTarget.addSound(clone, soundIndex + 1);
      this.emitTargetsUpdate();
    });
  }
  /**
   * Rename a costume on the current editing target. costume
   * @param {int} costumeIndex - the index of the costume to be renamed.
   * @param {string} newName - the desired new name of the costume (will be modified if already in use).
   */


  renameCostume(costumeIndex, newName) {
    console.log("v-m.js costume", costumeIndex);
    this.editingTarget.renameCostume(costumeIndex, newName);
    this.emitTargetsUpdate();
  }
  /**
   * Delete a costume from the current editing target. costume
   * @param {int} costumeIndex - the index of the costume to be removed.
   * @return {?function} A function to restore the deleted costume, or null,
   * if no costume was deleted.
   */


  deleteCostume(costumeIndex) {
    console.log("v-m.js costume", costumeIndex);
    const deletedCostume = this.editingTarget.deleteCostume(costumeIndex);

    if (deletedCostume) {
      const target = this.editingTarget;
      this.runtime.emitProjectChanged();
      return () => {
        target.addCostume(deletedCostume);
        this.emitTargetsUpdate();
      };
    }

    return null;
  }
  /**
   * Add a sound to the current editing target.
   * @param {!object} soundObject Object representing the costume.
   * @param {string} optTargetId - the id of the target to add to, if not the editing target.
   * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
   */


  addSound(soundObject, optTargetId) {
    const target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;

    if (target) {
      return loadSound(soundObject, this.runtime, target.sprite.soundBank).then(() => {
        target.addSound(soundObject);
        this.emitTargetsUpdate();
      });
    } // If the target cannot be found by id, return a rejected promise


    return new Promise.reject();
  }
  /**
   * Rename a sound on the current editing target.
   * @param {int} soundIndex - the index of the sound to be renamed.
   * @param {string} newName - the desired new name of the sound (will be modified if already in use).
   */


  renameSound(soundIndex, newName) {
    this.editingTarget.renameSound(soundIndex, newName);
    this.emitTargetsUpdate();
  }
  /**
   * Get a sound buffer from the audio engine. audio enginesound buffer
   * @param {int} soundIndex - the index of the sound to be got.
   * @return {AudioBuffer} the sound's audio buffer.
   */


  getSoundBuffer(soundIndex) {
    const id = this.editingTarget.sprite.sounds[soundIndex].soundId;

    if (id && this.runtime && this.runtime.audioEngine) {
      return this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer;
    }

    return null;
  }
  /**
   * Update a sound buffer.
   * @param {int} soundIndex - the index of the sound to be updated.
   * @param {AudioBuffer} newBuffer - new audio buffer for the audio engine.
   * @param {ArrayBuffer} soundEncoding - the new (wav) encoded sound to be stored
   */


  updateSoundBuffer(soundIndex, newBuffer, soundEncoding) {
    const sound = this.editingTarget.sprite.sounds[soundIndex];
    const id = sound ? sound.soundId : null;

    if (id && this.runtime && this.runtime.audioEngine) {
      this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer = newBuffer;
    } // Update sound in runtime


    if (soundEncoding) {
      // Now that we updated the sound, the format should also be updated
      // so that the sound can eventually be decoded the right way.
      // Sounds that were formerly 'adpcm', but were updated in sound editor
      // will not get decoded by the audio engine correctly unless the format
      // is updated as below.
      sound.format = "";
      const storage = this.runtime.storage;
      sound.asset = storage.createAsset(storage.AssetType.Sound, storage.DataFormat.WAV, soundEncoding, null, true // generate md5
      );
      sound.assetId = sound.asset.assetId;
      sound.dataFormat = storage.DataFormat.WAV;
      sound.md5 = `${sound.assetId}.${sound.dataFormat}`;
      sound.sampleCount = newBuffer.length;
      sound.rate = newBuffer.sampleRate;
    } // If soundEncoding is null, it's because gui had a problem
    // encoding the updated sound. We don't want to store anything in this
    // case, and gui should have logged an error.


    this.emitTargetsUpdate();
  }
  /**
   * Delete a sound from the current editing target.
   * @param {int} soundIndex - the index of the sound to be removed.
   * @return {?Function} A function to restore the sound that was deleted,
   * or null, if no sound was deleted.
   */


  deleteSound(soundIndex) {
    const target = this.editingTarget;
    const deletedSound = this.editingTarget.deleteSound(soundIndex);

    if (deletedSound) {
      this.runtime.emitProjectChanged();

      const restoreFun = () => {
        target.addSound(deletedSound);
        this.emitTargetsUpdate();
      };

      return restoreFun;
    }

    return null;
  }
  /**
   * Get a string representation of the image from storage. costume svg
   * @param {int} costumeIndex - the index of the costume to be got.
   * @return {string} the costume's SVG string if it's SVG,
   *     a dataURI if it's a PNG or JPG, or null if it couldn't be found or decoded.
   */


  getCostume(costumeIndex) {
    console.log("v-m.js costume svg", costumeIndex);
    const asset = this.editingTarget.getCostumes()[costumeIndex].asset;
    if (!asset || !this.runtime || !this.runtime.storage) return null;
    const format = asset.dataFormat;

    if (format === this.runtime.storage.DataFormat.SVG) {
      return asset.decodeText();
    } else if (format === this.runtime.storage.DataFormat.PNG || format === this.runtime.storage.DataFormat.JPG) {
      return asset.encodeDataURI();
    }

    console.error(`Unhandled format: ${asset.dataFormat}`);
    return null;
  }
  /**
   * Update a costume with the given bitmap
   * @param {!int} costumeIndex - the index of the costume to be updated.
   * @param {!ImageData} bitmap - new bitmap for the renderer.
   * @param {!number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
   * @param {!number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
   * @param {!number} bitmapResolution 1 for bitmaps that have 1 pixel per unit of stage,
   *     2 for double-resolution bitmaps
   */


  updateBitmap(costumeIndex, bitmap, rotationCenterX, rotationCenterY, bitmapResolution) {
    console.log("v-m.js Bitmap", costumeIndex, bitmap, rotationCenterX, rotationCenterY, bitmapResolution);
    const costume = this.editingTarget.getCostumes()[costumeIndex];
    if (!(costume && this.runtime && this.runtime.renderer)) return;
    costume.rotationCenterX = rotationCenterX;
    costume.rotationCenterY = rotationCenterY; // If the bitmap originally had a zero width or height, use that value

    const bitmapWidth = bitmap.sourceWidth === 0 ? 0 : bitmap.width;
    const bitmapHeight = bitmap.sourceHeight === 0 ? 0 : bitmap.height; // @todo: updateBitmapSkin does not take ImageData

    const canvas = document.createElement("canvas");
    canvas.width = bitmapWidth;
    canvas.height = bitmapHeight;
    const context = canvas.getContext("2d");
    context.putImageData(bitmap, 0, 0); // Divide by resolution because the renderer's definition of the rotation center
    // is the rotation center divided by the bitmap resolution

    this.runtime.renderer.updateBitmapSkin(costume.skinId, canvas, bitmapResolution, [rotationCenterX / bitmapResolution, rotationCenterY / bitmapResolution]); // @todo there should be a better way to get from ImageData to a decodable storage format

    canvas.toBlob(blob => {
      const reader = new FileReader();
      reader.addEventListener("loadend", () => {
        const storage = this.runtime.storage;
        costume.dataFormat = storage.DataFormat.PNG;
        costume.bitmapResolution = bitmapResolution;
        costume.size = [bitmapWidth, bitmapHeight];
        costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, costume.dataFormat, Buffer.from(reader.result), null, // id
        true // generate md5
        );
        costume.assetId = costume.asset.assetId;
        costume.md5 = `${costume.assetId}.${costume.dataFormat}`;
        this.emitTargetsUpdate();
      }); // Bitmaps with a zero width or height return null for their blob

      if (blob) {
        reader.readAsArrayBuffer(blob);
      }
    });
  }
  /**
   * Update a costume with the given SVG
   * @param {int} costumeIndex - the index of the costume to be updated.
   * @param {string} svg - new SVG for the renderer.
   * @param {number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
   * @param {number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
   */


  updateSvg(costumeIndex, svg, rotationCenterX, rotationCenterY) {
    console.log("v-m.js svg", costumeIndex, svg, rotationCenterX, rotationCenterY);
    const costume = this.editingTarget.getCostumes()[costumeIndex];

    if (costume && this.runtime && this.runtime.renderer) {
      costume.rotationCenterX = rotationCenterX;
      costume.rotationCenterY = rotationCenterY;
      this.runtime.renderer.updateSVGSkin(costume.skinId, svg, [rotationCenterX, rotationCenterY]);
      costume.size = this.runtime.renderer.getSkinSize(costume.skinId);
    }

    const storage = this.runtime.storage; // If we're in here, we've edited an svg in the vector editor,
    // so the dataFormat should be 'svg'

    costume.dataFormat = storage.DataFormat.SVG;
    costume.bitmapResolution = 1;
    costume.asset = storage.createAsset(storage.AssetType.ImageVector, costume.dataFormat, new TextEncoder().encode(svg), null, true // generate md5
    );
    costume.assetId = costume.asset.assetId;
    costume.md5 = `${costume.assetId}.${costume.dataFormat}`;
    this.emitTargetsUpdate();
  }
  /**
   * Add a backdrop to the stage.
   * @param {string} md5ext - the MD5 and extension of the backdrop to be loaded.
   * @param {!object} backdropObject Object representing the backdrop.
   * @property {int} skinId - the ID of the backdrop's render skin, once installed.
   * @property {number} rotationCenterX - the X component of the backdrop's origin.
   * @property {number} rotationCenterY - the Y component of the backdrop's origin.
   * @property {number} [bitmapResolution] - the resolution scale for a bitmap backdrop.
   * @returns {?Promise} - a promise that resolves when the backdrop has been added
   */


  addBackdrop(md5ext, backdropObject) {
    console.log("v-m.js ", md5ext, backdropObject);
    return loadCostume(md5ext, backdropObject, this.runtime).then(() => {
      const stage = this.runtime.getTargetForStage();
      stage.addCostume(backdropObject);
      stage.setCostume(stage.getCostumes().length - 1);
      this.runtime.emitProjectChanged();
    });
  }
  /**
   * Rename a sprite.
   * @param {string} targetId ID of a target whose sprite to rename.
   * @param {string} newName New name of the sprite.
   */


  renameSprite(targetId, newName) {
    console.log("v-m.js ", targetId, newName);
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      if (!target.isSprite()) {
        throw new Error("Cannot rename non-sprite targets.");
      }

      const sprite = target.sprite;

      if (!sprite) {
        throw new Error("No sprite associated with this target.");
      }

      if (newName && RESERVED_NAMES.indexOf(newName) === -1) {
        const names = this.runtime.targets.filter(runtimeTarget => runtimeTarget.isSprite() && runtimeTarget.id !== target.id).map(runtimeTarget => runtimeTarget.sprite.name);
        const oldName = sprite.name;
        const newUnusedName = StringUtil.unusedName(newName, names);
        sprite.name = newUnusedName;
        const allTargets = this.runtime.targets;

        for (let i = 0; i < allTargets.length; i++) {
          const currTarget = allTargets[i];
          currTarget.blocks.updateAssetName(oldName, newName, "sprite");
        }

        if (newUnusedName !== oldName) this.emitTargetsUpdate();
      }
    } else {
      throw new Error("No target with the provided id.");
    }
  }
  /**
   * Delete a sprite and all its clones.
   * @param {string} targetId ID of a target whose sprite to delete.
   * @return {Function} Returns a function to restore the sprite that was deleted
   */


  deleteSprite(targetId) {
    console.log("v-m.js ", targetId);
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const targetIndexBeforeDelete = this.runtime.targets.map(t => t.id).indexOf(target.id);

      if (!target.isSprite()) {
        throw new Error("Cannot delete non-sprite targets.");
      }

      const sprite = target.sprite;

      if (!sprite) {
        throw new Error("No sprite associated with this target.");
      }

      const spritePromise = this.exportSprite(targetId, "uint8array");

      const restoreSprite = () => spritePromise.then(spriteBuffer => this.addSprite(spriteBuffer)); // Remove monitors from the runtime state and remove the
      // target-specific monitored blocks (e.g. local variables)


      target.deleteMonitors();
      const currentEditingTarget = this.editingTarget;

      for (let i = 0; i < sprite.clones.length; i++) {
        const clone = sprite.clones[i];
        this.runtime.stopForTarget(sprite.clones[i]);
        this.runtime.disposeTarget(sprite.clones[i]); // Ensure editing target is switched if we are deleting it.

        if (clone === currentEditingTarget) {
          const nextTargetIndex = Math.min(this.runtime.targets.length - 1, targetIndexBeforeDelete);

          if (this.runtime.targets.length > 0) {
            this.setEditingTarget(this.runtime.targets[nextTargetIndex].id);
          } else {
            this.editingTarget = null;
          }
        }
      } // Sprite object should be deleted by GC.


      this.emitTargetsUpdate();
      return restoreSprite;
    }

    throw new Error("No target with the provided id.");
  }
  /**
   * Duplicate a sprite.
   * @param {string} targetId ID of a target whose sprite to duplicate.
   * @returns {Promise} Promise that resolves when duplicated target has
   *     been added to the runtime.
   */


  duplicateSprite(targetId) {
    console.log("v-m.js ", targetId);
    const target = this.runtime.getTargetById(targetId);

    if (!target) {
      throw new Error("No target with the provided id.");
    } else if (!target.isSprite()) {
      throw new Error("Cannot duplicate non-sprite targets.");
    } else if (!target.sprite) {
      throw new Error("No sprite associated with this target.");
    }

    return target.duplicate().then(newTarget => {
      this.runtime.addTarget(newTarget);
      newTarget.goBehindOther(target);
      this.setEditingTarget(newTarget.id);
    });
  }
  /**
   * Set the audio engine for the VM/runtime audio enginegui(gui.jsx)
   * @param {!AudioEngine} audioEngine The audio engine to attach
   */


  attachAudioEngine(audioEngine) {
    this.runtime.attachAudioEngine(audioEngine);
  }
  /**
   * Set the renderer for the VM/runtime , gui(stage.jsx)
   * @param {!RenderWebGL} renderer The renderer to attach
   */


  attachRenderer(renderer) {
    this.runtime.attachRenderer(renderer);
  }
  /**
   * @returns {RenderWebGL} The renderer attached to the vm
   */


  get renderer() {
    return this.runtime && this.runtime.renderer;
  }
  /**
   * /svg2 svg3 svg
   * @param {!SvgRenderer} svgAdapter The adapter to attach
   */


  attachV2SVGAdapter(svgAdapter) {
    console.log("/svg2 svg3 svg:", svgAdapter);
    this.runtime.attachV2SVGAdapter(svgAdapter);
  }
  /**
   * VM /23 32
   * @param {!function} bitmapAdapter The adapter to attach
   */


  attachV2BitmapAdapter(bitmapAdapter) {
    this.runtime.attachV2BitmapAdapter(bitmapAdapter);
  }
  /**
   * , gui(reducers/vm.js)
   * @param {!ScratchStorage} storage The storage module to attach
   */


  attachStorage(storage) {
    this.runtime.attachStorage(storage);
  }
  /**
   * 
   * @param {!string} locale       current locale
   * @param {!object} messages     builtin messages map for current locale
   * @returns {Promise} Promise that resolves when all the blocks have been
   *     updated for a new locale (or empty if locale hasn't changed.)
   */


  setLocale(locale, messages) {
    if (locale !== formatMessage.setup().locale) {
      formatMessage.setup({
        locale: locale,
        translations: {
          [locale]: messages
        }
      });
    }

    return this.extensionManager.refreshBlocks();
  }
  /**
   * get the current locale for the VM
   * @returns {string} the current locale in the VM
   */


  getLocale() {
    return formatMessage.setup().locale;
  }
  /**
   * Handle a Blockly event for the current editing target.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  blockListener(e) {
    if (this.editingTarget) {
      this.editingTarget.blocks.blocklyListen(e);
    }
  }
  /**
   * Handle a Blockly event for the flyout.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  flyoutBlockListener(e) {
    this.runtime.flyoutBlocks.blocklyListen(e);
  }
  /**
   * Handle a Blockly event for the flyout to be passed to the monitor container.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  monitorBlockListener(e) {
    // Filter events by type, since monitor blocks only need to listen to these events.
    // Monitor blocks shouldn't be destroyed when flyout blocks are deleted.
    if (["create", "change"].indexOf(e.type) !== -1) {
      this.runtime.monitorBlocks.blocklyListen(e);
    }
  }
  /**
   * Handle a Blockly event for the variable map.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  variableListener(e) {
    // Filter events by type, since blocks only needs to listen to these
    // var events.
    if (["var_create", "var_rename", "var_delete"].indexOf(e.type) !== -1) {
      this.runtime.getTargetForStage().blocks.blocklyListen(e);
    }
  }
  /**
   * Set an editing target. An editor UI can use this function to switch
   * between editing different targets, sprites, etc.
   * After switching the editing target, the VM may emit updates
   * to the list of targets and any attached workspace blocks
   * (see `emitTargetsUpdate` and `emitWorkspaceUpdate`).
   * @param {string} targetId Id of target to set as editing.
   */


  setEditingTarget(targetId) {
    console.log("setEditingTarget", targetId); // Has the target id changed? If not, exit.

    if (this.editingTarget && targetId === this.editingTarget.id) return;
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      this.editingTarget = target; // Emit appropriate UI updates.

      this.emitTargetsUpdate(false
      /* Don't emit project change */
      );
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(target);
    }
  }
  /**
   * Called when blocks are dragged from one sprite to another. Adds the blocks to the
   * workspace of the given target. spritesprite
   * @param {!Array<object>} blocks Blocks to add.
   * @param {!string} targetId Id of target to add blocks to.
   * @param {?string} optFromTargetId Optional target id indicating that blocks are being
   * shared from that target. This is needed for resolving any potential variable conflicts.
   * @return {!Promise} Promise that resolves when the extensions and blocks have been added.
   */


  shareBlocksToTarget(blocks, targetId, optFromTargetId) {
    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    const copiedBlocks = JSON.parse(JSON.stringify(blocks));
    Utility.newBlockIds(copiedBlocks);
    const target = this.runtime.getTargetById(targetId);

    if (optFromTargetId) {
      // If the blocks are being shared from another target,
      // resolve any possible variable conflicts that may arise.
      const fromTarget = this.runtime.getTargetById(optFromTargetId);
      fromTarget.resolveVariableSharingConflictsWithTarget(copiedBlocks, target);
    } // Create a unique set of extensionIds that are not yet loaded


    const extensionIDs = new Set(copiedBlocks.map(b => sb3.getExtensionIdForOpcode(b.opcode)).filter(id => !!id) // Remove ids that do not exist
    .filter(id => !this.extensionManager.isExtensionLoaded(id)) // and remove loaded extensions
    ); // Create an array promises for extensions to load

    const extensionPromises = Array.from(extensionIDs, id => this.extensionManager.loadExtensionURL(id));
    return Promise.all(extensionPromises).then(() => {
      copiedBlocks.forEach(block => {
        target.blocks.createBlock(block);
      });
      target.blocks.updateTargetSpecificBlocks(target.isStage);
    });
  }
  /**
   * .
   * .
   * @param {!number} costumeIndex .
   * @param {!string} targetId ID.
   * @return {Promise} .
   */


  shareCostumeToTarget(costumeIndex, targetId) {
    const originalCostume = this.editingTarget.getCostumes()[costumeIndex];
    const clone = Object.assign({}, originalCostume);
    const md5ext = `${clone.assetId}.${clone.dataFormat}`;
    return loadCostume(md5ext, clone, this.runtime).then(() => {
      const target = this.runtime.getTargetById(targetId);

      if (target) {
        target.addCostume(clone);
        target.setCostume(target.getCostumes().length - 1);
      }
    });
  }
  /**
   * Called when sounds are dragged from editing target to another target.
   * @param {!number} soundIndex Index of the sound of the editing target to share.
   * @param {!string} targetId Id of target to add the sound.
   * @return {Promise} Promise that resolves when the new sound has been loaded.
   */


  shareSoundToTarget(soundIndex, targetId) {
    const originalSound = this.editingTarget.getSounds()[soundIndex];
    const clone = Object.assign({}, originalSound);
    const target = this.runtime.getTargetById(targetId);
    return loadSound(clone, this.runtime, target.sprite.soundBank).then(() => {
      if (target) {
        target.addSound(clone);
        this.emitTargetsUpdate();
      }
    });
  }
  /**
   * Repopulate the workspace with the blocks of the current editingTarget. This
   * allows us to get around bugs like gui#413.
   * 
   */


  refreshWorkspace() {
    if (this.editingTarget) {
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(this.editingTarget);
      this.emitTargetsUpdate(false
      /* Don't emit project change */
      );
    }
  }
  /**
   * Emit metadata about available targets.
   * UI.
   * @param {bool} triggerProjectChange true.
   * .true.
   */


  emitTargetsUpdate(triggerProjectChange) {
    console.log("vm emitTargetsUpdate():", triggerProjectChange);
    if (typeof triggerProjectChange === "undefined") triggerProjectChange = true;
    this.emit("targetsUpdate", {
      // [[target id, human readable target name], ...].
      targetList: this.runtime.targets.filter( // .
      target => !target.hasOwnProperty("isOriginal") || target.isOriginal).map(target => target.toJSON()),
      // ID.
      editingTarget: this.editingTarget ? this.editingTarget.id : null
    });

    if (triggerProjectChange) {
      this.runtime.emitProjectChanged();
    }
  }
  /**
   * Emit an Blockly/scratch-blocks compatible XML representation
   * of the current editing target's blocks.
   */


  emitWorkspaceUpdate() {
    // Create a list of broadcast message Ids according to the stage variables
    const stageVariables = this.runtime.getTargetForStage().variables;
    let messageIds = [];

    for (const varId in stageVariables) {
      if (stageVariables[varId].type === Variable.BROADCAST_MESSAGE_TYPE) {
        messageIds.push(varId);
      }
    } // Go through all blocks on all targets, removing referenced
    // broadcast ids from the list.


    for (let i = 0; i < this.runtime.targets.length; i++) {
      const currTarget = this.runtime.targets[i];
      const currBlocks = currTarget.blocks._blocks;

      for (const blockId in currBlocks) {
        if (currBlocks[blockId].fields.BROADCAST_OPTION) {
          const id = currBlocks[blockId].fields.BROADCAST_OPTION.id;
          const index = messageIds.indexOf(id);

          if (index !== -1) {
            messageIds = messageIds.slice(0, index).concat(messageIds.slice(index + 1));
          }
        }
      }
    } // Anything left in messageIds is not referenced by a block, so delete it.


    for (let i = 0; i < messageIds.length; i++) {
      const id = messageIds[i];
      delete this.runtime.getTargetForStage().variables[id];
    }

    const globalVarMap = Object.assign({}, this.runtime.getTargetForStage().variables);
    const localVarMap = this.editingTarget.isStage ? Object.create(null) : Object.assign({}, this.editingTarget.variables);
    const globalVariables = Object.keys(globalVarMap).map(k => globalVarMap[k]);
    const localVariables = Object.keys(localVarMap).map(k => localVarMap[k]);
    const workspaceComments = Object.keys(this.editingTarget.comments).map(k => this.editingTarget.comments[k]).filter(c => c.blockId === null);
    const xmlString = `<xml xmlns="http://www.w3.org/1999/xhtml">
                            <variables>
                                ${globalVariables.map(v => v.toXML()).join()}
                                ${localVariables.map(v => v.toXML(true)).join()}
                            </variables>
                            ${workspaceComments.map(c => c.toXML()).join()}
                            ${this.editingTarget.blocks.toXML(this.editingTarget.comments)}
                        </xml>`;
    this.emit("workspaceUpdate", {
      xml: xmlString
    });
  }
  /**
   * Get a target id for a drawable id. Useful for interacting with the renderer
   * rendererdrawableidtargetid
   * @param {int} drawableId The drawable id to request the target id for
   * @returns {?string} The target id, if found. Will also be null if the target found is the stage.
   */


  getTargetIdForDrawableId(drawableId) {
    const target = this.runtime.getTargetByDrawableId(drawableId);

    if (target && target.hasOwnProperty("id") && target.hasOwnProperty("isStage") && !target.isStage) {
      return target.id;
    }

    return null;
  }
  /**
   * Reorder target by index. Return whether a change was made.
   * @param {!string} targetIndex Index of the target.
   * @param {!number} newIndex index that the target should be moved to.
   * @returns {boolean} Whether a target was reordered.
   */


  reorderTarget(targetIndex, newIndex) {
    let targets = this.runtime.targets;
    targetIndex = Utility.clamp(targetIndex, 0, targets.length - 1);
    newIndex = Utility.clamp(newIndex, 0, targets.length - 1);
    if (targetIndex === newIndex) return false;
    const target = targets[targetIndex];
    targets = targets.slice(0, targetIndex).concat(targets.slice(targetIndex + 1));
    targets.splice(newIndex, 0, target);
    this.runtime.targets = targets;
    this.emitTargetsUpdate();
    return true;
  }
  /**
   * Reorder the costumes of a target if it exists. Return whether it succeeded.
   * @param {!string} targetId ID of the target which owns the costumes.
   * @param {!number} costumeIndex index of the costume to move.
   * @param {!number} newIndex index that the costume should be moved to.
   * @returns {boolean} Whether a costume was reordered.
   */


  reorderCostume(targetId, costumeIndex, newIndex) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const reorderSuccessful = target.reorderCostume(costumeIndex, newIndex);

      if (reorderSuccessful) {
        this.runtime.emitProjectChanged();
      }

      return reorderSuccessful;
    }

    return false;
  }
  /**
   * Reorder the sounds of a target if it exists. Return whether it occured.
   * @param {!string} targetId ID of the target which owns the sounds.
   * @param {!number} soundIndex index of the sound to move.
   * @param {!number} newIndex index that the sound should be moved to.
   * @returns {boolean} Whether a sound was reordered.
   */


  reorderSound(targetId, soundIndex, newIndex) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const reorderSuccessful = target.reorderSound(soundIndex, newIndex);

      if (reorderSuccessful) {
        this.runtime.emitProjectChanged();
      }

      return reorderSuccessful;
    }

    return false;
  }
  /**
   * Put a target into a "drag" state, during which its X/Y positions will be unaffected
   * by blocks.
   * targetdrag mode(this. _dragTarget=target), gui(stage.jsx)
   * @param {string} targetId The id for the target to put into a drag state
   */


  startDrag(targetId) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      this._dragTarget = target;
      target.startDrag();
    }
  }
  /**
   * Remove a target from a drag state, so blocks may begin affecting X/Y position again
   * targetdrag mode(this. _dragTarget=null), gui(stage.jsx)
   * @param {string} targetId The id for the target to remove from the drag state
   */


  stopDrag(targetId) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      this._dragTarget = null;
      target.stopDrag();
      this.setEditingTarget(target.sprite && target.sprite.clones[0] ? target.sprite.clones[0].id : target.id);
    }
  }
  /**
   * Post/edit sprite info for the current editing target or the drag target.
   * editing target or dragging target sprite
   * @param {object} data An object with sprite info data to set.
   */


  postSpriteInfo(data) {
    if (this._dragTarget) {
      this._dragTarget.postSpriteInfo(data);
    } else {
      this.editingTarget.postSpriteInfo(data);
    } // Post sprite info means the gui has changed something about a sprite,
    // either through the sprite info pane fields (e.g. direction, size) or
    // through dragging a sprite on the stage
    // Emit a project changed event.


    this.runtime.emitProjectChanged();
  }
  /**
   * Set a target's variable's value. Return whether it succeeded.
   * @param {!string} targetId ID of the target which owns the variable.
   * @param {!string} variableId ID of the variable to set.
   * @param {!*} value The new value of that variable.
   * @returns {boolean} whether the target and variable were found and updated.
   */


  setVariableValue(targetId, variableId, value) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const variable = target.lookupVariableById(variableId);

      if (variable) {
        variable.value = value;

        if (variable.isCloud) {
          this.runtime.ioDevices.cloud.requestUpdateVariable(variable.name, variable.value);
        }

        return true;
      }
    }

    return false;
  }
  /**
   * Get a target's variable's value. Return null if the target or variable does not exist.
   * @param {!string} targetId ID of the target which owns the variable.
   * @param {!string} variableId ID of the variable to set.
   * @returns {?*} The value of the variable, or null if it could not be looked up.
   */


  getVariableValue(targetId, variableId) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const variable = target.lookupVariableById(variableId);

      if (variable) {
        return variable.value;
      }
    }

    return null;
  }
  /**
   * Allow VM consumer to configure the ScratchLink socket creator.
   * @param {Function} factory The custom ScratchLink socket factory.
   */


  configureScratchLinkSocketFactory(factory) {
    this.runtime.configureScratchLinkSocketFactory(factory);
  }

}

module.exports = VirtualMachine;

/***/ }),

/***/ "./src/vm-blocks.js":
/*!**************************!*\
  !*** ./src/vm-blocks.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * @Author: Satya
 * @Date: 2020-12-22 15:25:23
 * @Last Modified by: Satya
 * @Last Modified time: 2020-12-22 15:52:14
 * doc:
 * 
 */
const Timer = __webpack_require__(/*! ./util/timer */ "./src/util/timer.js");

const RenderedTarget = __webpack_require__(/*! ./sprites/rendered-target */ "./src/sprites/rendered-target.js");

const StageLayering = __webpack_require__(/*! ./engine/stage-layering */ "./src/engine/stage-layering.js");
/** @module  */


class KidControlBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The "counter" block value. For compatibility with 2.0.
     * @type {number}
     */

    this._counter = 0;
    this.runtime.on("RUNTIME_DISPOSED", this.clearCounter.bind(this));
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      control_repeat: this.repeat,
      control_repeat_until: this.repeatUntil,
      control_while: this.repeatWhile,
      control_for_each: this.forEach,
      control_forever: this.forever,
      control_wait: this.wait,
      control_wait_until: this.waitUntil,
      control_if: this.if,
      control_if_else: this.ifElse,
      control_stop: this.stop,
      control_create_clone_of: this.createClone,
      control_delete_this_clone: this.deleteClone,
      control_get_counter: this.getCounter,
      control_incr_counter: this.incrCounter,
      control_clear_counter: this.clearCounter,
      control_all_at_once: this.allAtOnce
    };
  }

  getHats() {
    return {
      control_start_as_clone: {
        restartExistingThreads: false
      }
    };
  }

  repeat(args, util) {
    const times = Math.round(Utility.toNumber(args.TIMES)); // Initialize loop

    if (typeof util.stackFrame.loopCounter === "undefined") {
      util.stackFrame.loopCounter = times;
    } // Only execute once per frame.
    // When the branch finishes, `repeat` will be executed again and
    // the second branch will be taken, yielding for the rest of the frame.
    // Decrease counter


    util.stackFrame.loopCounter--; // If we still have some left, start the branch.

    if (util.stackFrame.loopCounter >= 0) {
      util.startBranch(1, true);
    }
  }

  repeatUntil(args, util) {
    const condition = Utility.toBoolean(args.CONDITION); // If the condition is false (repeat UNTIL), start the branch.

    if (!condition) {
      util.startBranch(1, true);
    }
  }

  repeatWhile(args, util) {
    const condition = Utility.toBoolean(args.CONDITION); // If the condition is true (repeat WHILE), start the branch.

    if (condition) {
      util.startBranch(1, true);
    }
  }

  forEach(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);

    if (typeof util.stackFrame.index === "undefined") {
      util.stackFrame.index = 0;
    }

    if (util.stackFrame.index < Number(args.VALUE)) {
      util.stackFrame.index++;
      variable.value = util.stackFrame.index;
      util.startBranch(1, true);
    }
  }

  waitUntil(args, util) {
    const condition = Utility.toBoolean(args.CONDITION);

    if (!condition) {
      util.yield();
    }
  }

  forever(args, util) {
    util.startBranch(1, true);
  }

  wait(args, util) {
    if (util.stackTimerNeedsInit()) {
      const duration = Math.max(0, 1000 * Utility.toNumber(args.DURATION));
      util.startStackTimer(duration);
      this.runtime.requestRedraw();
      util.yield();
    } else if (!util.stackTimerFinished()) {
      util.yield();
    }
  }

  if(args, util) {
    const condition = Utility.toBoolean(args.CONDITION);

    if (condition) {
      util.startBranch(1, false);
    }
  }

  ifElse(args, util) {
    const condition = Utility.toBoolean(args.CONDITION);

    if (condition) {
      util.startBranch(1, false);
    } else {
      util.startBranch(2, false);
    }
  }

  stop(args, util) {
    const option = args.STOP_OPTION;

    if (option === "all") {
      util.stopAll();
    } else if (option === "other scripts in sprite" || option === "other scripts in stage") {
      util.stopOtherTargetThreads();
    } else if (option === "this script") {
      util.stopThisScript();
    }
  }

  createClone(args, util) {
    // Cast argument to string
    args.CLONE_OPTION = String(args.CLONE_OPTION); // Set clone target

    let cloneTarget;

    if (args.CLONE_OPTION === "_myself_") {
      cloneTarget = util.target;
    } else {
      cloneTarget = this.runtime.getSpriteTargetByName(args.CLONE_OPTION);
    } // If clone target is not found, return


    if (!cloneTarget) return; // Create clone

    const newClone = cloneTarget.makeClone();

    if (newClone) {
      this.runtime.addTarget(newClone); // Place behind the original target.

      newClone.goBehindOther(cloneTarget);
    }
  }

  deleteClone(args, util) {
    if (util.target.isOriginal) return;
    this.runtime.disposeTarget(util.target);
    this.runtime.stopForTarget(util.target);
  }

  getCounter() {
    return this._counter;
  }

  clearCounter() {
    this._counter = 0;
  }

  incrCounter() {
    this._counter++;
  }

  allAtOnce(args, util) {
    // Since the "all at once" block is implemented for compatiblity with
    // Scratch 2.0 projects, it behaves the same way it did in 2.0, which
    // is to simply run the contained script (like "if 1 = 1").
    // (In early versions of Scratch 2.0, it would work the same way as
    // "run without screen refresh" custom blocks do now, but this was
    // removed before the release of 2.0.)
    util.startBranch(1, false);
  }

}
/** @module  */


class KidEventBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this.runtime.on("KEY_PRESSED", key => {
      this.runtime.startHats("event_whenkeypressed", {
        KEY_OPTION: key
      });
      this.runtime.startHats("event_whenkeypressed", {
        KEY_OPTION: "any"
      });
    });
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      event_whentouchingobject: this.touchingObject,
      event_broadcast: this.broadcast,
      event_broadcastandwait: this.broadcastAndWait,
      event_whengreaterthan: this.hatGreaterThanPredicate
    };
  }

  getHats() {
    return {
      event_whenflagclicked: {
        restartExistingThreads: true
      },
      event_whenkeypressed: {
        restartExistingThreads: false
      },
      event_whenthisspriteclicked: {
        restartExistingThreads: true
      },
      event_whentouchingobject: {
        restartExistingThreads: false,
        edgeActivated: true
      },
      event_whenstageclicked: {
        restartExistingThreads: true
      },
      event_whenbackdropswitchesto: {
        restartExistingThreads: true
      },
      event_whengreaterthan: {
        restartExistingThreads: false,
        edgeActivated: true
      },
      event_whenbroadcastreceived: {
        restartExistingThreads: true
      }
    };
  }

  touchingObject(args, util) {
    return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);
  }

  hatGreaterThanPredicate(args, util) {
    const option = String(args.WHENGREATERTHANMENU).toLowerCase();
    const value = Utility.toNumber(args.VALUE);

    switch (option) {
      case "timer":
        return util.ioQuery("clock", "projectTimer") > value;

      case "loudness":
        return this.runtime.audioEngine && this.runtime.audioEngine.getLoudness() > value;
    }

    return false;
  }

  broadcast(args, util) {
    const broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);

    if (broadcastVar) {
      const broadcastOption = broadcastVar.name;
      util.startHats("event_whenbroadcastreceived", {
        BROADCAST_OPTION: broadcastOption
      });
    }
  }

  broadcastAndWait(args, util) {
    const broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);

    if (broadcastVar) {
      const broadcastOption = broadcastVar.name; // Have we run before, starting threads?

      if (!util.stackFrame.startedThreads) {
        // No - start hats for this broadcast.
        util.stackFrame.startedThreads = util.startHats("event_whenbroadcastreceived", {
          BROADCAST_OPTION: broadcastOption
        });

        if (util.stackFrame.startedThreads.length === 0) {
          // Nothing was started.
          return;
        }
      } // We've run before; check if the wait is still going on.


      const instance = this; // Scratch 2 considers threads to be waiting if they are still in
      // runtime.threads. Threads that have run all their blocks, or are
      // marked done but still in runtime.threads are still considered to
      // be waiting.

      const waiting = util.stackFrame.startedThreads.some(thread => instance.runtime.threads.indexOf(thread) !== -1);

      if (waiting) {
        // If all threads are waiting for the next tick or later yield
        // for a tick as well. Otherwise yield until the next loop of
        // the threads.
        if (util.stackFrame.startedThreads.every(thread => instance.runtime.isWaitingThread(thread))) {
          util.yieldTick();
        } else {
          util.yield();
        }
      }
    }
  }

}
/**
 * @module 
 * @typedef {object} BubbleState - the bubble state associated with a particular target.
 * @property {Boolean} onSpriteRight - tracks whether the bubble is right or left of the sprite.
 * @property {?int} drawableId - the ID of the associated bubble Drawable, null if none.
 * @property {string} text - the text of the bubble.
 * @property {string} type - the type of the bubble, "say" or "think"
 * @property {?string} usageId - ID indicating the most recent usage of the say/think bubble.
 *      Used for comparison when determining whether to clear a say/think bubble.
 */


class KidLooksBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this._onTargetChanged = this._onTargetChanged.bind(this);
    this._onResetBubbles = this._onResetBubbles.bind(this);
    this._onTargetWillExit = this._onTargetWillExit.bind(this);
    this._updateBubble = this._updateBubble.bind(this); // Reset all bubbles on start/stop

    this.runtime.on("PROJECT_STOP_ALL", this._onResetBubbles);
    this.runtime.on("targetWasRemoved", this._onTargetWillExit); // Enable other blocks to use bubbles like ask/answer

    this.runtime.on(KidLooksBlocks.SAY_OR_THINK, this._updateBubble);
  }
  /**
   * The default bubble state, to be used when a target has no existing bubble state.
   * @type {BubbleState}
   */


  static get DEFAULT_BUBBLE_STATE() {
    return {
      drawableId: null,
      onSpriteRight: true,
      skinId: null,
      text: "",
      type: "say",
      usageId: null
    };
  }
  /**
   * The key to load & store a target's bubble-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.looks";
  }
  /**
   * Event name for a text bubble being created or updated.
   * @const {string}
   */


  static get SAY_OR_THINK() {
    // There are currently many places in the codebase which explicitly refer to this event by the string 'SAY',
    // so keep this as the string 'SAY' for now rather than changing it to 'SAY_OR_THINK' and breaking things.
    return "SAY";
  }
  /**
   * Limit for say bubble string.
   * @const {string}
   */


  static get SAY_BUBBLE_LIMIT() {
    return 330;
  }
  /**
   * Limit for ghost effect
   * @const {object}
   */


  static get EFFECT_GHOST_LIMIT() {
    return {
      min: 0,
      max: 100
    };
  }
  /**
   * Limit for brightness effect
   * @const {object}
   */


  static get EFFECT_BRIGHTNESS_LIMIT() {
    return {
      min: -100,
      max: 100
    };
  }
  /**
   * @param {Target} target - collect bubble state for this target. Probably, but not necessarily, a RenderedTarget.
   * @returns {BubbleState} the mutable bubble state associated with that target. This will be created if necessary.
   * @private
   */


  _getBubbleState(target) {
    let bubbleState = target.getCustomState(KidLooksBlocks.STATE_KEY);

    if (!bubbleState) {
      bubbleState = Utility.cloneSimple(KidLooksBlocks.DEFAULT_BUBBLE_STATE);
      target.setCustomState(KidLooksBlocks.STATE_KEY, bubbleState);
    }

    return bubbleState;
  }
  /**
   * Handle a target which has moved.
   * @param {RenderedTarget} target - the target which has moved.
   * @private
   */


  _onTargetChanged(target) {
    const bubbleState = this._getBubbleState(target);

    if (bubbleState.drawableId) {
      this._positionBubble(target);
    }
  }
  /**
   * Handle a target which is exiting.
   * @param {RenderedTarget} target - the target.
   * @private
   */


  _onTargetWillExit(target) {
    const bubbleState = this._getBubbleState(target);

    if (bubbleState.drawableId && bubbleState.skinId) {
      this.runtime.renderer.destroyDrawable(bubbleState.drawableId, StageLayering.SPRITE_LAYER);
      this.runtime.renderer.destroySkin(bubbleState.skinId);
      bubbleState.drawableId = null;
      bubbleState.skinId = null;
      this.runtime.requestRedraw();
    }

    target.removeListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);
  }
  /**
   * Handle project start/stop by clearing all visible bubbles.
   * @private
   */


  _onResetBubbles() {
    for (let n = 0; n < this.runtime.targets.length; n++) {
      const bubbleState = this._getBubbleState(this.runtime.targets[n]);

      bubbleState.text = "";

      this._onTargetWillExit(this.runtime.targets[n]);
    }

    clearTimeout(this._bubbleTimeout);
  }
  /**
   * Position the bubble of a target. If it doesn't fit on the specified side, flip and rerender.
   * @param {!Target} target Target whose bubble needs positioning.
   * @private
   */


  _positionBubble(target) {
    if (!target.visible) return;

    const bubbleState = this._getBubbleState(target);

    const [bubbleWidth, bubbleHeight] = this.runtime.renderer.getCurrentSkinSize(bubbleState.drawableId);
    let targetBounds;

    try {
      targetBounds = target.getBoundsForBubble();
    } catch (error_) {
      // Bounds calculation could fail (e.g. on empty costumes), in that case
      // use the x/y position of the target.
      targetBounds = {
        left: target.x,
        right: target.x,
        top: target.y,
        bottom: target.y
      };
    }

    const stageSize = this.runtime.renderer.getNativeSize();
    const stageBounds = {
      left: -stageSize[0] / 2,
      right: stageSize[0] / 2,
      top: stageSize[1] / 2,
      bottom: -stageSize[1] / 2
    };

    if (bubbleState.onSpriteRight && bubbleWidth + targetBounds.right > stageBounds.right && targetBounds.left - bubbleWidth > stageBounds.left) {
      // Only flip if it would fit
      bubbleState.onSpriteRight = false;

      this._renderBubble(target);
    } else if (!bubbleState.onSpriteRight && targetBounds.left - bubbleWidth < stageBounds.left && bubbleWidth + targetBounds.right < stageBounds.right) {
      // Only flip if it would fit
      bubbleState.onSpriteRight = true;

      this._renderBubble(target);
    } else {
      this.runtime.renderer.updateDrawableProperties(bubbleState.drawableId, {
        position: [bubbleState.onSpriteRight ? Math.max(stageBounds.left, // Bubble should not extend past left edge of stage
        Math.min(stageBounds.right - bubbleWidth, targetBounds.right)) : Math.min(stageBounds.right - bubbleWidth, // Bubble should not extend past right edge of stage
        Math.max(stageBounds.left, targetBounds.left - bubbleWidth)), // Bubble should not extend past the top of the stage
        Math.min(stageBounds.top, targetBounds.bottom + bubbleHeight)]
      });
      this.runtime.requestRedraw();
    }
  }
  /**
   * Create a visible bubble for a target. If a bubble exists for the target,
   * just set it to visible and update the type/text. Otherwise create a new
   * bubble and update the relevant custom state.
   * @param {!Target} target Target who needs a bubble.
   * @return {undefined} Early return if text is empty string.
   * @private
   */


  _renderBubble(target) {
    if (!this.runtime.renderer) return;

    const bubbleState = this._getBubbleState(target);

    const {
      type,
      text,
      onSpriteRight
    } = bubbleState; // Remove the bubble if target is not visible, or text is being set to blank.

    if (!target.visible || text === "") {
      this._onTargetWillExit(target);

      return;
    }

    if (bubbleState.skinId) {
      this.runtime.renderer.updateTextSkin(bubbleState.skinId, type, text, onSpriteRight, [0, 0]);
    } else {
      target.addListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);
      bubbleState.drawableId = this.runtime.renderer.createDrawable(StageLayering.SPRITE_LAYER);
      bubbleState.skinId = this.runtime.renderer.createTextSkin(type, text, bubbleState.onSpriteRight, [0, 0]);
      this.runtime.renderer.updateDrawableProperties(bubbleState.drawableId, {
        skinId: bubbleState.skinId
      });
    }

    this._positionBubble(target);
  }
  /**
   * Properly format text for a text bubble.
   * @param {string} text The text to be formatted
   * @return {string} The formatted text
   * @private
   */


  _formatBubbleText(text) {
    if (text === "") return text; // Non-integers should be rounded to 2 decimal places (no more, no less), unless they're small enough that
    // rounding would display them as 0.00. This matches 2.0's behavior:
    // https://github.com/LLK/scratch-flash/blob/2e4a402ceb205a042887f54b26eebe1c2e6da6c0/src/scratch/ScratchSprite.as#L579-L585

    if (typeof text === "number" && Math.abs(text) >= 0.01 && text % 1 !== 0) {
      text = text.toFixed(2);
    } // Limit the length of the string.


    text = String(text).substr(0, KidLooksBlocks.SAY_BUBBLE_LIMIT);
    return text;
  }
  /**
   * The entry point for say/think blocks. Clears existing bubble if the text is empty.
   * Set the bubble custom state and then call _renderBubble.
   * @param {!Target} target Target that say/think blocks are being called on.
   * @param {!string} type Either "say" or "think"
   * @param {!string} text The text for the bubble, empty string clears the bubble.
   * @private
   */


  _updateBubble(target, type, text) {
    const bubbleState = this._getBubbleState(target);

    bubbleState.type = type;
    bubbleState.text = this._formatBubbleText(text);
    console.warn("look:", Utility.uid());
    bubbleState.usageId = Utility.uid();

    this._renderBubble(target);
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      /** KID-JR   */
      looks_zoomout: this.zoomOut,
      looks_zoomin: this.zoomIn,
      looks_zoomreset: this.zoomReset,

      /** KID-PRO   */
      looks_say: this.say,
      looks_sayforsecs: this.sayforsecs,
      looks_think: this.think,
      looks_thinkforsecs: this.thinkforsecs,
      looks_show: this.show,
      looks_hide: this.hide,
      looks_hideallsprites: () => {},
      // legacy no-op block
      looks_switchcostumeto: this.switchCostume,
      looks_switchbackdropto: this.switchBackdrop,
      looks_switchbackdroptoandwait: this.switchBackdropAndWait,
      looks_nextcostume: this.nextCostume,
      looks_nextbackdrop: this.nextBackdrop,
      looks_changeeffectby: this.changeEffect,
      looks_seteffectto: this.setEffect,
      looks_cleargraphiceffects: this.clearEffects,
      looks_changesizeby: this.changeSize,
      looks_setsizeto: this.setSize,
      looks_changestretchby: () => {},
      // legacy no-op blocks
      looks_setstretchto: () => {},
      looks_gotofrontback: this.goToFrontBack,
      looks_goforwardbackwardlayers: this.goForwardBackwardLayers,
      looks_size: this.getSize,
      looks_costumenumbername: this.getCostumeNumberName,
      looks_backdropnumbername: this.getBackdropNumberName
    };
  }

  getMonitored() {
    return {
      looks_size: {
        isSpriteSpecific: true,
        getId: targetId => `${targetId}_size`
      },
      looks_costumenumbername: {
        isSpriteSpecific: true,
        getId: (targetId, fields) => Utility.getMonitorIdForBlockWithArgs(`${targetId}_costumenumbername`, fields)
      },
      looks_backdropnumbername: {
        getId: (_, fields) => Utility.getMonitorIdForBlockWithArgs("backdropnumbername", fields)
      }
    };
  }
  /** KID-JR   */

  /**
   *   
   * @param {*} args
   * @param {*} util
   */


  zoomOut(args, util) {
    if (util.stackFrame.timer) {
      const n = util.stackFrame.timer.timeElapsed();

      if (n < 1e3 * util.stackFrame.duration) {
        const r = (n - util.stackFrame.prevTimeElapsed) / (1e3 * util.stackFrame.duration) * util.stackFrame.absPercent; // eslint-disable-next-line no-unused-expressions

        util.target.setSize(util.stackFrame.crtScale + r), util.yield();
      } else {
        util.target.setSize(util.stackFrame.crtScale + util.stackFrame.absPercent);
      }
    } else {
      // const i = Cast.toNumber(args.PERCENT);
      const i = Utility.toNumber(1);
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();

      if (util.stackFrame.duration = 0.1 * i, util.stackFrame.absPercent = 10 * i, util.stackFrame.crtScale = util.target.size, util.stackFrame.prevTimeElapsed = 0, util.stackFrame.duration <= 0) {
        return void util.target.setSize(util.stackFrame.crtScale + util.stackFrame.absPercent);
      }

      util.yield();
    }
  }
  /**
   *   
   * @param {*} args
   * @param {*} util
   */


  zoomIn(args, util) {
    if (util.stackFrame.timer) {
      const n = util.stackFrame.timer.timeElapsed();

      if (n < 1e3 * util.stackFrame.duration) {
        const r = (n - util.stackFrame.prevTimeElapsed) / (1e3 * util.stackFrame.duration) * util.stackFrame.absPercent; // eslint-disable-next-line no-unused-expressions

        util.target.setSize(util.stackFrame.crtScale - r), util.yield();
      } else {
        util.target.setSize(util.stackFrame.crtScale - util.stackFrame.absPercent);
      }
    } else {
      // const i = Cast.toNumber(args.PERCENT);
      const i = Utility.toNumber(1);
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();

      if (util.stackFrame.duration = 0.1 * i, util.stackFrame.absPercent = 10 * i, util.stackFrame.crtScale = util.target.size, util.stackFrame.prevTimeElapsed = 0, util.stackFrame.duration <= 0) {
        return void util.target.setSize(util.stackFrame.crtScale - util.stackFrame.absPercent);
      }

      util.yield();
    }
  }
  /**
   *   
   * @param {*} args
   * @param {*} util
   */


  zoomReset(args, util) {
    util.target.setSize(100);
  }
  /** KID-PRO   */


  say(args, util) {
    // @TODO in 2.0 calling say/think resets the right/left bias of the bubble
    this.runtime.emit(KidLooksBlocks.SAY_OR_THINK, util.target, "say", args.MESSAGE);
  }

  sayforsecs(args, util) {
    this.say(args, util);
    const target = util.target;

    const usageId = this._getBubbleState(target).usageId;

    return new Promise(resolve => {
      this._bubbleTimeout = setTimeout(() => {
        this._bubbleTimeout = null; // Clear say bubble if it hasn't been changed and proceed.

        if (this._getBubbleState(target).usageId === usageId) {
          this._updateBubble(target, "say", "");
        }

        resolve();
      }, 1000 * args.SECS);
    });
  }

  think(args, util) {
    this.runtime.emit(KidLooksBlocks.SAY_OR_THINK, util.target, "think", args.MESSAGE);
  }

  thinkforsecs(args, util) {
    this.think(args, util);
    const target = util.target;

    const usageId = this._getBubbleState(target).usageId;

    return new Promise(resolve => {
      this._bubbleTimeout = setTimeout(() => {
        this._bubbleTimeout = null; // Clear think bubble if it hasn't been changed and proceed.

        if (this._getBubbleState(target).usageId === usageId) {
          this._updateBubble(target, "think", "");
        }

        resolve();
      }, 1000 * args.SECS);
    });
  }

  show(args, util) {
    util.target.setVisible(true);

    this._renderBubble(util.target);
  }

  hide(args, util) {
    util.target.setVisible(false);

    this._renderBubble(util.target);
  }
  /**
   * Utility function to set the costume of a target.
   * Matches the behavior of Scratch 2.0 for different types of arguments.
   * @param {!Target} target Target to set costume to.
   * @param {Any} requestedCostume Costume requested, e.g., 0, 'name', etc.
   * @param {boolean=} optZeroIndex Set to zero-index the requestedCostume.
   * @return {Array.<!Thread>} Any threads started by this switch.
   */


  _setCostume(target, requestedCostume, optZeroIndex) {
    if (typeof requestedCostume === "number") {
      // Numbers should be treated as costume indices, always
      target.setCostume(optZeroIndex ? requestedCostume : requestedCostume - 1);
    } else {
      // Strings should be treated as costume names, where possible
      const costumeIndex = target.getCostumeIndexByName(requestedCostume.toString());

      if (costumeIndex !== -1) {
        target.setCostume(costumeIndex);
      } else if (requestedCostume === "next costume") {
        target.setCostume(target.currentCostume + 1);
      } else if (requestedCostume === "previous costume") {
        target.setCostume(target.currentCostume - 1); // Try to cast the string to a number (and treat it as a costume index)
        // Pure whitespace should not be treated as a number
        // Note: isNaN will cast the string to a number before checking if it's NaN
      } else if (!(isNaN(requestedCostume) || Utility.isWhiteSpace(requestedCostume))) {
        target.setCostume(optZeroIndex ? Number(requestedCostume) : Number(requestedCostume) - 1);
      }
    } // Per 2.0, 'switch costume' can't start threads even in the Stage.


    return [];
  }
  /**
   * Utility function to set the backdrop of a target.
   * Matches the behavior of Scratch 2.0 for different types of arguments.
   * @param {!Target} stage Target to set backdrop to.
   * @param {Any} requestedBackdrop Backdrop requested, e.g., 0, 'name', etc.
   * @param {boolean=} optZeroIndex Set to zero-index the requestedBackdrop.
   * @return {Array.<!Thread>} Any threads started by this switch.
   */


  _setBackdrop(stage, requestedBackdrop, optZeroIndex) {
    if (typeof requestedBackdrop === "number") {
      // Numbers should be treated as backdrop indices, always
      stage.setCostume(optZeroIndex ? requestedBackdrop : requestedBackdrop - 1);
    } else {
      // Strings should be treated as backdrop names where possible
      const costumeIndex = stage.getCostumeIndexByName(requestedBackdrop.toString());

      if (costumeIndex !== -1) {
        stage.setCostume(costumeIndex);
      } else if (requestedBackdrop === "next backdrop") {
        stage.setCostume(stage.currentCostume + 1);
      } else if (requestedBackdrop === "previous backdrop") {
        stage.setCostume(stage.currentCostume - 1);
      } else if (requestedBackdrop === "random backdrop") {
        const numCostumes = stage.getCostumes().length;

        if (numCostumes > 1) {
          // Don't pick the current backdrop, so that the block
          // will always have an observable effect.
          const lowerBound = 0;
          const upperBound = numCostumes - 1;
          const costumeToExclude = stage.currentCostume;
          const nextCostume = Utility.inclusiveRandIntWithout(lowerBound, upperBound, costumeToExclude);
          stage.setCostume(nextCostume);
        } // Try to cast the string to a number (and treat it as a costume index)
        // Pure whitespace should not be treated as a number
        // Note: isNaN will cast the string to a number before checking if it's NaN

      } else if (!(isNaN(requestedBackdrop) || Utility.isWhiteSpace(requestedBackdrop))) {
        stage.setCostume(optZeroIndex ? Number(requestedBackdrop) : Number(requestedBackdrop) - 1);
      }
    }

    const newName = stage.getCostumes()[stage.currentCostume].name;
    return this.runtime.startHats("event_whenbackdropswitchesto", {
      BACKDROP: newName
    });
  }

  switchCostume(args, util) {
    this._setCostume(util.target, args.COSTUME);
  }

  nextCostume(args, util) {
    this._setCostume(util.target, util.target.currentCostume + 1, true);
  }

  switchBackdrop(args) {
    this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);
  }

  switchBackdropAndWait(args, util) {
    // Have we run before, starting threads?
    if (!util.stackFrame.startedThreads) {
      // No - switch the backdrop.
      util.stackFrame.startedThreads = this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);

      if (util.stackFrame.startedThreads.length === 0) {
        // Nothing was started.
        return;
      }
    } // We've run before; check if the wait is still going on.


    const instance = this; // Scratch 2 considers threads to be waiting if they are still in
    // runtime.threads. Threads that have run all their blocks, or are
    // marked done but still in runtime.threads are still considered to
    // be waiting.

    const waiting = util.stackFrame.startedThreads.some(thread => instance.runtime.threads.indexOf(thread) !== -1);

    if (waiting) {
      // If all threads are waiting for the next tick or later yield
      // for a tick as well. Otherwise yield until the next loop of
      // the threads.
      if (util.stackFrame.startedThreads.every(thread => instance.runtime.isWaitingThread(thread))) {
        util.yieldTick();
      } else {
        util.yield();
      }
    }
  }

  nextBackdrop() {
    const stage = this.runtime.getTargetForStage();

    this._setBackdrop(stage, stage.currentCostume + 1, true);
  }

  clampEffect(effect, value) {
    let clampedValue = value;

    switch (effect) {
      case "ghost":
        clampedValue = Utility.clamp(value, KidLooksBlocks.EFFECT_GHOST_LIMIT.min, KidLooksBlocks.EFFECT_GHOST_LIMIT.max);
        break;

      case "brightness":
        clampedValue = Utility.clamp(value, KidLooksBlocks.EFFECT_BRIGHTNESS_LIMIT.min, KidLooksBlocks.EFFECT_BRIGHTNESS_LIMIT.max);
        break;
    }

    return clampedValue;
  }

  changeEffect(args, util) {
    const effect = String(args.EFFECT).toLowerCase();
    const change = Utility.toNumber(args.CHANGE);
    if (!util.target.effects.hasOwnProperty(effect)) return;
    let newValue = change + util.target.effects[effect];
    newValue = this.clampEffect(effect, newValue);
    util.target.setEffect(effect, newValue);
  }

  setEffect(args, util) {
    const effect = String(args.EFFECT).toLowerCase();
    let value = Utility.toNumber(args.VALUE);
    value = this.clampEffect(effect, value);
    util.target.setEffect(effect, value);
  }

  clearEffects(args, util) {
    util.target.clearEffects();
  }

  changeSize(args, util) {
    const change = Utility.toNumber(args.CHANGE);
    util.target.setSize(util.target.size + change);
  }

  setSize(args, util) {
    const size = Utility.toNumber(args.SIZE);
    util.target.setSize(size);
  }

  goToFrontBack(args, util) {
    if (!util.target.isStage) {
      if (args.FRONT_BACK === "front") {
        util.target.goToFront();
      } else {
        util.target.goToBack();
      }
    }
  }

  goForwardBackwardLayers(args, util) {
    if (!util.target.isStage) {
      if (args.FORWARD_BACKWARD === "forward") {
        util.target.goForwardLayers(Utility.toNumber(args.NUM));
      } else {
        util.target.goBackwardLayers(Utility.toNumber(args.NUM));
      }
    }
  }

  getSize(args, util) {
    return Math.round(util.target.size);
  }

  getBackdropNumberName(args) {
    const stage = this.runtime.getTargetForStage();

    if (args.NUMBER_NAME === "number") {
      return stage.currentCostume + 1;
    } // Else return name


    return stage.getCostumes()[stage.currentCostume].name;
  }

  getCostumeNumberName(args, util) {
    if (args.NUMBER_NAME === "number") {
      return util.target.currentCostume + 1;
    } // Else return name


    return util.target.getCostumes()[util.target.currentCostume].name;
  }

}
/** @module  */


class KidMotionBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      /**  Blockly */
      // colour_picker: this.colourPicker,

      /** KID-JR  */
      motion_moveleft: this.moveLeft,
      // 
      motion_moveright: this.moveRight,
      // 
      motion_moveup: this.moveUp,
      // 
      motion_movedown: this.moveDown,
      // 
      motion_jump: this.moveJump,
      // 
      motion_movereset: this.moveReset,
      // 

      /** KID-PRO  */
      motion_movesteps: this.moveSteps,
      motion_gotoxy: this.goToXY,
      motion_goto: this.goTo,
      motion_turnright: this.turnRight,
      motion_turnleft: this.turnLeft,
      motion_pointindirection: this.pointInDirection,
      motion_pointtowards: this.pointTowards,
      motion_glidesecstoxy: this.glide,
      motion_glideto: this.glideTo,
      motion_ifonedgebounce: this.ifOnEdgeBounce,
      motion_setrotationstyle: this.setRotationStyle,
      motion_changexby: this.changeX,
      motion_setx: this.setX,
      motion_changeyby: this.changeY,
      motion_sety: this.setY,
      motion_xposition: this.getX,
      motion_yposition: this.getY,
      motion_direction: this.getDirection,
      // Legacy no-op blocks:
      motion_scroll_right: () => {},
      motion_scroll_up: () => {},
      motion_align_scene: () => {},
      motion_xscroll: () => {},
      motion_yscroll: () => {}
    };
  }

  getMonitored() {
    return {
      motion_xposition: {
        isSpriteSpecific: true,
        getId: targetId => `${targetId}_xposition`
      },
      motion_yposition: {
        isSpriteSpecific: true,
        getId: targetId => `${targetId}_yposition`
      },
      motion_direction: {
        isSpriteSpecific: true,
        getId: targetId => `${targetId}_direction`
      }
    };
  } // /**  Blockly  vm */
  // colourPicker(args) {
  //   console.log(" Blockly vm:", args);
  // }

  /** KID-JR   */

  /**
   *   
   * @param {*} args  STEPS: "10"
   * @param {*} util
   */


  moveLeft(args, util) {
    console.log(":", args); // args.STEPS

    const steps = Utility.toNumber(args.STEPS); // 

    const radians = Utility.degToRad(-90 - util.target.direction); // 

    const dx = steps * Math.cos(radians) * 10; // 

    const dy = steps * Math.sin(radians) * 10; // /5/ 2020.09.18

    const secs = steps / 5 / Utility.toNumber(args.SECS); //  x
    // util.target.setXY(util.target.x - dx, util.target.y + dy);

    this.glide({
      SECS: secs,
      X: util.target.x + dx,
      Y: util.target.y + dy
    }, util);
  }
  /**
   *   
   * @param {*} args
   * @param {*} util
   */


  moveRight(args, util) {
    const steps = Utility.toNumber(args.STEPS);
    const radians = Utility.degToRad(90 - util.target.direction);
    const dx = steps * Math.cos(radians) * 10;
    const dy = steps * Math.sin(radians) * 10; // /5/ 2020.09.22

    const secs = steps / 5 / Utility.toNumber(args.SECS); // util.target.setXY(util.target.x + dx, util.target.y + dy);

    this.glide({
      SECS: secs,
      X: util.target.x + dx,
      Y: util.target.y + dy
    }, util);
  }
  /**
   *   
   * @param {*} args
   * @param {*} util
   */


  moveUp(args, util) {
    const steps = Utility.toNumber(args.STEPS);
    const radians = Utility.degToRad(180 - util.target.direction);
    const dx = steps * Math.cos(radians) * 10;
    const dy = steps * Math.sin(radians) * 10; // /5/ 2020.09.22

    const secs = steps / 5 / Utility.toNumber(args.SECS);
    this.glide({
      SECS: secs,
      X: util.target.x + dx,
      Y: util.target.y + dy
    }, util);
  }
  /**
   *   
   * @param {*} args
   * @param {*} util
   */


  moveDown(args, util) {
    const steps = Utility.toNumber(args.STEPS);
    const radians = Utility.degToRad(0 - util.target.direction);
    const dx = steps * Math.cos(radians) * 10;
    const dy = steps * Math.sin(radians) * 10; // util.target.setXY(util.target.x + dx, util.target.y + dy);
    // /5/ 2020.09.22

    const secs = steps / 5 / Utility.toNumber(args.SECS);
    this.glide({
      SECS: secs,
      X: util.target.x + dx,
      Y: util.target.y + dy
    }, util);
  }
  /**
   *   
   * @param {*} args
   * @param {*} util
   */


  moveJump(args, util) {
    const steps = Utility.toNumber(args.HEIGHT);
    const radians = Utility.degToRad(0 - util.target.direction);
    const dx = steps * Math.cos(radians) * 10;
    const dy = steps * Math.sin(radians) * 10; // eslint-disable-next-line no-console
    // this.glide({SECS: '1', X: util.target.x + dx, Y: util.target.y + dy}, util);

    const endX = util.target.x + dx;
    const endY = util.target.y + dy; // /5/ 2020.09.22

    const SECS = steps / 5 / Utility.toNumber(args.SECS);

    if (util.stackFrame.timer) {
      const timeElapsed = util.stackFrame.timer.timeElapsed();

      if (timeElapsed < util.stackFrame.duration * 500) {
        // .
        const frac = timeElapsed / (util.stackFrame.duration * 500);
        const tmpdx = frac * (util.stackFrame.endX - util.stackFrame.startX);
        const tmpdy = frac * (util.stackFrame.endY - util.stackFrame.startY);
        util.target.setXY(util.stackFrame.startX - tmpdx, util.stackFrame.startY - tmpdy);
        util.yield();
      } else if (timeElapsed < util.stackFrame.duration * 1000 && timeElapsed > util.stackFrame.duration * 500) {
        const frac1 = (timeElapsed - util.stackFrame.duration * 500) / (util.stackFrame.duration * 500);
        const tmpdx1 = (1 - frac1) * (util.stackFrame.endX - util.stackFrame.startX);
        const tmpdy1 = (1 - frac1) * (util.stackFrame.endY - util.stackFrame.startY);
        util.target.setXY(util.stackFrame.startX - tmpdx1, util.stackFrame.startY - tmpdy1);
        util.yield();
      } else {
        // .
        util.target.setXY(util.stackFrame.startX, util.stackFrame.startY);
      }
    } else {
      // .
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();
      util.stackFrame.duration = Utility.toNumber(SECS);
      util.stackFrame.startX = util.target.x;
      util.stackFrame.startY = util.target.y;
      util.stackFrame.endX = Utility.toNumber(endX);
      util.stackFrame.endY = Utility.toNumber(endY);

      if (util.stackFrame.duration <= 0) {
        // .
        util.target.setXY(util.stackFrame.startX, util.stackFrame.startY);
        return;
      }

      util.yield();
    }
  }
  /**
   *  ,
   * @param {*} args
   * @param {*} util
   */


  moveReset(args, util) {
    util.target.setXY(0, 0); // 0,0

    util.target.setDirection(90); // 
  }
  /** KID-PRO   */


  moveSteps(args, util) {
    console.log("pro:", args, util);
    const steps = Utility.toNumber(args.STEPS);
    const radians = Utility.degToRad(90 - util.target.direction);
    const dx = steps * Math.cos(radians);
    const dy = steps * Math.sin(radians);
    util.target.setXY(util.target.x + dx, util.target.y + dy);
  }

  goToXY(args, util) {
    const x = Utility.toNumber(args.X);
    const y = Utility.toNumber(args.Y);
    util.target.setXY(x, y);
  }

  getTargetXY(targetName, util) {
    let targetX = 0;
    let targetY = 0;

    if (targetName === "_mouse_") {
      targetX = util.ioQuery("mouse", "getScratchX");
      targetY = util.ioQuery("mouse", "getScratchY");
    } else if (targetName === "_random_") {
      const stageWidth = this.runtime.constructor.STAGE_WIDTH;
      const stageHeight = this.runtime.constructor.STAGE_HEIGHT;
      targetX = Math.round(stageWidth * (Math.random() - 0.5));
      targetY = Math.round(stageHeight * (Math.random() - 0.5));
    } else {
      targetName = String(targetName);
      const goToTarget = this.runtime.getSpriteTargetByName(targetName);
      if (!goToTarget) return;
      targetX = goToTarget.x;
      targetY = goToTarget.y;
    }

    return [targetX, targetY];
  }

  goTo(args, util) {
    const targetXY = this.getTargetXY(args.TO, util);

    if (targetXY) {
      util.target.setXY(targetXY[0], targetXY[1]);
    }
  }

  turnRight(args, util) {
    const degrees = Utility.toNumber(args.DEGREES);
    util.target.setDirection(util.target.direction + degrees);
  }

  turnLeft(args, util) {
    const degrees = Utility.toNumber(args.DEGREES);
    util.target.setDirection(util.target.direction - degrees);
  }

  pointInDirection(args, util) {
    console.log("pro:", args, util);
    const direction = Utility.toNumber(args.DIRECTION);
    util.target.setDirection(direction);
  }

  pointTowards(args, util) {
    let targetX = 0;
    let targetY = 0;

    if (args.TOWARDS === "_mouse_") {
      targetX = util.ioQuery("mouse", "getScratchX");
      targetY = util.ioQuery("mouse", "getScratchY");
    } else if (args.TOWARDS === "_random_") {
      util.target.setDirection(Math.round(Math.random() * 360) - 180);
      return;
    } else {
      args.TOWARDS = String(args.TOWARDS);
      const pointTarget = this.runtime.getSpriteTargetByName(args.TOWARDS);
      if (!pointTarget) return;
      targetX = pointTarget.x;
      targetY = pointTarget.y;
    }

    const dx = targetX - util.target.x;
    const dy = targetY - util.target.y;
    const direction = 90 - Utility.radToDeg(Math.atan2(dy, dx));
    util.target.setDirection(direction);
  }

  glide(args, util) {
    if (util.stackFrame.timer) {
      const timeElapsed = util.stackFrame.timer.timeElapsed();

      if (timeElapsed < util.stackFrame.duration * 1000) {
        // In progress: move to intermediate position.
        const frac = timeElapsed / (util.stackFrame.duration * 1000);
        const dx = frac * (util.stackFrame.endX - util.stackFrame.startX);
        const dy = frac * (util.stackFrame.endY - util.stackFrame.startY);
        util.target.setXY(util.stackFrame.startX + dx, util.stackFrame.startY + dy);
        util.yield();
      } else {
        // Finished: move to final position.
        util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
      }
    } else {
      // First time: save data for future use.
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();
      util.stackFrame.duration = Utility.toNumber(args.SECS);
      util.stackFrame.startX = util.target.x;
      util.stackFrame.startY = util.target.y;
      util.stackFrame.endX = Utility.toNumber(args.X);
      util.stackFrame.endY = Utility.toNumber(args.Y);

      if (util.stackFrame.duration <= 0) {
        // Duration too short to glide.
        util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
        return;
      }

      util.yield();
    }
  }

  glideTo(args, util) {
    const targetXY = this.getTargetXY(args.TO, util);

    if (targetXY) {
      this.glide({
        SECS: args.SECS,
        X: targetXY[0],
        Y: targetXY[1]
      }, util);
    }
  }

  ifOnEdgeBounce(args, util) {
    const bounds = util.target.getBounds();

    if (!bounds) {
      return;
    } // Measure distance to edges.
    // Values are positive when the sprite is far away,
    // and clamped to zero when the sprite is beyond.


    const stageWidth = this.runtime.constructor.STAGE_WIDTH;
    const stageHeight = this.runtime.constructor.STAGE_HEIGHT;
    const distLeft = Math.max(0, stageWidth / 2 + bounds.left);
    const distTop = Math.max(0, stageHeight / 2 - bounds.top);
    const distRight = Math.max(0, stageWidth / 2 - bounds.right);
    const distBottom = Math.max(0, stageHeight / 2 + bounds.bottom); // Find the nearest edge.

    let nearestEdge = "";
    let minDist = Infinity;

    if (distLeft < minDist) {
      minDist = distLeft;
      nearestEdge = "left";
    }

    if (distTop < minDist) {
      minDist = distTop;
      nearestEdge = "top";
    }

    if (distRight < minDist) {
      minDist = distRight;
      nearestEdge = "right";
    }

    if (distBottom < minDist) {
      minDist = distBottom;
      nearestEdge = "bottom";
    }

    if (minDist > 0) {
      return; // Not touching any edge.
    } // Point away from the nearest edge.


    const radians = Utility.degToRad(90 - util.target.direction);
    let dx = Math.cos(radians);
    let dy = -Math.sin(radians);

    if (nearestEdge === "left") {
      dx = Math.max(0.2, Math.abs(dx));
    } else if (nearestEdge === "top") {
      dy = Math.max(0.2, Math.abs(dy));
    } else if (nearestEdge === "right") {
      dx = 0 - Math.max(0.2, Math.abs(dx));
    } else if (nearestEdge === "bottom") {
      dy = 0 - Math.max(0.2, Math.abs(dy));
    }

    const newDirection = Utility.radToDeg(Math.atan2(dy, dx)) + 90;
    util.target.setDirection(newDirection); // Keep within the stage.

    const fencedPosition = util.target.keepInFence(util.target.x, util.target.y);
    util.target.setXY(fencedPosition[0], fencedPosition[1]);
  }

  setRotationStyle(args, util) {
    util.target.setRotationStyle(args.STYLE);
  }

  changeX(args, util) {
    const dx = Utility.toNumber(args.DX);
    util.target.setXY(util.target.x + dx, util.target.y);
  }

  setX(args, util) {
    const x = Utility.toNumber(args.X);
    util.target.setXY(x, util.target.y);
  }

  changeY(args, util) {
    const dy = Utility.toNumber(args.DY);
    util.target.setXY(util.target.x, util.target.y + dy);
  }

  setY(args, util) {
    const y = Utility.toNumber(args.Y);
    util.target.setXY(util.target.x, y);
  }

  getX(args, util) {
    console.log("getX args:", args, util);
    return this.limitPrecision(util.target.x);
  }

  getY(args, util) {
    return this.limitPrecision(util.target.y);
  }

  getDirection(args, util) {
    return util.target.direction;
  } // Scratch 2snapToInteger


  limitPrecision(coordinate) {
    const rounded = Math.round(coordinate);
    const delta = coordinate - rounded;
    const limitedCoord = Math.abs(delta) < 1e-9 ? rounded : coordinate;
    return limitedCoord;
  }

}
/** @module  */


class KidOperatorsBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      operator_add: this.add,
      operator_subtract: this.subtract,
      operator_multiply: this.multiply,
      operator_divide: this.divide,
      operator_lt: this.lt,
      operator_equals: this.equals,
      operator_gt: this.gt,
      operator_and: this.and,
      operator_or: this.or,
      operator_not: this.not,
      operator_random: this.random,
      operator_join: this.join,
      operator_letter_of: this.letterOf,
      operator_length: this.length,
      operator_contains: this.contains,
      operator_mod: this.mod,
      operator_round: this.round,
      operator_mathop: this.mathop
    };
  }

  add(args) {
    return Utility.toNumber(args.NUM1) + Utility.toNumber(args.NUM2);
  }

  subtract(args) {
    return Utility.toNumber(args.NUM1) - Utility.toNumber(args.NUM2);
  }

  multiply(args) {
    return Utility.toNumber(args.NUM1) * Utility.toNumber(args.NUM2);
  }

  divide(args) {
    return Utility.toNumber(args.NUM1) / Utility.toNumber(args.NUM2);
  }

  lt(args) {
    return Utility.compare(args.OPERAND1, args.OPERAND2) < 0;
  }

  equals(args) {
    return Utility.compare(args.OPERAND1, args.OPERAND2) === 0;
  }

  gt(args) {
    return Utility.compare(args.OPERAND1, args.OPERAND2) > 0;
  }

  and(args) {
    return Utility.toBoolean(args.OPERAND1) && Utility.toBoolean(args.OPERAND2);
  }

  or(args) {
    return Utility.toBoolean(args.OPERAND1) || Utility.toBoolean(args.OPERAND2);
  }

  not(args) {
    return !Utility.toBoolean(args.OPERAND);
  }

  random(args) {
    const nFrom = Utility.toNumber(args.FROM);
    const nTo = Utility.toNumber(args.TO);
    const low = nFrom <= nTo ? nFrom : nTo;
    const high = nFrom <= nTo ? nTo : nFrom;
    if (low === high) return low; // If both arguments are ints, truncate the result to an int.

    if (Utility.isInt(args.FROM) && Utility.isInt(args.TO)) {
      return low + Math.floor(Math.random() * (high + 1 - low));
    }

    return Math.random() * (high - low) + low;
  }

  join(args) {
    returnString(args.STRING1) + String(args.STRING2);
  }

  letterOf(args) {
    const index = Utility.toNumber(args.LETTER) - 1;
    const str = String(args.STRING); // Out of bounds?

    if (index < 0 || index >= str.length) {
      return "";
    }

    return str.charAt(index);
  }

  length(args) {
    return String(args.STRING).length;
  }

  contains(args) {
    const format = function (string) {
      return String(string).toLowerCase();
    };

    return format(args.STRING1).includes(format(args.STRING2));
  }

  mod(args) {
    const n = Utility.toNumber(args.NUM1);
    const modulus = Utility.toNumber(args.NUM2);
    let result = n % modulus; // Scratch mod uses floored division instead of truncated division.

    if (result / modulus < 0) result += modulus;
    return result;
  }

  round(args) {
    return Math.round(Utility.toNumber(args.NUM));
  }

  mathop(args) {
    const operator = String(args.OPERATOR).toLowerCase();
    const n = Utility.toNumber(args.NUM);

    switch (operator) {
      case "abs":
        return Math.abs(n);

      case "floor":
        return Math.floor(n);

      case "ceiling":
        return Math.ceil(n);

      case "sqrt":
        return Math.sqrt(n);

      case "sin":
        return parseFloat(Math.sin(Math.PI * n / 180).toFixed(10));

      case "cos":
        return parseFloat(Math.cos(Math.PI * n / 180).toFixed(10));

      case "tan":
        return Utility.tan(n);

      case "asin":
        return Math.asin(n) * 180 / Math.PI;

      case "acos":
        return Math.acos(n) * 180 / Math.PI;

      case "atan":
        return Math.atan(n) * 180 / Math.PI;

      case "ln":
        return Math.log(n);

      case "log":
        return Math.log(n) / Math.LN10;

      case "e ^":
        return Math.exp(n);

      case "10 ^":
        return Math.pow(10, n);
    }

    return 0;
  }

}
/**
 * Occluded boolean value to make its use more understandable.
 * @const {boolean}
 */


const STORE_WAITING = true;

class KidSoundBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this.waitingSounds = {}; // Clear sound effects on green flag and stop button events.

    this.stopAllSounds = this.stopAllSounds.bind(this);
    this._stopWaitingSoundsForTarget = this._stopWaitingSoundsForTarget.bind(this);
    this._clearEffectsForAllTargets = this._clearEffectsForAllTargets.bind(this);

    if (this.runtime) {
      this.runtime.on("PROJECT_STOP_ALL", this.stopAllSounds);
      this.runtime.on("PROJECT_STOP_ALL", this._clearEffectsForAllTargets);
      this.runtime.on("STOP_FOR_TARGET", this._stopWaitingSoundsForTarget);
      this.runtime.on("PROJECT_START", this._clearEffectsForAllTargets);
    }

    this._onTargetCreated = this._onTargetCreated.bind(this);

    if (this.runtime) {
      runtime.on("targetWasCreated", this._onTargetCreated);
    }
  }
  /**
   * The key to load & store a target's sound-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.sound";
  }
  /**
   * The default sound-related state, to be used when a target has no existing sound state.
   * @type {SoundState}
   */


  static get DEFAULT_SOUND_STATE() {
    return {
      effects: {
        pitch: 0,
        pan: 0
      }
    };
  }
  /**
   * The minimum and maximum MIDI note numbers, for clamping the input to play note.
   * @type {{min: number, max: number}}
   */


  static get MIDI_NOTE_RANGE() {
    return {
      min: 36,
      max: 96
    }; // C2 to C7
  }
  /**
   * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
   * 100 beats at the default tempo of 60bpm is 100 seconds.
   * @type {{min: number, max: number}}
   */


  static get BEAT_RANGE() {
    return {
      min: 0,
      max: 100
    };
  }
  /** The minimum and maximum tempo values, in bpm.
   * @type {{min: number, max: number}}
   */


  static get TEMPO_RANGE() {
    return {
      min: 20,
      max: 500
    };
  }
  /** The minimum and maximum values for each sound effect.
   * @type {{effect:{min: number, max: number}}}
   */


  static get EFFECT_RANGE() {
    return {
      pitch: {
        min: -360,
        max: 360
      },
      // -3 to 3 octaves
      pan: {
        min: -100,
        max: 100
      } // 100% left to 100% right

    };
  }
  /**
   * @param {Target} target - collect sound state for this target.
   * @returns {SoundState} the mutable sound state associated with that target. This will be created if necessary.
   * @private
   */


  _getSoundState(target) {
    let soundState = target.getCustomState(KidSoundBlocks.STATE_KEY);

    if (!soundState) {
      soundState = Utility.cloneSimple(KidSoundBlocks.DEFAULT_SOUND_STATE);
      target.setCustomState(KidSoundBlocks.STATE_KEY, soundState);
      target.soundEffects = soundState.effects;
    }

    return soundState;
  }
  /**
   * When a Target is cloned, clone the sound state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const soundState = sourceTarget.getCustomState(KidSoundBlocks.STATE_KEY);

      if (soundState && newTarget) {
        newTarget.setCustomState(KidSoundBlocks.STATE_KEY, Utility.cloneSimple(soundState));

        this._syncEffectsForTarget(newTarget);
      }
    }
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      sound_play: this.playSound,
      sound_playuntildone: this.playSoundAndWait,
      sound_stopallsounds: this.stopAllSounds,
      sound_seteffectto: this.setEffect,
      sound_changeeffectby: this.changeEffect,
      sound_cleareffects: this.clearEffects,
      sound_sounds_menu: this.soundsMenu,
      sound_beats_menu: this.beatsMenu,
      sound_effects_menu: this.effectsMenu,
      sound_setvolumeto: this.setVolume,
      sound_changevolumeby: this.changeVolume,
      sound_volume: this.getVolume
    };
  }

  getMonitored() {
    return {
      sound_volume: {
        isSpriteSpecific: true,
        getId: targetId => `${targetId}_volume`
      }
    };
  }

  playSound(args, util) {
    // Don't return the promise, it's the only difference for AndWait
    this._playSound(args, util);
  }

  playSoundAndWait(args, util) {
    return this._playSound(args, util, STORE_WAITING);
  }

  _playSound(args, util, storeWaiting) {
    const index = this._getSoundIndex(args.SOUND_MENU, util);

    if (index >= 0) {
      const {
        target
      } = util;
      const {
        sprite
      } = target;
      const {
        soundId
      } = sprite.sounds[index];

      if (sprite.soundBank) {
        if (storeWaiting === STORE_WAITING) {
          this._addWaitingSound(target.id, soundId);
        } else {
          this._removeWaitingSound(target.id, soundId);
        }

        return sprite.soundBank.playSound(target, soundId);
      }
    }
  }

  _addWaitingSound(targetId, soundId) {
    if (!this.waitingSounds[targetId]) {
      this.waitingSounds[targetId] = new Set();
    }

    this.waitingSounds[targetId].add(soundId);
  }

  _removeWaitingSound(targetId, soundId) {
    if (!this.waitingSounds[targetId]) {
      return;
    }

    this.waitingSounds[targetId].delete(soundId);
  }

  _getSoundIndex(soundName, util) {
    // if the sprite has no sounds, return -1
    const len = util.target.sprite.sounds.length;

    if (len === 0) {
      return -1;
    } // look up by name first


    const index = this.getSoundIndexByName(soundName, util);

    if (index !== -1) {
      return index;
    } // then try using the sound name as a 1-indexed index


    const oneIndexedIndex = parseInt(soundName, 10);

    if (!isNaN(oneIndexedIndex)) {
      return Utility.wrapClamp(oneIndexedIndex - 1, 0, len - 1);
    } // could not be found as a name or converted to index, return -1


    return -1;
  }

  getSoundIndexByName(soundName, util) {
    const sounds = util.target.sprite.sounds;

    for (let i = 0; i < sounds.length; i++) {
      if (sounds[i].name === soundName) {
        return i;
      }
    } // if there is no sound by that name, return -1


    return -1;
  }

  stopAllSounds() {
    if (this.runtime.targets === null) return;
    const allTargets = this.runtime.targets;

    for (let i = 0; i < allTargets.length; i++) {
      this._stopAllSoundsForTarget(allTargets[i]);
    }
  }

  _stopAllSoundsForTarget(target) {
    if (target.sprite.soundBank) {
      target.sprite.soundBank.stopAllSounds(target);

      if (this.waitingSounds[target.id]) {
        this.waitingSounds[target.id].clear();
      }
    }
  }

  _stopWaitingSoundsForTarget(target) {
    if (target.sprite.soundBank) {
      if (this.waitingSounds[target.id]) {
        for (const soundId of this.waitingSounds[target.id].values()) {
          target.sprite.soundBank.stop(target, soundId);
        }

        this.waitingSounds[target.id].clear();
      }
    }
  }

  setEffect(args, util) {
    return this._updateEffect(args, util, false);
  }

  changeEffect(args, util) {
    return this._updateEffect(args, util, true);
  }

  _updateEffect(args, util, change) {
    const effect = String(args.EFFECT).toLowerCase();
    const value = Utility.toNumber(args.VALUE);

    const soundState = this._getSoundState(util.target);

    if (!soundState.effects.hasOwnProperty(effect)) return;

    if (change) {
      soundState.effects[effect] += value;
    } else {
      soundState.effects[effect] = value;
    }

    const {
      min,
      max
    } = KidSoundBlocks.EFFECT_RANGE[effect];
    soundState.effects[effect] = Utility.clamp(soundState.effects[effect], min, max);

    this._syncEffectsForTarget(util.target); // Yield until the next tick.


    return Promise.resolve();
  }

  _syncEffectsForTarget(target) {
    if (!target || !target.sprite.soundBank) return;
    target.soundEffects = this._getSoundState(target).effects;
    target.sprite.soundBank.setEffects(target);
  }

  clearEffects(args, util) {
    this._clearEffectsForTarget(util.target);
  }

  _clearEffectsForTarget(target) {
    const soundState = this._getSoundState(target);

    for (const effect in soundState.effects) {
      if (!soundState.effects.hasOwnProperty(effect)) continue;
      soundState.effects[effect] = 0;
    }

    this._syncEffectsForTarget(target);
  }

  _clearEffectsForAllTargets() {
    if (this.runtime.targets === null) return;
    const allTargets = this.runtime.targets;

    for (let i = 0; i < allTargets.length; i++) {
      this._clearEffectsForTarget(allTargets[i]);
    }
  }

  setVolume(args, util) {
    const volume = Utility.toNumber(args.VOLUME);
    return this._updateVolume(volume, util);
  }

  changeVolume(args, util) {
    const volume = Utility.toNumber(args.VOLUME) + util.target.volume;
    return this._updateVolume(volume, util);
  }

  _updateVolume(volume, util) {
    volume = Utility.clamp(volume, 0, 100);
    util.target.volume = volume;

    this._syncEffectsForTarget(util.target); // Yield until the next tick.


    return Promise.resolve();
  }

  getVolume(args, util) {
    return util.target.volume;
  }

  soundsMenu(args) {
    return args.SOUND_MENU;
  }

  beatsMenu(args) {
    return args.BEATS;
  }

  effectsMenu(args) {
    return args.EFFECT;
  }

}

class KidSensingBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The "answer" block value.
     * @type {string}
     */

    this._answer = "";
    /**
     * The timer utility.
     * @type {Timer}
     */

    this._timer = new Timer();
    /**
     * The stored microphone loudness measurement.
     * @type {number}
     */

    this._cachedLoudness = -1;
    /**
     * The time of the most recent microphone loudness measurement.
     * @type {number}
     */

    this._cachedLoudnessTimestamp = 0;
    /**
     * The list of queued questions and respective `resolve` callbacks.
     * @type {!Array}
     */

    this._questionList = [];
    this.runtime.on("ANSWER", this._onAnswer.bind(this));
    this.runtime.on("PROJECT_START", this._resetAnswer.bind(this));
    this.runtime.on("PROJECT_STOP_ALL", this._clearAllQuestions.bind(this));
    this.runtime.on("STOP_FOR_TARGET", this._clearTargetQuestions.bind(this));
    this.runtime.on("RUNTIME_DISPOSED", this._resetAnswer.bind(this));
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      sensing_touchingobject: this.touchingObject,
      sensing_touchingcolor: this.touchingColor,
      sensing_coloristouchingcolor: this.colorTouchingColor,
      sensing_distanceto: this.distanceTo,
      sensing_timer: this.getTimer,
      sensing_resettimer: this.resetTimer,
      sensing_of: this.getAttributeOf,
      sensing_mousex: this.getMouseX,
      sensing_mousey: this.getMouseY,
      sensing_setdragmode: this.setDragMode,
      sensing_mousedown: this.getMouseDown,
      sensing_keypressed: this.getKeyPressed,
      sensing_current: this.current,
      sensing_dayssince2000: this.daysSince2000,
      sensing_loudness: this.getLoudness,
      sensing_loud: this.isLoud,
      sensing_askandwait: this.askAndWait,
      sensing_answer: this.getAnswer,
      sensing_username: this.getUsername,
      sensing_userid: () => {} // legacy no-op block

    };
  }

  getMonitored() {
    return {
      sensing_answer: {
        getId: () => "answer"
      },
      sensing_loudness: {
        getId: () => "loudness"
      },
      sensing_timer: {
        getId: () => "timer"
      },
      sensing_current: {
        // This is different from the default toolbox xml id in order to support
        // importing multiple monitors from the same opcode from sb2 files,
        // something that is not currently supported in scratch 3.
        getId: (_, fields) => Utility.getMonitorIdForBlockWithArgs("current", fields) // _${param}`

      }
    };
  }

  _onAnswer(answer) {
    this._answer = answer;

    const questionObj = this._questionList.shift();

    if (questionObj) {
      const [_question, resolve, target, wasVisible, wasStage] = questionObj; // If the target was visible when asked, hide the say bubble unless the target was the stage.

      if (wasVisible && !wasStage) {
        this.runtime.emit("SAY", target, "say", "");
      }

      resolve();

      this._askNextQuestion();
    }
  }

  _resetAnswer() {
    this._answer = "";
  }

  _enqueueAsk(question, resolve, target, wasVisible, wasStage) {
    this._questionList.push([question, resolve, target, wasVisible, wasStage]);
  }

  _askNextQuestion() {
    if (this._questionList.length > 0) {
      const [question, _resolve, target, wasVisible, wasStage] = this._questionList[0]; // If the target is visible, emit a blank question and use the
      // say event to trigger a bubble unless the target was the stage.

      if (wasVisible && !wasStage) {
        this.runtime.emit("SAY", target, "say", question);
        this.runtime.emit("QUESTION", "");
      } else {
        this.runtime.emit("QUESTION", question);
      }
    }
  }

  _clearAllQuestions() {
    this._questionList = [];
    this.runtime.emit("QUESTION", null);
  }

  _clearTargetQuestions(stopTarget) {
    const currentlyAsking = this._questionList.length > 0 && this._questionList[0][2] === stopTarget;
    this._questionList = this._questionList.filter(question => question[2] !== stopTarget);

    if (currentlyAsking) {
      this.runtime.emit("SAY", stopTarget, "say", "");

      if (this._questionList.length > 0) {
        this._askNextQuestion();
      } else {
        this.runtime.emit("QUESTION", null);
      }
    }
  }

  askAndWait(args, util) {
    const _target = util.target;
    return new Promise(resolve => {
      const isQuestionAsked = this._questionList.length > 0;

      this._enqueueAsk(String(args.QUESTION), resolve, _target, _target.visible, _target.isStage);

      if (!isQuestionAsked) {
        this._askNextQuestion();
      }
    });
  }

  getAnswer() {
    return this._answer;
  }

  touchingObject(args, util) {
    return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);
  }

  touchingColor(args, util) {
    const color = Utility.toRgbColorList(args.COLOR);
    return util.target.isTouchingColor(color);
  }

  colorTouchingColor(args, util) {
    const maskColor = Utility.toRgbColorList(args.COLOR);
    const targetColor = Utility.toRgbColorList(args.COLOR2);
    return util.target.colorIsTouchingColor(targetColor, maskColor);
  }

  distanceTo(args, util) {
    if (util.target.isStage) return 10000;
    let targetX = 0;
    let targetY = 0;

    if (args.DISTANCETOMENU === "_mouse_") {
      targetX = util.ioQuery("mouse", "getScratchX");
      targetY = util.ioQuery("mouse", "getScratchY");
    } else {
      args.DISTANCETOMENU = String(args.DISTANCETOMENU);
      const distTarget = this.runtime.getSpriteTargetByName(args.DISTANCETOMENU);
      if (!distTarget) return 10000;
      targetX = distTarget.x;
      targetY = distTarget.y;
    }

    const dx = util.target.x - targetX;
    const dy = util.target.y - targetY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  setDragMode(args, util) {
    util.target.setDraggable(args.DRAG_MODE === "draggable");
  }

  getTimer(args, util) {
    return util.ioQuery("clock", "projectTimer");
  }

  resetTimer(args, util) {
    util.ioQuery("clock", "resetProjectTimer");
  }

  getMouseX(args, util) {
    return util.ioQuery("mouse", "getScratchX");
  }

  getMouseY(args, util) {
    return util.ioQuery("mouse", "getScratchY");
  }

  getMouseDown(args, util) {
    return util.ioQuery("mouse", "getIsDown");
  }

  current(args) {
    const menuOption = String(args.CURRENTMENU).toLowerCase();
    const date = new Date();

    switch (menuOption) {
      case "year":
        return date.getFullYear();

      case "month":
        return date.getMonth() + 1;
      // getMonth is zero-based

      case "date":
        return date.getDate();

      case "dayofweek":
        return date.getDay() + 1;
      // getDay is zero-based, Sun=0

      case "hour":
        return date.getHours();

      case "minute":
        return date.getMinutes();

      case "second":
        return date.getSeconds();
    }

    return 0;
  }

  getKeyPressed(args, util) {
    return util.ioQuery("keyboard", "getKeyIsDown", [args.KEY_OPTION]);
  }

  daysSince2000() {
    const msPerDay = 24 * 60 * 60 * 1000;
    const start = new Date(2000, 0, 1); // Months are 0-indexed.

    const today = new Date();
    const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
    let mSecsSinceStart = today.valueOf() - start.valueOf();
    mSecsSinceStart += (today.getTimezoneOffset() - dstAdjust) * 60 * 1000;
    return mSecsSinceStart / msPerDay;
  }

  getLoudness() {
    if (typeof this.runtime.audioEngine === "undefined") return -1;
    if (this.runtime.currentStepTime === null) return -1; // Only measure loudness once per step

    const timeSinceLoudness = this._timer.time() - this._cachedLoudnessTimestamp;

    if (timeSinceLoudness < this.runtime.currentStepTime) {
      return this._cachedLoudness;
    }

    this._cachedLoudnessTimestamp = this._timer.time();
    this._cachedLoudness = this.runtime.audioEngine.getLoudness();
    return this._cachedLoudness;
  }

  isLoud() {
    return this.getLoudness() > 10;
  }

  getAttributeOf(args) {
    let attrTarget;

    if (args.OBJECT === "_stage_") {
      attrTarget = this.runtime.getTargetForStage();
    } else {
      args.OBJECT = String(args.OBJECT);
      attrTarget = this.runtime.getSpriteTargetByName(args.OBJECT);
    } // attrTarget can be undefined if the target does not exist
    // (e.g. single sprite uploaded from larger project referencing
    // another sprite that wasn't uploaded)


    if (!attrTarget) return 0; // Generic attributes

    if (attrTarget.isStage) {
      switch (args.PROPERTY) {
        // Scratch 1.4 support
        case "background #":
          return attrTarget.currentCostume + 1;

        case "backdrop #":
          return attrTarget.currentCostume + 1;

        case "backdrop name":
          return attrTarget.getCostumes()[attrTarget.currentCostume].name;

        case "volume":
          return attrTarget.volume;
      }
    } else {
      switch (args.PROPERTY) {
        case "x position":
          return attrTarget.x;

        case "y position":
          return attrTarget.y;

        case "direction":
          return attrTarget.direction;

        case "costume #":
          return attrTarget.currentCostume + 1;

        case "costume name":
          return attrTarget.getCostumes()[attrTarget.currentCostume].name;

        case "size":
          return attrTarget.size;

        case "volume":
          return attrTarget.volume;
      }
    } // Target variables.


    const varName = args.PROPERTY;
    const variable = attrTarget.lookupVariableByNameAndType(varName, "", true);

    if (variable) {
      return variable.value;
    } // Otherwise, 0


    return 0;
  }

  getUsername(args, util) {
    return util.ioQuery("userData", "getUsername");
  }

}

class KidDataBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      data_variable: this.getVariable,
      data_setvariableto: this.setVariableTo,
      data_changevariableby: this.changeVariableBy,
      data_hidevariable: this.hideVariable,
      data_showvariable: this.showVariable,
      data_listcontents: this.getListContents,
      data_addtolist: this.addToList,
      data_deleteoflist: this.deleteOfList,
      data_deletealloflist: this.deleteAllOfList,
      data_insertatlist: this.insertAtList,
      data_replaceitemoflist: this.replaceItemOfList,
      data_itemoflist: this.getItemOfList,
      data_itemnumoflist: this.getItemNumOfList,
      data_lengthoflist: this.lengthOfList,
      data_listcontainsitem: this.listContainsItem,
      data_hidelist: this.hideList,
      data_showlist: this.showList
    };
  }

  getVariable(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    return variable.value;
  }

  setVariableTo(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    variable.value = args.VALUE;

    if (variable.isCloud) {
      util.ioQuery("cloud", "requestUpdateVariable", [variable.name, args.VALUE]);
    }
  }

  changeVariableBy(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    const castedValue = Utility.toNumber(variable.value);
    const dValue = Utility.toNumber(args.VALUE);
    const newValue = castedValue + dValue;
    variable.value = newValue;

    if (variable.isCloud) {
      util.ioQuery("cloud", "requestUpdateVariable", [variable.name, newValue]);
    }
  }

  changeMonitorVisibility(id, visible) {
    // Send the monitor blocks an event like the flyout checkbox event.
    // This both updates the monitor state and changes the isMonitored block flag.
    this.runtime.monitorBlocks.changeBlock({
      id: id,
      // Monitor blocks for variables are the variable ID.
      element: "checkbox",
      // Mimic checkbox event from flyout.
      value: visible
    }, this.runtime);
  }

  showVariable(args) {
    this.changeMonitorVisibility(args.VARIABLE.id, true);
  }

  hideVariable(args) {
    this.changeMonitorVisibility(args.VARIABLE.id, false);
  }

  showList(args) {
    this.changeMonitorVisibility(args.LIST.id, true);
  }

  hideList(args) {
    this.changeMonitorVisibility(args.LIST.id, false);
  }

  getListContents(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name); // If block is running for monitors, return copy of list as an array if changed.

    if (util.thread.updateMonitor) {
      // Return original list value if up-to-date, which doesn't trigger monitor update.
      if (list._monitorUpToDate) return list.value; // If value changed, reset the flag and return a copy to trigger monitor update.
      // Because monitors use Immutable data structures, only new objects trigger updates.

      list._monitorUpToDate = true;
      return list.value.slice();
    } // Determine if the list is all single letters.
    // If it is, report contents joined together with no separator.
    // If it's not, report contents joined together with a space.


    let allSingleLetters = true;

    for (let i = 0; i < list.value.length; i++) {
      const listItem = list.value[i];

      if (!(typeof listItem === "string" && listItem.length === 1)) {
        allSingleLetters = false;
        break;
      }
    }

    if (allSingleLetters) {
      return list.value.join("");
    }

    return list.value.join(" ");
  }

  addToList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);

    if (list.value.length < KidDataBlocks.LIST_ITEM_LIMIT) {
      list.value.push(args.ITEM);
      list._monitorUpToDate = false;
    }
  }

  deleteOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Utility.toListIndex(args.INDEX, list.value.length, true);

    if (index === Utility.LIST_INVALID) {
      return;
    } else if (index === Utility.LIST_ALL) {
      list.value = [];
      return;
    }

    list.value.splice(index - 1, 1);
    list._monitorUpToDate = false;
  }

  deleteAllOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    list.value = [];
    return;
  }

  insertAtList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Utility.toListIndex(args.INDEX, list.value.length + 1, false);
    if (index === Utility.LIST_INVALID) return;
    const listLimit = KidDataBlocks.LIST_ITEM_LIMIT;
    if (index > listLimit) return;
    list.value.splice(index - 1, 0, item);

    if (list.value.length > listLimit) {
      // If inserting caused the list to grow larger than the limit,
      // remove the last element in the list
      list.value.pop();
    }

    list._monitorUpToDate = false;
  }

  replaceItemOfList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Utility.toListIndex(args.INDEX, list.value.length, false);
    if (index === Utility.LIST_INVALID) return;
    list.value[index - 1] = item;
    list._monitorUpToDate = false;
  }

  getItemOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Utility.toListIndex(args.INDEX, list.value.length, false);
    if (index === Utility.LIST_INVALID) return "";
    return list.value[index - 1];
  }

  getItemNumOfList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name); // Go through the list items one-by-one using Utility.compare. This is for
    // cases like checking if 123 is contained in a list [4, 7, '123'] --
    // Scratch considers 123 and '123' to be equal.

    for (let i = 0; i < list.value.length; i++) {
      if (Utility.compare(list.value[i], item) === 0) {
        return i + 1;
      }
    } // We don't bother using .indexOf() at all, because it would end up with
    // edge cases such as the index of '123' in [4, 7, 123, '123', 9].
    // If we use indexOf(), this block would return 4 instead of 3, because
    // indexOf() sees the first occurence of the string 123 as the fourth
    // item in the list. With Scratch, this would be confusing -- after all,
    // '123' and 123 look the same, so one would expect the block to say
    // that the first occurrence of '123' (or 123) to be the third item.
    // Default to 0 if there's no match. Since Scratch lists are 1-indexed,
    // we don't have to worry about this conflicting with the "this item is
    // the first value" number (in JS that is 0, but in Scratch it's 1).


    return 0;
  }

  lengthOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    return list.value.length;
  }

  listContainsItem(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);

    if (list.value.indexOf(item) >= 0) {
      return true;
    } // Try using Scratch comparison operator on each item.
    // (Scratch considers the string '123' equal to the number 123).


    for (let i = 0; i < list.value.length; i++) {
      if (Utility.compare(list.value[i], item) === 0) {
        return true;
      }
    }

    return false;
  }
  /**
   * Type representation for list variables.
   * @const {number}
   */


  static get LIST_ITEM_LIMIT() {
    return 200000;
  }

}

class KidProcedureBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      procedures_definition: this.definition,
      procedures_call: this.call,
      argument_reporter_string_number: this.argumentReporterStringNumber,
      argument_reporter_boolean: this.argumentReporterBoolean
    };
  }

  definition() {// No-op: execute the blocks.
  }

  call(args, util) {
    if (!util.stackFrame.executed) {
      const procedureCode = args.mutation.proccode;
      const paramNamesIdsAndDefaults = util.getProcedureParamNamesIdsAndDefaults(procedureCode); // If null, procedure could not be found, which can happen if custom
      // block is dragged between sprites without the definition.
      // Match Scratch 2.0 behavior and noop.

      if (paramNamesIdsAndDefaults === null) {
        return;
      }

      const [paramNames, paramIds, paramDefaults] = paramNamesIdsAndDefaults; // Initialize params for the current stackFrame to {}, even if the procedure does
      // not take any arguments. This is so that `getParam` down the line does not look
      // at earlier stack frames for the values of a given parameter (#1729)

      util.initParams();

      for (let i = 0; i < paramIds.length; i++) {
        if (args.hasOwnProperty(paramIds[i])) {
          util.pushParam(paramNames[i], args[paramIds[i]]);
        } else {
          util.pushParam(paramNames[i], paramDefaults[i]);
        }
      }

      util.stackFrame.executed = true;
      util.startProcedure(procedureCode);
    }
  }

  argumentReporterStringNumber(args, util) {
    const value = util.getParam(args.VALUE);

    if (value === null) {
      // When the parameter is not found in the most recent procedure
      // call, the default is always 0.
      return 0;
    }

    return value;
  }

  argumentReporterBoolean(args, util) {
    const value = util.getParam(args.VALUE);

    if (value === null) {
      // When the parameter is not found in the most recent procedure
      // call, the default is always 0.
      return 0;
    }

    return value;
  }

}
/**
 * .
 * @readonly
 * @enum {string}
 */


const ColorParam = {
  COLOR: "color",
  SATURATION: "saturation",
  BRIGHTNESS: "brightness",
  TRANSPARENCY: "transparency"
};
/**
 * @typedef {object} PenState - .
 * @property {Boolean} penDown - .
 * @property {number} color - .
 * @property {PenAttributes} penAttributes -  .
 */

/**
 * Scratch 3.0
 * @param {Runtime} runtime - 
 * @constructor
 */

class KidPenBlocks {
  constructor(runtime) {
    /**
     * 
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * DrawableID.
     * @type {int}
     * @private
     */

    this._penDrawableId = -1;
    /**
     * ID.
     * @type {int}
     * @private
     */

    this._penSkinId = -1;
    this._onTargetCreated = this._onTargetCreated.bind(this);
    this._onTargetMoved = this._onTargetMoved.bind(this);
    runtime.on("targetWasCreated", this._onTargetCreated);
    runtime.on("RUNTIME_DISPOSED", this.penClear.bind(this));
  }
  /**
   * , .
   * @type {PenState}
   */


  static get DEFAULT_PEN_STATE() {
    return {
      penDown: false,
      color: 66.66,
      saturation: 100,
      brightness: 100,
      transparency: 0,
      _shade: 50,
      // 
      penAttributes: {
        color4f: [0, 0, 1, 1],
        diameter: 1
      }
    };
  }
  /**
   * .
   * .
   * @type {{min: number, max: number}}
   */


  static get PEN_SIZE_RANGE() {
    return {
      min: 1,
      max: 1200
    };
  }
  /**
   * .
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.pen";
  }
  /**
   * 
   * @return {object.<string, Function>} .
   */


  getPrimitives() {
    return {
      pen_clear: this.penClear,
      // .
      pen_down: this.penDown,
      // .
      pen_up: this.penUp,
      // .
      pen_setcolorto: this.setPenColorToColor // .

    };
  }
  /**
   * .
   * @param {number} requestedSize - .
   * @returns {number} the clamped size.
   * @private
   */


  _clampPenSize(requestedSize) {
    return Utility.clamp(requestedSize, KidPenBlocks.PEN_SIZE_RANGE.min, KidPenBlocks.PEN_SIZE_RANGE.max);
  }
  /**
   *  SkinID .
   * @returns {int} ID-1.
   * @private
   */


  _getPenLayerID() {
    if (this._penSkinId < 0 && this.runtime.renderer) {
      this._penSkinId = this.runtime.renderer.createPenSkin();
      this._penDrawableId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);
      this.runtime.renderer.updateDrawableProperties(this._penDrawableId, {
        skinId: this._penSkinId
      });
    }

    return this._penSkinId;
  }
  /**
   * @param {Target} target -  .
   * @returns {PenState}  .
   * @private
   */


  _getPenState(target) {
    let penState = target.getCustomState(KidPenBlocks.STATE_KEY);

    if (!penState) {
      penState = Utility.cloneSimple(KidPenBlocks.DEFAULT_PEN_STATE);
      target.setCustomState(KidPenBlocks.STATE_KEY, penState);
    }

    return penState;
  }
  /**
   * .
   * @param {Target} newTarget - .
   * @param {Target} [sourceTarget] - .
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const penState = sourceTarget.getCustomState(KidPenBlocks.STATE_KEY);

      if (penState) {
        newTarget.setCustomState(KidPenBlocks.STATE_KEY, Utility.cloneSimple(penState));

        if (penState.penDown) {
          console.log(":", penState);
          newTarget.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
        }
      }
    }
  }
  /**
   *  .
   * @param {RenderedTarget} target - .
   * @param {number} oldX - X.
   * @param {number} oldY - Y.
   * @param {boolean} isForce - .
   * @private
   */


  _onTargetMoved(target, oldX, oldY, isForce) {
    // .
    if (!isForce) {
      const penSkinId = this._getPenLayerID();

      if (penSkinId >= 0) {
        const penState = this._getPenState(target);

        this.runtime.renderer.penLine(penSkinId, penState.penAttributes, oldX, oldY, target.x, target.y);
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * 0,100.
   * @param {number} value - the value to be wrapped.
   * @returns {number} the wrapped value.
   * @private
   */


  _wrapColor(value) {
    return Utility.wrapClamp(value, 0, 100);
  }
  /**
   * 0,100.
   * @param {number} value - the value to be clamped.
   * @returns {number} the clamped value.
   * @private
   */


  _clampColorParam(value) {
    return Utility.clamp(value, 0, 100);
  }
  /**
   * Alpha.
   * Alpha0101.
   * 01000100.
   * @param {number} alpha - Alpha.
   * @returns {number} .
   * @private
   */


  _alphaToTransparency(alpha) {
    return (1.0 - alpha) * 100.0;
  }
  /**
   * Alpha.
   * Alpha0101.
   * 01000100.
   * @param {number} transparency - .
   * @returns {number} the alpha value.
   * @private
   */


  _transparencyToAlpha(transparency) {
    return 1.0 - transparency / 100.0;
  }
  /**
   *   
   */


  penClear() {
    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penClear(penSkinId);
      this.runtime.requestRedraw();
    }
  }
  /**
   *   
   * "pen down"
   * @param {*} args 
   * @param {*} util 
   */


  penDown(args, util) {
    // console.log("pen_down", "args:", args, "util:", util);
    const target = util.target;

    const penState = this._getPenState(target);

    if (!penState.penDown) {
      penState.penDown = true;
      target.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
    }

    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penPoint(penSkinId, penState.penAttributes, target.x, target.y);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "pen up" block stops the target from leaving pen trails.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  penUp(args, util) {
    // console.log("pen_up", "args:", args, "util:", util);
    const target = util.target;

    const penState = this._getPenState(target);

    if (penState.penDown) {
      penState.penDown = false;
      target.removeListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
    }
  }
  /**
   * The pen "set pen color to {color}" RGB
   * 0.
   * @param {object} args - the block arguments.
   *  @property {int} COLOR - 24RGB0xRRGGBB.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenColorToColor(args, util) {
    const penState = this._getPenState(util.target);

    const rgb = Utility.toRgbColorObject(args.COLOR);
    const hsv = Utility.rgbToHsv(rgb);
    penState.color = hsv.h / 360 * 100;
    penState.saturation = hsv.s * 100;
    penState.brightness = hsv.v * 100;

    if (rgb.hasOwnProperty("a")) {
      penState.transparency = 100 * (1 - rgb.a / 255.0);
    } else {
      penState.transparency = 0;
    } // 2.


    penState._shade = penState.brightness / 2;

    this._updatePenColor(penState);
  }
  /**
   * PenState.
   * @param {PenState} penState - the pen state to update.
   * @private
   */


  _updatePenColor(penState) {
    const rgb = Utility.hsvToRgb({
      h: penState.color * 360 / 100,
      s: penState.saturation / 100,
      v: penState.brightness / 100
    });
    penState.penAttributes.color4f[0] = rgb.r / 255.0;
    penState.penAttributes.color4f[1] = rgb.g / 255.0;
    penState.penAttributes.color4f[2] = rgb.b / 255.0;
    penState.penAttributes.color4f[3] = this._transparencyToAlpha(penState.transparency);
  }
  /**
   * .
   * @param {ColorParam} param - .
   * @param {number} value - .
   * @param {PenState} penState - .
   * @param {boolean} change - truefalsevalue.
   * @private
   */


  _setOrChangeColorParam(param, value, penState, change) {
    switch (param) {
      case ColorParam.COLOR:
        penState.color = this._wrapColor(value + (change ? penState.color : 0));
        break;

      case ColorParam.SATURATION:
        penState.saturation = this._clampColorParam(value + (change ? penState.saturation : 0));
        break;

      case ColorParam.BRIGHTNESS:
        penState.brightness = this._clampColorParam(value + (change ? penState.brightness : 0));
        break;

      case ColorParam.TRANSPARENCY:
        penState.transparency = this._clampColorParam(value + (change ? penState.transparency : 0));
        break;

      default:
        console.warn(`Tried to set or change unknown color parameter: ${param}`);
    }

    this._updatePenColor(penState);
  }
  /**
   * The "change pen {ColorParam} by {number}" block changes one of the pen's color parameters
   * by a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to change the selected parameter by.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenColorParamBy(args, util) {
    const penState = this._getPenState(util.target);

    this._setOrChangeColorParam(args.COLOR_PARAM, Utility.toNumber(args.VALUE), penState, true);
  }
  /**
   * The "set pen {ColorParam} to {number}" block sets one of the pen's color parameters
   * to a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to set the selected parameter to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenColorParamTo(args, util) {
    const penState = this._getPenState(util.target);

    this._setOrChangeColorParam(args.COLOR_PARAM, Utility.toNumber(args.VALUE), penState, false);
  }
  /**
   * The pen "change pen size by {number}" block changes the pen size by the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenSizeBy(args, util) {
    const penAttributes = this._getPenState(util.target).penAttributes;

    penAttributes.diameter = this._clampPenSize(penAttributes.diameter + Utility.toNumber(args.SIZE));
  }
  /**
   * The pen "set pen size to {number}" block sets the pen size to the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenSizeTo(args, util) {
    const penAttributes = this._getPenState(util.target).penAttributes;

    penAttributes.diameter = this._clampPenSize(Utility.toNumber(args.SIZE));
  }
  /* LEGACY OPCODES */

  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount to set the hue to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenHueToNumber(args, util) {
    const penState = this._getPenState(util.target);

    const hueValue = Utility.toNumber(args.HUE);
    const colorValue = hueValue / 2;

    this._setOrChangeColorParam(ColorParam.COLOR, colorValue, penState, false);

    this._setOrChangeColorParam(ColorParam.TRANSPARENCY, 0, penState, false);

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount of desired hue change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenHueBy(args, util) {
    const penState = this._getPenState(util.target);

    const hueChange = Utility.toNumber(args.HUE);
    const colorChange = hueChange / 2;

    this._setOrChangeColorParam(ColorParam.COLOR, colorChange, penState, true);

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Use legacy "set shade" code to calculate RGB value for shade,
   * then convert back to HSV and store those components.
   * It is important to also track the given shade in penState._shade
   * because it cannot be accurately backed out of the new HSV later.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount to set the shade to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenShadeToNumber(args, util) {
    const penState = this._getPenState(util.target);

    let newShade = Utility.toNumber(args.SHADE); // Wrap clamp the new shade value the way scratch 2 did.

    newShade = newShade % 200;
    if (newShade < 0) newShade += 200; // And store the shade that was used to compute this new color for later use.

    penState._shade = newShade;

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Because "shade" cannot be backed out of hsv consistently, use the previously
   * stored penState._shade to make the shade change.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount of desired shade change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenShadeBy(args, util) {
    const penState = this._getPenState(util.target);

    const shadeChange = Utility.toNumber(args.SHADE);
    this.setPenShadeToNumber({
      SHADE: penState._shade + shadeChange
    }, util);
  }
  /**
   * Update the pen state's color from its hue & shade values, Scratch 2.0 style.
   * @param {object} penState - update the HSV & RGB values in this pen state from its hue & shade values.
   * @private
   */


  _legacyUpdatePenColor(penState) {
    // Create the new color in RGB using the scratch 2 "shade" model
    let rgb = Utility.hsvToRgb({
      h: penState.color * 360 / 100,
      s: 1,
      v: 1
    });
    const shade = penState._shade > 100 ? 200 - penState._shade : penState._shade;

    if (shade < 50) {
      rgb = Utility.mixRgb(Utility.RGB_BLACK, rgb, (10 + shade) / 60);
    } else {
      rgb = Utility.mixRgb(rgb, Utility.RGB_WHITE, (shade - 50) / 60);
    } // Update the pen state according to new color


    const hsv = Utility.rgbToHsv(rgb);
    penState.color = 100 * hsv.h / 360;
    penState.saturation = 100 * hsv.s;
    penState.brightness = 100 * hsv.v;

    this._updatePenColor(penState);
  }
  /**
   * The pen "stamp" block stamps the current drawable's image onto the pen layer.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  stamp(args, util) {
    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      const target = util.target;
      this.runtime.renderer.penStamp(penSkinId, target.drawableID);
      this.runtime.requestRedraw();
    }
  }

}

const defaultBlockPackages = {
  /** kid-pro  */
  kid_control: KidControlBlocks,
  kid_event: KidEventBlocks,
  kid_looks: KidLooksBlocks,
  kid_motion: KidMotionBlocks,
  kid_operators: KidOperatorsBlocks,
  kid_sound: KidSoundBlocks,
  kid_sensing: KidSensingBlocks,
  kid_data: KidDataBlocks,
  kid_procedures: KidProcedureBlocks,

  /** kid-jr */
  //    blocks 
  kid_pen: KidPenBlocks //   /**  */
  //   control: require("../blocks/control"),
  //   event: require("../blocks/event"),
  //   looks: require("../blocks/looks"),
  //   motion: require("../blocks/motion"),
  //   operators: require("../blocks/operators"),
  //   sound: require("../blocks/sound"),
  //   sensing: require("../blocks/sensing"),
  //   // data: require("../blocks/data"),
  //   // procedures: require("../blocks/procedures"),

};
module.exports = defaultBlockPackages;

/***/ }),

/***/ 0:
/*!*********************************!*\
  !*** readable-stream (ignored) ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});
//# sourceMappingURL=kid-vm.js.map