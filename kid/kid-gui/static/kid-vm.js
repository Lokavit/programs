(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VirtualMachine"] = factory();
	else
		root["VirtualMachine"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js-exposed");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-loader/lib!./src/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const VirtualMachine = __webpack_require__(/*! ./virtual-machine */ "./src/virtual-machine.js");

module.exports = VirtualMachine;

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/decode-html/index.js":
/*!*******************************************!*\
  !*** ./node_modules/decode-html/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Store markers outside of the function scope,
// not to recreate them on every call
var entities = {
  'amp': '&',
  'apos': '\'',
  'lt': '<',
  'gt': '>',
  'quot': '"',
  'nbsp': '\xa0'
};
var entityPattern = /&([a-z]+);/ig;

module.exports = function decodeHTMLEntities(text) {
  // A single replace pass with a static RegExp is faster than a loop
  return text.replace(entityPattern, function(match, entity) {
    entity = entity.toLowerCase();
    if (entities.hasOwnProperty(entity)) {
      return entities[entity];
    }
    // return original string if there is no matching entity (no replace)
    return match;
  });
};


/***/ }),

/***/ "./node_modules/dom-serializer/foreignNames.json":
/*!*******************************************************!*\
  !*** ./node_modules/dom-serializer/foreignNames.json ***!
  \*******************************************************/
/*! exports provided: elementNames, attributeNames, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"elementNames\":{\"altglyph\":\"altGlyph\",\"altglyphdef\":\"altGlyphDef\",\"altglyphitem\":\"altGlyphItem\",\"animatecolor\":\"animateColor\",\"animatemotion\":\"animateMotion\",\"animatetransform\":\"animateTransform\",\"clippath\":\"clipPath\",\"feblend\":\"feBlend\",\"fecolormatrix\":\"feColorMatrix\",\"fecomponenttransfer\":\"feComponentTransfer\",\"fecomposite\":\"feComposite\",\"feconvolvematrix\":\"feConvolveMatrix\",\"fediffuselighting\":\"feDiffuseLighting\",\"fedisplacementmap\":\"feDisplacementMap\",\"fedistantlight\":\"feDistantLight\",\"fedropshadow\":\"feDropShadow\",\"feflood\":\"feFlood\",\"fefunca\":\"feFuncA\",\"fefuncb\":\"feFuncB\",\"fefuncg\":\"feFuncG\",\"fefuncr\":\"feFuncR\",\"fegaussianblur\":\"feGaussianBlur\",\"feimage\":\"feImage\",\"femerge\":\"feMerge\",\"femergenode\":\"feMergeNode\",\"femorphology\":\"feMorphology\",\"feoffset\":\"feOffset\",\"fepointlight\":\"fePointLight\",\"fespecularlighting\":\"feSpecularLighting\",\"fespotlight\":\"feSpotLight\",\"fetile\":\"feTile\",\"feturbulence\":\"feTurbulence\",\"foreignobject\":\"foreignObject\",\"glyphref\":\"glyphRef\",\"lineargradient\":\"linearGradient\",\"radialgradient\":\"radialGradient\",\"textpath\":\"textPath\"},\"attributeNames\":{\"definitionurl\":\"definitionURL\",\"attributename\":\"attributeName\",\"attributetype\":\"attributeType\",\"basefrequency\":\"baseFrequency\",\"baseprofile\":\"baseProfile\",\"calcmode\":\"calcMode\",\"clippathunits\":\"clipPathUnits\",\"diffuseconstant\":\"diffuseConstant\",\"edgemode\":\"edgeMode\",\"filterunits\":\"filterUnits\",\"glyphref\":\"glyphRef\",\"gradienttransform\":\"gradientTransform\",\"gradientunits\":\"gradientUnits\",\"kernelmatrix\":\"kernelMatrix\",\"kernelunitlength\":\"kernelUnitLength\",\"keypoints\":\"keyPoints\",\"keysplines\":\"keySplines\",\"keytimes\":\"keyTimes\",\"lengthadjust\":\"lengthAdjust\",\"limitingconeangle\":\"limitingConeAngle\",\"markerheight\":\"markerHeight\",\"markerunits\":\"markerUnits\",\"markerwidth\":\"markerWidth\",\"maskcontentunits\":\"maskContentUnits\",\"maskunits\":\"maskUnits\",\"numoctaves\":\"numOctaves\",\"pathlength\":\"pathLength\",\"patterncontentunits\":\"patternContentUnits\",\"patterntransform\":\"patternTransform\",\"patternunits\":\"patternUnits\",\"pointsatx\":\"pointsAtX\",\"pointsaty\":\"pointsAtY\",\"pointsatz\":\"pointsAtZ\",\"preservealpha\":\"preserveAlpha\",\"preserveaspectratio\":\"preserveAspectRatio\",\"primitiveunits\":\"primitiveUnits\",\"refx\":\"refX\",\"refy\":\"refY\",\"repeatcount\":\"repeatCount\",\"repeatdur\":\"repeatDur\",\"requiredextensions\":\"requiredExtensions\",\"requiredfeatures\":\"requiredFeatures\",\"specularconstant\":\"specularConstant\",\"specularexponent\":\"specularExponent\",\"spreadmethod\":\"spreadMethod\",\"startoffset\":\"startOffset\",\"stddeviation\":\"stdDeviation\",\"stitchtiles\":\"stitchTiles\",\"surfacescale\":\"surfaceScale\",\"systemlanguage\":\"systemLanguage\",\"tablevalues\":\"tableValues\",\"targetx\":\"targetX\",\"targety\":\"targetY\",\"textlength\":\"textLength\",\"viewbox\":\"viewBox\",\"viewtarget\":\"viewTarget\",\"xchannelselector\":\"xChannelSelector\",\"ychannelselector\":\"yChannelSelector\",\"zoomandpan\":\"zoomAndPan\"}}");

/***/ }),

/***/ "./node_modules/dom-serializer/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dom-serializer/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
  Module dependencies
*/
var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/dom-serializer/node_modules/domelementtype/lib/index.js");
var entities = __webpack_require__(/*! entities */ "./node_modules/dom-serializer/node_modules/entities/lib/index.js");

/* mixed-case SVG and MathML tags & attributes
   recognized by the HTML parser, see
   https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
*/
var foreignNames = __webpack_require__(/*! ./foreignNames.json */ "./node_modules/dom-serializer/foreignNames.json");
foreignNames.elementNames.__proto__ = null; /* use as a simple dictionary */
foreignNames.attributeNames.__proto__ = null;

var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function formatAttrs(attributes, opts) {
  if (!attributes) return;

  var output = '';
  var value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }

    if (opts.xmlMode === 'foreign') {
      /* fix up mixed-case attribute names */
      key = foreignNames.attributeNames[key] || key;
    }
    output += key;
    if ((value !== null && value !== '') || opts.xmlMode) {
      output +=
        '="' +
        (opts.decodeEntities
          ? entities.encodeXML(value)
          : value.replace(/\"/g, '&quot;')) +
        '"';
    }
  }

  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

var render = (module.exports = function(dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};

  var output = '';

  for (var i = 0; i < dom.length; i++) {
    var elem = dom[i];

    if (elem.type === 'root') output += render(elem.children, opts);
    else if (ElementType.isTag(elem)) output += renderTag(elem, opts);
    else if (elem.type === ElementType.Directive)
      output += renderDirective(elem);
    else if (elem.type === ElementType.Comment) output += renderComment(elem);
    else if (elem.type === ElementType.CDATA) output += renderCdata(elem);
    else output += renderText(elem, opts);
  }

  return output;
});

var foreignModeIntegrationPoints = [
  'mi',
  'mo',
  'mn',
  'ms',
  'mtext',
  'annotation-xml',
  'foreignObject',
  'desc',
  'title'
];

function renderTag(elem, opts) {
  // Handle SVG / MathML in HTML
  if (opts.xmlMode === 'foreign') {
    /* fix up mixed-case element names */
    elem.name = foreignNames.elementNames[elem.name] || elem.name;
    /* exit foreign mode at integration points */
    if (
      elem.parent &&
      foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0
    )
      opts = Object.assign({}, opts, { xmlMode: false });
  }
  if (!opts.xmlMode && ['svg', 'math'].indexOf(elem.name) >= 0) {
    opts = Object.assign({}, opts, { xmlMode: 'foreign' });
  }

  var tag = '<' + elem.name;
  var attribs = formatAttrs(elem.attribs, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += render(elem.children, opts);
    }

    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag;
}

function renderDirective(elem) {
  return '<' + elem.data + '>';
}

function renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (
    opts.decodeEntities &&
    !(elem.parent && elem.parent.name in unencodedElements)
  ) {
    data = entities.encodeXML(data);
  }

  return data;
}

function renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}

function renderComment(elem) {
  return '<!--' + elem.data + '-->';
}


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/domelementtype/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/domelementtype/lib/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.isTag = void 0;
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === "tag" /* Tag */ ||
        elem.type === "script" /* Script */ ||
        elem.type === "style" /* Style */);
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for Text */
exports.Text = "text" /* Text */;
/** Type for <? ... ?> */
exports.Directive = "directive" /* Directive */;
/** Type for <!-- ... --> */
exports.Comment = "comment" /* Comment */;
/** Type for <script> tags */
exports.Script = "script" /* Script */;
/** Type for <style> tags */
exports.Style = "style" /* Style */;
/** Type for Any tag */
exports.Tag = "tag" /* Tag */;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = "cdata" /* CDATA */;
/** Type for <!doctype ...> */
exports.Doctype = "doctype" /* Doctype */;


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/decode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/decode.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
var entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json"));
var legacy_json_1 = __importDefault(__webpack_require__(/*! ./maps/legacy.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json"));
var xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json"));
var decode_codepoint_1 = __importDefault(__webpack_require__(/*! ./decode_codepoint */ "./node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js"));
exports.decodeXML = getStrictDecoder(xml_json_1.default);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
function getStrictDecoder(map) {
    var keys = Object.keys(map).join("|");
    var replace = getReplacer(map);
    keys += "|#[xX][\\da-fA-F]+|#\\d+";
    var re = new RegExp("&(?:" + keys + ");", "g");
    return function (str) { return String(str).replace(re, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
exports.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        return map[str.slice(1, -1)];
    };
}


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var decode_json_1 = __importDefault(__webpack_require__(/*! ./maps/decode.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json"));
// Modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    var output = "";
    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }
    output += String.fromCharCode(codePoint);
    return output;
}
exports.default = decodeCodePoint;


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/encode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/encode.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.escape = exports.encodeHTML = exports.encodeXML = void 0;
var xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json"));
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
exports.encodeXML = getInverse(inverseXML, xmlReplacer);
var entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json"));
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
function singleCharReplacer(c) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return "&#x" + c.codePointAt(0).toString(16).toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reXmlChars = getInverseReplacer(inverseXML);
function escape(data) {
    return data
        .replace(reXmlChars, singleCharReplacer)
        .replace(reNonASCII, singleCharReplacer);
}
exports.escape = escape;


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escape = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = __webpack_require__(/*! ./decode */ "./node_modules/dom-serializer/node_modules/entities/lib/decode.js");
var encode_1 = __webpack_require__(/*! ./encode */ "./node_modules/dom-serializer/node_modules/entities/lib/encode.js");
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */
function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 */
function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = __webpack_require__(/*! ./encode */ "./node_modules/dom-serializer/node_modules/entities/lib/encode.js");
Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
// Legacy aliases
Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
var decode_2 = __webpack_require__(/*! ./decode */ "./node_modules/dom-serializer/node_modules/entities/lib/decode.js");
Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
// Legacy aliases
Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } });


/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json":
/*!********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json ***!
  \********************************************************************************/
/*! exports provided: 0, 128, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 142, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 158, 159, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"0\":65533,\"128\":8364,\"130\":8218,\"131\":402,\"132\":8222,\"133\":8230,\"134\":8224,\"135\":8225,\"136\":710,\"137\":8240,\"138\":352,\"139\":8249,\"140\":338,\"142\":381,\"145\":8216,\"146\":8217,\"147\":8220,\"148\":8221,\"149\":8226,\"150\":8211,\"151\":8212,\"152\":732,\"153\":8482,\"154\":353,\"155\":8250,\"156\":339,\"158\":382,\"159\":376}");

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json":
/*!**********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json ***!
  \**********************************************************************************/
/*! exports provided: Aacute, aacute, Abreve, abreve, ac, acd, acE, Acirc, acirc, acute, Acy, acy, AElig, aelig, af, Afr, afr, Agrave, agrave, alefsym, aleph, Alpha, alpha, Amacr, amacr, amalg, amp, AMP, andand, And, and, andd, andslope, andv, ang, ange, angle, angmsdaa, angmsdab, angmsdac, angmsdad, angmsdae, angmsdaf, angmsdag, angmsdah, angmsd, angrt, angrtvb, angrtvbd, angsph, angst, angzarr, Aogon, aogon, Aopf, aopf, apacir, ap, apE, ape, apid, apos, ApplyFunction, approx, approxeq, Aring, aring, Ascr, ascr, Assign, ast, asymp, asympeq, Atilde, atilde, Auml, auml, awconint, awint, backcong, backepsilon, backprime, backsim, backsimeq, Backslash, Barv, barvee, barwed, Barwed, barwedge, bbrk, bbrktbrk, bcong, Bcy, bcy, bdquo, becaus, because, Because, bemptyv, bepsi, bernou, Bernoullis, Beta, beta, beth, between, Bfr, bfr, bigcap, bigcirc, bigcup, bigodot, bigoplus, bigotimes, bigsqcup, bigstar, bigtriangledown, bigtriangleup, biguplus, bigvee, bigwedge, bkarow, blacklozenge, blacksquare, blacktriangle, blacktriangledown, blacktriangleleft, blacktriangleright, blank, blk12, blk14, blk34, block, bne, bnequiv, bNot, bnot, Bopf, bopf, bot, bottom, bowtie, boxbox, boxdl, boxdL, boxDl, boxDL, boxdr, boxdR, boxDr, boxDR, boxh, boxH, boxhd, boxHd, boxhD, boxHD, boxhu, boxHu, boxhU, boxHU, boxminus, boxplus, boxtimes, boxul, boxuL, boxUl, boxUL, boxur, boxuR, boxUr, boxUR, boxv, boxV, boxvh, boxvH, boxVh, boxVH, boxvl, boxvL, boxVl, boxVL, boxvr, boxvR, boxVr, boxVR, bprime, breve, Breve, brvbar, bscr, Bscr, bsemi, bsim, bsime, bsolb, bsol, bsolhsub, bull, bullet, bump, bumpE, bumpe, Bumpeq, bumpeq, Cacute, cacute, capand, capbrcup, capcap, cap, Cap, capcup, capdot, CapitalDifferentialD, caps, caret, caron, Cayleys, ccaps, Ccaron, ccaron, Ccedil, ccedil, Ccirc, ccirc, Cconint, ccups, ccupssm, Cdot, cdot, cedil, Cedilla, cemptyv, cent, centerdot, CenterDot, cfr, Cfr, CHcy, chcy, check, checkmark, Chi, chi, circ, circeq, circlearrowleft, circlearrowright, circledast, circledcirc, circleddash, CircleDot, circledR, circledS, CircleMinus, CirclePlus, CircleTimes, cir, cirE, cire, cirfnint, cirmid, cirscir, ClockwiseContourIntegral, CloseCurlyDoubleQuote, CloseCurlyQuote, clubs, clubsuit, colon, Colon, Colone, colone, coloneq, comma, commat, comp, compfn, complement, complexes, cong, congdot, Congruent, conint, Conint, ContourIntegral, copf, Copf, coprod, Coproduct, copy, COPY, copysr, CounterClockwiseContourIntegral, crarr, cross, Cross, Cscr, cscr, csub, csube, csup, csupe, ctdot, cudarrl, cudarrr, cuepr, cuesc, cularr, cularrp, cupbrcap, cupcap, CupCap, cup, Cup, cupcup, cupdot, cupor, cups, curarr, curarrm, curlyeqprec, curlyeqsucc, curlyvee, curlywedge, curren, curvearrowleft, curvearrowright, cuvee, cuwed, cwconint, cwint, cylcty, dagger, Dagger, daleth, darr, Darr, dArr, dash, Dashv, dashv, dbkarow, dblac, Dcaron, dcaron, Dcy, dcy, ddagger, ddarr, DD, dd, DDotrahd, ddotseq, deg, Del, Delta, delta, demptyv, dfisht, Dfr, dfr, dHar, dharl, dharr, DiacriticalAcute, DiacriticalDot, DiacriticalDoubleAcute, DiacriticalGrave, DiacriticalTilde, diam, diamond, Diamond, diamondsuit, diams, die, DifferentialD, digamma, disin, div, divide, divideontimes, divonx, DJcy, djcy, dlcorn, dlcrop, dollar, Dopf, dopf, Dot, dot, DotDot, doteq, doteqdot, DotEqual, dotminus, dotplus, dotsquare, doublebarwedge, DoubleContourIntegral, DoubleDot, DoubleDownArrow, DoubleLeftArrow, DoubleLeftRightArrow, DoubleLeftTee, DoubleLongLeftArrow, DoubleLongLeftRightArrow, DoubleLongRightArrow, DoubleRightArrow, DoubleRightTee, DoubleUpArrow, DoubleUpDownArrow, DoubleVerticalBar, DownArrowBar, downarrow, DownArrow, Downarrow, DownArrowUpArrow, DownBreve, downdownarrows, downharpoonleft, downharpoonright, DownLeftRightVector, DownLeftTeeVector, DownLeftVectorBar, DownLeftVector, DownRightTeeVector, DownRightVectorBar, DownRightVector, DownTeeArrow, DownTee, drbkarow, drcorn, drcrop, Dscr, dscr, DScy, dscy, dsol, Dstrok, dstrok, dtdot, dtri, dtrif, duarr, duhar, dwangle, DZcy, dzcy, dzigrarr, Eacute, eacute, easter, Ecaron, ecaron, Ecirc, ecirc, ecir, ecolon, Ecy, ecy, eDDot, Edot, edot, eDot, ee, efDot, Efr, efr, eg, Egrave, egrave, egs, egsdot, el, Element, elinters, ell, els, elsdot, Emacr, emacr, empty, emptyset, EmptySmallSquare, emptyv, EmptyVerySmallSquare, emsp13, emsp14, emsp, ENG, eng, ensp, Eogon, eogon, Eopf, eopf, epar, eparsl, eplus, epsi, Epsilon, epsilon, epsiv, eqcirc, eqcolon, eqsim, eqslantgtr, eqslantless, Equal, equals, EqualTilde, equest, Equilibrium, equiv, equivDD, eqvparsl, erarr, erDot, escr, Escr, esdot, Esim, esim, Eta, eta, ETH, eth, Euml, euml, euro, excl, exist, Exists, expectation, exponentiale, ExponentialE, fallingdotseq, Fcy, fcy, female, ffilig, fflig, ffllig, Ffr, ffr, filig, FilledSmallSquare, FilledVerySmallSquare, fjlig, flat, fllig, fltns, fnof, Fopf, fopf, forall, ForAll, fork, forkv, Fouriertrf, fpartint, frac12, frac13, frac14, frac15, frac16, frac18, frac23, frac25, frac34, frac35, frac38, frac45, frac56, frac58, frac78, frasl, frown, fscr, Fscr, gacute, Gamma, gamma, Gammad, gammad, gap, Gbreve, gbreve, Gcedil, Gcirc, gcirc, Gcy, gcy, Gdot, gdot, ge, gE, gEl, gel, geq, geqq, geqslant, gescc, ges, gesdot, gesdoto, gesdotol, gesl, gesles, Gfr, gfr, gg, Gg, ggg, gimel, GJcy, gjcy, gla, gl, glE, glj, gnap, gnapprox, gne, gnE, gneq, gneqq, gnsim, Gopf, gopf, grave, GreaterEqual, GreaterEqualLess, GreaterFullEqual, GreaterGreater, GreaterLess, GreaterSlantEqual, GreaterTilde, Gscr, gscr, gsim, gsime, gsiml, gtcc, gtcir, gt, GT, Gt, gtdot, gtlPar, gtquest, gtrapprox, gtrarr, gtrdot, gtreqless, gtreqqless, gtrless, gtrsim, gvertneqq, gvnE, Hacek, hairsp, half, hamilt, HARDcy, hardcy, harrcir, harr, hArr, harrw, Hat, hbar, Hcirc, hcirc, hearts, heartsuit, hellip, hercon, hfr, Hfr, HilbertSpace, hksearow, hkswarow, hoarr, homtht, hookleftarrow, hookrightarrow, hopf, Hopf, horbar, HorizontalLine, hscr, Hscr, hslash, Hstrok, hstrok, HumpDownHump, HumpEqual, hybull, hyphen, Iacute, iacute, ic, Icirc, icirc, Icy, icy, Idot, IEcy, iecy, iexcl, iff, ifr, Ifr, Igrave, igrave, ii, iiiint, iiint, iinfin, iiota, IJlig, ijlig, Imacr, imacr, image, ImaginaryI, imagline, imagpart, imath, Im, imof, imped, Implies, incare, in, infin, infintie, inodot, intcal, int, Int, integers, Integral, intercal, Intersection, intlarhk, intprod, InvisibleComma, InvisibleTimes, IOcy, iocy, Iogon, iogon, Iopf, iopf, Iota, iota, iprod, iquest, iscr, Iscr, isin, isindot, isinE, isins, isinsv, isinv, it, Itilde, itilde, Iukcy, iukcy, Iuml, iuml, Jcirc, jcirc, Jcy, jcy, Jfr, jfr, jmath, Jopf, jopf, Jscr, jscr, Jsercy, jsercy, Jukcy, jukcy, Kappa, kappa, kappav, Kcedil, kcedil, Kcy, kcy, Kfr, kfr, kgreen, KHcy, khcy, KJcy, kjcy, Kopf, kopf, Kscr, kscr, lAarr, Lacute, lacute, laemptyv, lagran, Lambda, lambda, lang, Lang, langd, langle, lap, Laplacetrf, laquo, larrb, larrbfs, larr, Larr, lArr, larrfs, larrhk, larrlp, larrpl, larrsim, larrtl, latail, lAtail, lat, late, lates, lbarr, lBarr, lbbrk, lbrace, lbrack, lbrke, lbrksld, lbrkslu, Lcaron, lcaron, Lcedil, lcedil, lceil, lcub, Lcy, lcy, ldca, ldquo, ldquor, ldrdhar, ldrushar, ldsh, le, lE, LeftAngleBracket, LeftArrowBar, leftarrow, LeftArrow, Leftarrow, LeftArrowRightArrow, leftarrowtail, LeftCeiling, LeftDoubleBracket, LeftDownTeeVector, LeftDownVectorBar, LeftDownVector, LeftFloor, leftharpoondown, leftharpoonup, leftleftarrows, leftrightarrow, LeftRightArrow, Leftrightarrow, leftrightarrows, leftrightharpoons, leftrightsquigarrow, LeftRightVector, LeftTeeArrow, LeftTee, LeftTeeVector, leftthreetimes, LeftTriangleBar, LeftTriangle, LeftTriangleEqual, LeftUpDownVector, LeftUpTeeVector, LeftUpVectorBar, LeftUpVector, LeftVectorBar, LeftVector, lEg, leg, leq, leqq, leqslant, lescc, les, lesdot, lesdoto, lesdotor, lesg, lesges, lessapprox, lessdot, lesseqgtr, lesseqqgtr, LessEqualGreater, LessFullEqual, LessGreater, lessgtr, LessLess, lesssim, LessSlantEqual, LessTilde, lfisht, lfloor, Lfr, lfr, lg, lgE, lHar, lhard, lharu, lharul, lhblk, LJcy, ljcy, llarr, ll, Ll, llcorner, Lleftarrow, llhard, lltri, Lmidot, lmidot, lmoustache, lmoust, lnap, lnapprox, lne, lnE, lneq, lneqq, lnsim, loang, loarr, lobrk, longleftarrow, LongLeftArrow, Longleftarrow, longleftrightarrow, LongLeftRightArrow, Longleftrightarrow, longmapsto, longrightarrow, LongRightArrow, Longrightarrow, looparrowleft, looparrowright, lopar, Lopf, lopf, loplus, lotimes, lowast, lowbar, LowerLeftArrow, LowerRightArrow, loz, lozenge, lozf, lpar, lparlt, lrarr, lrcorner, lrhar, lrhard, lrm, lrtri, lsaquo, lscr, Lscr, lsh, Lsh, lsim, lsime, lsimg, lsqb, lsquo, lsquor, Lstrok, lstrok, ltcc, ltcir, lt, LT, Lt, ltdot, lthree, ltimes, ltlarr, ltquest, ltri, ltrie, ltrif, ltrPar, lurdshar, luruhar, lvertneqq, lvnE, macr, male, malt, maltese, Map, map, mapsto, mapstodown, mapstoleft, mapstoup, marker, mcomma, Mcy, mcy, mdash, mDDot, measuredangle, MediumSpace, Mellintrf, Mfr, mfr, mho, micro, midast, midcir, mid, middot, minusb, minus, minusd, minusdu, MinusPlus, mlcp, mldr, mnplus, models, Mopf, mopf, mp, mscr, Mscr, mstpos, Mu, mu, multimap, mumap, nabla, Nacute, nacute, nang, nap, napE, napid, napos, napprox, natural, naturals, natur, nbsp, nbump, nbumpe, ncap, Ncaron, ncaron, Ncedil, ncedil, ncong, ncongdot, ncup, Ncy, ncy, ndash, nearhk, nearr, neArr, nearrow, ne, nedot, NegativeMediumSpace, NegativeThickSpace, NegativeThinSpace, NegativeVeryThinSpace, nequiv, nesear, nesim, NestedGreaterGreater, NestedLessLess, NewLine, nexist, nexists, Nfr, nfr, ngE, nge, ngeq, ngeqq, ngeqslant, nges, nGg, ngsim, nGt, ngt, ngtr, nGtv, nharr, nhArr, nhpar, ni, nis, nisd, niv, NJcy, njcy, nlarr, nlArr, nldr, nlE, nle, nleftarrow, nLeftarrow, nleftrightarrow, nLeftrightarrow, nleq, nleqq, nleqslant, nles, nless, nLl, nlsim, nLt, nlt, nltri, nltrie, nLtv, nmid, NoBreak, NonBreakingSpace, nopf, Nopf, Not, not, NotCongruent, NotCupCap, NotDoubleVerticalBar, NotElement, NotEqual, NotEqualTilde, NotExists, NotGreater, NotGreaterEqual, NotGreaterFullEqual, NotGreaterGreater, NotGreaterLess, NotGreaterSlantEqual, NotGreaterTilde, NotHumpDownHump, NotHumpEqual, notin, notindot, notinE, notinva, notinvb, notinvc, NotLeftTriangleBar, NotLeftTriangle, NotLeftTriangleEqual, NotLess, NotLessEqual, NotLessGreater, NotLessLess, NotLessSlantEqual, NotLessTilde, NotNestedGreaterGreater, NotNestedLessLess, notni, notniva, notnivb, notnivc, NotPrecedes, NotPrecedesEqual, NotPrecedesSlantEqual, NotReverseElement, NotRightTriangleBar, NotRightTriangle, NotRightTriangleEqual, NotSquareSubset, NotSquareSubsetEqual, NotSquareSuperset, NotSquareSupersetEqual, NotSubset, NotSubsetEqual, NotSucceeds, NotSucceedsEqual, NotSucceedsSlantEqual, NotSucceedsTilde, NotSuperset, NotSupersetEqual, NotTilde, NotTildeEqual, NotTildeFullEqual, NotTildeTilde, NotVerticalBar, nparallel, npar, nparsl, npart, npolint, npr, nprcue, nprec, npreceq, npre, nrarrc, nrarr, nrArr, nrarrw, nrightarrow, nRightarrow, nrtri, nrtrie, nsc, nsccue, nsce, Nscr, nscr, nshortmid, nshortparallel, nsim, nsime, nsimeq, nsmid, nspar, nsqsube, nsqsupe, nsub, nsubE, nsube, nsubset, nsubseteq, nsubseteqq, nsucc, nsucceq, nsup, nsupE, nsupe, nsupset, nsupseteq, nsupseteqq, ntgl, Ntilde, ntilde, ntlg, ntriangleleft, ntrianglelefteq, ntriangleright, ntrianglerighteq, Nu, nu, num, numero, numsp, nvap, nvdash, nvDash, nVdash, nVDash, nvge, nvgt, nvHarr, nvinfin, nvlArr, nvle, nvlt, nvltrie, nvrArr, nvrtrie, nvsim, nwarhk, nwarr, nwArr, nwarrow, nwnear, Oacute, oacute, oast, Ocirc, ocirc, ocir, Ocy, ocy, odash, Odblac, odblac, odiv, odot, odsold, OElig, oelig, ofcir, Ofr, ofr, ogon, Ograve, ograve, ogt, ohbar, ohm, oint, olarr, olcir, olcross, oline, olt, Omacr, omacr, Omega, omega, Omicron, omicron, omid, ominus, Oopf, oopf, opar, OpenCurlyDoubleQuote, OpenCurlyQuote, operp, oplus, orarr, Or, or, ord, order, orderof, ordf, ordm, origof, oror, orslope, orv, oS, Oscr, oscr, Oslash, oslash, osol, Otilde, otilde, otimesas, Otimes, otimes, Ouml, ouml, ovbar, OverBar, OverBrace, OverBracket, OverParenthesis, para, parallel, par, parsim, parsl, part, PartialD, Pcy, pcy, percnt, period, permil, perp, pertenk, Pfr, pfr, Phi, phi, phiv, phmmat, phone, Pi, pi, pitchfork, piv, planck, planckh, plankv, plusacir, plusb, pluscir, plus, plusdo, plusdu, pluse, PlusMinus, plusmn, plussim, plustwo, pm, Poincareplane, pointint, popf, Popf, pound, prap, Pr, pr, prcue, precapprox, prec, preccurlyeq, Precedes, PrecedesEqual, PrecedesSlantEqual, PrecedesTilde, preceq, precnapprox, precneqq, precnsim, pre, prE, precsim, prime, Prime, primes, prnap, prnE, prnsim, prod, Product, profalar, profline, profsurf, prop, Proportional, Proportion, propto, prsim, prurel, Pscr, pscr, Psi, psi, puncsp, Qfr, qfr, qint, qopf, Qopf, qprime, Qscr, qscr, quaternions, quatint, quest, questeq, quot, QUOT, rAarr, race, Racute, racute, radic, raemptyv, rang, Rang, rangd, range, rangle, raquo, rarrap, rarrb, rarrbfs, rarrc, rarr, Rarr, rArr, rarrfs, rarrhk, rarrlp, rarrpl, rarrsim, Rarrtl, rarrtl, rarrw, ratail, rAtail, ratio, rationals, rbarr, rBarr, RBarr, rbbrk, rbrace, rbrack, rbrke, rbrksld, rbrkslu, Rcaron, rcaron, Rcedil, rcedil, rceil, rcub, Rcy, rcy, rdca, rdldhar, rdquo, rdquor, rdsh, real, realine, realpart, reals, Re, rect, reg, REG, ReverseElement, ReverseEquilibrium, ReverseUpEquilibrium, rfisht, rfloor, rfr, Rfr, rHar, rhard, rharu, rharul, Rho, rho, rhov, RightAngleBracket, RightArrowBar, rightarrow, RightArrow, Rightarrow, RightArrowLeftArrow, rightarrowtail, RightCeiling, RightDoubleBracket, RightDownTeeVector, RightDownVectorBar, RightDownVector, RightFloor, rightharpoondown, rightharpoonup, rightleftarrows, rightleftharpoons, rightrightarrows, rightsquigarrow, RightTeeArrow, RightTee, RightTeeVector, rightthreetimes, RightTriangleBar, RightTriangle, RightTriangleEqual, RightUpDownVector, RightUpTeeVector, RightUpVectorBar, RightUpVector, RightVectorBar, RightVector, ring, risingdotseq, rlarr, rlhar, rlm, rmoustache, rmoust, rnmid, roang, roarr, robrk, ropar, ropf, Ropf, roplus, rotimes, RoundImplies, rpar, rpargt, rppolint, rrarr, Rrightarrow, rsaquo, rscr, Rscr, rsh, Rsh, rsqb, rsquo, rsquor, rthree, rtimes, rtri, rtrie, rtrif, rtriltri, RuleDelayed, ruluhar, rx, Sacute, sacute, sbquo, scap, Scaron, scaron, Sc, sc, sccue, sce, scE, Scedil, scedil, Scirc, scirc, scnap, scnE, scnsim, scpolint, scsim, Scy, scy, sdotb, sdot, sdote, searhk, searr, seArr, searrow, sect, semi, seswar, setminus, setmn, sext, Sfr, sfr, sfrown, sharp, SHCHcy, shchcy, SHcy, shcy, ShortDownArrow, ShortLeftArrow, shortmid, shortparallel, ShortRightArrow, ShortUpArrow, shy, Sigma, sigma, sigmaf, sigmav, sim, simdot, sime, simeq, simg, simgE, siml, simlE, simne, simplus, simrarr, slarr, SmallCircle, smallsetminus, smashp, smeparsl, smid, smile, smt, smte, smtes, SOFTcy, softcy, solbar, solb, sol, Sopf, sopf, spades, spadesuit, spar, sqcap, sqcaps, sqcup, sqcups, Sqrt, sqsub, sqsube, sqsubset, sqsubseteq, sqsup, sqsupe, sqsupset, sqsupseteq, square, Square, SquareIntersection, SquareSubset, SquareSubsetEqual, SquareSuperset, SquareSupersetEqual, SquareUnion, squarf, squ, squf, srarr, Sscr, sscr, ssetmn, ssmile, sstarf, Star, star, starf, straightepsilon, straightphi, strns, sub, Sub, subdot, subE, sube, subedot, submult, subnE, subne, subplus, subrarr, subset, Subset, subseteq, subseteqq, SubsetEqual, subsetneq, subsetneqq, subsim, subsub, subsup, succapprox, succ, succcurlyeq, Succeeds, SucceedsEqual, SucceedsSlantEqual, SucceedsTilde, succeq, succnapprox, succneqq, succnsim, succsim, SuchThat, sum, Sum, sung, sup1, sup2, sup3, sup, Sup, supdot, supdsub, supE, supe, supedot, Superset, SupersetEqual, suphsol, suphsub, suplarr, supmult, supnE, supne, supplus, supset, Supset, supseteq, supseteqq, supsetneq, supsetneqq, supsim, supsub, supsup, swarhk, swarr, swArr, swarrow, swnwar, szlig, Tab, target, Tau, tau, tbrk, Tcaron, tcaron, Tcedil, tcedil, Tcy, tcy, tdot, telrec, Tfr, tfr, there4, therefore, Therefore, Theta, theta, thetasym, thetav, thickapprox, thicksim, ThickSpace, ThinSpace, thinsp, thkap, thksim, THORN, thorn, tilde, Tilde, TildeEqual, TildeFullEqual, TildeTilde, timesbar, timesb, times, timesd, tint, toea, topbot, topcir, top, Topf, topf, topfork, tosa, tprime, trade, TRADE, triangle, triangledown, triangleleft, trianglelefteq, triangleq, triangleright, trianglerighteq, tridot, trie, triminus, TripleDot, triplus, trisb, tritime, trpezium, Tscr, tscr, TScy, tscy, TSHcy, tshcy, Tstrok, tstrok, twixt, twoheadleftarrow, twoheadrightarrow, Uacute, uacute, uarr, Uarr, uArr, Uarrocir, Ubrcy, ubrcy, Ubreve, ubreve, Ucirc, ucirc, Ucy, ucy, udarr, Udblac, udblac, udhar, ufisht, Ufr, ufr, Ugrave, ugrave, uHar, uharl, uharr, uhblk, ulcorn, ulcorner, ulcrop, ultri, Umacr, umacr, uml, UnderBar, UnderBrace, UnderBracket, UnderParenthesis, Union, UnionPlus, Uogon, uogon, Uopf, uopf, UpArrowBar, uparrow, UpArrow, Uparrow, UpArrowDownArrow, updownarrow, UpDownArrow, Updownarrow, UpEquilibrium, upharpoonleft, upharpoonright, uplus, UpperLeftArrow, UpperRightArrow, upsi, Upsi, upsih, Upsilon, upsilon, UpTeeArrow, UpTee, upuparrows, urcorn, urcorner, urcrop, Uring, uring, urtri, Uscr, uscr, utdot, Utilde, utilde, utri, utrif, uuarr, Uuml, uuml, uwangle, vangrt, varepsilon, varkappa, varnothing, varphi, varpi, varpropto, varr, vArr, varrho, varsigma, varsubsetneq, varsubsetneqq, varsupsetneq, varsupsetneqq, vartheta, vartriangleleft, vartriangleright, vBar, Vbar, vBarv, Vcy, vcy, vdash, vDash, Vdash, VDash, Vdashl, veebar, vee, Vee, veeeq, vellip, verbar, Verbar, vert, Vert, VerticalBar, VerticalLine, VerticalSeparator, VerticalTilde, VeryThinSpace, Vfr, vfr, vltri, vnsub, vnsup, Vopf, vopf, vprop, vrtri, Vscr, vscr, vsubnE, vsubne, vsupnE, vsupne, Vvdash, vzigzag, Wcirc, wcirc, wedbar, wedge, Wedge, wedgeq, weierp, Wfr, wfr, Wopf, wopf, wp, wr, wreath, Wscr, wscr, xcap, xcirc, xcup, xdtri, Xfr, xfr, xharr, xhArr, Xi, xi, xlarr, xlArr, xmap, xnis, xodot, Xopf, xopf, xoplus, xotime, xrarr, xrArr, Xscr, xscr, xsqcup, xuplus, xutri, xvee, xwedge, Yacute, yacute, YAcy, yacy, Ycirc, ycirc, Ycy, ycy, yen, Yfr, yfr, YIcy, yicy, Yopf, yopf, Yscr, yscr, YUcy, yucy, yuml, Yuml, Zacute, zacute, Zcaron, zcaron, Zcy, zcy, Zdot, zdot, zeetrf, ZeroWidthSpace, Zeta, zeta, zfr, Zfr, ZHcy, zhcy, zigrarr, zopf, Zopf, Zscr, zscr, zwj, zwnj, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Abreve\":\"Ă\",\"abreve\":\"ă\",\"ac\":\"∾\",\"acd\":\"∿\",\"acE\":\"∾̳\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"Acy\":\"А\",\"acy\":\"а\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"af\":\"⁡\",\"Afr\":\"𝔄\",\"afr\":\"𝔞\",\"Agrave\":\"À\",\"agrave\":\"à\",\"alefsym\":\"ℵ\",\"aleph\":\"ℵ\",\"Alpha\":\"Α\",\"alpha\":\"α\",\"Amacr\":\"Ā\",\"amacr\":\"ā\",\"amalg\":\"⨿\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"⩕\",\"And\":\"⩓\",\"and\":\"∧\",\"andd\":\"⩜\",\"andslope\":\"⩘\",\"andv\":\"⩚\",\"ang\":\"∠\",\"ange\":\"⦤\",\"angle\":\"∠\",\"angmsdaa\":\"⦨\",\"angmsdab\":\"⦩\",\"angmsdac\":\"⦪\",\"angmsdad\":\"⦫\",\"angmsdae\":\"⦬\",\"angmsdaf\":\"⦭\",\"angmsdag\":\"⦮\",\"angmsdah\":\"⦯\",\"angmsd\":\"∡\",\"angrt\":\"∟\",\"angrtvb\":\"⊾\",\"angrtvbd\":\"⦝\",\"angsph\":\"∢\",\"angst\":\"Å\",\"angzarr\":\"⍼\",\"Aogon\":\"Ą\",\"aogon\":\"ą\",\"Aopf\":\"𝔸\",\"aopf\":\"𝕒\",\"apacir\":\"⩯\",\"ap\":\"≈\",\"apE\":\"⩰\",\"ape\":\"≊\",\"apid\":\"≋\",\"apos\":\"'\",\"ApplyFunction\":\"⁡\",\"approx\":\"≈\",\"approxeq\":\"≊\",\"Aring\":\"Å\",\"aring\":\"å\",\"Ascr\":\"𝒜\",\"ascr\":\"𝒶\",\"Assign\":\"≔\",\"ast\":\"*\",\"asymp\":\"≈\",\"asympeq\":\"≍\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"awconint\":\"∳\",\"awint\":\"⨑\",\"backcong\":\"≌\",\"backepsilon\":\"϶\",\"backprime\":\"‵\",\"backsim\":\"∽\",\"backsimeq\":\"⋍\",\"Backslash\":\"∖\",\"Barv\":\"⫧\",\"barvee\":\"⊽\",\"barwed\":\"⌅\",\"Barwed\":\"⌆\",\"barwedge\":\"⌅\",\"bbrk\":\"⎵\",\"bbrktbrk\":\"⎶\",\"bcong\":\"≌\",\"Bcy\":\"Б\",\"bcy\":\"б\",\"bdquo\":\"„\",\"becaus\":\"∵\",\"because\":\"∵\",\"Because\":\"∵\",\"bemptyv\":\"⦰\",\"bepsi\":\"϶\",\"bernou\":\"ℬ\",\"Bernoullis\":\"ℬ\",\"Beta\":\"Β\",\"beta\":\"β\",\"beth\":\"ℶ\",\"between\":\"≬\",\"Bfr\":\"𝔅\",\"bfr\":\"𝔟\",\"bigcap\":\"⋂\",\"bigcirc\":\"◯\",\"bigcup\":\"⋃\",\"bigodot\":\"⨀\",\"bigoplus\":\"⨁\",\"bigotimes\":\"⨂\",\"bigsqcup\":\"⨆\",\"bigstar\":\"★\",\"bigtriangledown\":\"▽\",\"bigtriangleup\":\"△\",\"biguplus\":\"⨄\",\"bigvee\":\"⋁\",\"bigwedge\":\"⋀\",\"bkarow\":\"⤍\",\"blacklozenge\":\"⧫\",\"blacksquare\":\"▪\",\"blacktriangle\":\"▴\",\"blacktriangledown\":\"▾\",\"blacktriangleleft\":\"◂\",\"blacktriangleright\":\"▸\",\"blank\":\"␣\",\"blk12\":\"▒\",\"blk14\":\"░\",\"blk34\":\"▓\",\"block\":\"█\",\"bne\":\"=⃥\",\"bnequiv\":\"≡⃥\",\"bNot\":\"⫭\",\"bnot\":\"⌐\",\"Bopf\":\"𝔹\",\"bopf\":\"𝕓\",\"bot\":\"⊥\",\"bottom\":\"⊥\",\"bowtie\":\"⋈\",\"boxbox\":\"⧉\",\"boxdl\":\"┐\",\"boxdL\":\"╕\",\"boxDl\":\"╖\",\"boxDL\":\"╗\",\"boxdr\":\"┌\",\"boxdR\":\"╒\",\"boxDr\":\"╓\",\"boxDR\":\"╔\",\"boxh\":\"─\",\"boxH\":\"═\",\"boxhd\":\"┬\",\"boxHd\":\"╤\",\"boxhD\":\"╥\",\"boxHD\":\"╦\",\"boxhu\":\"┴\",\"boxHu\":\"╧\",\"boxhU\":\"╨\",\"boxHU\":\"╩\",\"boxminus\":\"⊟\",\"boxplus\":\"⊞\",\"boxtimes\":\"⊠\",\"boxul\":\"┘\",\"boxuL\":\"╛\",\"boxUl\":\"╜\",\"boxUL\":\"╝\",\"boxur\":\"└\",\"boxuR\":\"╘\",\"boxUr\":\"╙\",\"boxUR\":\"╚\",\"boxv\":\"│\",\"boxV\":\"║\",\"boxvh\":\"┼\",\"boxvH\":\"╪\",\"boxVh\":\"╫\",\"boxVH\":\"╬\",\"boxvl\":\"┤\",\"boxvL\":\"╡\",\"boxVl\":\"╢\",\"boxVL\":\"╣\",\"boxvr\":\"├\",\"boxvR\":\"╞\",\"boxVr\":\"╟\",\"boxVR\":\"╠\",\"bprime\":\"‵\",\"breve\":\"˘\",\"Breve\":\"˘\",\"brvbar\":\"¦\",\"bscr\":\"𝒷\",\"Bscr\":\"ℬ\",\"bsemi\":\"⁏\",\"bsim\":\"∽\",\"bsime\":\"⋍\",\"bsolb\":\"⧅\",\"bsol\":\"\\\\\",\"bsolhsub\":\"⟈\",\"bull\":\"•\",\"bullet\":\"•\",\"bump\":\"≎\",\"bumpE\":\"⪮\",\"bumpe\":\"≏\",\"Bumpeq\":\"≎\",\"bumpeq\":\"≏\",\"Cacute\":\"Ć\",\"cacute\":\"ć\",\"capand\":\"⩄\",\"capbrcup\":\"⩉\",\"capcap\":\"⩋\",\"cap\":\"∩\",\"Cap\":\"⋒\",\"capcup\":\"⩇\",\"capdot\":\"⩀\",\"CapitalDifferentialD\":\"ⅅ\",\"caps\":\"∩︀\",\"caret\":\"⁁\",\"caron\":\"ˇ\",\"Cayleys\":\"ℭ\",\"ccaps\":\"⩍\",\"Ccaron\":\"Č\",\"ccaron\":\"č\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"Ccirc\":\"Ĉ\",\"ccirc\":\"ĉ\",\"Cconint\":\"∰\",\"ccups\":\"⩌\",\"ccupssm\":\"⩐\",\"Cdot\":\"Ċ\",\"cdot\":\"ċ\",\"cedil\":\"¸\",\"Cedilla\":\"¸\",\"cemptyv\":\"⦲\",\"cent\":\"¢\",\"centerdot\":\"·\",\"CenterDot\":\"·\",\"cfr\":\"𝔠\",\"Cfr\":\"ℭ\",\"CHcy\":\"Ч\",\"chcy\":\"ч\",\"check\":\"✓\",\"checkmark\":\"✓\",\"Chi\":\"Χ\",\"chi\":\"χ\",\"circ\":\"ˆ\",\"circeq\":\"≗\",\"circlearrowleft\":\"↺\",\"circlearrowright\":\"↻\",\"circledast\":\"⊛\",\"circledcirc\":\"⊚\",\"circleddash\":\"⊝\",\"CircleDot\":\"⊙\",\"circledR\":\"®\",\"circledS\":\"Ⓢ\",\"CircleMinus\":\"⊖\",\"CirclePlus\":\"⊕\",\"CircleTimes\":\"⊗\",\"cir\":\"○\",\"cirE\":\"⧃\",\"cire\":\"≗\",\"cirfnint\":\"⨐\",\"cirmid\":\"⫯\",\"cirscir\":\"⧂\",\"ClockwiseContourIntegral\":\"∲\",\"CloseCurlyDoubleQuote\":\"”\",\"CloseCurlyQuote\":\"’\",\"clubs\":\"♣\",\"clubsuit\":\"♣\",\"colon\":\":\",\"Colon\":\"∷\",\"Colone\":\"⩴\",\"colone\":\"≔\",\"coloneq\":\"≔\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"∁\",\"compfn\":\"∘\",\"complement\":\"∁\",\"complexes\":\"ℂ\",\"cong\":\"≅\",\"congdot\":\"⩭\",\"Congruent\":\"≡\",\"conint\":\"∮\",\"Conint\":\"∯\",\"ContourIntegral\":\"∮\",\"copf\":\"𝕔\",\"Copf\":\"ℂ\",\"coprod\":\"∐\",\"Coproduct\":\"∐\",\"copy\":\"©\",\"COPY\":\"©\",\"copysr\":\"℗\",\"CounterClockwiseContourIntegral\":\"∳\",\"crarr\":\"↵\",\"cross\":\"✗\",\"Cross\":\"⨯\",\"Cscr\":\"𝒞\",\"cscr\":\"𝒸\",\"csub\":\"⫏\",\"csube\":\"⫑\",\"csup\":\"⫐\",\"csupe\":\"⫒\",\"ctdot\":\"⋯\",\"cudarrl\":\"⤸\",\"cudarrr\":\"⤵\",\"cuepr\":\"⋞\",\"cuesc\":\"⋟\",\"cularr\":\"↶\",\"cularrp\":\"⤽\",\"cupbrcap\":\"⩈\",\"cupcap\":\"⩆\",\"CupCap\":\"≍\",\"cup\":\"∪\",\"Cup\":\"⋓\",\"cupcup\":\"⩊\",\"cupdot\":\"⊍\",\"cupor\":\"⩅\",\"cups\":\"∪︀\",\"curarr\":\"↷\",\"curarrm\":\"⤼\",\"curlyeqprec\":\"⋞\",\"curlyeqsucc\":\"⋟\",\"curlyvee\":\"⋎\",\"curlywedge\":\"⋏\",\"curren\":\"¤\",\"curvearrowleft\":\"↶\",\"curvearrowright\":\"↷\",\"cuvee\":\"⋎\",\"cuwed\":\"⋏\",\"cwconint\":\"∲\",\"cwint\":\"∱\",\"cylcty\":\"⌭\",\"dagger\":\"†\",\"Dagger\":\"‡\",\"daleth\":\"ℸ\",\"darr\":\"↓\",\"Darr\":\"↡\",\"dArr\":\"⇓\",\"dash\":\"‐\",\"Dashv\":\"⫤\",\"dashv\":\"⊣\",\"dbkarow\":\"⤏\",\"dblac\":\"˝\",\"Dcaron\":\"Ď\",\"dcaron\":\"ď\",\"Dcy\":\"Д\",\"dcy\":\"д\",\"ddagger\":\"‡\",\"ddarr\":\"⇊\",\"DD\":\"ⅅ\",\"dd\":\"ⅆ\",\"DDotrahd\":\"⤑\",\"ddotseq\":\"⩷\",\"deg\":\"°\",\"Del\":\"∇\",\"Delta\":\"Δ\",\"delta\":\"δ\",\"demptyv\":\"⦱\",\"dfisht\":\"⥿\",\"Dfr\":\"𝔇\",\"dfr\":\"𝔡\",\"dHar\":\"⥥\",\"dharl\":\"⇃\",\"dharr\":\"⇂\",\"DiacriticalAcute\":\"´\",\"DiacriticalDot\":\"˙\",\"DiacriticalDoubleAcute\":\"˝\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"˜\",\"diam\":\"⋄\",\"diamond\":\"⋄\",\"Diamond\":\"⋄\",\"diamondsuit\":\"♦\",\"diams\":\"♦\",\"die\":\"¨\",\"DifferentialD\":\"ⅆ\",\"digamma\":\"ϝ\",\"disin\":\"⋲\",\"div\":\"÷\",\"divide\":\"÷\",\"divideontimes\":\"⋇\",\"divonx\":\"⋇\",\"DJcy\":\"Ђ\",\"djcy\":\"ђ\",\"dlcorn\":\"⌞\",\"dlcrop\":\"⌍\",\"dollar\":\"$\",\"Dopf\":\"𝔻\",\"dopf\":\"𝕕\",\"Dot\":\"¨\",\"dot\":\"˙\",\"DotDot\":\"⃜\",\"doteq\":\"≐\",\"doteqdot\":\"≑\",\"DotEqual\":\"≐\",\"dotminus\":\"∸\",\"dotplus\":\"∔\",\"dotsquare\":\"⊡\",\"doublebarwedge\":\"⌆\",\"DoubleContourIntegral\":\"∯\",\"DoubleDot\":\"¨\",\"DoubleDownArrow\":\"⇓\",\"DoubleLeftArrow\":\"⇐\",\"DoubleLeftRightArrow\":\"⇔\",\"DoubleLeftTee\":\"⫤\",\"DoubleLongLeftArrow\":\"⟸\",\"DoubleLongLeftRightArrow\":\"⟺\",\"DoubleLongRightArrow\":\"⟹\",\"DoubleRightArrow\":\"⇒\",\"DoubleRightTee\":\"⊨\",\"DoubleUpArrow\":\"⇑\",\"DoubleUpDownArrow\":\"⇕\",\"DoubleVerticalBar\":\"∥\",\"DownArrowBar\":\"⤓\",\"downarrow\":\"↓\",\"DownArrow\":\"↓\",\"Downarrow\":\"⇓\",\"DownArrowUpArrow\":\"⇵\",\"DownBreve\":\"̑\",\"downdownarrows\":\"⇊\",\"downharpoonleft\":\"⇃\",\"downharpoonright\":\"⇂\",\"DownLeftRightVector\":\"⥐\",\"DownLeftTeeVector\":\"⥞\",\"DownLeftVectorBar\":\"⥖\",\"DownLeftVector\":\"↽\",\"DownRightTeeVector\":\"⥟\",\"DownRightVectorBar\":\"⥗\",\"DownRightVector\":\"⇁\",\"DownTeeArrow\":\"↧\",\"DownTee\":\"⊤\",\"drbkarow\":\"⤐\",\"drcorn\":\"⌟\",\"drcrop\":\"⌌\",\"Dscr\":\"𝒟\",\"dscr\":\"𝒹\",\"DScy\":\"Ѕ\",\"dscy\":\"ѕ\",\"dsol\":\"⧶\",\"Dstrok\":\"Đ\",\"dstrok\":\"đ\",\"dtdot\":\"⋱\",\"dtri\":\"▿\",\"dtrif\":\"▾\",\"duarr\":\"⇵\",\"duhar\":\"⥯\",\"dwangle\":\"⦦\",\"DZcy\":\"Џ\",\"dzcy\":\"џ\",\"dzigrarr\":\"⟿\",\"Eacute\":\"É\",\"eacute\":\"é\",\"easter\":\"⩮\",\"Ecaron\":\"Ě\",\"ecaron\":\"ě\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"ecir\":\"≖\",\"ecolon\":\"≕\",\"Ecy\":\"Э\",\"ecy\":\"э\",\"eDDot\":\"⩷\",\"Edot\":\"Ė\",\"edot\":\"ė\",\"eDot\":\"≑\",\"ee\":\"ⅇ\",\"efDot\":\"≒\",\"Efr\":\"𝔈\",\"efr\":\"𝔢\",\"eg\":\"⪚\",\"Egrave\":\"È\",\"egrave\":\"è\",\"egs\":\"⪖\",\"egsdot\":\"⪘\",\"el\":\"⪙\",\"Element\":\"∈\",\"elinters\":\"⏧\",\"ell\":\"ℓ\",\"els\":\"⪕\",\"elsdot\":\"⪗\",\"Emacr\":\"Ē\",\"emacr\":\"ē\",\"empty\":\"∅\",\"emptyset\":\"∅\",\"EmptySmallSquare\":\"◻\",\"emptyv\":\"∅\",\"EmptyVerySmallSquare\":\"▫\",\"emsp13\":\" \",\"emsp14\":\" \",\"emsp\":\" \",\"ENG\":\"Ŋ\",\"eng\":\"ŋ\",\"ensp\":\" \",\"Eogon\":\"Ę\",\"eogon\":\"ę\",\"Eopf\":\"𝔼\",\"eopf\":\"𝕖\",\"epar\":\"⋕\",\"eparsl\":\"⧣\",\"eplus\":\"⩱\",\"epsi\":\"ε\",\"Epsilon\":\"Ε\",\"epsilon\":\"ε\",\"epsiv\":\"ϵ\",\"eqcirc\":\"≖\",\"eqcolon\":\"≕\",\"eqsim\":\"≂\",\"eqslantgtr\":\"⪖\",\"eqslantless\":\"⪕\",\"Equal\":\"⩵\",\"equals\":\"=\",\"EqualTilde\":\"≂\",\"equest\":\"≟\",\"Equilibrium\":\"⇌\",\"equiv\":\"≡\",\"equivDD\":\"⩸\",\"eqvparsl\":\"⧥\",\"erarr\":\"⥱\",\"erDot\":\"≓\",\"escr\":\"ℯ\",\"Escr\":\"ℰ\",\"esdot\":\"≐\",\"Esim\":\"⩳\",\"esim\":\"≂\",\"Eta\":\"Η\",\"eta\":\"η\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"euro\":\"€\",\"excl\":\"!\",\"exist\":\"∃\",\"Exists\":\"∃\",\"expectation\":\"ℰ\",\"exponentiale\":\"ⅇ\",\"ExponentialE\":\"ⅇ\",\"fallingdotseq\":\"≒\",\"Fcy\":\"Ф\",\"fcy\":\"ф\",\"female\":\"♀\",\"ffilig\":\"ﬃ\",\"fflig\":\"ﬀ\",\"ffllig\":\"ﬄ\",\"Ffr\":\"𝔉\",\"ffr\":\"𝔣\",\"filig\":\"ﬁ\",\"FilledSmallSquare\":\"◼\",\"FilledVerySmallSquare\":\"▪\",\"fjlig\":\"fj\",\"flat\":\"♭\",\"fllig\":\"ﬂ\",\"fltns\":\"▱\",\"fnof\":\"ƒ\",\"Fopf\":\"𝔽\",\"fopf\":\"𝕗\",\"forall\":\"∀\",\"ForAll\":\"∀\",\"fork\":\"⋔\",\"forkv\":\"⫙\",\"Fouriertrf\":\"ℱ\",\"fpartint\":\"⨍\",\"frac12\":\"½\",\"frac13\":\"⅓\",\"frac14\":\"¼\",\"frac15\":\"⅕\",\"frac16\":\"⅙\",\"frac18\":\"⅛\",\"frac23\":\"⅔\",\"frac25\":\"⅖\",\"frac34\":\"¾\",\"frac35\":\"⅗\",\"frac38\":\"⅜\",\"frac45\":\"⅘\",\"frac56\":\"⅚\",\"frac58\":\"⅝\",\"frac78\":\"⅞\",\"frasl\":\"⁄\",\"frown\":\"⌢\",\"fscr\":\"𝒻\",\"Fscr\":\"ℱ\",\"gacute\":\"ǵ\",\"Gamma\":\"Γ\",\"gamma\":\"γ\",\"Gammad\":\"Ϝ\",\"gammad\":\"ϝ\",\"gap\":\"⪆\",\"Gbreve\":\"Ğ\",\"gbreve\":\"ğ\",\"Gcedil\":\"Ģ\",\"Gcirc\":\"Ĝ\",\"gcirc\":\"ĝ\",\"Gcy\":\"Г\",\"gcy\":\"г\",\"Gdot\":\"Ġ\",\"gdot\":\"ġ\",\"ge\":\"≥\",\"gE\":\"≧\",\"gEl\":\"⪌\",\"gel\":\"⋛\",\"geq\":\"≥\",\"geqq\":\"≧\",\"geqslant\":\"⩾\",\"gescc\":\"⪩\",\"ges\":\"⩾\",\"gesdot\":\"⪀\",\"gesdoto\":\"⪂\",\"gesdotol\":\"⪄\",\"gesl\":\"⋛︀\",\"gesles\":\"⪔\",\"Gfr\":\"𝔊\",\"gfr\":\"𝔤\",\"gg\":\"≫\",\"Gg\":\"⋙\",\"ggg\":\"⋙\",\"gimel\":\"ℷ\",\"GJcy\":\"Ѓ\",\"gjcy\":\"ѓ\",\"gla\":\"⪥\",\"gl\":\"≷\",\"glE\":\"⪒\",\"glj\":\"⪤\",\"gnap\":\"⪊\",\"gnapprox\":\"⪊\",\"gne\":\"⪈\",\"gnE\":\"≩\",\"gneq\":\"⪈\",\"gneqq\":\"≩\",\"gnsim\":\"⋧\",\"Gopf\":\"𝔾\",\"gopf\":\"𝕘\",\"grave\":\"`\",\"GreaterEqual\":\"≥\",\"GreaterEqualLess\":\"⋛\",\"GreaterFullEqual\":\"≧\",\"GreaterGreater\":\"⪢\",\"GreaterLess\":\"≷\",\"GreaterSlantEqual\":\"⩾\",\"GreaterTilde\":\"≳\",\"Gscr\":\"𝒢\",\"gscr\":\"ℊ\",\"gsim\":\"≳\",\"gsime\":\"⪎\",\"gsiml\":\"⪐\",\"gtcc\":\"⪧\",\"gtcir\":\"⩺\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"≫\",\"gtdot\":\"⋗\",\"gtlPar\":\"⦕\",\"gtquest\":\"⩼\",\"gtrapprox\":\"⪆\",\"gtrarr\":\"⥸\",\"gtrdot\":\"⋗\",\"gtreqless\":\"⋛\",\"gtreqqless\":\"⪌\",\"gtrless\":\"≷\",\"gtrsim\":\"≳\",\"gvertneqq\":\"≩︀\",\"gvnE\":\"≩︀\",\"Hacek\":\"ˇ\",\"hairsp\":\" \",\"half\":\"½\",\"hamilt\":\"ℋ\",\"HARDcy\":\"Ъ\",\"hardcy\":\"ъ\",\"harrcir\":\"⥈\",\"harr\":\"↔\",\"hArr\":\"⇔\",\"harrw\":\"↭\",\"Hat\":\"^\",\"hbar\":\"ℏ\",\"Hcirc\":\"Ĥ\",\"hcirc\":\"ĥ\",\"hearts\":\"♥\",\"heartsuit\":\"♥\",\"hellip\":\"…\",\"hercon\":\"⊹\",\"hfr\":\"𝔥\",\"Hfr\":\"ℌ\",\"HilbertSpace\":\"ℋ\",\"hksearow\":\"⤥\",\"hkswarow\":\"⤦\",\"hoarr\":\"⇿\",\"homtht\":\"∻\",\"hookleftarrow\":\"↩\",\"hookrightarrow\":\"↪\",\"hopf\":\"𝕙\",\"Hopf\":\"ℍ\",\"horbar\":\"―\",\"HorizontalLine\":\"─\",\"hscr\":\"𝒽\",\"Hscr\":\"ℋ\",\"hslash\":\"ℏ\",\"Hstrok\":\"Ħ\",\"hstrok\":\"ħ\",\"HumpDownHump\":\"≎\",\"HumpEqual\":\"≏\",\"hybull\":\"⁃\",\"hyphen\":\"‐\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"ic\":\"⁣\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"Icy\":\"И\",\"icy\":\"и\",\"Idot\":\"İ\",\"IEcy\":\"Е\",\"iecy\":\"е\",\"iexcl\":\"¡\",\"iff\":\"⇔\",\"ifr\":\"𝔦\",\"Ifr\":\"ℑ\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"ii\":\"ⅈ\",\"iiiint\":\"⨌\",\"iiint\":\"∭\",\"iinfin\":\"⧜\",\"iiota\":\"℩\",\"IJlig\":\"Ĳ\",\"ijlig\":\"ĳ\",\"Imacr\":\"Ī\",\"imacr\":\"ī\",\"image\":\"ℑ\",\"ImaginaryI\":\"ⅈ\",\"imagline\":\"ℐ\",\"imagpart\":\"ℑ\",\"imath\":\"ı\",\"Im\":\"ℑ\",\"imof\":\"⊷\",\"imped\":\"Ƶ\",\"Implies\":\"⇒\",\"incare\":\"℅\",\"in\":\"∈\",\"infin\":\"∞\",\"infintie\":\"⧝\",\"inodot\":\"ı\",\"intcal\":\"⊺\",\"int\":\"∫\",\"Int\":\"∬\",\"integers\":\"ℤ\",\"Integral\":\"∫\",\"intercal\":\"⊺\",\"Intersection\":\"⋂\",\"intlarhk\":\"⨗\",\"intprod\":\"⨼\",\"InvisibleComma\":\"⁣\",\"InvisibleTimes\":\"⁢\",\"IOcy\":\"Ё\",\"iocy\":\"ё\",\"Iogon\":\"Į\",\"iogon\":\"į\",\"Iopf\":\"𝕀\",\"iopf\":\"𝕚\",\"Iota\":\"Ι\",\"iota\":\"ι\",\"iprod\":\"⨼\",\"iquest\":\"¿\",\"iscr\":\"𝒾\",\"Iscr\":\"ℐ\",\"isin\":\"∈\",\"isindot\":\"⋵\",\"isinE\":\"⋹\",\"isins\":\"⋴\",\"isinsv\":\"⋳\",\"isinv\":\"∈\",\"it\":\"⁢\",\"Itilde\":\"Ĩ\",\"itilde\":\"ĩ\",\"Iukcy\":\"І\",\"iukcy\":\"і\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"Jcirc\":\"Ĵ\",\"jcirc\":\"ĵ\",\"Jcy\":\"Й\",\"jcy\":\"й\",\"Jfr\":\"𝔍\",\"jfr\":\"𝔧\",\"jmath\":\"ȷ\",\"Jopf\":\"𝕁\",\"jopf\":\"𝕛\",\"Jscr\":\"𝒥\",\"jscr\":\"𝒿\",\"Jsercy\":\"Ј\",\"jsercy\":\"ј\",\"Jukcy\":\"Є\",\"jukcy\":\"є\",\"Kappa\":\"Κ\",\"kappa\":\"κ\",\"kappav\":\"ϰ\",\"Kcedil\":\"Ķ\",\"kcedil\":\"ķ\",\"Kcy\":\"К\",\"kcy\":\"к\",\"Kfr\":\"𝔎\",\"kfr\":\"𝔨\",\"kgreen\":\"ĸ\",\"KHcy\":\"Х\",\"khcy\":\"х\",\"KJcy\":\"Ќ\",\"kjcy\":\"ќ\",\"Kopf\":\"𝕂\",\"kopf\":\"𝕜\",\"Kscr\":\"𝒦\",\"kscr\":\"𝓀\",\"lAarr\":\"⇚\",\"Lacute\":\"Ĺ\",\"lacute\":\"ĺ\",\"laemptyv\":\"⦴\",\"lagran\":\"ℒ\",\"Lambda\":\"Λ\",\"lambda\":\"λ\",\"lang\":\"⟨\",\"Lang\":\"⟪\",\"langd\":\"⦑\",\"langle\":\"⟨\",\"lap\":\"⪅\",\"Laplacetrf\":\"ℒ\",\"laquo\":\"«\",\"larrb\":\"⇤\",\"larrbfs\":\"⤟\",\"larr\":\"←\",\"Larr\":\"↞\",\"lArr\":\"⇐\",\"larrfs\":\"⤝\",\"larrhk\":\"↩\",\"larrlp\":\"↫\",\"larrpl\":\"⤹\",\"larrsim\":\"⥳\",\"larrtl\":\"↢\",\"latail\":\"⤙\",\"lAtail\":\"⤛\",\"lat\":\"⪫\",\"late\":\"⪭\",\"lates\":\"⪭︀\",\"lbarr\":\"⤌\",\"lBarr\":\"⤎\",\"lbbrk\":\"❲\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"⦋\",\"lbrksld\":\"⦏\",\"lbrkslu\":\"⦍\",\"Lcaron\":\"Ľ\",\"lcaron\":\"ľ\",\"Lcedil\":\"Ļ\",\"lcedil\":\"ļ\",\"lceil\":\"⌈\",\"lcub\":\"{\",\"Lcy\":\"Л\",\"lcy\":\"л\",\"ldca\":\"⤶\",\"ldquo\":\"“\",\"ldquor\":\"„\",\"ldrdhar\":\"⥧\",\"ldrushar\":\"⥋\",\"ldsh\":\"↲\",\"le\":\"≤\",\"lE\":\"≦\",\"LeftAngleBracket\":\"⟨\",\"LeftArrowBar\":\"⇤\",\"leftarrow\":\"←\",\"LeftArrow\":\"←\",\"Leftarrow\":\"⇐\",\"LeftArrowRightArrow\":\"⇆\",\"leftarrowtail\":\"↢\",\"LeftCeiling\":\"⌈\",\"LeftDoubleBracket\":\"⟦\",\"LeftDownTeeVector\":\"⥡\",\"LeftDownVectorBar\":\"⥙\",\"LeftDownVector\":\"⇃\",\"LeftFloor\":\"⌊\",\"leftharpoondown\":\"↽\",\"leftharpoonup\":\"↼\",\"leftleftarrows\":\"⇇\",\"leftrightarrow\":\"↔\",\"LeftRightArrow\":\"↔\",\"Leftrightarrow\":\"⇔\",\"leftrightarrows\":\"⇆\",\"leftrightharpoons\":\"⇋\",\"leftrightsquigarrow\":\"↭\",\"LeftRightVector\":\"⥎\",\"LeftTeeArrow\":\"↤\",\"LeftTee\":\"⊣\",\"LeftTeeVector\":\"⥚\",\"leftthreetimes\":\"⋋\",\"LeftTriangleBar\":\"⧏\",\"LeftTriangle\":\"⊲\",\"LeftTriangleEqual\":\"⊴\",\"LeftUpDownVector\":\"⥑\",\"LeftUpTeeVector\":\"⥠\",\"LeftUpVectorBar\":\"⥘\",\"LeftUpVector\":\"↿\",\"LeftVectorBar\":\"⥒\",\"LeftVector\":\"↼\",\"lEg\":\"⪋\",\"leg\":\"⋚\",\"leq\":\"≤\",\"leqq\":\"≦\",\"leqslant\":\"⩽\",\"lescc\":\"⪨\",\"les\":\"⩽\",\"lesdot\":\"⩿\",\"lesdoto\":\"⪁\",\"lesdotor\":\"⪃\",\"lesg\":\"⋚︀\",\"lesges\":\"⪓\",\"lessapprox\":\"⪅\",\"lessdot\":\"⋖\",\"lesseqgtr\":\"⋚\",\"lesseqqgtr\":\"⪋\",\"LessEqualGreater\":\"⋚\",\"LessFullEqual\":\"≦\",\"LessGreater\":\"≶\",\"lessgtr\":\"≶\",\"LessLess\":\"⪡\",\"lesssim\":\"≲\",\"LessSlantEqual\":\"⩽\",\"LessTilde\":\"≲\",\"lfisht\":\"⥼\",\"lfloor\":\"⌊\",\"Lfr\":\"𝔏\",\"lfr\":\"𝔩\",\"lg\":\"≶\",\"lgE\":\"⪑\",\"lHar\":\"⥢\",\"lhard\":\"↽\",\"lharu\":\"↼\",\"lharul\":\"⥪\",\"lhblk\":\"▄\",\"LJcy\":\"Љ\",\"ljcy\":\"љ\",\"llarr\":\"⇇\",\"ll\":\"≪\",\"Ll\":\"⋘\",\"llcorner\":\"⌞\",\"Lleftarrow\":\"⇚\",\"llhard\":\"⥫\",\"lltri\":\"◺\",\"Lmidot\":\"Ŀ\",\"lmidot\":\"ŀ\",\"lmoustache\":\"⎰\",\"lmoust\":\"⎰\",\"lnap\":\"⪉\",\"lnapprox\":\"⪉\",\"lne\":\"⪇\",\"lnE\":\"≨\",\"lneq\":\"⪇\",\"lneqq\":\"≨\",\"lnsim\":\"⋦\",\"loang\":\"⟬\",\"loarr\":\"⇽\",\"lobrk\":\"⟦\",\"longleftarrow\":\"⟵\",\"LongLeftArrow\":\"⟵\",\"Longleftarrow\":\"⟸\",\"longleftrightarrow\":\"⟷\",\"LongLeftRightArrow\":\"⟷\",\"Longleftrightarrow\":\"⟺\",\"longmapsto\":\"⟼\",\"longrightarrow\":\"⟶\",\"LongRightArrow\":\"⟶\",\"Longrightarrow\":\"⟹\",\"looparrowleft\":\"↫\",\"looparrowright\":\"↬\",\"lopar\":\"⦅\",\"Lopf\":\"𝕃\",\"lopf\":\"𝕝\",\"loplus\":\"⨭\",\"lotimes\":\"⨴\",\"lowast\":\"∗\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"↙\",\"LowerRightArrow\":\"↘\",\"loz\":\"◊\",\"lozenge\":\"◊\",\"lozf\":\"⧫\",\"lpar\":\"(\",\"lparlt\":\"⦓\",\"lrarr\":\"⇆\",\"lrcorner\":\"⌟\",\"lrhar\":\"⇋\",\"lrhard\":\"⥭\",\"lrm\":\"‎\",\"lrtri\":\"⊿\",\"lsaquo\":\"‹\",\"lscr\":\"𝓁\",\"Lscr\":\"ℒ\",\"lsh\":\"↰\",\"Lsh\":\"↰\",\"lsim\":\"≲\",\"lsime\":\"⪍\",\"lsimg\":\"⪏\",\"lsqb\":\"[\",\"lsquo\":\"‘\",\"lsquor\":\"‚\",\"Lstrok\":\"Ł\",\"lstrok\":\"ł\",\"ltcc\":\"⪦\",\"ltcir\":\"⩹\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"≪\",\"ltdot\":\"⋖\",\"lthree\":\"⋋\",\"ltimes\":\"⋉\",\"ltlarr\":\"⥶\",\"ltquest\":\"⩻\",\"ltri\":\"◃\",\"ltrie\":\"⊴\",\"ltrif\":\"◂\",\"ltrPar\":\"⦖\",\"lurdshar\":\"⥊\",\"luruhar\":\"⥦\",\"lvertneqq\":\"≨︀\",\"lvnE\":\"≨︀\",\"macr\":\"¯\",\"male\":\"♂\",\"malt\":\"✠\",\"maltese\":\"✠\",\"Map\":\"⤅\",\"map\":\"↦\",\"mapsto\":\"↦\",\"mapstodown\":\"↧\",\"mapstoleft\":\"↤\",\"mapstoup\":\"↥\",\"marker\":\"▮\",\"mcomma\":\"⨩\",\"Mcy\":\"М\",\"mcy\":\"м\",\"mdash\":\"—\",\"mDDot\":\"∺\",\"measuredangle\":\"∡\",\"MediumSpace\":\" \",\"Mellintrf\":\"ℳ\",\"Mfr\":\"𝔐\",\"mfr\":\"𝔪\",\"mho\":\"℧\",\"micro\":\"µ\",\"midast\":\"*\",\"midcir\":\"⫰\",\"mid\":\"∣\",\"middot\":\"·\",\"minusb\":\"⊟\",\"minus\":\"−\",\"minusd\":\"∸\",\"minusdu\":\"⨪\",\"MinusPlus\":\"∓\",\"mlcp\":\"⫛\",\"mldr\":\"…\",\"mnplus\":\"∓\",\"models\":\"⊧\",\"Mopf\":\"𝕄\",\"mopf\":\"𝕞\",\"mp\":\"∓\",\"mscr\":\"𝓂\",\"Mscr\":\"ℳ\",\"mstpos\":\"∾\",\"Mu\":\"Μ\",\"mu\":\"μ\",\"multimap\":\"⊸\",\"mumap\":\"⊸\",\"nabla\":\"∇\",\"Nacute\":\"Ń\",\"nacute\":\"ń\",\"nang\":\"∠⃒\",\"nap\":\"≉\",\"napE\":\"⩰̸\",\"napid\":\"≋̸\",\"napos\":\"ŉ\",\"napprox\":\"≉\",\"natural\":\"♮\",\"naturals\":\"ℕ\",\"natur\":\"♮\",\"nbsp\":\" \",\"nbump\":\"≎̸\",\"nbumpe\":\"≏̸\",\"ncap\":\"⩃\",\"Ncaron\":\"Ň\",\"ncaron\":\"ň\",\"Ncedil\":\"Ņ\",\"ncedil\":\"ņ\",\"ncong\":\"≇\",\"ncongdot\":\"⩭̸\",\"ncup\":\"⩂\",\"Ncy\":\"Н\",\"ncy\":\"н\",\"ndash\":\"–\",\"nearhk\":\"⤤\",\"nearr\":\"↗\",\"neArr\":\"⇗\",\"nearrow\":\"↗\",\"ne\":\"≠\",\"nedot\":\"≐̸\",\"NegativeMediumSpace\":\"​\",\"NegativeThickSpace\":\"​\",\"NegativeThinSpace\":\"​\",\"NegativeVeryThinSpace\":\"​\",\"nequiv\":\"≢\",\"nesear\":\"⤨\",\"nesim\":\"≂̸\",\"NestedGreaterGreater\":\"≫\",\"NestedLessLess\":\"≪\",\"NewLine\":\"\\n\",\"nexist\":\"∄\",\"nexists\":\"∄\",\"Nfr\":\"𝔑\",\"nfr\":\"𝔫\",\"ngE\":\"≧̸\",\"nge\":\"≱\",\"ngeq\":\"≱\",\"ngeqq\":\"≧̸\",\"ngeqslant\":\"⩾̸\",\"nges\":\"⩾̸\",\"nGg\":\"⋙̸\",\"ngsim\":\"≵\",\"nGt\":\"≫⃒\",\"ngt\":\"≯\",\"ngtr\":\"≯\",\"nGtv\":\"≫̸\",\"nharr\":\"↮\",\"nhArr\":\"⇎\",\"nhpar\":\"⫲\",\"ni\":\"∋\",\"nis\":\"⋼\",\"nisd\":\"⋺\",\"niv\":\"∋\",\"NJcy\":\"Њ\",\"njcy\":\"њ\",\"nlarr\":\"↚\",\"nlArr\":\"⇍\",\"nldr\":\"‥\",\"nlE\":\"≦̸\",\"nle\":\"≰\",\"nleftarrow\":\"↚\",\"nLeftarrow\":\"⇍\",\"nleftrightarrow\":\"↮\",\"nLeftrightarrow\":\"⇎\",\"nleq\":\"≰\",\"nleqq\":\"≦̸\",\"nleqslant\":\"⩽̸\",\"nles\":\"⩽̸\",\"nless\":\"≮\",\"nLl\":\"⋘̸\",\"nlsim\":\"≴\",\"nLt\":\"≪⃒\",\"nlt\":\"≮\",\"nltri\":\"⋪\",\"nltrie\":\"⋬\",\"nLtv\":\"≪̸\",\"nmid\":\"∤\",\"NoBreak\":\"⁠\",\"NonBreakingSpace\":\" \",\"nopf\":\"𝕟\",\"Nopf\":\"ℕ\",\"Not\":\"⫬\",\"not\":\"¬\",\"NotCongruent\":\"≢\",\"NotCupCap\":\"≭\",\"NotDoubleVerticalBar\":\"∦\",\"NotElement\":\"∉\",\"NotEqual\":\"≠\",\"NotEqualTilde\":\"≂̸\",\"NotExists\":\"∄\",\"NotGreater\":\"≯\",\"NotGreaterEqual\":\"≱\",\"NotGreaterFullEqual\":\"≧̸\",\"NotGreaterGreater\":\"≫̸\",\"NotGreaterLess\":\"≹\",\"NotGreaterSlantEqual\":\"⩾̸\",\"NotGreaterTilde\":\"≵\",\"NotHumpDownHump\":\"≎̸\",\"NotHumpEqual\":\"≏̸\",\"notin\":\"∉\",\"notindot\":\"⋵̸\",\"notinE\":\"⋹̸\",\"notinva\":\"∉\",\"notinvb\":\"⋷\",\"notinvc\":\"⋶\",\"NotLeftTriangleBar\":\"⧏̸\",\"NotLeftTriangle\":\"⋪\",\"NotLeftTriangleEqual\":\"⋬\",\"NotLess\":\"≮\",\"NotLessEqual\":\"≰\",\"NotLessGreater\":\"≸\",\"NotLessLess\":\"≪̸\",\"NotLessSlantEqual\":\"⩽̸\",\"NotLessTilde\":\"≴\",\"NotNestedGreaterGreater\":\"⪢̸\",\"NotNestedLessLess\":\"⪡̸\",\"notni\":\"∌\",\"notniva\":\"∌\",\"notnivb\":\"⋾\",\"notnivc\":\"⋽\",\"NotPrecedes\":\"⊀\",\"NotPrecedesEqual\":\"⪯̸\",\"NotPrecedesSlantEqual\":\"⋠\",\"NotReverseElement\":\"∌\",\"NotRightTriangleBar\":\"⧐̸\",\"NotRightTriangle\":\"⋫\",\"NotRightTriangleEqual\":\"⋭\",\"NotSquareSubset\":\"⊏̸\",\"NotSquareSubsetEqual\":\"⋢\",\"NotSquareSuperset\":\"⊐̸\",\"NotSquareSupersetEqual\":\"⋣\",\"NotSubset\":\"⊂⃒\",\"NotSubsetEqual\":\"⊈\",\"NotSucceeds\":\"⊁\",\"NotSucceedsEqual\":\"⪰̸\",\"NotSucceedsSlantEqual\":\"⋡\",\"NotSucceedsTilde\":\"≿̸\",\"NotSuperset\":\"⊃⃒\",\"NotSupersetEqual\":\"⊉\",\"NotTilde\":\"≁\",\"NotTildeEqual\":\"≄\",\"NotTildeFullEqual\":\"≇\",\"NotTildeTilde\":\"≉\",\"NotVerticalBar\":\"∤\",\"nparallel\":\"∦\",\"npar\":\"∦\",\"nparsl\":\"⫽⃥\",\"npart\":\"∂̸\",\"npolint\":\"⨔\",\"npr\":\"⊀\",\"nprcue\":\"⋠\",\"nprec\":\"⊀\",\"npreceq\":\"⪯̸\",\"npre\":\"⪯̸\",\"nrarrc\":\"⤳̸\",\"nrarr\":\"↛\",\"nrArr\":\"⇏\",\"nrarrw\":\"↝̸\",\"nrightarrow\":\"↛\",\"nRightarrow\":\"⇏\",\"nrtri\":\"⋫\",\"nrtrie\":\"⋭\",\"nsc\":\"⊁\",\"nsccue\":\"⋡\",\"nsce\":\"⪰̸\",\"Nscr\":\"𝒩\",\"nscr\":\"𝓃\",\"nshortmid\":\"∤\",\"nshortparallel\":\"∦\",\"nsim\":\"≁\",\"nsime\":\"≄\",\"nsimeq\":\"≄\",\"nsmid\":\"∤\",\"nspar\":\"∦\",\"nsqsube\":\"⋢\",\"nsqsupe\":\"⋣\",\"nsub\":\"⊄\",\"nsubE\":\"⫅̸\",\"nsube\":\"⊈\",\"nsubset\":\"⊂⃒\",\"nsubseteq\":\"⊈\",\"nsubseteqq\":\"⫅̸\",\"nsucc\":\"⊁\",\"nsucceq\":\"⪰̸\",\"nsup\":\"⊅\",\"nsupE\":\"⫆̸\",\"nsupe\":\"⊉\",\"nsupset\":\"⊃⃒\",\"nsupseteq\":\"⊉\",\"nsupseteqq\":\"⫆̸\",\"ntgl\":\"≹\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"ntlg\":\"≸\",\"ntriangleleft\":\"⋪\",\"ntrianglelefteq\":\"⋬\",\"ntriangleright\":\"⋫\",\"ntrianglerighteq\":\"⋭\",\"Nu\":\"Ν\",\"nu\":\"ν\",\"num\":\"#\",\"numero\":\"№\",\"numsp\":\" \",\"nvap\":\"≍⃒\",\"nvdash\":\"⊬\",\"nvDash\":\"⊭\",\"nVdash\":\"⊮\",\"nVDash\":\"⊯\",\"nvge\":\"≥⃒\",\"nvgt\":\">⃒\",\"nvHarr\":\"⤄\",\"nvinfin\":\"⧞\",\"nvlArr\":\"⤂\",\"nvle\":\"≤⃒\",\"nvlt\":\"<⃒\",\"nvltrie\":\"⊴⃒\",\"nvrArr\":\"⤃\",\"nvrtrie\":\"⊵⃒\",\"nvsim\":\"∼⃒\",\"nwarhk\":\"⤣\",\"nwarr\":\"↖\",\"nwArr\":\"⇖\",\"nwarrow\":\"↖\",\"nwnear\":\"⤧\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"oast\":\"⊛\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"ocir\":\"⊚\",\"Ocy\":\"О\",\"ocy\":\"о\",\"odash\":\"⊝\",\"Odblac\":\"Ő\",\"odblac\":\"ő\",\"odiv\":\"⨸\",\"odot\":\"⊙\",\"odsold\":\"⦼\",\"OElig\":\"Œ\",\"oelig\":\"œ\",\"ofcir\":\"⦿\",\"Ofr\":\"𝔒\",\"ofr\":\"𝔬\",\"ogon\":\"˛\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ogt\":\"⧁\",\"ohbar\":\"⦵\",\"ohm\":\"Ω\",\"oint\":\"∮\",\"olarr\":\"↺\",\"olcir\":\"⦾\",\"olcross\":\"⦻\",\"oline\":\"‾\",\"olt\":\"⧀\",\"Omacr\":\"Ō\",\"omacr\":\"ō\",\"Omega\":\"Ω\",\"omega\":\"ω\",\"Omicron\":\"Ο\",\"omicron\":\"ο\",\"omid\":\"⦶\",\"ominus\":\"⊖\",\"Oopf\":\"𝕆\",\"oopf\":\"𝕠\",\"opar\":\"⦷\",\"OpenCurlyDoubleQuote\":\"“\",\"OpenCurlyQuote\":\"‘\",\"operp\":\"⦹\",\"oplus\":\"⊕\",\"orarr\":\"↻\",\"Or\":\"⩔\",\"or\":\"∨\",\"ord\":\"⩝\",\"order\":\"ℴ\",\"orderof\":\"ℴ\",\"ordf\":\"ª\",\"ordm\":\"º\",\"origof\":\"⊶\",\"oror\":\"⩖\",\"orslope\":\"⩗\",\"orv\":\"⩛\",\"oS\":\"Ⓢ\",\"Oscr\":\"𝒪\",\"oscr\":\"ℴ\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"osol\":\"⊘\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"otimesas\":\"⨶\",\"Otimes\":\"⨷\",\"otimes\":\"⊗\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"ovbar\":\"⌽\",\"OverBar\":\"‾\",\"OverBrace\":\"⏞\",\"OverBracket\":\"⎴\",\"OverParenthesis\":\"⏜\",\"para\":\"¶\",\"parallel\":\"∥\",\"par\":\"∥\",\"parsim\":\"⫳\",\"parsl\":\"⫽\",\"part\":\"∂\",\"PartialD\":\"∂\",\"Pcy\":\"П\",\"pcy\":\"п\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"‰\",\"perp\":\"⊥\",\"pertenk\":\"‱\",\"Pfr\":\"𝔓\",\"pfr\":\"𝔭\",\"Phi\":\"Φ\",\"phi\":\"φ\",\"phiv\":\"ϕ\",\"phmmat\":\"ℳ\",\"phone\":\"☎\",\"Pi\":\"Π\",\"pi\":\"π\",\"pitchfork\":\"⋔\",\"piv\":\"ϖ\",\"planck\":\"ℏ\",\"planckh\":\"ℎ\",\"plankv\":\"ℏ\",\"plusacir\":\"⨣\",\"plusb\":\"⊞\",\"pluscir\":\"⨢\",\"plus\":\"+\",\"plusdo\":\"∔\",\"plusdu\":\"⨥\",\"pluse\":\"⩲\",\"PlusMinus\":\"±\",\"plusmn\":\"±\",\"plussim\":\"⨦\",\"plustwo\":\"⨧\",\"pm\":\"±\",\"Poincareplane\":\"ℌ\",\"pointint\":\"⨕\",\"popf\":\"𝕡\",\"Popf\":\"ℙ\",\"pound\":\"£\",\"prap\":\"⪷\",\"Pr\":\"⪻\",\"pr\":\"≺\",\"prcue\":\"≼\",\"precapprox\":\"⪷\",\"prec\":\"≺\",\"preccurlyeq\":\"≼\",\"Precedes\":\"≺\",\"PrecedesEqual\":\"⪯\",\"PrecedesSlantEqual\":\"≼\",\"PrecedesTilde\":\"≾\",\"preceq\":\"⪯\",\"precnapprox\":\"⪹\",\"precneqq\":\"⪵\",\"precnsim\":\"⋨\",\"pre\":\"⪯\",\"prE\":\"⪳\",\"precsim\":\"≾\",\"prime\":\"′\",\"Prime\":\"″\",\"primes\":\"ℙ\",\"prnap\":\"⪹\",\"prnE\":\"⪵\",\"prnsim\":\"⋨\",\"prod\":\"∏\",\"Product\":\"∏\",\"profalar\":\"⌮\",\"profline\":\"⌒\",\"profsurf\":\"⌓\",\"prop\":\"∝\",\"Proportional\":\"∝\",\"Proportion\":\"∷\",\"propto\":\"∝\",\"prsim\":\"≾\",\"prurel\":\"⊰\",\"Pscr\":\"𝒫\",\"pscr\":\"𝓅\",\"Psi\":\"Ψ\",\"psi\":\"ψ\",\"puncsp\":\" \",\"Qfr\":\"𝔔\",\"qfr\":\"𝔮\",\"qint\":\"⨌\",\"qopf\":\"𝕢\",\"Qopf\":\"ℚ\",\"qprime\":\"⁗\",\"Qscr\":\"𝒬\",\"qscr\":\"𝓆\",\"quaternions\":\"ℍ\",\"quatint\":\"⨖\",\"quest\":\"?\",\"questeq\":\"≟\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"rAarr\":\"⇛\",\"race\":\"∽̱\",\"Racute\":\"Ŕ\",\"racute\":\"ŕ\",\"radic\":\"√\",\"raemptyv\":\"⦳\",\"rang\":\"⟩\",\"Rang\":\"⟫\",\"rangd\":\"⦒\",\"range\":\"⦥\",\"rangle\":\"⟩\",\"raquo\":\"»\",\"rarrap\":\"⥵\",\"rarrb\":\"⇥\",\"rarrbfs\":\"⤠\",\"rarrc\":\"⤳\",\"rarr\":\"→\",\"Rarr\":\"↠\",\"rArr\":\"⇒\",\"rarrfs\":\"⤞\",\"rarrhk\":\"↪\",\"rarrlp\":\"↬\",\"rarrpl\":\"⥅\",\"rarrsim\":\"⥴\",\"Rarrtl\":\"⤖\",\"rarrtl\":\"↣\",\"rarrw\":\"↝\",\"ratail\":\"⤚\",\"rAtail\":\"⤜\",\"ratio\":\"∶\",\"rationals\":\"ℚ\",\"rbarr\":\"⤍\",\"rBarr\":\"⤏\",\"RBarr\":\"⤐\",\"rbbrk\":\"❳\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"⦌\",\"rbrksld\":\"⦎\",\"rbrkslu\":\"⦐\",\"Rcaron\":\"Ř\",\"rcaron\":\"ř\",\"Rcedil\":\"Ŗ\",\"rcedil\":\"ŗ\",\"rceil\":\"⌉\",\"rcub\":\"}\",\"Rcy\":\"Р\",\"rcy\":\"р\",\"rdca\":\"⤷\",\"rdldhar\":\"⥩\",\"rdquo\":\"”\",\"rdquor\":\"”\",\"rdsh\":\"↳\",\"real\":\"ℜ\",\"realine\":\"ℛ\",\"realpart\":\"ℜ\",\"reals\":\"ℝ\",\"Re\":\"ℜ\",\"rect\":\"▭\",\"reg\":\"®\",\"REG\":\"®\",\"ReverseElement\":\"∋\",\"ReverseEquilibrium\":\"⇋\",\"ReverseUpEquilibrium\":\"⥯\",\"rfisht\":\"⥽\",\"rfloor\":\"⌋\",\"rfr\":\"𝔯\",\"Rfr\":\"ℜ\",\"rHar\":\"⥤\",\"rhard\":\"⇁\",\"rharu\":\"⇀\",\"rharul\":\"⥬\",\"Rho\":\"Ρ\",\"rho\":\"ρ\",\"rhov\":\"ϱ\",\"RightAngleBracket\":\"⟩\",\"RightArrowBar\":\"⇥\",\"rightarrow\":\"→\",\"RightArrow\":\"→\",\"Rightarrow\":\"⇒\",\"RightArrowLeftArrow\":\"⇄\",\"rightarrowtail\":\"↣\",\"RightCeiling\":\"⌉\",\"RightDoubleBracket\":\"⟧\",\"RightDownTeeVector\":\"⥝\",\"RightDownVectorBar\":\"⥕\",\"RightDownVector\":\"⇂\",\"RightFloor\":\"⌋\",\"rightharpoondown\":\"⇁\",\"rightharpoonup\":\"⇀\",\"rightleftarrows\":\"⇄\",\"rightleftharpoons\":\"⇌\",\"rightrightarrows\":\"⇉\",\"rightsquigarrow\":\"↝\",\"RightTeeArrow\":\"↦\",\"RightTee\":\"⊢\",\"RightTeeVector\":\"⥛\",\"rightthreetimes\":\"⋌\",\"RightTriangleBar\":\"⧐\",\"RightTriangle\":\"⊳\",\"RightTriangleEqual\":\"⊵\",\"RightUpDownVector\":\"⥏\",\"RightUpTeeVector\":\"⥜\",\"RightUpVectorBar\":\"⥔\",\"RightUpVector\":\"↾\",\"RightVectorBar\":\"⥓\",\"RightVector\":\"⇀\",\"ring\":\"˚\",\"risingdotseq\":\"≓\",\"rlarr\":\"⇄\",\"rlhar\":\"⇌\",\"rlm\":\"‏\",\"rmoustache\":\"⎱\",\"rmoust\":\"⎱\",\"rnmid\":\"⫮\",\"roang\":\"⟭\",\"roarr\":\"⇾\",\"robrk\":\"⟧\",\"ropar\":\"⦆\",\"ropf\":\"𝕣\",\"Ropf\":\"ℝ\",\"roplus\":\"⨮\",\"rotimes\":\"⨵\",\"RoundImplies\":\"⥰\",\"rpar\":\")\",\"rpargt\":\"⦔\",\"rppolint\":\"⨒\",\"rrarr\":\"⇉\",\"Rrightarrow\":\"⇛\",\"rsaquo\":\"›\",\"rscr\":\"𝓇\",\"Rscr\":\"ℛ\",\"rsh\":\"↱\",\"Rsh\":\"↱\",\"rsqb\":\"]\",\"rsquo\":\"’\",\"rsquor\":\"’\",\"rthree\":\"⋌\",\"rtimes\":\"⋊\",\"rtri\":\"▹\",\"rtrie\":\"⊵\",\"rtrif\":\"▸\",\"rtriltri\":\"⧎\",\"RuleDelayed\":\"⧴\",\"ruluhar\":\"⥨\",\"rx\":\"℞\",\"Sacute\":\"Ś\",\"sacute\":\"ś\",\"sbquo\":\"‚\",\"scap\":\"⪸\",\"Scaron\":\"Š\",\"scaron\":\"š\",\"Sc\":\"⪼\",\"sc\":\"≻\",\"sccue\":\"≽\",\"sce\":\"⪰\",\"scE\":\"⪴\",\"Scedil\":\"Ş\",\"scedil\":\"ş\",\"Scirc\":\"Ŝ\",\"scirc\":\"ŝ\",\"scnap\":\"⪺\",\"scnE\":\"⪶\",\"scnsim\":\"⋩\",\"scpolint\":\"⨓\",\"scsim\":\"≿\",\"Scy\":\"С\",\"scy\":\"с\",\"sdotb\":\"⊡\",\"sdot\":\"⋅\",\"sdote\":\"⩦\",\"searhk\":\"⤥\",\"searr\":\"↘\",\"seArr\":\"⇘\",\"searrow\":\"↘\",\"sect\":\"§\",\"semi\":\";\",\"seswar\":\"⤩\",\"setminus\":\"∖\",\"setmn\":\"∖\",\"sext\":\"✶\",\"Sfr\":\"𝔖\",\"sfr\":\"𝔰\",\"sfrown\":\"⌢\",\"sharp\":\"♯\",\"SHCHcy\":\"Щ\",\"shchcy\":\"щ\",\"SHcy\":\"Ш\",\"shcy\":\"ш\",\"ShortDownArrow\":\"↓\",\"ShortLeftArrow\":\"←\",\"shortmid\":\"∣\",\"shortparallel\":\"∥\",\"ShortRightArrow\":\"→\",\"ShortUpArrow\":\"↑\",\"shy\":\"­\",\"Sigma\":\"Σ\",\"sigma\":\"σ\",\"sigmaf\":\"ς\",\"sigmav\":\"ς\",\"sim\":\"∼\",\"simdot\":\"⩪\",\"sime\":\"≃\",\"simeq\":\"≃\",\"simg\":\"⪞\",\"simgE\":\"⪠\",\"siml\":\"⪝\",\"simlE\":\"⪟\",\"simne\":\"≆\",\"simplus\":\"⨤\",\"simrarr\":\"⥲\",\"slarr\":\"←\",\"SmallCircle\":\"∘\",\"smallsetminus\":\"∖\",\"smashp\":\"⨳\",\"smeparsl\":\"⧤\",\"smid\":\"∣\",\"smile\":\"⌣\",\"smt\":\"⪪\",\"smte\":\"⪬\",\"smtes\":\"⪬︀\",\"SOFTcy\":\"Ь\",\"softcy\":\"ь\",\"solbar\":\"⌿\",\"solb\":\"⧄\",\"sol\":\"/\",\"Sopf\":\"𝕊\",\"sopf\":\"𝕤\",\"spades\":\"♠\",\"spadesuit\":\"♠\",\"spar\":\"∥\",\"sqcap\":\"⊓\",\"sqcaps\":\"⊓︀\",\"sqcup\":\"⊔\",\"sqcups\":\"⊔︀\",\"Sqrt\":\"√\",\"sqsub\":\"⊏\",\"sqsube\":\"⊑\",\"sqsubset\":\"⊏\",\"sqsubseteq\":\"⊑\",\"sqsup\":\"⊐\",\"sqsupe\":\"⊒\",\"sqsupset\":\"⊐\",\"sqsupseteq\":\"⊒\",\"square\":\"□\",\"Square\":\"□\",\"SquareIntersection\":\"⊓\",\"SquareSubset\":\"⊏\",\"SquareSubsetEqual\":\"⊑\",\"SquareSuperset\":\"⊐\",\"SquareSupersetEqual\":\"⊒\",\"SquareUnion\":\"⊔\",\"squarf\":\"▪\",\"squ\":\"□\",\"squf\":\"▪\",\"srarr\":\"→\",\"Sscr\":\"𝒮\",\"sscr\":\"𝓈\",\"ssetmn\":\"∖\",\"ssmile\":\"⌣\",\"sstarf\":\"⋆\",\"Star\":\"⋆\",\"star\":\"☆\",\"starf\":\"★\",\"straightepsilon\":\"ϵ\",\"straightphi\":\"ϕ\",\"strns\":\"¯\",\"sub\":\"⊂\",\"Sub\":\"⋐\",\"subdot\":\"⪽\",\"subE\":\"⫅\",\"sube\":\"⊆\",\"subedot\":\"⫃\",\"submult\":\"⫁\",\"subnE\":\"⫋\",\"subne\":\"⊊\",\"subplus\":\"⪿\",\"subrarr\":\"⥹\",\"subset\":\"⊂\",\"Subset\":\"⋐\",\"subseteq\":\"⊆\",\"subseteqq\":\"⫅\",\"SubsetEqual\":\"⊆\",\"subsetneq\":\"⊊\",\"subsetneqq\":\"⫋\",\"subsim\":\"⫇\",\"subsub\":\"⫕\",\"subsup\":\"⫓\",\"succapprox\":\"⪸\",\"succ\":\"≻\",\"succcurlyeq\":\"≽\",\"Succeeds\":\"≻\",\"SucceedsEqual\":\"⪰\",\"SucceedsSlantEqual\":\"≽\",\"SucceedsTilde\":\"≿\",\"succeq\":\"⪰\",\"succnapprox\":\"⪺\",\"succneqq\":\"⪶\",\"succnsim\":\"⋩\",\"succsim\":\"≿\",\"SuchThat\":\"∋\",\"sum\":\"∑\",\"Sum\":\"∑\",\"sung\":\"♪\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"sup\":\"⊃\",\"Sup\":\"⋑\",\"supdot\":\"⪾\",\"supdsub\":\"⫘\",\"supE\":\"⫆\",\"supe\":\"⊇\",\"supedot\":\"⫄\",\"Superset\":\"⊃\",\"SupersetEqual\":\"⊇\",\"suphsol\":\"⟉\",\"suphsub\":\"⫗\",\"suplarr\":\"⥻\",\"supmult\":\"⫂\",\"supnE\":\"⫌\",\"supne\":\"⊋\",\"supplus\":\"⫀\",\"supset\":\"⊃\",\"Supset\":\"⋑\",\"supseteq\":\"⊇\",\"supseteqq\":\"⫆\",\"supsetneq\":\"⊋\",\"supsetneqq\":\"⫌\",\"supsim\":\"⫈\",\"supsub\":\"⫔\",\"supsup\":\"⫖\",\"swarhk\":\"⤦\",\"swarr\":\"↙\",\"swArr\":\"⇙\",\"swarrow\":\"↙\",\"swnwar\":\"⤪\",\"szlig\":\"ß\",\"Tab\":\"\\t\",\"target\":\"⌖\",\"Tau\":\"Τ\",\"tau\":\"τ\",\"tbrk\":\"⎴\",\"Tcaron\":\"Ť\",\"tcaron\":\"ť\",\"Tcedil\":\"Ţ\",\"tcedil\":\"ţ\",\"Tcy\":\"Т\",\"tcy\":\"т\",\"tdot\":\"⃛\",\"telrec\":\"⌕\",\"Tfr\":\"𝔗\",\"tfr\":\"𝔱\",\"there4\":\"∴\",\"therefore\":\"∴\",\"Therefore\":\"∴\",\"Theta\":\"Θ\",\"theta\":\"θ\",\"thetasym\":\"ϑ\",\"thetav\":\"ϑ\",\"thickapprox\":\"≈\",\"thicksim\":\"∼\",\"ThickSpace\":\"  \",\"ThinSpace\":\" \",\"thinsp\":\" \",\"thkap\":\"≈\",\"thksim\":\"∼\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"tilde\":\"˜\",\"Tilde\":\"∼\",\"TildeEqual\":\"≃\",\"TildeFullEqual\":\"≅\",\"TildeTilde\":\"≈\",\"timesbar\":\"⨱\",\"timesb\":\"⊠\",\"times\":\"×\",\"timesd\":\"⨰\",\"tint\":\"∭\",\"toea\":\"⤨\",\"topbot\":\"⌶\",\"topcir\":\"⫱\",\"top\":\"⊤\",\"Topf\":\"𝕋\",\"topf\":\"𝕥\",\"topfork\":\"⫚\",\"tosa\":\"⤩\",\"tprime\":\"‴\",\"trade\":\"™\",\"TRADE\":\"™\",\"triangle\":\"▵\",\"triangledown\":\"▿\",\"triangleleft\":\"◃\",\"trianglelefteq\":\"⊴\",\"triangleq\":\"≜\",\"triangleright\":\"▹\",\"trianglerighteq\":\"⊵\",\"tridot\":\"◬\",\"trie\":\"≜\",\"triminus\":\"⨺\",\"TripleDot\":\"⃛\",\"triplus\":\"⨹\",\"trisb\":\"⧍\",\"tritime\":\"⨻\",\"trpezium\":\"⏢\",\"Tscr\":\"𝒯\",\"tscr\":\"𝓉\",\"TScy\":\"Ц\",\"tscy\":\"ц\",\"TSHcy\":\"Ћ\",\"tshcy\":\"ћ\",\"Tstrok\":\"Ŧ\",\"tstrok\":\"ŧ\",\"twixt\":\"≬\",\"twoheadleftarrow\":\"↞\",\"twoheadrightarrow\":\"↠\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"uarr\":\"↑\",\"Uarr\":\"↟\",\"uArr\":\"⇑\",\"Uarrocir\":\"⥉\",\"Ubrcy\":\"Ў\",\"ubrcy\":\"ў\",\"Ubreve\":\"Ŭ\",\"ubreve\":\"ŭ\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ucy\":\"У\",\"ucy\":\"у\",\"udarr\":\"⇅\",\"Udblac\":\"Ű\",\"udblac\":\"ű\",\"udhar\":\"⥮\",\"ufisht\":\"⥾\",\"Ufr\":\"𝔘\",\"ufr\":\"𝔲\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uHar\":\"⥣\",\"uharl\":\"↿\",\"uharr\":\"↾\",\"uhblk\":\"▀\",\"ulcorn\":\"⌜\",\"ulcorner\":\"⌜\",\"ulcrop\":\"⌏\",\"ultri\":\"◸\",\"Umacr\":\"Ū\",\"umacr\":\"ū\",\"uml\":\"¨\",\"UnderBar\":\"_\",\"UnderBrace\":\"⏟\",\"UnderBracket\":\"⎵\",\"UnderParenthesis\":\"⏝\",\"Union\":\"⋃\",\"UnionPlus\":\"⊎\",\"Uogon\":\"Ų\",\"uogon\":\"ų\",\"Uopf\":\"𝕌\",\"uopf\":\"𝕦\",\"UpArrowBar\":\"⤒\",\"uparrow\":\"↑\",\"UpArrow\":\"↑\",\"Uparrow\":\"⇑\",\"UpArrowDownArrow\":\"⇅\",\"updownarrow\":\"↕\",\"UpDownArrow\":\"↕\",\"Updownarrow\":\"⇕\",\"UpEquilibrium\":\"⥮\",\"upharpoonleft\":\"↿\",\"upharpoonright\":\"↾\",\"uplus\":\"⊎\",\"UpperLeftArrow\":\"↖\",\"UpperRightArrow\":\"↗\",\"upsi\":\"υ\",\"Upsi\":\"ϒ\",\"upsih\":\"ϒ\",\"Upsilon\":\"Υ\",\"upsilon\":\"υ\",\"UpTeeArrow\":\"↥\",\"UpTee\":\"⊥\",\"upuparrows\":\"⇈\",\"urcorn\":\"⌝\",\"urcorner\":\"⌝\",\"urcrop\":\"⌎\",\"Uring\":\"Ů\",\"uring\":\"ů\",\"urtri\":\"◹\",\"Uscr\":\"𝒰\",\"uscr\":\"𝓊\",\"utdot\":\"⋰\",\"Utilde\":\"Ũ\",\"utilde\":\"ũ\",\"utri\":\"▵\",\"utrif\":\"▴\",\"uuarr\":\"⇈\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"uwangle\":\"⦧\",\"vangrt\":\"⦜\",\"varepsilon\":\"ϵ\",\"varkappa\":\"ϰ\",\"varnothing\":\"∅\",\"varphi\":\"ϕ\",\"varpi\":\"ϖ\",\"varpropto\":\"∝\",\"varr\":\"↕\",\"vArr\":\"⇕\",\"varrho\":\"ϱ\",\"varsigma\":\"ς\",\"varsubsetneq\":\"⊊︀\",\"varsubsetneqq\":\"⫋︀\",\"varsupsetneq\":\"⊋︀\",\"varsupsetneqq\":\"⫌︀\",\"vartheta\":\"ϑ\",\"vartriangleleft\":\"⊲\",\"vartriangleright\":\"⊳\",\"vBar\":\"⫨\",\"Vbar\":\"⫫\",\"vBarv\":\"⫩\",\"Vcy\":\"В\",\"vcy\":\"в\",\"vdash\":\"⊢\",\"vDash\":\"⊨\",\"Vdash\":\"⊩\",\"VDash\":\"⊫\",\"Vdashl\":\"⫦\",\"veebar\":\"⊻\",\"vee\":\"∨\",\"Vee\":\"⋁\",\"veeeq\":\"≚\",\"vellip\":\"⋮\",\"verbar\":\"|\",\"Verbar\":\"‖\",\"vert\":\"|\",\"Vert\":\"‖\",\"VerticalBar\":\"∣\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"❘\",\"VerticalTilde\":\"≀\",\"VeryThinSpace\":\" \",\"Vfr\":\"𝔙\",\"vfr\":\"𝔳\",\"vltri\":\"⊲\",\"vnsub\":\"⊂⃒\",\"vnsup\":\"⊃⃒\",\"Vopf\":\"𝕍\",\"vopf\":\"𝕧\",\"vprop\":\"∝\",\"vrtri\":\"⊳\",\"Vscr\":\"𝒱\",\"vscr\":\"𝓋\",\"vsubnE\":\"⫋︀\",\"vsubne\":\"⊊︀\",\"vsupnE\":\"⫌︀\",\"vsupne\":\"⊋︀\",\"Vvdash\":\"⊪\",\"vzigzag\":\"⦚\",\"Wcirc\":\"Ŵ\",\"wcirc\":\"ŵ\",\"wedbar\":\"⩟\",\"wedge\":\"∧\",\"Wedge\":\"⋀\",\"wedgeq\":\"≙\",\"weierp\":\"℘\",\"Wfr\":\"𝔚\",\"wfr\":\"𝔴\",\"Wopf\":\"𝕎\",\"wopf\":\"𝕨\",\"wp\":\"℘\",\"wr\":\"≀\",\"wreath\":\"≀\",\"Wscr\":\"𝒲\",\"wscr\":\"𝓌\",\"xcap\":\"⋂\",\"xcirc\":\"◯\",\"xcup\":\"⋃\",\"xdtri\":\"▽\",\"Xfr\":\"𝔛\",\"xfr\":\"𝔵\",\"xharr\":\"⟷\",\"xhArr\":\"⟺\",\"Xi\":\"Ξ\",\"xi\":\"ξ\",\"xlarr\":\"⟵\",\"xlArr\":\"⟸\",\"xmap\":\"⟼\",\"xnis\":\"⋻\",\"xodot\":\"⨀\",\"Xopf\":\"𝕏\",\"xopf\":\"𝕩\",\"xoplus\":\"⨁\",\"xotime\":\"⨂\",\"xrarr\":\"⟶\",\"xrArr\":\"⟹\",\"Xscr\":\"𝒳\",\"xscr\":\"𝓍\",\"xsqcup\":\"⨆\",\"xuplus\":\"⨄\",\"xutri\":\"△\",\"xvee\":\"⋁\",\"xwedge\":\"⋀\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"YAcy\":\"Я\",\"yacy\":\"я\",\"Ycirc\":\"Ŷ\",\"ycirc\":\"ŷ\",\"Ycy\":\"Ы\",\"ycy\":\"ы\",\"yen\":\"¥\",\"Yfr\":\"𝔜\",\"yfr\":\"𝔶\",\"YIcy\":\"Ї\",\"yicy\":\"ї\",\"Yopf\":\"𝕐\",\"yopf\":\"𝕪\",\"Yscr\":\"𝒴\",\"yscr\":\"𝓎\",\"YUcy\":\"Ю\",\"yucy\":\"ю\",\"yuml\":\"ÿ\",\"Yuml\":\"Ÿ\",\"Zacute\":\"Ź\",\"zacute\":\"ź\",\"Zcaron\":\"Ž\",\"zcaron\":\"ž\",\"Zcy\":\"З\",\"zcy\":\"з\",\"Zdot\":\"Ż\",\"zdot\":\"ż\",\"zeetrf\":\"ℨ\",\"ZeroWidthSpace\":\"​\",\"Zeta\":\"Ζ\",\"zeta\":\"ζ\",\"zfr\":\"𝔷\",\"Zfr\":\"ℨ\",\"ZHcy\":\"Ж\",\"zhcy\":\"ж\",\"zigrarr\":\"⇝\",\"zopf\":\"𝕫\",\"Zopf\":\"ℤ\",\"Zscr\":\"𝒵\",\"zscr\":\"𝓏\",\"zwj\":\"‍\",\"zwnj\":\"‌\"}");

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json":
/*!********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json ***!
  \********************************************************************************/
/*! exports provided: Aacute, aacute, Acirc, acirc, acute, AElig, aelig, Agrave, agrave, amp, AMP, Aring, aring, Atilde, atilde, Auml, auml, brvbar, Ccedil, ccedil, cedil, cent, copy, COPY, curren, deg, divide, Eacute, eacute, Ecirc, ecirc, Egrave, egrave, ETH, eth, Euml, euml, frac12, frac14, frac34, gt, GT, Iacute, iacute, Icirc, icirc, iexcl, Igrave, igrave, iquest, Iuml, iuml, laquo, lt, LT, macr, micro, middot, nbsp, not, Ntilde, ntilde, Oacute, oacute, Ocirc, ocirc, Ograve, ograve, ordf, ordm, Oslash, oslash, Otilde, otilde, Ouml, ouml, para, plusmn, pound, quot, QUOT, raquo, reg, REG, sect, shy, sup1, sup2, sup3, szlig, THORN, thorn, times, Uacute, uacute, Ucirc, ucirc, Ugrave, ugrave, uml, Uuml, uuml, Yacute, yacute, yen, yuml, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"Agrave\":\"À\",\"agrave\":\"à\",\"amp\":\"&\",\"AMP\":\"&\",\"Aring\":\"Å\",\"aring\":\"å\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"brvbar\":\"¦\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"cedil\":\"¸\",\"cent\":\"¢\",\"copy\":\"©\",\"COPY\":\"©\",\"curren\":\"¤\",\"deg\":\"°\",\"divide\":\"÷\",\"Eacute\":\"É\",\"eacute\":\"é\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"Egrave\":\"È\",\"egrave\":\"è\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"frac12\":\"½\",\"frac14\":\"¼\",\"frac34\":\"¾\",\"gt\":\">\",\"GT\":\">\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"iexcl\":\"¡\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"iquest\":\"¿\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"laquo\":\"«\",\"lt\":\"<\",\"LT\":\"<\",\"macr\":\"¯\",\"micro\":\"µ\",\"middot\":\"·\",\"nbsp\":\" \",\"not\":\"¬\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ordf\":\"ª\",\"ordm\":\"º\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"para\":\"¶\",\"plusmn\":\"±\",\"pound\":\"£\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"raquo\":\"»\",\"reg\":\"®\",\"REG\":\"®\",\"sect\":\"§\",\"shy\":\"­\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"szlig\":\"ß\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"times\":\"×\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uml\":\"¨\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"yen\":\"¥\",\"yuml\":\"ÿ\"}");

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json":
/*!*****************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json ***!
  \*****************************************************************************/
/*! exports provided: amp, apos, gt, lt, quot, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"amp\":\"&\",\"apos\":\"'\",\"gt\":\">\",\"lt\":\"<\",\"quot\":\"\\\"\"}");

/***/ }),

/***/ "./node_modules/domelementtype/index.js":
/*!**********************************************!*\
  !*** ./node_modules/domelementtype/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//Types of elements found in the DOM
module.exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>
	Doctype: "doctype",

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};


/***/ }),

/***/ "./node_modules/domhandler/index.js":
/*!******************************************!*\
  !*** ./node_modules/domhandler/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/index.js");

var re_whitespace = /\s+/g;
var NodePrototype = __webpack_require__(/*! ./lib/node */ "./node_modules/domhandler/lib/node.js");
var ElementPrototype = __webpack_require__(/*! ./lib/element */ "./node_modules/domhandler/lib/element.js");

function DomHandler(callback, options, elementCB){
	if(typeof callback === "object"){
		elementCB = options;
		options = callback;
		callback = null;
	} else if(typeof options === "function"){
		elementCB = options;
		options = defaultOpts;
	}
	this._callback = callback;
	this._options = options || defaultOpts;
	this._elementCB = elementCB;
	this.dom = [];
	this._done = false;
	this._tagStack = [];
	this._parser = this._parser || null;
}

//default options
var defaultOpts = {
	normalizeWhitespace: false, //Replace all whitespace with single spaces
	withStartIndices: false, //Add startIndex properties to nodes
	withEndIndices: false, //Add endIndex properties to nodes
};

DomHandler.prototype.onparserinit = function(parser){
	this._parser = parser;
};

//Resets the handler back to starting state
DomHandler.prototype.onreset = function(){
	DomHandler.call(this, this._callback, this._options, this._elementCB);
};

//Signals the handler that parsing is done
DomHandler.prototype.onend = function(){
	if(this._done) return;
	this._done = true;
	this._parser = null;
	this._handleCallback(null);
};

DomHandler.prototype._handleCallback =
DomHandler.prototype.onerror = function(error){
	if(typeof this._callback === "function"){
		this._callback(error, this.dom);
	} else {
		if(error) throw error;
	}
};

DomHandler.prototype.onclosetag = function(){
	//if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));
	
	var elem = this._tagStack.pop();

	if(this._options.withEndIndices && elem){
		elem.endIndex = this._parser.endIndex;
	}

	if(this._elementCB) this._elementCB(elem);
};

DomHandler.prototype._createDomElement = function(properties){
	if (!this._options.withDomLvl1) return properties;

	var element;
	if (properties.type === "tag") {
		element = Object.create(ElementPrototype);
	} else {
		element = Object.create(NodePrototype);
	}

	for (var key in properties) {
		if (properties.hasOwnProperty(key)) {
			element[key] = properties[key];
		}
	}

	return element;
};

DomHandler.prototype._addDomElement = function(element){
	var parent = this._tagStack[this._tagStack.length - 1];
	var siblings = parent ? parent.children : this.dom;
	var previousSibling = siblings[siblings.length - 1];

	element.next = null;

	if(this._options.withStartIndices){
		element.startIndex = this._parser.startIndex;
	}
	if(this._options.withEndIndices){
		element.endIndex = this._parser.endIndex;
	}

	if(previousSibling){
		element.prev = previousSibling;
		previousSibling.next = element;
	} else {
		element.prev = null;
	}

	siblings.push(element);
	element.parent = parent || null;
};

DomHandler.prototype.onopentag = function(name, attribs){
	var properties = {
		type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
		name: name,
		attribs: attribs,
		children: []
	};

	var element = this._createDomElement(properties);

	this._addDomElement(element);

	this._tagStack.push(element);
};

DomHandler.prototype.ontext = function(data){
	//the ignoreWhitespace is officially dropped, but for now,
	//it's an alias for normalizeWhitespace
	var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;

	var lastTag;

	if(!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length-1]).type === ElementType.Text){
		if(normalize){
			lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
		} else {
			lastTag.data += data;
		}
	} else {
		if(
			this._tagStack.length &&
			(lastTag = this._tagStack[this._tagStack.length - 1]) &&
			(lastTag = lastTag.children[lastTag.children.length - 1]) &&
			lastTag.type === ElementType.Text
		){
			if(normalize){
				lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
			} else {
				lastTag.data += data;
			}
		} else {
			if(normalize){
				data = data.replace(re_whitespace, " ");
			}

			var element = this._createDomElement({
				data: data,
				type: ElementType.Text
			});

			this._addDomElement(element);
		}
	}
};

DomHandler.prototype.oncomment = function(data){
	var lastTag = this._tagStack[this._tagStack.length - 1];

	if(lastTag && lastTag.type === ElementType.Comment){
		lastTag.data += data;
		return;
	}

	var properties = {
		data: data,
		type: ElementType.Comment
	};

	var element = this._createDomElement(properties);

	this._addDomElement(element);
	this._tagStack.push(element);
};

DomHandler.prototype.oncdatastart = function(){
	var properties = {
		children: [{
			data: "",
			type: ElementType.Text
		}],
		type: ElementType.CDATA
	};

	var element = this._createDomElement(properties);

	this._addDomElement(element);
	this._tagStack.push(element);
};

DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function(){
	this._tagStack.pop();
};

DomHandler.prototype.onprocessinginstruction = function(name, data){
	var element = this._createDomElement({
		name: name,
		data: data,
		type: ElementType.Directive
	});

	this._addDomElement(element);
};

module.exports = DomHandler;


/***/ }),

/***/ "./node_modules/domhandler/lib/element.js":
/*!************************************************!*\
  !*** ./node_modules/domhandler/lib/element.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// DOM-Level-1-compliant structure
var NodePrototype = __webpack_require__(/*! ./node */ "./node_modules/domhandler/lib/node.js");
var ElementPrototype = module.exports = Object.create(NodePrototype);

var domLvl1 = {
	tagName: "name"
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(ElementPrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});


/***/ }),

/***/ "./node_modules/domhandler/lib/node.js":
/*!*********************************************!*\
  !*** ./node_modules/domhandler/lib/node.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var NodePrototype = module.exports = {
	get firstChild() {
		var children = this.children;
		return children && children[0] || null;
	},
	get lastChild() {
		var children = this.children;
		return children && children[children.length - 1] || null;
	},
	get nodeType() {
		return nodeTypes[this.type] || nodeTypes.element;
	}
};

var domLvl1 = {
	tagName: "name",
	childNodes: "children",
	parentNode: "parent",
	previousSibling: "prev",
	nextSibling: "next",
	nodeValue: "data"
};

var nodeTypes = {
	element: 1,
	text: 3,
	cdata: 4,
	comment: 8
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(NodePrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});


/***/ }),

/***/ "./node_modules/domutils/index.js":
/*!****************************************!*\
  !*** ./node_modules/domutils/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DomUtils = module.exports;

[
	__webpack_require__(/*! ./lib/stringify */ "./node_modules/domutils/lib/stringify.js"),
	__webpack_require__(/*! ./lib/traversal */ "./node_modules/domutils/lib/traversal.js"),
	__webpack_require__(/*! ./lib/manipulation */ "./node_modules/domutils/lib/manipulation.js"),
	__webpack_require__(/*! ./lib/querying */ "./node_modules/domutils/lib/querying.js"),
	__webpack_require__(/*! ./lib/legacy */ "./node_modules/domutils/lib/legacy.js"),
	__webpack_require__(/*! ./lib/helpers */ "./node_modules/domutils/lib/helpers.js")
].forEach(function(ext){
	Object.keys(ext).forEach(function(key){
		DomUtils[key] = ext[key].bind(DomUtils);
	});
});


/***/ }),

/***/ "./node_modules/domutils/lib/helpers.js":
/*!**********************************************!*\
  !*** ./node_modules/domutils/lib/helpers.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
exports.removeSubsets = function(nodes) {
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while (--idx > -1) {
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while (ancestor) {
			if (nodes.indexOf(ancestor) > -1) {
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = ancestor.parent;
		}

		// If the node has been found to be unique, re-insert it.
		if (replace) {
			nodes[idx] = node;
		}
	}

	return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var POSITION = {
	DISCONNECTED: 1,
	PRECEDING: 2,
	FOLLOWING: 4,
	CONTAINS: 8,
	CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
	var aParents = [];
	var bParents = [];
	var current, sharedParent, siblings, aSibling, bSibling, idx;

	if (nodeA === nodeB) {
		return 0;
	}

	current = nodeA;
	while (current) {
		aParents.unshift(current);
		current = current.parent;
	}
	current = nodeB;
	while (current) {
		bParents.unshift(current);
		current = current.parent;
	}

	idx = 0;
	while (aParents[idx] === bParents[idx]) {
		idx++;
	}

	if (idx === 0) {
		return POSITION.DISCONNECTED;
	}

	sharedParent = aParents[idx - 1];
	siblings = sharedParent.children;
	aSibling = aParents[idx];
	bSibling = bParents[idx];

	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		if (sharedParent === nodeB) {
			return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
		}
		return POSITION.FOLLOWING;
	} else {
		if (sharedParent === nodeA) {
			return POSITION.PRECEDING | POSITION.CONTAINS;
		}
		return POSITION.PRECEDING;
	}
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
exports.uniqueSort = function(nodes) {
	var idx = nodes.length, node, position;

	nodes = nodes.slice();

	while (--idx > -1) {
		node = nodes[idx];
		position = nodes.indexOf(node);
		if (position > -1 && position < idx) {
			nodes.splice(idx, 1);
		}
	}
	nodes.sort(function(a, b) {
		var relative = comparePos(a, b);
		if (relative & POSITION.PRECEDING) {
			return -1;
		} else if (relative & POSITION.FOLLOWING) {
			return 1;
		}
		return 0;
	});

	return nodes;
};


/***/ }),

/***/ "./node_modules/domutils/lib/legacy.js":
/*!*********************************************!*\
  !*** ./node_modules/domutils/lib/legacy.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/index.js");
var isTag = exports.isTag = ElementType.isTag;

exports.testElement = function(options, element){
	for(var key in options){
		if(!options.hasOwnProperty(key));
		else if(key === "tag_name"){
			if(!isTag(element) || !options.tag_name(element.name)){
				return false;
			}
		} else if(key === "tag_type"){
			if(!options.tag_type(element.type)) return false;
		} else if(key === "tag_contains"){
			if(isTag(element) || !options.tag_contains(element.data)){
				return false;
			}
		} else if(!element.attribs || !options[key](element.attribs[key])){
			return false;
		}
	}
	return true;
};

var Checks = {
	tag_name: function(name){
		if(typeof name === "function"){
			return function(elem){ return isTag(elem) && name(elem.name); };
		} else if(name === "*"){
			return isTag;
		} else {
			return function(elem){ return isTag(elem) && elem.name === name; };
		}
	},
	tag_type: function(type){
		if(typeof type === "function"){
			return function(elem){ return type(elem.type); };
		} else {
			return function(elem){ return elem.type === type; };
		}
	},
	tag_contains: function(data){
		if(typeof data === "function"){
			return function(elem){ return !isTag(elem) && data(elem.data); };
		} else {
			return function(elem){ return !isTag(elem) && elem.data === data; };
		}
	}
};

function getAttribCheck(attrib, value){
	if(typeof value === "function"){
		return function(elem){ return elem.attribs && value(elem.attribs[attrib]); };
	} else {
		return function(elem){ return elem.attribs && elem.attribs[attrib] === value; };
	}
}

function combineFuncs(a, b){
	return function(elem){
		return a(elem) || b(elem);
	};
}

exports.getElements = function(options, element, recurse, limit){
	var funcs = Object.keys(options).map(function(key){
		var value = options[key];
		return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
	});

	return funcs.length === 0 ? [] : this.filter(
		funcs.reduce(combineFuncs),
		element, recurse, limit
	);
};

exports.getElementById = function(id, element, recurse){
	if(!Array.isArray(element)) element = [element];
	return this.findOne(getAttribCheck("id", id), element, recurse !== false);
};

exports.getElementsByTagName = function(name, element, recurse, limit){
	return this.filter(Checks.tag_name(name), element, recurse, limit);
};

exports.getElementsByTagType = function(type, element, recurse, limit){
	return this.filter(Checks.tag_type(type), element, recurse, limit);
};


/***/ }),

/***/ "./node_modules/domutils/lib/manipulation.js":
/*!***************************************************!*\
  !*** ./node_modules/domutils/lib/manipulation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.removeElement = function(elem){
	if(elem.prev) elem.prev.next = elem.next;
	if(elem.next) elem.next.prev = elem.prev;

	if(elem.parent){
		var childs = elem.parent.children;
		childs.splice(childs.lastIndexOf(elem), 1);
	}
};

exports.replaceElement = function(elem, replacement){
	var prev = replacement.prev = elem.prev;
	if(prev){
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if(next){
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs[childs.lastIndexOf(elem)] = replacement;
	}
};

exports.appendChild = function(elem, child){
	child.parent = elem;

	if(elem.children.push(child) !== 1){
		var sibling = elem.children[elem.children.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
};

exports.append = function(elem, next){
	var parent = elem.parent,
		currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if(currNext){
		currNext.prev = next;
		if(parent){
			var childs = parent.children;
			childs.splice(childs.lastIndexOf(currNext), 0, next);
		}
	} else if(parent){
		parent.children.push(next);
	}
};

exports.prepend = function(elem, prev){
	var parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs.splice(childs.lastIndexOf(elem), 0, prev);
	}

	if(elem.prev){
		elem.prev.next = prev;
	}
	
	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
};




/***/ }),

/***/ "./node_modules/domutils/lib/querying.js":
/*!***********************************************!*\
  !*** ./node_modules/domutils/lib/querying.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isTag = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/index.js").isTag;

module.exports = {
	filter: filter,
	find: find,
	findOneChild: findOneChild,
	findOne: findOne,
	existsOne: existsOne,
	findAll: findAll
};

function filter(test, element, recurse, limit){
	if(!Array.isArray(element)) element = [element];

	if(typeof limit !== "number" || !isFinite(limit)){
		limit = Infinity;
	}
	return find(test, element, recurse !== false, limit);
}

function find(test, elems, recurse, limit){
	var result = [], childs;

	for(var i = 0, j = elems.length; i < j; i++){
		if(test(elems[i])){
			result.push(elems[i]);
			if(--limit <= 0) break;
		}

		childs = elems[i].children;
		if(recurse && childs && childs.length > 0){
			childs = find(test, childs, recurse, limit);
			result = result.concat(childs);
			limit -= childs.length;
			if(limit <= 0) break;
		}
	}

	return result;
}

function findOneChild(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(test(elems[i])) return elems[i];
	}

	return null;
}

function findOne(test, elems){
	var elem = null;

	for(var i = 0, l = elems.length; i < l && !elem; i++){
		if(!isTag(elems[i])){
			continue;
		} else if(test(elems[i])){
			elem = elems[i];
		} else if(elems[i].children.length > 0){
			elem = findOne(test, elems[i].children);
		}
	}

	return elem;
}

function existsOne(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(
			isTag(elems[i]) && (
				test(elems[i]) || (
					elems[i].children.length > 0 &&
					existsOne(test, elems[i].children)
				)
			)
		){
			return true;
		}
	}

	return false;
}

function findAll(test, rootElems){
	var result = [];
	var stack = rootElems.slice();
	while(stack.length){
		var elem = stack.shift();
		if(!isTag(elem)) continue;
		if (elem.children && elem.children.length > 0) {
			stack.unshift.apply(stack, elem.children);
		}
		if(test(elem)) result.push(elem);
	}
	return result;
}


/***/ }),

/***/ "./node_modules/domutils/lib/stringify.js":
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/stringify.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/index.js"),
    getOuterHTML = __webpack_require__(/*! dom-serializer */ "./node_modules/dom-serializer/index.js"),
    isTag = ElementType.isTag;

module.exports = {
	getInnerHTML: getInnerHTML,
	getOuterHTML: getOuterHTML,
	getText: getText
};

function getInnerHTML(elem, opts){
	return elem.children ? elem.children.map(function(elem){
		return getOuterHTML(elem, opts);
	}).join("") : "";
}

function getText(elem){
	if(Array.isArray(elem)) return elem.map(getText).join("");
	if(isTag(elem)) return elem.name === "br" ? "\n" : getText(elem.children);
	if(elem.type === ElementType.CDATA) return getText(elem.children);
	if(elem.type === ElementType.Text) return elem.data;
	return "";
}


/***/ }),

/***/ "./node_modules/domutils/lib/traversal.js":
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/traversal.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var getChildren = exports.getChildren = function(elem){
	return elem.children;
};

var getParent = exports.getParent = function(elem){
	return elem.parent;
};

exports.getSiblings = function(elem){
	var parent = getParent(elem);
	return parent ? getChildren(parent) : [elem];
};

exports.getAttributeValue = function(elem, name){
	return elem.attribs && elem.attribs[name];
};

exports.hasAttrib = function(elem, name){
	return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};

exports.getName = function(elem){
	return elem.name;
};


/***/ }),

/***/ "./node_modules/entities/lib/decode_codepoint.js":
/*!*******************************************************!*\
  !*** ./node_modules/entities/lib/decode_codepoint.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var decodeMap = __webpack_require__(/*! ../maps/decode.json */ "./node_modules/entities/maps/decode.json");

module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }

    if (codePoint in decodeMap) {
        codePoint = decodeMap[codePoint];
    }

    var output = "";

    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }

    output += String.fromCharCode(codePoint);
    return output;
}


/***/ }),

/***/ "./node_modules/entities/maps/decode.json":
/*!************************************************!*\
  !*** ./node_modules/entities/maps/decode.json ***!
  \************************************************/
/*! exports provided: 0, 128, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 142, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 158, 159, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"0\":65533,\"128\":8364,\"130\":8218,\"131\":402,\"132\":8222,\"133\":8230,\"134\":8224,\"135\":8225,\"136\":710,\"137\":8240,\"138\":352,\"139\":8249,\"140\":338,\"142\":381,\"145\":8216,\"146\":8217,\"147\":8220,\"148\":8221,\"149\":8226,\"150\":8211,\"151\":8212,\"152\":732,\"153\":8482,\"154\":353,\"155\":8250,\"156\":339,\"158\":382,\"159\":376}");

/***/ }),

/***/ "./node_modules/entities/maps/entities.json":
/*!**************************************************!*\
  !*** ./node_modules/entities/maps/entities.json ***!
  \**************************************************/
/*! exports provided: Aacute, aacute, Abreve, abreve, ac, acd, acE, Acirc, acirc, acute, Acy, acy, AElig, aelig, af, Afr, afr, Agrave, agrave, alefsym, aleph, Alpha, alpha, Amacr, amacr, amalg, amp, AMP, andand, And, and, andd, andslope, andv, ang, ange, angle, angmsdaa, angmsdab, angmsdac, angmsdad, angmsdae, angmsdaf, angmsdag, angmsdah, angmsd, angrt, angrtvb, angrtvbd, angsph, angst, angzarr, Aogon, aogon, Aopf, aopf, apacir, ap, apE, ape, apid, apos, ApplyFunction, approx, approxeq, Aring, aring, Ascr, ascr, Assign, ast, asymp, asympeq, Atilde, atilde, Auml, auml, awconint, awint, backcong, backepsilon, backprime, backsim, backsimeq, Backslash, Barv, barvee, barwed, Barwed, barwedge, bbrk, bbrktbrk, bcong, Bcy, bcy, bdquo, becaus, because, Because, bemptyv, bepsi, bernou, Bernoullis, Beta, beta, beth, between, Bfr, bfr, bigcap, bigcirc, bigcup, bigodot, bigoplus, bigotimes, bigsqcup, bigstar, bigtriangledown, bigtriangleup, biguplus, bigvee, bigwedge, bkarow, blacklozenge, blacksquare, blacktriangle, blacktriangledown, blacktriangleleft, blacktriangleright, blank, blk12, blk14, blk34, block, bne, bnequiv, bNot, bnot, Bopf, bopf, bot, bottom, bowtie, boxbox, boxdl, boxdL, boxDl, boxDL, boxdr, boxdR, boxDr, boxDR, boxh, boxH, boxhd, boxHd, boxhD, boxHD, boxhu, boxHu, boxhU, boxHU, boxminus, boxplus, boxtimes, boxul, boxuL, boxUl, boxUL, boxur, boxuR, boxUr, boxUR, boxv, boxV, boxvh, boxvH, boxVh, boxVH, boxvl, boxvL, boxVl, boxVL, boxvr, boxvR, boxVr, boxVR, bprime, breve, Breve, brvbar, bscr, Bscr, bsemi, bsim, bsime, bsolb, bsol, bsolhsub, bull, bullet, bump, bumpE, bumpe, Bumpeq, bumpeq, Cacute, cacute, capand, capbrcup, capcap, cap, Cap, capcup, capdot, CapitalDifferentialD, caps, caret, caron, Cayleys, ccaps, Ccaron, ccaron, Ccedil, ccedil, Ccirc, ccirc, Cconint, ccups, ccupssm, Cdot, cdot, cedil, Cedilla, cemptyv, cent, centerdot, CenterDot, cfr, Cfr, CHcy, chcy, check, checkmark, Chi, chi, circ, circeq, circlearrowleft, circlearrowright, circledast, circledcirc, circleddash, CircleDot, circledR, circledS, CircleMinus, CirclePlus, CircleTimes, cir, cirE, cire, cirfnint, cirmid, cirscir, ClockwiseContourIntegral, CloseCurlyDoubleQuote, CloseCurlyQuote, clubs, clubsuit, colon, Colon, Colone, colone, coloneq, comma, commat, comp, compfn, complement, complexes, cong, congdot, Congruent, conint, Conint, ContourIntegral, copf, Copf, coprod, Coproduct, copy, COPY, copysr, CounterClockwiseContourIntegral, crarr, cross, Cross, Cscr, cscr, csub, csube, csup, csupe, ctdot, cudarrl, cudarrr, cuepr, cuesc, cularr, cularrp, cupbrcap, cupcap, CupCap, cup, Cup, cupcup, cupdot, cupor, cups, curarr, curarrm, curlyeqprec, curlyeqsucc, curlyvee, curlywedge, curren, curvearrowleft, curvearrowright, cuvee, cuwed, cwconint, cwint, cylcty, dagger, Dagger, daleth, darr, Darr, dArr, dash, Dashv, dashv, dbkarow, dblac, Dcaron, dcaron, Dcy, dcy, ddagger, ddarr, DD, dd, DDotrahd, ddotseq, deg, Del, Delta, delta, demptyv, dfisht, Dfr, dfr, dHar, dharl, dharr, DiacriticalAcute, DiacriticalDot, DiacriticalDoubleAcute, DiacriticalGrave, DiacriticalTilde, diam, diamond, Diamond, diamondsuit, diams, die, DifferentialD, digamma, disin, div, divide, divideontimes, divonx, DJcy, djcy, dlcorn, dlcrop, dollar, Dopf, dopf, Dot, dot, DotDot, doteq, doteqdot, DotEqual, dotminus, dotplus, dotsquare, doublebarwedge, DoubleContourIntegral, DoubleDot, DoubleDownArrow, DoubleLeftArrow, DoubleLeftRightArrow, DoubleLeftTee, DoubleLongLeftArrow, DoubleLongLeftRightArrow, DoubleLongRightArrow, DoubleRightArrow, DoubleRightTee, DoubleUpArrow, DoubleUpDownArrow, DoubleVerticalBar, DownArrowBar, downarrow, DownArrow, Downarrow, DownArrowUpArrow, DownBreve, downdownarrows, downharpoonleft, downharpoonright, DownLeftRightVector, DownLeftTeeVector, DownLeftVectorBar, DownLeftVector, DownRightTeeVector, DownRightVectorBar, DownRightVector, DownTeeArrow, DownTee, drbkarow, drcorn, drcrop, Dscr, dscr, DScy, dscy, dsol, Dstrok, dstrok, dtdot, dtri, dtrif, duarr, duhar, dwangle, DZcy, dzcy, dzigrarr, Eacute, eacute, easter, Ecaron, ecaron, Ecirc, ecirc, ecir, ecolon, Ecy, ecy, eDDot, Edot, edot, eDot, ee, efDot, Efr, efr, eg, Egrave, egrave, egs, egsdot, el, Element, elinters, ell, els, elsdot, Emacr, emacr, empty, emptyset, EmptySmallSquare, emptyv, EmptyVerySmallSquare, emsp13, emsp14, emsp, ENG, eng, ensp, Eogon, eogon, Eopf, eopf, epar, eparsl, eplus, epsi, Epsilon, epsilon, epsiv, eqcirc, eqcolon, eqsim, eqslantgtr, eqslantless, Equal, equals, EqualTilde, equest, Equilibrium, equiv, equivDD, eqvparsl, erarr, erDot, escr, Escr, esdot, Esim, esim, Eta, eta, ETH, eth, Euml, euml, euro, excl, exist, Exists, expectation, exponentiale, ExponentialE, fallingdotseq, Fcy, fcy, female, ffilig, fflig, ffllig, Ffr, ffr, filig, FilledSmallSquare, FilledVerySmallSquare, fjlig, flat, fllig, fltns, fnof, Fopf, fopf, forall, ForAll, fork, forkv, Fouriertrf, fpartint, frac12, frac13, frac14, frac15, frac16, frac18, frac23, frac25, frac34, frac35, frac38, frac45, frac56, frac58, frac78, frasl, frown, fscr, Fscr, gacute, Gamma, gamma, Gammad, gammad, gap, Gbreve, gbreve, Gcedil, Gcirc, gcirc, Gcy, gcy, Gdot, gdot, ge, gE, gEl, gel, geq, geqq, geqslant, gescc, ges, gesdot, gesdoto, gesdotol, gesl, gesles, Gfr, gfr, gg, Gg, ggg, gimel, GJcy, gjcy, gla, gl, glE, glj, gnap, gnapprox, gne, gnE, gneq, gneqq, gnsim, Gopf, gopf, grave, GreaterEqual, GreaterEqualLess, GreaterFullEqual, GreaterGreater, GreaterLess, GreaterSlantEqual, GreaterTilde, Gscr, gscr, gsim, gsime, gsiml, gtcc, gtcir, gt, GT, Gt, gtdot, gtlPar, gtquest, gtrapprox, gtrarr, gtrdot, gtreqless, gtreqqless, gtrless, gtrsim, gvertneqq, gvnE, Hacek, hairsp, half, hamilt, HARDcy, hardcy, harrcir, harr, hArr, harrw, Hat, hbar, Hcirc, hcirc, hearts, heartsuit, hellip, hercon, hfr, Hfr, HilbertSpace, hksearow, hkswarow, hoarr, homtht, hookleftarrow, hookrightarrow, hopf, Hopf, horbar, HorizontalLine, hscr, Hscr, hslash, Hstrok, hstrok, HumpDownHump, HumpEqual, hybull, hyphen, Iacute, iacute, ic, Icirc, icirc, Icy, icy, Idot, IEcy, iecy, iexcl, iff, ifr, Ifr, Igrave, igrave, ii, iiiint, iiint, iinfin, iiota, IJlig, ijlig, Imacr, imacr, image, ImaginaryI, imagline, imagpart, imath, Im, imof, imped, Implies, incare, in, infin, infintie, inodot, intcal, int, Int, integers, Integral, intercal, Intersection, intlarhk, intprod, InvisibleComma, InvisibleTimes, IOcy, iocy, Iogon, iogon, Iopf, iopf, Iota, iota, iprod, iquest, iscr, Iscr, isin, isindot, isinE, isins, isinsv, isinv, it, Itilde, itilde, Iukcy, iukcy, Iuml, iuml, Jcirc, jcirc, Jcy, jcy, Jfr, jfr, jmath, Jopf, jopf, Jscr, jscr, Jsercy, jsercy, Jukcy, jukcy, Kappa, kappa, kappav, Kcedil, kcedil, Kcy, kcy, Kfr, kfr, kgreen, KHcy, khcy, KJcy, kjcy, Kopf, kopf, Kscr, kscr, lAarr, Lacute, lacute, laemptyv, lagran, Lambda, lambda, lang, Lang, langd, langle, lap, Laplacetrf, laquo, larrb, larrbfs, larr, Larr, lArr, larrfs, larrhk, larrlp, larrpl, larrsim, larrtl, latail, lAtail, lat, late, lates, lbarr, lBarr, lbbrk, lbrace, lbrack, lbrke, lbrksld, lbrkslu, Lcaron, lcaron, Lcedil, lcedil, lceil, lcub, Lcy, lcy, ldca, ldquo, ldquor, ldrdhar, ldrushar, ldsh, le, lE, LeftAngleBracket, LeftArrowBar, leftarrow, LeftArrow, Leftarrow, LeftArrowRightArrow, leftarrowtail, LeftCeiling, LeftDoubleBracket, LeftDownTeeVector, LeftDownVectorBar, LeftDownVector, LeftFloor, leftharpoondown, leftharpoonup, leftleftarrows, leftrightarrow, LeftRightArrow, Leftrightarrow, leftrightarrows, leftrightharpoons, leftrightsquigarrow, LeftRightVector, LeftTeeArrow, LeftTee, LeftTeeVector, leftthreetimes, LeftTriangleBar, LeftTriangle, LeftTriangleEqual, LeftUpDownVector, LeftUpTeeVector, LeftUpVectorBar, LeftUpVector, LeftVectorBar, LeftVector, lEg, leg, leq, leqq, leqslant, lescc, les, lesdot, lesdoto, lesdotor, lesg, lesges, lessapprox, lessdot, lesseqgtr, lesseqqgtr, LessEqualGreater, LessFullEqual, LessGreater, lessgtr, LessLess, lesssim, LessSlantEqual, LessTilde, lfisht, lfloor, Lfr, lfr, lg, lgE, lHar, lhard, lharu, lharul, lhblk, LJcy, ljcy, llarr, ll, Ll, llcorner, Lleftarrow, llhard, lltri, Lmidot, lmidot, lmoustache, lmoust, lnap, lnapprox, lne, lnE, lneq, lneqq, lnsim, loang, loarr, lobrk, longleftarrow, LongLeftArrow, Longleftarrow, longleftrightarrow, LongLeftRightArrow, Longleftrightarrow, longmapsto, longrightarrow, LongRightArrow, Longrightarrow, looparrowleft, looparrowright, lopar, Lopf, lopf, loplus, lotimes, lowast, lowbar, LowerLeftArrow, LowerRightArrow, loz, lozenge, lozf, lpar, lparlt, lrarr, lrcorner, lrhar, lrhard, lrm, lrtri, lsaquo, lscr, Lscr, lsh, Lsh, lsim, lsime, lsimg, lsqb, lsquo, lsquor, Lstrok, lstrok, ltcc, ltcir, lt, LT, Lt, ltdot, lthree, ltimes, ltlarr, ltquest, ltri, ltrie, ltrif, ltrPar, lurdshar, luruhar, lvertneqq, lvnE, macr, male, malt, maltese, Map, map, mapsto, mapstodown, mapstoleft, mapstoup, marker, mcomma, Mcy, mcy, mdash, mDDot, measuredangle, MediumSpace, Mellintrf, Mfr, mfr, mho, micro, midast, midcir, mid, middot, minusb, minus, minusd, minusdu, MinusPlus, mlcp, mldr, mnplus, models, Mopf, mopf, mp, mscr, Mscr, mstpos, Mu, mu, multimap, mumap, nabla, Nacute, nacute, nang, nap, napE, napid, napos, napprox, natural, naturals, natur, nbsp, nbump, nbumpe, ncap, Ncaron, ncaron, Ncedil, ncedil, ncong, ncongdot, ncup, Ncy, ncy, ndash, nearhk, nearr, neArr, nearrow, ne, nedot, NegativeMediumSpace, NegativeThickSpace, NegativeThinSpace, NegativeVeryThinSpace, nequiv, nesear, nesim, NestedGreaterGreater, NestedLessLess, NewLine, nexist, nexists, Nfr, nfr, ngE, nge, ngeq, ngeqq, ngeqslant, nges, nGg, ngsim, nGt, ngt, ngtr, nGtv, nharr, nhArr, nhpar, ni, nis, nisd, niv, NJcy, njcy, nlarr, nlArr, nldr, nlE, nle, nleftarrow, nLeftarrow, nleftrightarrow, nLeftrightarrow, nleq, nleqq, nleqslant, nles, nless, nLl, nlsim, nLt, nlt, nltri, nltrie, nLtv, nmid, NoBreak, NonBreakingSpace, nopf, Nopf, Not, not, NotCongruent, NotCupCap, NotDoubleVerticalBar, NotElement, NotEqual, NotEqualTilde, NotExists, NotGreater, NotGreaterEqual, NotGreaterFullEqual, NotGreaterGreater, NotGreaterLess, NotGreaterSlantEqual, NotGreaterTilde, NotHumpDownHump, NotHumpEqual, notin, notindot, notinE, notinva, notinvb, notinvc, NotLeftTriangleBar, NotLeftTriangle, NotLeftTriangleEqual, NotLess, NotLessEqual, NotLessGreater, NotLessLess, NotLessSlantEqual, NotLessTilde, NotNestedGreaterGreater, NotNestedLessLess, notni, notniva, notnivb, notnivc, NotPrecedes, NotPrecedesEqual, NotPrecedesSlantEqual, NotReverseElement, NotRightTriangleBar, NotRightTriangle, NotRightTriangleEqual, NotSquareSubset, NotSquareSubsetEqual, NotSquareSuperset, NotSquareSupersetEqual, NotSubset, NotSubsetEqual, NotSucceeds, NotSucceedsEqual, NotSucceedsSlantEqual, NotSucceedsTilde, NotSuperset, NotSupersetEqual, NotTilde, NotTildeEqual, NotTildeFullEqual, NotTildeTilde, NotVerticalBar, nparallel, npar, nparsl, npart, npolint, npr, nprcue, nprec, npreceq, npre, nrarrc, nrarr, nrArr, nrarrw, nrightarrow, nRightarrow, nrtri, nrtrie, nsc, nsccue, nsce, Nscr, nscr, nshortmid, nshortparallel, nsim, nsime, nsimeq, nsmid, nspar, nsqsube, nsqsupe, nsub, nsubE, nsube, nsubset, nsubseteq, nsubseteqq, nsucc, nsucceq, nsup, nsupE, nsupe, nsupset, nsupseteq, nsupseteqq, ntgl, Ntilde, ntilde, ntlg, ntriangleleft, ntrianglelefteq, ntriangleright, ntrianglerighteq, Nu, nu, num, numero, numsp, nvap, nvdash, nvDash, nVdash, nVDash, nvge, nvgt, nvHarr, nvinfin, nvlArr, nvle, nvlt, nvltrie, nvrArr, nvrtrie, nvsim, nwarhk, nwarr, nwArr, nwarrow, nwnear, Oacute, oacute, oast, Ocirc, ocirc, ocir, Ocy, ocy, odash, Odblac, odblac, odiv, odot, odsold, OElig, oelig, ofcir, Ofr, ofr, ogon, Ograve, ograve, ogt, ohbar, ohm, oint, olarr, olcir, olcross, oline, olt, Omacr, omacr, Omega, omega, Omicron, omicron, omid, ominus, Oopf, oopf, opar, OpenCurlyDoubleQuote, OpenCurlyQuote, operp, oplus, orarr, Or, or, ord, order, orderof, ordf, ordm, origof, oror, orslope, orv, oS, Oscr, oscr, Oslash, oslash, osol, Otilde, otilde, otimesas, Otimes, otimes, Ouml, ouml, ovbar, OverBar, OverBrace, OverBracket, OverParenthesis, para, parallel, par, parsim, parsl, part, PartialD, Pcy, pcy, percnt, period, permil, perp, pertenk, Pfr, pfr, Phi, phi, phiv, phmmat, phone, Pi, pi, pitchfork, piv, planck, planckh, plankv, plusacir, plusb, pluscir, plus, plusdo, plusdu, pluse, PlusMinus, plusmn, plussim, plustwo, pm, Poincareplane, pointint, popf, Popf, pound, prap, Pr, pr, prcue, precapprox, prec, preccurlyeq, Precedes, PrecedesEqual, PrecedesSlantEqual, PrecedesTilde, preceq, precnapprox, precneqq, precnsim, pre, prE, precsim, prime, Prime, primes, prnap, prnE, prnsim, prod, Product, profalar, profline, profsurf, prop, Proportional, Proportion, propto, prsim, prurel, Pscr, pscr, Psi, psi, puncsp, Qfr, qfr, qint, qopf, Qopf, qprime, Qscr, qscr, quaternions, quatint, quest, questeq, quot, QUOT, rAarr, race, Racute, racute, radic, raemptyv, rang, Rang, rangd, range, rangle, raquo, rarrap, rarrb, rarrbfs, rarrc, rarr, Rarr, rArr, rarrfs, rarrhk, rarrlp, rarrpl, rarrsim, Rarrtl, rarrtl, rarrw, ratail, rAtail, ratio, rationals, rbarr, rBarr, RBarr, rbbrk, rbrace, rbrack, rbrke, rbrksld, rbrkslu, Rcaron, rcaron, Rcedil, rcedil, rceil, rcub, Rcy, rcy, rdca, rdldhar, rdquo, rdquor, rdsh, real, realine, realpart, reals, Re, rect, reg, REG, ReverseElement, ReverseEquilibrium, ReverseUpEquilibrium, rfisht, rfloor, rfr, Rfr, rHar, rhard, rharu, rharul, Rho, rho, rhov, RightAngleBracket, RightArrowBar, rightarrow, RightArrow, Rightarrow, RightArrowLeftArrow, rightarrowtail, RightCeiling, RightDoubleBracket, RightDownTeeVector, RightDownVectorBar, RightDownVector, RightFloor, rightharpoondown, rightharpoonup, rightleftarrows, rightleftharpoons, rightrightarrows, rightsquigarrow, RightTeeArrow, RightTee, RightTeeVector, rightthreetimes, RightTriangleBar, RightTriangle, RightTriangleEqual, RightUpDownVector, RightUpTeeVector, RightUpVectorBar, RightUpVector, RightVectorBar, RightVector, ring, risingdotseq, rlarr, rlhar, rlm, rmoustache, rmoust, rnmid, roang, roarr, robrk, ropar, ropf, Ropf, roplus, rotimes, RoundImplies, rpar, rpargt, rppolint, rrarr, Rrightarrow, rsaquo, rscr, Rscr, rsh, Rsh, rsqb, rsquo, rsquor, rthree, rtimes, rtri, rtrie, rtrif, rtriltri, RuleDelayed, ruluhar, rx, Sacute, sacute, sbquo, scap, Scaron, scaron, Sc, sc, sccue, sce, scE, Scedil, scedil, Scirc, scirc, scnap, scnE, scnsim, scpolint, scsim, Scy, scy, sdotb, sdot, sdote, searhk, searr, seArr, searrow, sect, semi, seswar, setminus, setmn, sext, Sfr, sfr, sfrown, sharp, SHCHcy, shchcy, SHcy, shcy, ShortDownArrow, ShortLeftArrow, shortmid, shortparallel, ShortRightArrow, ShortUpArrow, shy, Sigma, sigma, sigmaf, sigmav, sim, simdot, sime, simeq, simg, simgE, siml, simlE, simne, simplus, simrarr, slarr, SmallCircle, smallsetminus, smashp, smeparsl, smid, smile, smt, smte, smtes, SOFTcy, softcy, solbar, solb, sol, Sopf, sopf, spades, spadesuit, spar, sqcap, sqcaps, sqcup, sqcups, Sqrt, sqsub, sqsube, sqsubset, sqsubseteq, sqsup, sqsupe, sqsupset, sqsupseteq, square, Square, SquareIntersection, SquareSubset, SquareSubsetEqual, SquareSuperset, SquareSupersetEqual, SquareUnion, squarf, squ, squf, srarr, Sscr, sscr, ssetmn, ssmile, sstarf, Star, star, starf, straightepsilon, straightphi, strns, sub, Sub, subdot, subE, sube, subedot, submult, subnE, subne, subplus, subrarr, subset, Subset, subseteq, subseteqq, SubsetEqual, subsetneq, subsetneqq, subsim, subsub, subsup, succapprox, succ, succcurlyeq, Succeeds, SucceedsEqual, SucceedsSlantEqual, SucceedsTilde, succeq, succnapprox, succneqq, succnsim, succsim, SuchThat, sum, Sum, sung, sup1, sup2, sup3, sup, Sup, supdot, supdsub, supE, supe, supedot, Superset, SupersetEqual, suphsol, suphsub, suplarr, supmult, supnE, supne, supplus, supset, Supset, supseteq, supseteqq, supsetneq, supsetneqq, supsim, supsub, supsup, swarhk, swarr, swArr, swarrow, swnwar, szlig, Tab, target, Tau, tau, tbrk, Tcaron, tcaron, Tcedil, tcedil, Tcy, tcy, tdot, telrec, Tfr, tfr, there4, therefore, Therefore, Theta, theta, thetasym, thetav, thickapprox, thicksim, ThickSpace, ThinSpace, thinsp, thkap, thksim, THORN, thorn, tilde, Tilde, TildeEqual, TildeFullEqual, TildeTilde, timesbar, timesb, times, timesd, tint, toea, topbot, topcir, top, Topf, topf, topfork, tosa, tprime, trade, TRADE, triangle, triangledown, triangleleft, trianglelefteq, triangleq, triangleright, trianglerighteq, tridot, trie, triminus, TripleDot, triplus, trisb, tritime, trpezium, Tscr, tscr, TScy, tscy, TSHcy, tshcy, Tstrok, tstrok, twixt, twoheadleftarrow, twoheadrightarrow, Uacute, uacute, uarr, Uarr, uArr, Uarrocir, Ubrcy, ubrcy, Ubreve, ubreve, Ucirc, ucirc, Ucy, ucy, udarr, Udblac, udblac, udhar, ufisht, Ufr, ufr, Ugrave, ugrave, uHar, uharl, uharr, uhblk, ulcorn, ulcorner, ulcrop, ultri, Umacr, umacr, uml, UnderBar, UnderBrace, UnderBracket, UnderParenthesis, Union, UnionPlus, Uogon, uogon, Uopf, uopf, UpArrowBar, uparrow, UpArrow, Uparrow, UpArrowDownArrow, updownarrow, UpDownArrow, Updownarrow, UpEquilibrium, upharpoonleft, upharpoonright, uplus, UpperLeftArrow, UpperRightArrow, upsi, Upsi, upsih, Upsilon, upsilon, UpTeeArrow, UpTee, upuparrows, urcorn, urcorner, urcrop, Uring, uring, urtri, Uscr, uscr, utdot, Utilde, utilde, utri, utrif, uuarr, Uuml, uuml, uwangle, vangrt, varepsilon, varkappa, varnothing, varphi, varpi, varpropto, varr, vArr, varrho, varsigma, varsubsetneq, varsubsetneqq, varsupsetneq, varsupsetneqq, vartheta, vartriangleleft, vartriangleright, vBar, Vbar, vBarv, Vcy, vcy, vdash, vDash, Vdash, VDash, Vdashl, veebar, vee, Vee, veeeq, vellip, verbar, Verbar, vert, Vert, VerticalBar, VerticalLine, VerticalSeparator, VerticalTilde, VeryThinSpace, Vfr, vfr, vltri, vnsub, vnsup, Vopf, vopf, vprop, vrtri, Vscr, vscr, vsubnE, vsubne, vsupnE, vsupne, Vvdash, vzigzag, Wcirc, wcirc, wedbar, wedge, Wedge, wedgeq, weierp, Wfr, wfr, Wopf, wopf, wp, wr, wreath, Wscr, wscr, xcap, xcirc, xcup, xdtri, Xfr, xfr, xharr, xhArr, Xi, xi, xlarr, xlArr, xmap, xnis, xodot, Xopf, xopf, xoplus, xotime, xrarr, xrArr, Xscr, xscr, xsqcup, xuplus, xutri, xvee, xwedge, Yacute, yacute, YAcy, yacy, Ycirc, ycirc, Ycy, ycy, yen, Yfr, yfr, YIcy, yicy, Yopf, yopf, Yscr, yscr, YUcy, yucy, yuml, Yuml, Zacute, zacute, Zcaron, zcaron, Zcy, zcy, Zdot, zdot, zeetrf, ZeroWidthSpace, Zeta, zeta, zfr, Zfr, ZHcy, zhcy, zigrarr, zopf, Zopf, Zscr, zscr, zwj, zwnj, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Abreve\":\"Ă\",\"abreve\":\"ă\",\"ac\":\"∾\",\"acd\":\"∿\",\"acE\":\"∾̳\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"Acy\":\"А\",\"acy\":\"а\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"af\":\"⁡\",\"Afr\":\"𝔄\",\"afr\":\"𝔞\",\"Agrave\":\"À\",\"agrave\":\"à\",\"alefsym\":\"ℵ\",\"aleph\":\"ℵ\",\"Alpha\":\"Α\",\"alpha\":\"α\",\"Amacr\":\"Ā\",\"amacr\":\"ā\",\"amalg\":\"⨿\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"⩕\",\"And\":\"⩓\",\"and\":\"∧\",\"andd\":\"⩜\",\"andslope\":\"⩘\",\"andv\":\"⩚\",\"ang\":\"∠\",\"ange\":\"⦤\",\"angle\":\"∠\",\"angmsdaa\":\"⦨\",\"angmsdab\":\"⦩\",\"angmsdac\":\"⦪\",\"angmsdad\":\"⦫\",\"angmsdae\":\"⦬\",\"angmsdaf\":\"⦭\",\"angmsdag\":\"⦮\",\"angmsdah\":\"⦯\",\"angmsd\":\"∡\",\"angrt\":\"∟\",\"angrtvb\":\"⊾\",\"angrtvbd\":\"⦝\",\"angsph\":\"∢\",\"angst\":\"Å\",\"angzarr\":\"⍼\",\"Aogon\":\"Ą\",\"aogon\":\"ą\",\"Aopf\":\"𝔸\",\"aopf\":\"𝕒\",\"apacir\":\"⩯\",\"ap\":\"≈\",\"apE\":\"⩰\",\"ape\":\"≊\",\"apid\":\"≋\",\"apos\":\"'\",\"ApplyFunction\":\"⁡\",\"approx\":\"≈\",\"approxeq\":\"≊\",\"Aring\":\"Å\",\"aring\":\"å\",\"Ascr\":\"𝒜\",\"ascr\":\"𝒶\",\"Assign\":\"≔\",\"ast\":\"*\",\"asymp\":\"≈\",\"asympeq\":\"≍\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"awconint\":\"∳\",\"awint\":\"⨑\",\"backcong\":\"≌\",\"backepsilon\":\"϶\",\"backprime\":\"‵\",\"backsim\":\"∽\",\"backsimeq\":\"⋍\",\"Backslash\":\"∖\",\"Barv\":\"⫧\",\"barvee\":\"⊽\",\"barwed\":\"⌅\",\"Barwed\":\"⌆\",\"barwedge\":\"⌅\",\"bbrk\":\"⎵\",\"bbrktbrk\":\"⎶\",\"bcong\":\"≌\",\"Bcy\":\"Б\",\"bcy\":\"б\",\"bdquo\":\"„\",\"becaus\":\"∵\",\"because\":\"∵\",\"Because\":\"∵\",\"bemptyv\":\"⦰\",\"bepsi\":\"϶\",\"bernou\":\"ℬ\",\"Bernoullis\":\"ℬ\",\"Beta\":\"Β\",\"beta\":\"β\",\"beth\":\"ℶ\",\"between\":\"≬\",\"Bfr\":\"𝔅\",\"bfr\":\"𝔟\",\"bigcap\":\"⋂\",\"bigcirc\":\"◯\",\"bigcup\":\"⋃\",\"bigodot\":\"⨀\",\"bigoplus\":\"⨁\",\"bigotimes\":\"⨂\",\"bigsqcup\":\"⨆\",\"bigstar\":\"★\",\"bigtriangledown\":\"▽\",\"bigtriangleup\":\"△\",\"biguplus\":\"⨄\",\"bigvee\":\"⋁\",\"bigwedge\":\"⋀\",\"bkarow\":\"⤍\",\"blacklozenge\":\"⧫\",\"blacksquare\":\"▪\",\"blacktriangle\":\"▴\",\"blacktriangledown\":\"▾\",\"blacktriangleleft\":\"◂\",\"blacktriangleright\":\"▸\",\"blank\":\"␣\",\"blk12\":\"▒\",\"blk14\":\"░\",\"blk34\":\"▓\",\"block\":\"█\",\"bne\":\"=⃥\",\"bnequiv\":\"≡⃥\",\"bNot\":\"⫭\",\"bnot\":\"⌐\",\"Bopf\":\"𝔹\",\"bopf\":\"𝕓\",\"bot\":\"⊥\",\"bottom\":\"⊥\",\"bowtie\":\"⋈\",\"boxbox\":\"⧉\",\"boxdl\":\"┐\",\"boxdL\":\"╕\",\"boxDl\":\"╖\",\"boxDL\":\"╗\",\"boxdr\":\"┌\",\"boxdR\":\"╒\",\"boxDr\":\"╓\",\"boxDR\":\"╔\",\"boxh\":\"─\",\"boxH\":\"═\",\"boxhd\":\"┬\",\"boxHd\":\"╤\",\"boxhD\":\"╥\",\"boxHD\":\"╦\",\"boxhu\":\"┴\",\"boxHu\":\"╧\",\"boxhU\":\"╨\",\"boxHU\":\"╩\",\"boxminus\":\"⊟\",\"boxplus\":\"⊞\",\"boxtimes\":\"⊠\",\"boxul\":\"┘\",\"boxuL\":\"╛\",\"boxUl\":\"╜\",\"boxUL\":\"╝\",\"boxur\":\"└\",\"boxuR\":\"╘\",\"boxUr\":\"╙\",\"boxUR\":\"╚\",\"boxv\":\"│\",\"boxV\":\"║\",\"boxvh\":\"┼\",\"boxvH\":\"╪\",\"boxVh\":\"╫\",\"boxVH\":\"╬\",\"boxvl\":\"┤\",\"boxvL\":\"╡\",\"boxVl\":\"╢\",\"boxVL\":\"╣\",\"boxvr\":\"├\",\"boxvR\":\"╞\",\"boxVr\":\"╟\",\"boxVR\":\"╠\",\"bprime\":\"‵\",\"breve\":\"˘\",\"Breve\":\"˘\",\"brvbar\":\"¦\",\"bscr\":\"𝒷\",\"Bscr\":\"ℬ\",\"bsemi\":\"⁏\",\"bsim\":\"∽\",\"bsime\":\"⋍\",\"bsolb\":\"⧅\",\"bsol\":\"\\\\\",\"bsolhsub\":\"⟈\",\"bull\":\"•\",\"bullet\":\"•\",\"bump\":\"≎\",\"bumpE\":\"⪮\",\"bumpe\":\"≏\",\"Bumpeq\":\"≎\",\"bumpeq\":\"≏\",\"Cacute\":\"Ć\",\"cacute\":\"ć\",\"capand\":\"⩄\",\"capbrcup\":\"⩉\",\"capcap\":\"⩋\",\"cap\":\"∩\",\"Cap\":\"⋒\",\"capcup\":\"⩇\",\"capdot\":\"⩀\",\"CapitalDifferentialD\":\"ⅅ\",\"caps\":\"∩︀\",\"caret\":\"⁁\",\"caron\":\"ˇ\",\"Cayleys\":\"ℭ\",\"ccaps\":\"⩍\",\"Ccaron\":\"Č\",\"ccaron\":\"č\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"Ccirc\":\"Ĉ\",\"ccirc\":\"ĉ\",\"Cconint\":\"∰\",\"ccups\":\"⩌\",\"ccupssm\":\"⩐\",\"Cdot\":\"Ċ\",\"cdot\":\"ċ\",\"cedil\":\"¸\",\"Cedilla\":\"¸\",\"cemptyv\":\"⦲\",\"cent\":\"¢\",\"centerdot\":\"·\",\"CenterDot\":\"·\",\"cfr\":\"𝔠\",\"Cfr\":\"ℭ\",\"CHcy\":\"Ч\",\"chcy\":\"ч\",\"check\":\"✓\",\"checkmark\":\"✓\",\"Chi\":\"Χ\",\"chi\":\"χ\",\"circ\":\"ˆ\",\"circeq\":\"≗\",\"circlearrowleft\":\"↺\",\"circlearrowright\":\"↻\",\"circledast\":\"⊛\",\"circledcirc\":\"⊚\",\"circleddash\":\"⊝\",\"CircleDot\":\"⊙\",\"circledR\":\"®\",\"circledS\":\"Ⓢ\",\"CircleMinus\":\"⊖\",\"CirclePlus\":\"⊕\",\"CircleTimes\":\"⊗\",\"cir\":\"○\",\"cirE\":\"⧃\",\"cire\":\"≗\",\"cirfnint\":\"⨐\",\"cirmid\":\"⫯\",\"cirscir\":\"⧂\",\"ClockwiseContourIntegral\":\"∲\",\"CloseCurlyDoubleQuote\":\"”\",\"CloseCurlyQuote\":\"’\",\"clubs\":\"♣\",\"clubsuit\":\"♣\",\"colon\":\":\",\"Colon\":\"∷\",\"Colone\":\"⩴\",\"colone\":\"≔\",\"coloneq\":\"≔\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"∁\",\"compfn\":\"∘\",\"complement\":\"∁\",\"complexes\":\"ℂ\",\"cong\":\"≅\",\"congdot\":\"⩭\",\"Congruent\":\"≡\",\"conint\":\"∮\",\"Conint\":\"∯\",\"ContourIntegral\":\"∮\",\"copf\":\"𝕔\",\"Copf\":\"ℂ\",\"coprod\":\"∐\",\"Coproduct\":\"∐\",\"copy\":\"©\",\"COPY\":\"©\",\"copysr\":\"℗\",\"CounterClockwiseContourIntegral\":\"∳\",\"crarr\":\"↵\",\"cross\":\"✗\",\"Cross\":\"⨯\",\"Cscr\":\"𝒞\",\"cscr\":\"𝒸\",\"csub\":\"⫏\",\"csube\":\"⫑\",\"csup\":\"⫐\",\"csupe\":\"⫒\",\"ctdot\":\"⋯\",\"cudarrl\":\"⤸\",\"cudarrr\":\"⤵\",\"cuepr\":\"⋞\",\"cuesc\":\"⋟\",\"cularr\":\"↶\",\"cularrp\":\"⤽\",\"cupbrcap\":\"⩈\",\"cupcap\":\"⩆\",\"CupCap\":\"≍\",\"cup\":\"∪\",\"Cup\":\"⋓\",\"cupcup\":\"⩊\",\"cupdot\":\"⊍\",\"cupor\":\"⩅\",\"cups\":\"∪︀\",\"curarr\":\"↷\",\"curarrm\":\"⤼\",\"curlyeqprec\":\"⋞\",\"curlyeqsucc\":\"⋟\",\"curlyvee\":\"⋎\",\"curlywedge\":\"⋏\",\"curren\":\"¤\",\"curvearrowleft\":\"↶\",\"curvearrowright\":\"↷\",\"cuvee\":\"⋎\",\"cuwed\":\"⋏\",\"cwconint\":\"∲\",\"cwint\":\"∱\",\"cylcty\":\"⌭\",\"dagger\":\"†\",\"Dagger\":\"‡\",\"daleth\":\"ℸ\",\"darr\":\"↓\",\"Darr\":\"↡\",\"dArr\":\"⇓\",\"dash\":\"‐\",\"Dashv\":\"⫤\",\"dashv\":\"⊣\",\"dbkarow\":\"⤏\",\"dblac\":\"˝\",\"Dcaron\":\"Ď\",\"dcaron\":\"ď\",\"Dcy\":\"Д\",\"dcy\":\"д\",\"ddagger\":\"‡\",\"ddarr\":\"⇊\",\"DD\":\"ⅅ\",\"dd\":\"ⅆ\",\"DDotrahd\":\"⤑\",\"ddotseq\":\"⩷\",\"deg\":\"°\",\"Del\":\"∇\",\"Delta\":\"Δ\",\"delta\":\"δ\",\"demptyv\":\"⦱\",\"dfisht\":\"⥿\",\"Dfr\":\"𝔇\",\"dfr\":\"𝔡\",\"dHar\":\"⥥\",\"dharl\":\"⇃\",\"dharr\":\"⇂\",\"DiacriticalAcute\":\"´\",\"DiacriticalDot\":\"˙\",\"DiacriticalDoubleAcute\":\"˝\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"˜\",\"diam\":\"⋄\",\"diamond\":\"⋄\",\"Diamond\":\"⋄\",\"diamondsuit\":\"♦\",\"diams\":\"♦\",\"die\":\"¨\",\"DifferentialD\":\"ⅆ\",\"digamma\":\"ϝ\",\"disin\":\"⋲\",\"div\":\"÷\",\"divide\":\"÷\",\"divideontimes\":\"⋇\",\"divonx\":\"⋇\",\"DJcy\":\"Ђ\",\"djcy\":\"ђ\",\"dlcorn\":\"⌞\",\"dlcrop\":\"⌍\",\"dollar\":\"$\",\"Dopf\":\"𝔻\",\"dopf\":\"𝕕\",\"Dot\":\"¨\",\"dot\":\"˙\",\"DotDot\":\"⃜\",\"doteq\":\"≐\",\"doteqdot\":\"≑\",\"DotEqual\":\"≐\",\"dotminus\":\"∸\",\"dotplus\":\"∔\",\"dotsquare\":\"⊡\",\"doublebarwedge\":\"⌆\",\"DoubleContourIntegral\":\"∯\",\"DoubleDot\":\"¨\",\"DoubleDownArrow\":\"⇓\",\"DoubleLeftArrow\":\"⇐\",\"DoubleLeftRightArrow\":\"⇔\",\"DoubleLeftTee\":\"⫤\",\"DoubleLongLeftArrow\":\"⟸\",\"DoubleLongLeftRightArrow\":\"⟺\",\"DoubleLongRightArrow\":\"⟹\",\"DoubleRightArrow\":\"⇒\",\"DoubleRightTee\":\"⊨\",\"DoubleUpArrow\":\"⇑\",\"DoubleUpDownArrow\":\"⇕\",\"DoubleVerticalBar\":\"∥\",\"DownArrowBar\":\"⤓\",\"downarrow\":\"↓\",\"DownArrow\":\"↓\",\"Downarrow\":\"⇓\",\"DownArrowUpArrow\":\"⇵\",\"DownBreve\":\"̑\",\"downdownarrows\":\"⇊\",\"downharpoonleft\":\"⇃\",\"downharpoonright\":\"⇂\",\"DownLeftRightVector\":\"⥐\",\"DownLeftTeeVector\":\"⥞\",\"DownLeftVectorBar\":\"⥖\",\"DownLeftVector\":\"↽\",\"DownRightTeeVector\":\"⥟\",\"DownRightVectorBar\":\"⥗\",\"DownRightVector\":\"⇁\",\"DownTeeArrow\":\"↧\",\"DownTee\":\"⊤\",\"drbkarow\":\"⤐\",\"drcorn\":\"⌟\",\"drcrop\":\"⌌\",\"Dscr\":\"𝒟\",\"dscr\":\"𝒹\",\"DScy\":\"Ѕ\",\"dscy\":\"ѕ\",\"dsol\":\"⧶\",\"Dstrok\":\"Đ\",\"dstrok\":\"đ\",\"dtdot\":\"⋱\",\"dtri\":\"▿\",\"dtrif\":\"▾\",\"duarr\":\"⇵\",\"duhar\":\"⥯\",\"dwangle\":\"⦦\",\"DZcy\":\"Џ\",\"dzcy\":\"џ\",\"dzigrarr\":\"⟿\",\"Eacute\":\"É\",\"eacute\":\"é\",\"easter\":\"⩮\",\"Ecaron\":\"Ě\",\"ecaron\":\"ě\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"ecir\":\"≖\",\"ecolon\":\"≕\",\"Ecy\":\"Э\",\"ecy\":\"э\",\"eDDot\":\"⩷\",\"Edot\":\"Ė\",\"edot\":\"ė\",\"eDot\":\"≑\",\"ee\":\"ⅇ\",\"efDot\":\"≒\",\"Efr\":\"𝔈\",\"efr\":\"𝔢\",\"eg\":\"⪚\",\"Egrave\":\"È\",\"egrave\":\"è\",\"egs\":\"⪖\",\"egsdot\":\"⪘\",\"el\":\"⪙\",\"Element\":\"∈\",\"elinters\":\"⏧\",\"ell\":\"ℓ\",\"els\":\"⪕\",\"elsdot\":\"⪗\",\"Emacr\":\"Ē\",\"emacr\":\"ē\",\"empty\":\"∅\",\"emptyset\":\"∅\",\"EmptySmallSquare\":\"◻\",\"emptyv\":\"∅\",\"EmptyVerySmallSquare\":\"▫\",\"emsp13\":\" \",\"emsp14\":\" \",\"emsp\":\" \",\"ENG\":\"Ŋ\",\"eng\":\"ŋ\",\"ensp\":\" \",\"Eogon\":\"Ę\",\"eogon\":\"ę\",\"Eopf\":\"𝔼\",\"eopf\":\"𝕖\",\"epar\":\"⋕\",\"eparsl\":\"⧣\",\"eplus\":\"⩱\",\"epsi\":\"ε\",\"Epsilon\":\"Ε\",\"epsilon\":\"ε\",\"epsiv\":\"ϵ\",\"eqcirc\":\"≖\",\"eqcolon\":\"≕\",\"eqsim\":\"≂\",\"eqslantgtr\":\"⪖\",\"eqslantless\":\"⪕\",\"Equal\":\"⩵\",\"equals\":\"=\",\"EqualTilde\":\"≂\",\"equest\":\"≟\",\"Equilibrium\":\"⇌\",\"equiv\":\"≡\",\"equivDD\":\"⩸\",\"eqvparsl\":\"⧥\",\"erarr\":\"⥱\",\"erDot\":\"≓\",\"escr\":\"ℯ\",\"Escr\":\"ℰ\",\"esdot\":\"≐\",\"Esim\":\"⩳\",\"esim\":\"≂\",\"Eta\":\"Η\",\"eta\":\"η\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"euro\":\"€\",\"excl\":\"!\",\"exist\":\"∃\",\"Exists\":\"∃\",\"expectation\":\"ℰ\",\"exponentiale\":\"ⅇ\",\"ExponentialE\":\"ⅇ\",\"fallingdotseq\":\"≒\",\"Fcy\":\"Ф\",\"fcy\":\"ф\",\"female\":\"♀\",\"ffilig\":\"ﬃ\",\"fflig\":\"ﬀ\",\"ffllig\":\"ﬄ\",\"Ffr\":\"𝔉\",\"ffr\":\"𝔣\",\"filig\":\"ﬁ\",\"FilledSmallSquare\":\"◼\",\"FilledVerySmallSquare\":\"▪\",\"fjlig\":\"fj\",\"flat\":\"♭\",\"fllig\":\"ﬂ\",\"fltns\":\"▱\",\"fnof\":\"ƒ\",\"Fopf\":\"𝔽\",\"fopf\":\"𝕗\",\"forall\":\"∀\",\"ForAll\":\"∀\",\"fork\":\"⋔\",\"forkv\":\"⫙\",\"Fouriertrf\":\"ℱ\",\"fpartint\":\"⨍\",\"frac12\":\"½\",\"frac13\":\"⅓\",\"frac14\":\"¼\",\"frac15\":\"⅕\",\"frac16\":\"⅙\",\"frac18\":\"⅛\",\"frac23\":\"⅔\",\"frac25\":\"⅖\",\"frac34\":\"¾\",\"frac35\":\"⅗\",\"frac38\":\"⅜\",\"frac45\":\"⅘\",\"frac56\":\"⅚\",\"frac58\":\"⅝\",\"frac78\":\"⅞\",\"frasl\":\"⁄\",\"frown\":\"⌢\",\"fscr\":\"𝒻\",\"Fscr\":\"ℱ\",\"gacute\":\"ǵ\",\"Gamma\":\"Γ\",\"gamma\":\"γ\",\"Gammad\":\"Ϝ\",\"gammad\":\"ϝ\",\"gap\":\"⪆\",\"Gbreve\":\"Ğ\",\"gbreve\":\"ğ\",\"Gcedil\":\"Ģ\",\"Gcirc\":\"Ĝ\",\"gcirc\":\"ĝ\",\"Gcy\":\"Г\",\"gcy\":\"г\",\"Gdot\":\"Ġ\",\"gdot\":\"ġ\",\"ge\":\"≥\",\"gE\":\"≧\",\"gEl\":\"⪌\",\"gel\":\"⋛\",\"geq\":\"≥\",\"geqq\":\"≧\",\"geqslant\":\"⩾\",\"gescc\":\"⪩\",\"ges\":\"⩾\",\"gesdot\":\"⪀\",\"gesdoto\":\"⪂\",\"gesdotol\":\"⪄\",\"gesl\":\"⋛︀\",\"gesles\":\"⪔\",\"Gfr\":\"𝔊\",\"gfr\":\"𝔤\",\"gg\":\"≫\",\"Gg\":\"⋙\",\"ggg\":\"⋙\",\"gimel\":\"ℷ\",\"GJcy\":\"Ѓ\",\"gjcy\":\"ѓ\",\"gla\":\"⪥\",\"gl\":\"≷\",\"glE\":\"⪒\",\"glj\":\"⪤\",\"gnap\":\"⪊\",\"gnapprox\":\"⪊\",\"gne\":\"⪈\",\"gnE\":\"≩\",\"gneq\":\"⪈\",\"gneqq\":\"≩\",\"gnsim\":\"⋧\",\"Gopf\":\"𝔾\",\"gopf\":\"𝕘\",\"grave\":\"`\",\"GreaterEqual\":\"≥\",\"GreaterEqualLess\":\"⋛\",\"GreaterFullEqual\":\"≧\",\"GreaterGreater\":\"⪢\",\"GreaterLess\":\"≷\",\"GreaterSlantEqual\":\"⩾\",\"GreaterTilde\":\"≳\",\"Gscr\":\"𝒢\",\"gscr\":\"ℊ\",\"gsim\":\"≳\",\"gsime\":\"⪎\",\"gsiml\":\"⪐\",\"gtcc\":\"⪧\",\"gtcir\":\"⩺\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"≫\",\"gtdot\":\"⋗\",\"gtlPar\":\"⦕\",\"gtquest\":\"⩼\",\"gtrapprox\":\"⪆\",\"gtrarr\":\"⥸\",\"gtrdot\":\"⋗\",\"gtreqless\":\"⋛\",\"gtreqqless\":\"⪌\",\"gtrless\":\"≷\",\"gtrsim\":\"≳\",\"gvertneqq\":\"≩︀\",\"gvnE\":\"≩︀\",\"Hacek\":\"ˇ\",\"hairsp\":\" \",\"half\":\"½\",\"hamilt\":\"ℋ\",\"HARDcy\":\"Ъ\",\"hardcy\":\"ъ\",\"harrcir\":\"⥈\",\"harr\":\"↔\",\"hArr\":\"⇔\",\"harrw\":\"↭\",\"Hat\":\"^\",\"hbar\":\"ℏ\",\"Hcirc\":\"Ĥ\",\"hcirc\":\"ĥ\",\"hearts\":\"♥\",\"heartsuit\":\"♥\",\"hellip\":\"…\",\"hercon\":\"⊹\",\"hfr\":\"𝔥\",\"Hfr\":\"ℌ\",\"HilbertSpace\":\"ℋ\",\"hksearow\":\"⤥\",\"hkswarow\":\"⤦\",\"hoarr\":\"⇿\",\"homtht\":\"∻\",\"hookleftarrow\":\"↩\",\"hookrightarrow\":\"↪\",\"hopf\":\"𝕙\",\"Hopf\":\"ℍ\",\"horbar\":\"―\",\"HorizontalLine\":\"─\",\"hscr\":\"𝒽\",\"Hscr\":\"ℋ\",\"hslash\":\"ℏ\",\"Hstrok\":\"Ħ\",\"hstrok\":\"ħ\",\"HumpDownHump\":\"≎\",\"HumpEqual\":\"≏\",\"hybull\":\"⁃\",\"hyphen\":\"‐\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"ic\":\"⁣\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"Icy\":\"И\",\"icy\":\"и\",\"Idot\":\"İ\",\"IEcy\":\"Е\",\"iecy\":\"е\",\"iexcl\":\"¡\",\"iff\":\"⇔\",\"ifr\":\"𝔦\",\"Ifr\":\"ℑ\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"ii\":\"ⅈ\",\"iiiint\":\"⨌\",\"iiint\":\"∭\",\"iinfin\":\"⧜\",\"iiota\":\"℩\",\"IJlig\":\"Ĳ\",\"ijlig\":\"ĳ\",\"Imacr\":\"Ī\",\"imacr\":\"ī\",\"image\":\"ℑ\",\"ImaginaryI\":\"ⅈ\",\"imagline\":\"ℐ\",\"imagpart\":\"ℑ\",\"imath\":\"ı\",\"Im\":\"ℑ\",\"imof\":\"⊷\",\"imped\":\"Ƶ\",\"Implies\":\"⇒\",\"incare\":\"℅\",\"in\":\"∈\",\"infin\":\"∞\",\"infintie\":\"⧝\",\"inodot\":\"ı\",\"intcal\":\"⊺\",\"int\":\"∫\",\"Int\":\"∬\",\"integers\":\"ℤ\",\"Integral\":\"∫\",\"intercal\":\"⊺\",\"Intersection\":\"⋂\",\"intlarhk\":\"⨗\",\"intprod\":\"⨼\",\"InvisibleComma\":\"⁣\",\"InvisibleTimes\":\"⁢\",\"IOcy\":\"Ё\",\"iocy\":\"ё\",\"Iogon\":\"Į\",\"iogon\":\"į\",\"Iopf\":\"𝕀\",\"iopf\":\"𝕚\",\"Iota\":\"Ι\",\"iota\":\"ι\",\"iprod\":\"⨼\",\"iquest\":\"¿\",\"iscr\":\"𝒾\",\"Iscr\":\"ℐ\",\"isin\":\"∈\",\"isindot\":\"⋵\",\"isinE\":\"⋹\",\"isins\":\"⋴\",\"isinsv\":\"⋳\",\"isinv\":\"∈\",\"it\":\"⁢\",\"Itilde\":\"Ĩ\",\"itilde\":\"ĩ\",\"Iukcy\":\"І\",\"iukcy\":\"і\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"Jcirc\":\"Ĵ\",\"jcirc\":\"ĵ\",\"Jcy\":\"Й\",\"jcy\":\"й\",\"Jfr\":\"𝔍\",\"jfr\":\"𝔧\",\"jmath\":\"ȷ\",\"Jopf\":\"𝕁\",\"jopf\":\"𝕛\",\"Jscr\":\"𝒥\",\"jscr\":\"𝒿\",\"Jsercy\":\"Ј\",\"jsercy\":\"ј\",\"Jukcy\":\"Є\",\"jukcy\":\"є\",\"Kappa\":\"Κ\",\"kappa\":\"κ\",\"kappav\":\"ϰ\",\"Kcedil\":\"Ķ\",\"kcedil\":\"ķ\",\"Kcy\":\"К\",\"kcy\":\"к\",\"Kfr\":\"𝔎\",\"kfr\":\"𝔨\",\"kgreen\":\"ĸ\",\"KHcy\":\"Х\",\"khcy\":\"х\",\"KJcy\":\"Ќ\",\"kjcy\":\"ќ\",\"Kopf\":\"𝕂\",\"kopf\":\"𝕜\",\"Kscr\":\"𝒦\",\"kscr\":\"𝓀\",\"lAarr\":\"⇚\",\"Lacute\":\"Ĺ\",\"lacute\":\"ĺ\",\"laemptyv\":\"⦴\",\"lagran\":\"ℒ\",\"Lambda\":\"Λ\",\"lambda\":\"λ\",\"lang\":\"⟨\",\"Lang\":\"⟪\",\"langd\":\"⦑\",\"langle\":\"⟨\",\"lap\":\"⪅\",\"Laplacetrf\":\"ℒ\",\"laquo\":\"«\",\"larrb\":\"⇤\",\"larrbfs\":\"⤟\",\"larr\":\"←\",\"Larr\":\"↞\",\"lArr\":\"⇐\",\"larrfs\":\"⤝\",\"larrhk\":\"↩\",\"larrlp\":\"↫\",\"larrpl\":\"⤹\",\"larrsim\":\"⥳\",\"larrtl\":\"↢\",\"latail\":\"⤙\",\"lAtail\":\"⤛\",\"lat\":\"⪫\",\"late\":\"⪭\",\"lates\":\"⪭︀\",\"lbarr\":\"⤌\",\"lBarr\":\"⤎\",\"lbbrk\":\"❲\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"⦋\",\"lbrksld\":\"⦏\",\"lbrkslu\":\"⦍\",\"Lcaron\":\"Ľ\",\"lcaron\":\"ľ\",\"Lcedil\":\"Ļ\",\"lcedil\":\"ļ\",\"lceil\":\"⌈\",\"lcub\":\"{\",\"Lcy\":\"Л\",\"lcy\":\"л\",\"ldca\":\"⤶\",\"ldquo\":\"“\",\"ldquor\":\"„\",\"ldrdhar\":\"⥧\",\"ldrushar\":\"⥋\",\"ldsh\":\"↲\",\"le\":\"≤\",\"lE\":\"≦\",\"LeftAngleBracket\":\"⟨\",\"LeftArrowBar\":\"⇤\",\"leftarrow\":\"←\",\"LeftArrow\":\"←\",\"Leftarrow\":\"⇐\",\"LeftArrowRightArrow\":\"⇆\",\"leftarrowtail\":\"↢\",\"LeftCeiling\":\"⌈\",\"LeftDoubleBracket\":\"⟦\",\"LeftDownTeeVector\":\"⥡\",\"LeftDownVectorBar\":\"⥙\",\"LeftDownVector\":\"⇃\",\"LeftFloor\":\"⌊\",\"leftharpoondown\":\"↽\",\"leftharpoonup\":\"↼\",\"leftleftarrows\":\"⇇\",\"leftrightarrow\":\"↔\",\"LeftRightArrow\":\"↔\",\"Leftrightarrow\":\"⇔\",\"leftrightarrows\":\"⇆\",\"leftrightharpoons\":\"⇋\",\"leftrightsquigarrow\":\"↭\",\"LeftRightVector\":\"⥎\",\"LeftTeeArrow\":\"↤\",\"LeftTee\":\"⊣\",\"LeftTeeVector\":\"⥚\",\"leftthreetimes\":\"⋋\",\"LeftTriangleBar\":\"⧏\",\"LeftTriangle\":\"⊲\",\"LeftTriangleEqual\":\"⊴\",\"LeftUpDownVector\":\"⥑\",\"LeftUpTeeVector\":\"⥠\",\"LeftUpVectorBar\":\"⥘\",\"LeftUpVector\":\"↿\",\"LeftVectorBar\":\"⥒\",\"LeftVector\":\"↼\",\"lEg\":\"⪋\",\"leg\":\"⋚\",\"leq\":\"≤\",\"leqq\":\"≦\",\"leqslant\":\"⩽\",\"lescc\":\"⪨\",\"les\":\"⩽\",\"lesdot\":\"⩿\",\"lesdoto\":\"⪁\",\"lesdotor\":\"⪃\",\"lesg\":\"⋚︀\",\"lesges\":\"⪓\",\"lessapprox\":\"⪅\",\"lessdot\":\"⋖\",\"lesseqgtr\":\"⋚\",\"lesseqqgtr\":\"⪋\",\"LessEqualGreater\":\"⋚\",\"LessFullEqual\":\"≦\",\"LessGreater\":\"≶\",\"lessgtr\":\"≶\",\"LessLess\":\"⪡\",\"lesssim\":\"≲\",\"LessSlantEqual\":\"⩽\",\"LessTilde\":\"≲\",\"lfisht\":\"⥼\",\"lfloor\":\"⌊\",\"Lfr\":\"𝔏\",\"lfr\":\"𝔩\",\"lg\":\"≶\",\"lgE\":\"⪑\",\"lHar\":\"⥢\",\"lhard\":\"↽\",\"lharu\":\"↼\",\"lharul\":\"⥪\",\"lhblk\":\"▄\",\"LJcy\":\"Љ\",\"ljcy\":\"љ\",\"llarr\":\"⇇\",\"ll\":\"≪\",\"Ll\":\"⋘\",\"llcorner\":\"⌞\",\"Lleftarrow\":\"⇚\",\"llhard\":\"⥫\",\"lltri\":\"◺\",\"Lmidot\":\"Ŀ\",\"lmidot\":\"ŀ\",\"lmoustache\":\"⎰\",\"lmoust\":\"⎰\",\"lnap\":\"⪉\",\"lnapprox\":\"⪉\",\"lne\":\"⪇\",\"lnE\":\"≨\",\"lneq\":\"⪇\",\"lneqq\":\"≨\",\"lnsim\":\"⋦\",\"loang\":\"⟬\",\"loarr\":\"⇽\",\"lobrk\":\"⟦\",\"longleftarrow\":\"⟵\",\"LongLeftArrow\":\"⟵\",\"Longleftarrow\":\"⟸\",\"longleftrightarrow\":\"⟷\",\"LongLeftRightArrow\":\"⟷\",\"Longleftrightarrow\":\"⟺\",\"longmapsto\":\"⟼\",\"longrightarrow\":\"⟶\",\"LongRightArrow\":\"⟶\",\"Longrightarrow\":\"⟹\",\"looparrowleft\":\"↫\",\"looparrowright\":\"↬\",\"lopar\":\"⦅\",\"Lopf\":\"𝕃\",\"lopf\":\"𝕝\",\"loplus\":\"⨭\",\"lotimes\":\"⨴\",\"lowast\":\"∗\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"↙\",\"LowerRightArrow\":\"↘\",\"loz\":\"◊\",\"lozenge\":\"◊\",\"lozf\":\"⧫\",\"lpar\":\"(\",\"lparlt\":\"⦓\",\"lrarr\":\"⇆\",\"lrcorner\":\"⌟\",\"lrhar\":\"⇋\",\"lrhard\":\"⥭\",\"lrm\":\"‎\",\"lrtri\":\"⊿\",\"lsaquo\":\"‹\",\"lscr\":\"𝓁\",\"Lscr\":\"ℒ\",\"lsh\":\"↰\",\"Lsh\":\"↰\",\"lsim\":\"≲\",\"lsime\":\"⪍\",\"lsimg\":\"⪏\",\"lsqb\":\"[\",\"lsquo\":\"‘\",\"lsquor\":\"‚\",\"Lstrok\":\"Ł\",\"lstrok\":\"ł\",\"ltcc\":\"⪦\",\"ltcir\":\"⩹\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"≪\",\"ltdot\":\"⋖\",\"lthree\":\"⋋\",\"ltimes\":\"⋉\",\"ltlarr\":\"⥶\",\"ltquest\":\"⩻\",\"ltri\":\"◃\",\"ltrie\":\"⊴\",\"ltrif\":\"◂\",\"ltrPar\":\"⦖\",\"lurdshar\":\"⥊\",\"luruhar\":\"⥦\",\"lvertneqq\":\"≨︀\",\"lvnE\":\"≨︀\",\"macr\":\"¯\",\"male\":\"♂\",\"malt\":\"✠\",\"maltese\":\"✠\",\"Map\":\"⤅\",\"map\":\"↦\",\"mapsto\":\"↦\",\"mapstodown\":\"↧\",\"mapstoleft\":\"↤\",\"mapstoup\":\"↥\",\"marker\":\"▮\",\"mcomma\":\"⨩\",\"Mcy\":\"М\",\"mcy\":\"м\",\"mdash\":\"—\",\"mDDot\":\"∺\",\"measuredangle\":\"∡\",\"MediumSpace\":\" \",\"Mellintrf\":\"ℳ\",\"Mfr\":\"𝔐\",\"mfr\":\"𝔪\",\"mho\":\"℧\",\"micro\":\"µ\",\"midast\":\"*\",\"midcir\":\"⫰\",\"mid\":\"∣\",\"middot\":\"·\",\"minusb\":\"⊟\",\"minus\":\"−\",\"minusd\":\"∸\",\"minusdu\":\"⨪\",\"MinusPlus\":\"∓\",\"mlcp\":\"⫛\",\"mldr\":\"…\",\"mnplus\":\"∓\",\"models\":\"⊧\",\"Mopf\":\"𝕄\",\"mopf\":\"𝕞\",\"mp\":\"∓\",\"mscr\":\"𝓂\",\"Mscr\":\"ℳ\",\"mstpos\":\"∾\",\"Mu\":\"Μ\",\"mu\":\"μ\",\"multimap\":\"⊸\",\"mumap\":\"⊸\",\"nabla\":\"∇\",\"Nacute\":\"Ń\",\"nacute\":\"ń\",\"nang\":\"∠⃒\",\"nap\":\"≉\",\"napE\":\"⩰̸\",\"napid\":\"≋̸\",\"napos\":\"ŉ\",\"napprox\":\"≉\",\"natural\":\"♮\",\"naturals\":\"ℕ\",\"natur\":\"♮\",\"nbsp\":\" \",\"nbump\":\"≎̸\",\"nbumpe\":\"≏̸\",\"ncap\":\"⩃\",\"Ncaron\":\"Ň\",\"ncaron\":\"ň\",\"Ncedil\":\"Ņ\",\"ncedil\":\"ņ\",\"ncong\":\"≇\",\"ncongdot\":\"⩭̸\",\"ncup\":\"⩂\",\"Ncy\":\"Н\",\"ncy\":\"н\",\"ndash\":\"–\",\"nearhk\":\"⤤\",\"nearr\":\"↗\",\"neArr\":\"⇗\",\"nearrow\":\"↗\",\"ne\":\"≠\",\"nedot\":\"≐̸\",\"NegativeMediumSpace\":\"​\",\"NegativeThickSpace\":\"​\",\"NegativeThinSpace\":\"​\",\"NegativeVeryThinSpace\":\"​\",\"nequiv\":\"≢\",\"nesear\":\"⤨\",\"nesim\":\"≂̸\",\"NestedGreaterGreater\":\"≫\",\"NestedLessLess\":\"≪\",\"NewLine\":\"\\n\",\"nexist\":\"∄\",\"nexists\":\"∄\",\"Nfr\":\"𝔑\",\"nfr\":\"𝔫\",\"ngE\":\"≧̸\",\"nge\":\"≱\",\"ngeq\":\"≱\",\"ngeqq\":\"≧̸\",\"ngeqslant\":\"⩾̸\",\"nges\":\"⩾̸\",\"nGg\":\"⋙̸\",\"ngsim\":\"≵\",\"nGt\":\"≫⃒\",\"ngt\":\"≯\",\"ngtr\":\"≯\",\"nGtv\":\"≫̸\",\"nharr\":\"↮\",\"nhArr\":\"⇎\",\"nhpar\":\"⫲\",\"ni\":\"∋\",\"nis\":\"⋼\",\"nisd\":\"⋺\",\"niv\":\"∋\",\"NJcy\":\"Њ\",\"njcy\":\"њ\",\"nlarr\":\"↚\",\"nlArr\":\"⇍\",\"nldr\":\"‥\",\"nlE\":\"≦̸\",\"nle\":\"≰\",\"nleftarrow\":\"↚\",\"nLeftarrow\":\"⇍\",\"nleftrightarrow\":\"↮\",\"nLeftrightarrow\":\"⇎\",\"nleq\":\"≰\",\"nleqq\":\"≦̸\",\"nleqslant\":\"⩽̸\",\"nles\":\"⩽̸\",\"nless\":\"≮\",\"nLl\":\"⋘̸\",\"nlsim\":\"≴\",\"nLt\":\"≪⃒\",\"nlt\":\"≮\",\"nltri\":\"⋪\",\"nltrie\":\"⋬\",\"nLtv\":\"≪̸\",\"nmid\":\"∤\",\"NoBreak\":\"⁠\",\"NonBreakingSpace\":\" \",\"nopf\":\"𝕟\",\"Nopf\":\"ℕ\",\"Not\":\"⫬\",\"not\":\"¬\",\"NotCongruent\":\"≢\",\"NotCupCap\":\"≭\",\"NotDoubleVerticalBar\":\"∦\",\"NotElement\":\"∉\",\"NotEqual\":\"≠\",\"NotEqualTilde\":\"≂̸\",\"NotExists\":\"∄\",\"NotGreater\":\"≯\",\"NotGreaterEqual\":\"≱\",\"NotGreaterFullEqual\":\"≧̸\",\"NotGreaterGreater\":\"≫̸\",\"NotGreaterLess\":\"≹\",\"NotGreaterSlantEqual\":\"⩾̸\",\"NotGreaterTilde\":\"≵\",\"NotHumpDownHump\":\"≎̸\",\"NotHumpEqual\":\"≏̸\",\"notin\":\"∉\",\"notindot\":\"⋵̸\",\"notinE\":\"⋹̸\",\"notinva\":\"∉\",\"notinvb\":\"⋷\",\"notinvc\":\"⋶\",\"NotLeftTriangleBar\":\"⧏̸\",\"NotLeftTriangle\":\"⋪\",\"NotLeftTriangleEqual\":\"⋬\",\"NotLess\":\"≮\",\"NotLessEqual\":\"≰\",\"NotLessGreater\":\"≸\",\"NotLessLess\":\"≪̸\",\"NotLessSlantEqual\":\"⩽̸\",\"NotLessTilde\":\"≴\",\"NotNestedGreaterGreater\":\"⪢̸\",\"NotNestedLessLess\":\"⪡̸\",\"notni\":\"∌\",\"notniva\":\"∌\",\"notnivb\":\"⋾\",\"notnivc\":\"⋽\",\"NotPrecedes\":\"⊀\",\"NotPrecedesEqual\":\"⪯̸\",\"NotPrecedesSlantEqual\":\"⋠\",\"NotReverseElement\":\"∌\",\"NotRightTriangleBar\":\"⧐̸\",\"NotRightTriangle\":\"⋫\",\"NotRightTriangleEqual\":\"⋭\",\"NotSquareSubset\":\"⊏̸\",\"NotSquareSubsetEqual\":\"⋢\",\"NotSquareSuperset\":\"⊐̸\",\"NotSquareSupersetEqual\":\"⋣\",\"NotSubset\":\"⊂⃒\",\"NotSubsetEqual\":\"⊈\",\"NotSucceeds\":\"⊁\",\"NotSucceedsEqual\":\"⪰̸\",\"NotSucceedsSlantEqual\":\"⋡\",\"NotSucceedsTilde\":\"≿̸\",\"NotSuperset\":\"⊃⃒\",\"NotSupersetEqual\":\"⊉\",\"NotTilde\":\"≁\",\"NotTildeEqual\":\"≄\",\"NotTildeFullEqual\":\"≇\",\"NotTildeTilde\":\"≉\",\"NotVerticalBar\":\"∤\",\"nparallel\":\"∦\",\"npar\":\"∦\",\"nparsl\":\"⫽⃥\",\"npart\":\"∂̸\",\"npolint\":\"⨔\",\"npr\":\"⊀\",\"nprcue\":\"⋠\",\"nprec\":\"⊀\",\"npreceq\":\"⪯̸\",\"npre\":\"⪯̸\",\"nrarrc\":\"⤳̸\",\"nrarr\":\"↛\",\"nrArr\":\"⇏\",\"nrarrw\":\"↝̸\",\"nrightarrow\":\"↛\",\"nRightarrow\":\"⇏\",\"nrtri\":\"⋫\",\"nrtrie\":\"⋭\",\"nsc\":\"⊁\",\"nsccue\":\"⋡\",\"nsce\":\"⪰̸\",\"Nscr\":\"𝒩\",\"nscr\":\"𝓃\",\"nshortmid\":\"∤\",\"nshortparallel\":\"∦\",\"nsim\":\"≁\",\"nsime\":\"≄\",\"nsimeq\":\"≄\",\"nsmid\":\"∤\",\"nspar\":\"∦\",\"nsqsube\":\"⋢\",\"nsqsupe\":\"⋣\",\"nsub\":\"⊄\",\"nsubE\":\"⫅̸\",\"nsube\":\"⊈\",\"nsubset\":\"⊂⃒\",\"nsubseteq\":\"⊈\",\"nsubseteqq\":\"⫅̸\",\"nsucc\":\"⊁\",\"nsucceq\":\"⪰̸\",\"nsup\":\"⊅\",\"nsupE\":\"⫆̸\",\"nsupe\":\"⊉\",\"nsupset\":\"⊃⃒\",\"nsupseteq\":\"⊉\",\"nsupseteqq\":\"⫆̸\",\"ntgl\":\"≹\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"ntlg\":\"≸\",\"ntriangleleft\":\"⋪\",\"ntrianglelefteq\":\"⋬\",\"ntriangleright\":\"⋫\",\"ntrianglerighteq\":\"⋭\",\"Nu\":\"Ν\",\"nu\":\"ν\",\"num\":\"#\",\"numero\":\"№\",\"numsp\":\" \",\"nvap\":\"≍⃒\",\"nvdash\":\"⊬\",\"nvDash\":\"⊭\",\"nVdash\":\"⊮\",\"nVDash\":\"⊯\",\"nvge\":\"≥⃒\",\"nvgt\":\">⃒\",\"nvHarr\":\"⤄\",\"nvinfin\":\"⧞\",\"nvlArr\":\"⤂\",\"nvle\":\"≤⃒\",\"nvlt\":\"<⃒\",\"nvltrie\":\"⊴⃒\",\"nvrArr\":\"⤃\",\"nvrtrie\":\"⊵⃒\",\"nvsim\":\"∼⃒\",\"nwarhk\":\"⤣\",\"nwarr\":\"↖\",\"nwArr\":\"⇖\",\"nwarrow\":\"↖\",\"nwnear\":\"⤧\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"oast\":\"⊛\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"ocir\":\"⊚\",\"Ocy\":\"О\",\"ocy\":\"о\",\"odash\":\"⊝\",\"Odblac\":\"Ő\",\"odblac\":\"ő\",\"odiv\":\"⨸\",\"odot\":\"⊙\",\"odsold\":\"⦼\",\"OElig\":\"Œ\",\"oelig\":\"œ\",\"ofcir\":\"⦿\",\"Ofr\":\"𝔒\",\"ofr\":\"𝔬\",\"ogon\":\"˛\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ogt\":\"⧁\",\"ohbar\":\"⦵\",\"ohm\":\"Ω\",\"oint\":\"∮\",\"olarr\":\"↺\",\"olcir\":\"⦾\",\"olcross\":\"⦻\",\"oline\":\"‾\",\"olt\":\"⧀\",\"Omacr\":\"Ō\",\"omacr\":\"ō\",\"Omega\":\"Ω\",\"omega\":\"ω\",\"Omicron\":\"Ο\",\"omicron\":\"ο\",\"omid\":\"⦶\",\"ominus\":\"⊖\",\"Oopf\":\"𝕆\",\"oopf\":\"𝕠\",\"opar\":\"⦷\",\"OpenCurlyDoubleQuote\":\"“\",\"OpenCurlyQuote\":\"‘\",\"operp\":\"⦹\",\"oplus\":\"⊕\",\"orarr\":\"↻\",\"Or\":\"⩔\",\"or\":\"∨\",\"ord\":\"⩝\",\"order\":\"ℴ\",\"orderof\":\"ℴ\",\"ordf\":\"ª\",\"ordm\":\"º\",\"origof\":\"⊶\",\"oror\":\"⩖\",\"orslope\":\"⩗\",\"orv\":\"⩛\",\"oS\":\"Ⓢ\",\"Oscr\":\"𝒪\",\"oscr\":\"ℴ\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"osol\":\"⊘\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"otimesas\":\"⨶\",\"Otimes\":\"⨷\",\"otimes\":\"⊗\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"ovbar\":\"⌽\",\"OverBar\":\"‾\",\"OverBrace\":\"⏞\",\"OverBracket\":\"⎴\",\"OverParenthesis\":\"⏜\",\"para\":\"¶\",\"parallel\":\"∥\",\"par\":\"∥\",\"parsim\":\"⫳\",\"parsl\":\"⫽\",\"part\":\"∂\",\"PartialD\":\"∂\",\"Pcy\":\"П\",\"pcy\":\"п\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"‰\",\"perp\":\"⊥\",\"pertenk\":\"‱\",\"Pfr\":\"𝔓\",\"pfr\":\"𝔭\",\"Phi\":\"Φ\",\"phi\":\"φ\",\"phiv\":\"ϕ\",\"phmmat\":\"ℳ\",\"phone\":\"☎\",\"Pi\":\"Π\",\"pi\":\"π\",\"pitchfork\":\"⋔\",\"piv\":\"ϖ\",\"planck\":\"ℏ\",\"planckh\":\"ℎ\",\"plankv\":\"ℏ\",\"plusacir\":\"⨣\",\"plusb\":\"⊞\",\"pluscir\":\"⨢\",\"plus\":\"+\",\"plusdo\":\"∔\",\"plusdu\":\"⨥\",\"pluse\":\"⩲\",\"PlusMinus\":\"±\",\"plusmn\":\"±\",\"plussim\":\"⨦\",\"plustwo\":\"⨧\",\"pm\":\"±\",\"Poincareplane\":\"ℌ\",\"pointint\":\"⨕\",\"popf\":\"𝕡\",\"Popf\":\"ℙ\",\"pound\":\"£\",\"prap\":\"⪷\",\"Pr\":\"⪻\",\"pr\":\"≺\",\"prcue\":\"≼\",\"precapprox\":\"⪷\",\"prec\":\"≺\",\"preccurlyeq\":\"≼\",\"Precedes\":\"≺\",\"PrecedesEqual\":\"⪯\",\"PrecedesSlantEqual\":\"≼\",\"PrecedesTilde\":\"≾\",\"preceq\":\"⪯\",\"precnapprox\":\"⪹\",\"precneqq\":\"⪵\",\"precnsim\":\"⋨\",\"pre\":\"⪯\",\"prE\":\"⪳\",\"precsim\":\"≾\",\"prime\":\"′\",\"Prime\":\"″\",\"primes\":\"ℙ\",\"prnap\":\"⪹\",\"prnE\":\"⪵\",\"prnsim\":\"⋨\",\"prod\":\"∏\",\"Product\":\"∏\",\"profalar\":\"⌮\",\"profline\":\"⌒\",\"profsurf\":\"⌓\",\"prop\":\"∝\",\"Proportional\":\"∝\",\"Proportion\":\"∷\",\"propto\":\"∝\",\"prsim\":\"≾\",\"prurel\":\"⊰\",\"Pscr\":\"𝒫\",\"pscr\":\"𝓅\",\"Psi\":\"Ψ\",\"psi\":\"ψ\",\"puncsp\":\" \",\"Qfr\":\"𝔔\",\"qfr\":\"𝔮\",\"qint\":\"⨌\",\"qopf\":\"𝕢\",\"Qopf\":\"ℚ\",\"qprime\":\"⁗\",\"Qscr\":\"𝒬\",\"qscr\":\"𝓆\",\"quaternions\":\"ℍ\",\"quatint\":\"⨖\",\"quest\":\"?\",\"questeq\":\"≟\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"rAarr\":\"⇛\",\"race\":\"∽̱\",\"Racute\":\"Ŕ\",\"racute\":\"ŕ\",\"radic\":\"√\",\"raemptyv\":\"⦳\",\"rang\":\"⟩\",\"Rang\":\"⟫\",\"rangd\":\"⦒\",\"range\":\"⦥\",\"rangle\":\"⟩\",\"raquo\":\"»\",\"rarrap\":\"⥵\",\"rarrb\":\"⇥\",\"rarrbfs\":\"⤠\",\"rarrc\":\"⤳\",\"rarr\":\"→\",\"Rarr\":\"↠\",\"rArr\":\"⇒\",\"rarrfs\":\"⤞\",\"rarrhk\":\"↪\",\"rarrlp\":\"↬\",\"rarrpl\":\"⥅\",\"rarrsim\":\"⥴\",\"Rarrtl\":\"⤖\",\"rarrtl\":\"↣\",\"rarrw\":\"↝\",\"ratail\":\"⤚\",\"rAtail\":\"⤜\",\"ratio\":\"∶\",\"rationals\":\"ℚ\",\"rbarr\":\"⤍\",\"rBarr\":\"⤏\",\"RBarr\":\"⤐\",\"rbbrk\":\"❳\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"⦌\",\"rbrksld\":\"⦎\",\"rbrkslu\":\"⦐\",\"Rcaron\":\"Ř\",\"rcaron\":\"ř\",\"Rcedil\":\"Ŗ\",\"rcedil\":\"ŗ\",\"rceil\":\"⌉\",\"rcub\":\"}\",\"Rcy\":\"Р\",\"rcy\":\"р\",\"rdca\":\"⤷\",\"rdldhar\":\"⥩\",\"rdquo\":\"”\",\"rdquor\":\"”\",\"rdsh\":\"↳\",\"real\":\"ℜ\",\"realine\":\"ℛ\",\"realpart\":\"ℜ\",\"reals\":\"ℝ\",\"Re\":\"ℜ\",\"rect\":\"▭\",\"reg\":\"®\",\"REG\":\"®\",\"ReverseElement\":\"∋\",\"ReverseEquilibrium\":\"⇋\",\"ReverseUpEquilibrium\":\"⥯\",\"rfisht\":\"⥽\",\"rfloor\":\"⌋\",\"rfr\":\"𝔯\",\"Rfr\":\"ℜ\",\"rHar\":\"⥤\",\"rhard\":\"⇁\",\"rharu\":\"⇀\",\"rharul\":\"⥬\",\"Rho\":\"Ρ\",\"rho\":\"ρ\",\"rhov\":\"ϱ\",\"RightAngleBracket\":\"⟩\",\"RightArrowBar\":\"⇥\",\"rightarrow\":\"→\",\"RightArrow\":\"→\",\"Rightarrow\":\"⇒\",\"RightArrowLeftArrow\":\"⇄\",\"rightarrowtail\":\"↣\",\"RightCeiling\":\"⌉\",\"RightDoubleBracket\":\"⟧\",\"RightDownTeeVector\":\"⥝\",\"RightDownVectorBar\":\"⥕\",\"RightDownVector\":\"⇂\",\"RightFloor\":\"⌋\",\"rightharpoondown\":\"⇁\",\"rightharpoonup\":\"⇀\",\"rightleftarrows\":\"⇄\",\"rightleftharpoons\":\"⇌\",\"rightrightarrows\":\"⇉\",\"rightsquigarrow\":\"↝\",\"RightTeeArrow\":\"↦\",\"RightTee\":\"⊢\",\"RightTeeVector\":\"⥛\",\"rightthreetimes\":\"⋌\",\"RightTriangleBar\":\"⧐\",\"RightTriangle\":\"⊳\",\"RightTriangleEqual\":\"⊵\",\"RightUpDownVector\":\"⥏\",\"RightUpTeeVector\":\"⥜\",\"RightUpVectorBar\":\"⥔\",\"RightUpVector\":\"↾\",\"RightVectorBar\":\"⥓\",\"RightVector\":\"⇀\",\"ring\":\"˚\",\"risingdotseq\":\"≓\",\"rlarr\":\"⇄\",\"rlhar\":\"⇌\",\"rlm\":\"‏\",\"rmoustache\":\"⎱\",\"rmoust\":\"⎱\",\"rnmid\":\"⫮\",\"roang\":\"⟭\",\"roarr\":\"⇾\",\"robrk\":\"⟧\",\"ropar\":\"⦆\",\"ropf\":\"𝕣\",\"Ropf\":\"ℝ\",\"roplus\":\"⨮\",\"rotimes\":\"⨵\",\"RoundImplies\":\"⥰\",\"rpar\":\")\",\"rpargt\":\"⦔\",\"rppolint\":\"⨒\",\"rrarr\":\"⇉\",\"Rrightarrow\":\"⇛\",\"rsaquo\":\"›\",\"rscr\":\"𝓇\",\"Rscr\":\"ℛ\",\"rsh\":\"↱\",\"Rsh\":\"↱\",\"rsqb\":\"]\",\"rsquo\":\"’\",\"rsquor\":\"’\",\"rthree\":\"⋌\",\"rtimes\":\"⋊\",\"rtri\":\"▹\",\"rtrie\":\"⊵\",\"rtrif\":\"▸\",\"rtriltri\":\"⧎\",\"RuleDelayed\":\"⧴\",\"ruluhar\":\"⥨\",\"rx\":\"℞\",\"Sacute\":\"Ś\",\"sacute\":\"ś\",\"sbquo\":\"‚\",\"scap\":\"⪸\",\"Scaron\":\"Š\",\"scaron\":\"š\",\"Sc\":\"⪼\",\"sc\":\"≻\",\"sccue\":\"≽\",\"sce\":\"⪰\",\"scE\":\"⪴\",\"Scedil\":\"Ş\",\"scedil\":\"ş\",\"Scirc\":\"Ŝ\",\"scirc\":\"ŝ\",\"scnap\":\"⪺\",\"scnE\":\"⪶\",\"scnsim\":\"⋩\",\"scpolint\":\"⨓\",\"scsim\":\"≿\",\"Scy\":\"С\",\"scy\":\"с\",\"sdotb\":\"⊡\",\"sdot\":\"⋅\",\"sdote\":\"⩦\",\"searhk\":\"⤥\",\"searr\":\"↘\",\"seArr\":\"⇘\",\"searrow\":\"↘\",\"sect\":\"§\",\"semi\":\";\",\"seswar\":\"⤩\",\"setminus\":\"∖\",\"setmn\":\"∖\",\"sext\":\"✶\",\"Sfr\":\"𝔖\",\"sfr\":\"𝔰\",\"sfrown\":\"⌢\",\"sharp\":\"♯\",\"SHCHcy\":\"Щ\",\"shchcy\":\"щ\",\"SHcy\":\"Ш\",\"shcy\":\"ш\",\"ShortDownArrow\":\"↓\",\"ShortLeftArrow\":\"←\",\"shortmid\":\"∣\",\"shortparallel\":\"∥\",\"ShortRightArrow\":\"→\",\"ShortUpArrow\":\"↑\",\"shy\":\"­\",\"Sigma\":\"Σ\",\"sigma\":\"σ\",\"sigmaf\":\"ς\",\"sigmav\":\"ς\",\"sim\":\"∼\",\"simdot\":\"⩪\",\"sime\":\"≃\",\"simeq\":\"≃\",\"simg\":\"⪞\",\"simgE\":\"⪠\",\"siml\":\"⪝\",\"simlE\":\"⪟\",\"simne\":\"≆\",\"simplus\":\"⨤\",\"simrarr\":\"⥲\",\"slarr\":\"←\",\"SmallCircle\":\"∘\",\"smallsetminus\":\"∖\",\"smashp\":\"⨳\",\"smeparsl\":\"⧤\",\"smid\":\"∣\",\"smile\":\"⌣\",\"smt\":\"⪪\",\"smte\":\"⪬\",\"smtes\":\"⪬︀\",\"SOFTcy\":\"Ь\",\"softcy\":\"ь\",\"solbar\":\"⌿\",\"solb\":\"⧄\",\"sol\":\"/\",\"Sopf\":\"𝕊\",\"sopf\":\"𝕤\",\"spades\":\"♠\",\"spadesuit\":\"♠\",\"spar\":\"∥\",\"sqcap\":\"⊓\",\"sqcaps\":\"⊓︀\",\"sqcup\":\"⊔\",\"sqcups\":\"⊔︀\",\"Sqrt\":\"√\",\"sqsub\":\"⊏\",\"sqsube\":\"⊑\",\"sqsubset\":\"⊏\",\"sqsubseteq\":\"⊑\",\"sqsup\":\"⊐\",\"sqsupe\":\"⊒\",\"sqsupset\":\"⊐\",\"sqsupseteq\":\"⊒\",\"square\":\"□\",\"Square\":\"□\",\"SquareIntersection\":\"⊓\",\"SquareSubset\":\"⊏\",\"SquareSubsetEqual\":\"⊑\",\"SquareSuperset\":\"⊐\",\"SquareSupersetEqual\":\"⊒\",\"SquareUnion\":\"⊔\",\"squarf\":\"▪\",\"squ\":\"□\",\"squf\":\"▪\",\"srarr\":\"→\",\"Sscr\":\"𝒮\",\"sscr\":\"𝓈\",\"ssetmn\":\"∖\",\"ssmile\":\"⌣\",\"sstarf\":\"⋆\",\"Star\":\"⋆\",\"star\":\"☆\",\"starf\":\"★\",\"straightepsilon\":\"ϵ\",\"straightphi\":\"ϕ\",\"strns\":\"¯\",\"sub\":\"⊂\",\"Sub\":\"⋐\",\"subdot\":\"⪽\",\"subE\":\"⫅\",\"sube\":\"⊆\",\"subedot\":\"⫃\",\"submult\":\"⫁\",\"subnE\":\"⫋\",\"subne\":\"⊊\",\"subplus\":\"⪿\",\"subrarr\":\"⥹\",\"subset\":\"⊂\",\"Subset\":\"⋐\",\"subseteq\":\"⊆\",\"subseteqq\":\"⫅\",\"SubsetEqual\":\"⊆\",\"subsetneq\":\"⊊\",\"subsetneqq\":\"⫋\",\"subsim\":\"⫇\",\"subsub\":\"⫕\",\"subsup\":\"⫓\",\"succapprox\":\"⪸\",\"succ\":\"≻\",\"succcurlyeq\":\"≽\",\"Succeeds\":\"≻\",\"SucceedsEqual\":\"⪰\",\"SucceedsSlantEqual\":\"≽\",\"SucceedsTilde\":\"≿\",\"succeq\":\"⪰\",\"succnapprox\":\"⪺\",\"succneqq\":\"⪶\",\"succnsim\":\"⋩\",\"succsim\":\"≿\",\"SuchThat\":\"∋\",\"sum\":\"∑\",\"Sum\":\"∑\",\"sung\":\"♪\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"sup\":\"⊃\",\"Sup\":\"⋑\",\"supdot\":\"⪾\",\"supdsub\":\"⫘\",\"supE\":\"⫆\",\"supe\":\"⊇\",\"supedot\":\"⫄\",\"Superset\":\"⊃\",\"SupersetEqual\":\"⊇\",\"suphsol\":\"⟉\",\"suphsub\":\"⫗\",\"suplarr\":\"⥻\",\"supmult\":\"⫂\",\"supnE\":\"⫌\",\"supne\":\"⊋\",\"supplus\":\"⫀\",\"supset\":\"⊃\",\"Supset\":\"⋑\",\"supseteq\":\"⊇\",\"supseteqq\":\"⫆\",\"supsetneq\":\"⊋\",\"supsetneqq\":\"⫌\",\"supsim\":\"⫈\",\"supsub\":\"⫔\",\"supsup\":\"⫖\",\"swarhk\":\"⤦\",\"swarr\":\"↙\",\"swArr\":\"⇙\",\"swarrow\":\"↙\",\"swnwar\":\"⤪\",\"szlig\":\"ß\",\"Tab\":\"\\t\",\"target\":\"⌖\",\"Tau\":\"Τ\",\"tau\":\"τ\",\"tbrk\":\"⎴\",\"Tcaron\":\"Ť\",\"tcaron\":\"ť\",\"Tcedil\":\"Ţ\",\"tcedil\":\"ţ\",\"Tcy\":\"Т\",\"tcy\":\"т\",\"tdot\":\"⃛\",\"telrec\":\"⌕\",\"Tfr\":\"𝔗\",\"tfr\":\"𝔱\",\"there4\":\"∴\",\"therefore\":\"∴\",\"Therefore\":\"∴\",\"Theta\":\"Θ\",\"theta\":\"θ\",\"thetasym\":\"ϑ\",\"thetav\":\"ϑ\",\"thickapprox\":\"≈\",\"thicksim\":\"∼\",\"ThickSpace\":\"  \",\"ThinSpace\":\" \",\"thinsp\":\" \",\"thkap\":\"≈\",\"thksim\":\"∼\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"tilde\":\"˜\",\"Tilde\":\"∼\",\"TildeEqual\":\"≃\",\"TildeFullEqual\":\"≅\",\"TildeTilde\":\"≈\",\"timesbar\":\"⨱\",\"timesb\":\"⊠\",\"times\":\"×\",\"timesd\":\"⨰\",\"tint\":\"∭\",\"toea\":\"⤨\",\"topbot\":\"⌶\",\"topcir\":\"⫱\",\"top\":\"⊤\",\"Topf\":\"𝕋\",\"topf\":\"𝕥\",\"topfork\":\"⫚\",\"tosa\":\"⤩\",\"tprime\":\"‴\",\"trade\":\"™\",\"TRADE\":\"™\",\"triangle\":\"▵\",\"triangledown\":\"▿\",\"triangleleft\":\"◃\",\"trianglelefteq\":\"⊴\",\"triangleq\":\"≜\",\"triangleright\":\"▹\",\"trianglerighteq\":\"⊵\",\"tridot\":\"◬\",\"trie\":\"≜\",\"triminus\":\"⨺\",\"TripleDot\":\"⃛\",\"triplus\":\"⨹\",\"trisb\":\"⧍\",\"tritime\":\"⨻\",\"trpezium\":\"⏢\",\"Tscr\":\"𝒯\",\"tscr\":\"𝓉\",\"TScy\":\"Ц\",\"tscy\":\"ц\",\"TSHcy\":\"Ћ\",\"tshcy\":\"ћ\",\"Tstrok\":\"Ŧ\",\"tstrok\":\"ŧ\",\"twixt\":\"≬\",\"twoheadleftarrow\":\"↞\",\"twoheadrightarrow\":\"↠\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"uarr\":\"↑\",\"Uarr\":\"↟\",\"uArr\":\"⇑\",\"Uarrocir\":\"⥉\",\"Ubrcy\":\"Ў\",\"ubrcy\":\"ў\",\"Ubreve\":\"Ŭ\",\"ubreve\":\"ŭ\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ucy\":\"У\",\"ucy\":\"у\",\"udarr\":\"⇅\",\"Udblac\":\"Ű\",\"udblac\":\"ű\",\"udhar\":\"⥮\",\"ufisht\":\"⥾\",\"Ufr\":\"𝔘\",\"ufr\":\"𝔲\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uHar\":\"⥣\",\"uharl\":\"↿\",\"uharr\":\"↾\",\"uhblk\":\"▀\",\"ulcorn\":\"⌜\",\"ulcorner\":\"⌜\",\"ulcrop\":\"⌏\",\"ultri\":\"◸\",\"Umacr\":\"Ū\",\"umacr\":\"ū\",\"uml\":\"¨\",\"UnderBar\":\"_\",\"UnderBrace\":\"⏟\",\"UnderBracket\":\"⎵\",\"UnderParenthesis\":\"⏝\",\"Union\":\"⋃\",\"UnionPlus\":\"⊎\",\"Uogon\":\"Ų\",\"uogon\":\"ų\",\"Uopf\":\"𝕌\",\"uopf\":\"𝕦\",\"UpArrowBar\":\"⤒\",\"uparrow\":\"↑\",\"UpArrow\":\"↑\",\"Uparrow\":\"⇑\",\"UpArrowDownArrow\":\"⇅\",\"updownarrow\":\"↕\",\"UpDownArrow\":\"↕\",\"Updownarrow\":\"⇕\",\"UpEquilibrium\":\"⥮\",\"upharpoonleft\":\"↿\",\"upharpoonright\":\"↾\",\"uplus\":\"⊎\",\"UpperLeftArrow\":\"↖\",\"UpperRightArrow\":\"↗\",\"upsi\":\"υ\",\"Upsi\":\"ϒ\",\"upsih\":\"ϒ\",\"Upsilon\":\"Υ\",\"upsilon\":\"υ\",\"UpTeeArrow\":\"↥\",\"UpTee\":\"⊥\",\"upuparrows\":\"⇈\",\"urcorn\":\"⌝\",\"urcorner\":\"⌝\",\"urcrop\":\"⌎\",\"Uring\":\"Ů\",\"uring\":\"ů\",\"urtri\":\"◹\",\"Uscr\":\"𝒰\",\"uscr\":\"𝓊\",\"utdot\":\"⋰\",\"Utilde\":\"Ũ\",\"utilde\":\"ũ\",\"utri\":\"▵\",\"utrif\":\"▴\",\"uuarr\":\"⇈\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"uwangle\":\"⦧\",\"vangrt\":\"⦜\",\"varepsilon\":\"ϵ\",\"varkappa\":\"ϰ\",\"varnothing\":\"∅\",\"varphi\":\"ϕ\",\"varpi\":\"ϖ\",\"varpropto\":\"∝\",\"varr\":\"↕\",\"vArr\":\"⇕\",\"varrho\":\"ϱ\",\"varsigma\":\"ς\",\"varsubsetneq\":\"⊊︀\",\"varsubsetneqq\":\"⫋︀\",\"varsupsetneq\":\"⊋︀\",\"varsupsetneqq\":\"⫌︀\",\"vartheta\":\"ϑ\",\"vartriangleleft\":\"⊲\",\"vartriangleright\":\"⊳\",\"vBar\":\"⫨\",\"Vbar\":\"⫫\",\"vBarv\":\"⫩\",\"Vcy\":\"В\",\"vcy\":\"в\",\"vdash\":\"⊢\",\"vDash\":\"⊨\",\"Vdash\":\"⊩\",\"VDash\":\"⊫\",\"Vdashl\":\"⫦\",\"veebar\":\"⊻\",\"vee\":\"∨\",\"Vee\":\"⋁\",\"veeeq\":\"≚\",\"vellip\":\"⋮\",\"verbar\":\"|\",\"Verbar\":\"‖\",\"vert\":\"|\",\"Vert\":\"‖\",\"VerticalBar\":\"∣\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"❘\",\"VerticalTilde\":\"≀\",\"VeryThinSpace\":\" \",\"Vfr\":\"𝔙\",\"vfr\":\"𝔳\",\"vltri\":\"⊲\",\"vnsub\":\"⊂⃒\",\"vnsup\":\"⊃⃒\",\"Vopf\":\"𝕍\",\"vopf\":\"𝕧\",\"vprop\":\"∝\",\"vrtri\":\"⊳\",\"Vscr\":\"𝒱\",\"vscr\":\"𝓋\",\"vsubnE\":\"⫋︀\",\"vsubne\":\"⊊︀\",\"vsupnE\":\"⫌︀\",\"vsupne\":\"⊋︀\",\"Vvdash\":\"⊪\",\"vzigzag\":\"⦚\",\"Wcirc\":\"Ŵ\",\"wcirc\":\"ŵ\",\"wedbar\":\"⩟\",\"wedge\":\"∧\",\"Wedge\":\"⋀\",\"wedgeq\":\"≙\",\"weierp\":\"℘\",\"Wfr\":\"𝔚\",\"wfr\":\"𝔴\",\"Wopf\":\"𝕎\",\"wopf\":\"𝕨\",\"wp\":\"℘\",\"wr\":\"≀\",\"wreath\":\"≀\",\"Wscr\":\"𝒲\",\"wscr\":\"𝓌\",\"xcap\":\"⋂\",\"xcirc\":\"◯\",\"xcup\":\"⋃\",\"xdtri\":\"▽\",\"Xfr\":\"𝔛\",\"xfr\":\"𝔵\",\"xharr\":\"⟷\",\"xhArr\":\"⟺\",\"Xi\":\"Ξ\",\"xi\":\"ξ\",\"xlarr\":\"⟵\",\"xlArr\":\"⟸\",\"xmap\":\"⟼\",\"xnis\":\"⋻\",\"xodot\":\"⨀\",\"Xopf\":\"𝕏\",\"xopf\":\"𝕩\",\"xoplus\":\"⨁\",\"xotime\":\"⨂\",\"xrarr\":\"⟶\",\"xrArr\":\"⟹\",\"Xscr\":\"𝒳\",\"xscr\":\"𝓍\",\"xsqcup\":\"⨆\",\"xuplus\":\"⨄\",\"xutri\":\"△\",\"xvee\":\"⋁\",\"xwedge\":\"⋀\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"YAcy\":\"Я\",\"yacy\":\"я\",\"Ycirc\":\"Ŷ\",\"ycirc\":\"ŷ\",\"Ycy\":\"Ы\",\"ycy\":\"ы\",\"yen\":\"¥\",\"Yfr\":\"𝔜\",\"yfr\":\"𝔶\",\"YIcy\":\"Ї\",\"yicy\":\"ї\",\"Yopf\":\"𝕐\",\"yopf\":\"𝕪\",\"Yscr\":\"𝒴\",\"yscr\":\"𝓎\",\"YUcy\":\"Ю\",\"yucy\":\"ю\",\"yuml\":\"ÿ\",\"Yuml\":\"Ÿ\",\"Zacute\":\"Ź\",\"zacute\":\"ź\",\"Zcaron\":\"Ž\",\"zcaron\":\"ž\",\"Zcy\":\"З\",\"zcy\":\"з\",\"Zdot\":\"Ż\",\"zdot\":\"ż\",\"zeetrf\":\"ℨ\",\"ZeroWidthSpace\":\"​\",\"Zeta\":\"Ζ\",\"zeta\":\"ζ\",\"zfr\":\"𝔷\",\"Zfr\":\"ℨ\",\"ZHcy\":\"Ж\",\"zhcy\":\"ж\",\"zigrarr\":\"⇝\",\"zopf\":\"𝕫\",\"Zopf\":\"ℤ\",\"Zscr\":\"𝒵\",\"zscr\":\"𝓏\",\"zwj\":\"‍\",\"zwnj\":\"‌\"}");

/***/ }),

/***/ "./node_modules/entities/maps/legacy.json":
/*!************************************************!*\
  !*** ./node_modules/entities/maps/legacy.json ***!
  \************************************************/
/*! exports provided: Aacute, aacute, Acirc, acirc, acute, AElig, aelig, Agrave, agrave, amp, AMP, Aring, aring, Atilde, atilde, Auml, auml, brvbar, Ccedil, ccedil, cedil, cent, copy, COPY, curren, deg, divide, Eacute, eacute, Ecirc, ecirc, Egrave, egrave, ETH, eth, Euml, euml, frac12, frac14, frac34, gt, GT, Iacute, iacute, Icirc, icirc, iexcl, Igrave, igrave, iquest, Iuml, iuml, laquo, lt, LT, macr, micro, middot, nbsp, not, Ntilde, ntilde, Oacute, oacute, Ocirc, ocirc, Ograve, ograve, ordf, ordm, Oslash, oslash, Otilde, otilde, Ouml, ouml, para, plusmn, pound, quot, QUOT, raquo, reg, REG, sect, shy, sup1, sup2, sup3, szlig, THORN, thorn, times, Uacute, uacute, Ucirc, ucirc, Ugrave, ugrave, uml, Uuml, uuml, Yacute, yacute, yen, yuml, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"Agrave\":\"À\",\"agrave\":\"à\",\"amp\":\"&\",\"AMP\":\"&\",\"Aring\":\"Å\",\"aring\":\"å\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"brvbar\":\"¦\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"cedil\":\"¸\",\"cent\":\"¢\",\"copy\":\"©\",\"COPY\":\"©\",\"curren\":\"¤\",\"deg\":\"°\",\"divide\":\"÷\",\"Eacute\":\"É\",\"eacute\":\"é\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"Egrave\":\"È\",\"egrave\":\"è\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"frac12\":\"½\",\"frac14\":\"¼\",\"frac34\":\"¾\",\"gt\":\">\",\"GT\":\">\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"iexcl\":\"¡\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"iquest\":\"¿\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"laquo\":\"«\",\"lt\":\"<\",\"LT\":\"<\",\"macr\":\"¯\",\"micro\":\"µ\",\"middot\":\"·\",\"nbsp\":\" \",\"not\":\"¬\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ordf\":\"ª\",\"ordm\":\"º\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"para\":\"¶\",\"plusmn\":\"±\",\"pound\":\"£\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"raquo\":\"»\",\"reg\":\"®\",\"REG\":\"®\",\"sect\":\"§\",\"shy\":\"­\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"szlig\":\"ß\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"times\":\"×\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uml\":\"¨\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"yen\":\"¥\",\"yuml\":\"ÿ\"}");

/***/ }),

/***/ "./node_modules/entities/maps/xml.json":
/*!*********************************************!*\
  !*** ./node_modules/entities/maps/xml.json ***!
  \*********************************************/
/*! exports provided: amp, apos, gt, lt, quot, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"amp\":\"&\",\"apos\":\"'\",\"gt\":\">\",\"lt\":\"<\",\"quot\":\"\\\"\"}");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),

/***/ "./node_modules/format-message-formats/index.js":
/*!******************************************************!*\
  !*** ./node_modules/format-message-formats/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// @flow
var LONG = 'long'
var SHORT = 'short'
var NARROW = 'narrow'
var NUMERIC = 'numeric'
var TWODIGIT = '2-digit'

/**
 * formatting information
 **/
module.exports = {
  number: {
    decimal: {
      style: 'decimal'
    },
    integer: {
      style: 'decimal',
      maximumFractionDigits: 0
    },
    currency: {
      style: 'currency',
      currency: 'USD'
    },
    percent: {
      style: 'percent'
    },
    default: {
      style: 'decimal'
    }
  },
  date: {
    short: {
      month: NUMERIC,
      day: NUMERIC,
      year: TWODIGIT
    },
    medium: {
      month: SHORT,
      day: NUMERIC,
      year: NUMERIC
    },
    long: {
      month: LONG,
      day: NUMERIC,
      year: NUMERIC
    },
    full: {
      month: LONG,
      day: NUMERIC,
      year: NUMERIC,
      weekday: LONG
    },
    default: {
      month: SHORT,
      day: NUMERIC,
      year: NUMERIC
    }
  },
  time: {
    short: {
      hour: NUMERIC,
      minute: NUMERIC
    },
    medium: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC
    },
    long: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC,
      timeZoneName: SHORT
    },
    full: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC,
      timeZoneName: SHORT
    },
    default: {
      hour: NUMERIC,
      minute: NUMERIC,
      second: NUMERIC
    }
  },
  duration: {
    default: {
      hours: {
        minimumIntegerDigits: 1,
        maximumFractionDigits: 0
      },
      minutes: {
        minimumIntegerDigits: 2,
        maximumFractionDigits: 0
      },
      seconds: {
        minimumIntegerDigits: 2,
        maximumFractionDigits: 3
      }
    }
  },
  parseNumberPattern: function (pattern/*: ?string */) {
    if (!pattern) return
    var options = {}
    var currency = pattern.match(/\b[A-Z]{3}\b/i)
    var syms = pattern.replace(/[^¤]/g, '').length
    if (!syms && currency) syms = 1
    if (syms) {
      options.style = 'currency'
      options.currencyDisplay = syms === 1 ? 'symbol' : syms === 2 ? 'code' : 'name'
      options.currency = currency ? currency[0].toUpperCase() : 'USD'
    } else if (pattern.indexOf('%') >= 0) {
      options.style = 'percent'
    }
    if (!/[@#0]/.test(pattern)) return options.style ? options : undefined
    options.useGrouping = pattern.indexOf(',') >= 0
    if (/E\+?[@#0]+/i.test(pattern) || pattern.indexOf('@') >= 0) {
      var size = pattern.replace(/E\+?[@#0]+|[^@#0]/gi, '')
      options.minimumSignificantDigits = Math.min(Math.max(size.replace(/[^@0]/g, '').length, 1), 21)
      options.maximumSignificantDigits = Math.min(Math.max(size.length, 1), 21)
    } else {
      var parts = pattern.replace(/[^#0.]/g, '').split('.')
      var integer = parts[0]
      var n = integer.length - 1
      while (integer[n] === '0') --n
      options.minimumIntegerDigits = Math.min(Math.max(integer.length - 1 - n, 1), 21)
      var fraction = parts[1] || ''
      n = 0
      while (fraction[n] === '0') ++n
      options.minimumFractionDigits = Math.min(Math.max(n, 0), 20)
      while (fraction[n] === '#') ++n
      options.maximumFractionDigits = Math.min(Math.max(n, 0), 20)
    }
    return options
  },
  parseDatePattern: function (pattern/*: ?string */) {
    if (!pattern) return
    var options = {}
    for (var i = 0; i < pattern.length;) {
      var current = pattern[i]
      var n = 1
      while (pattern[++i] === current) ++n
      switch (current) {
        case 'G':
          options.era = n === 5 ? NARROW : n === 4 ? LONG : SHORT
          break
        case 'y':
        case 'Y':
          options.year = n === 2 ? TWODIGIT : NUMERIC
          break
        case 'M':
        case 'L':
          n = Math.min(Math.max(n - 1, 0), 4)
          options.month = [ NUMERIC, TWODIGIT, SHORT, LONG, NARROW ][n]
          break
        case 'E':
        case 'e':
        case 'c':
          options.weekday = n === 5 ? NARROW : n === 4 ? LONG : SHORT
          break
        case 'd':
        case 'D':
          options.day = n === 2 ? TWODIGIT : NUMERIC
          break
        case 'h':
        case 'K':
          options.hour12 = true
          options.hour = n === 2 ? TWODIGIT : NUMERIC
          break
        case 'H':
        case 'k':
          options.hour12 = false
          options.hour = n === 2 ? TWODIGIT : NUMERIC
          break
        case 'm':
          options.minute = n === 2 ? TWODIGIT : NUMERIC
          break
        case 's':
        case 'S':
          options.second = n === 2 ? TWODIGIT : NUMERIC
          break
        case 'z':
        case 'Z':
        case 'v':
        case 'V':
          options.timeZoneName = n === 1 ? SHORT : LONG
          break
      }
    }
    return Object.keys(options).length ? options : undefined
  }
}


/***/ }),

/***/ "./node_modules/format-message-interpret/index.js":
/*!********************************************************!*\
  !*** ./node_modules/format-message-interpret/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @flow

var formats = __webpack_require__(/*! format-message-formats */ "./node_modules/format-message-formats/index.js")
var lookupClosestLocale = __webpack_require__(/*! lookup-closest-locale */ "./node_modules/lookup-closest-locale/index.js")
var plurals = __webpack_require__(/*! ./plurals */ "./node_modules/format-message-interpret/plurals.js")

/*::
import type {
  AST,
  SubMessages
} from '../format-message-parse'
type Locale = string
type Locales = Locale | Locale[]
type Placeholder = any[] // https://github.com/facebook/flow/issues/4050
export type Type = (Placeholder, Locales) => (any, ?Object) => any
export type Types = { [string]: Type }
*/

exports = module.exports = function interpret (
  ast/*: AST */,
  locale/*:: ?: Locales */,
  types/*:: ?: Types */
)/*: (args?: Object) => string */ {
  return interpretAST(ast, null, locale || 'en', types || {}, true)
}

exports.toParts = function toParts (
  ast/*: AST */,
  locale/*:: ?: Locales */,
  types/*:: ?: Types */
)/*: (args?: Object) => any[] */ {
  return interpretAST(ast, null, locale || 'en', types || {}, false)
}

function interpretAST (
  elements/*: any[] */,
  parent/*: ?Placeholder */,
  locale/*: Locales */,
  types/*: Types */,
  join/*: boolean */
)/*: Function */ {
  var parts = elements.map(function (element) {
    return interpretElement(element, parent, locale, types, join)
  })

  if (!join) {
    return function format (args) {
      return parts.reduce(function (parts, part) {
        return parts.concat(part(args))
      }, [])
    }
  }

  if (parts.length === 1) return parts[0]
  return function format (args) {
    var message = ''
    for (var e = 0; e < parts.length; ++e) {
      message += parts[e](args)
    }
    return message
  }
}

function interpretElement (
  element/*: Placeholder */,
  parent/*: ?Placeholder */,
  locale/*: Locales */,
  types/*: Types */,
  join/*: boolean */
)/*: Function */ {
  if (typeof element === 'string') {
    var value/*: string */ = element
    return function format () { return value }
  }

  var id = element[0]
  var type = element[1]

  if (parent && element[0] === '#') {
    id = parent[0]
    var offset = parent[2]
    var formatter = (types.number || defaults.number)([ id, 'number' ], locale)
    return function format (args) {
      return formatter(getArg(id, args) - offset, args)
    }
  }

  // pre-process children
  var children
  if (type === 'plural' || type === 'selectordinal') {
    children = {}
    Object.keys(element[3]).forEach(function (key) {
      children[key] = interpretAST(element[3][key], element, locale, types, join)
    })
    element = [ element[0], element[1], element[2], children ]
  } else if (element[2] && typeof element[2] === 'object') {
    children = {}
    Object.keys(element[2]).forEach(function (key) {
      children[key] = interpretAST(element[2][key], element, locale, types, join)
    })
    element = [ element[0], element[1], children ]
  }

  var getFrmt = type && (types[type] || defaults[type])
  if (getFrmt) {
    var frmt = getFrmt(element, locale)
    return function format (args) {
      return frmt(getArg(id, args), args)
    }
  }

  return join
    ? function format (args) { return String(getArg(id, args)) }
    : function format (args) { return getArg(id, args) }
}

function getArg (id/*: string */, args/*: ?Object */)/*: any */ {
  if (args && (id in args)) return args[id]
  var parts = id.split('.')
  var a = args
  for (var i = 0, ii = parts.length; a && i < ii; ++i) {
    a = a[parts[i]]
  }
  return a
}

function interpretNumber (element/*: Placeholder */, locales/*: Locales */) {
  var style = element[2]
  var options = formats.number[style] || formats.parseNumberPattern(style) || formats.number.default
  return new Intl.NumberFormat(locales, options).format
}

function interpretDuration (element/*: Placeholder */, locales/*: Locales */) {
  var style = element[2]
  var options = formats.duration[style] || formats.duration.default
  var fs = new Intl.NumberFormat(locales, options.seconds).format
  var fm = new Intl.NumberFormat(locales, options.minutes).format
  var fh = new Intl.NumberFormat(locales, options.hours).format
  var sep = /^fi$|^fi-|^da/.test(String(locales)) ? '.' : ':'

  return function (s, args) {
    s = +s
    if (!isFinite(s)) return fs(s)
    var h = ~~(s / 60 / 60) // ~~ acts much like Math.trunc
    var m = ~~(s / 60 % 60)
    var dur = (h ? (fh(Math.abs(h)) + sep) : '') +
      fm(Math.abs(m)) + sep + fs(Math.abs(s % 60))
    return s < 0 ? fh(-1).replace(fh(1), dur) : dur
  }
}

function interpretDateTime (element/*: Placeholder */, locales/*: Locales */) {
  var type = element[1]
  var style = element[2]
  var options = formats[type][style] || formats.parseDatePattern(style) || formats[type].default
  return new Intl.DateTimeFormat(locales, options).format
}

function interpretPlural (element/*: Placeholder */, locales/*: Locales */) {
  var type = element[1]
  var pluralType = type === 'selectordinal' ? 'ordinal' : 'cardinal'
  var offset = element[2]
  var children = element[3]
  var pluralRules
  if (Intl.PluralRules && Intl.PluralRules.supportedLocalesOf(locales).length > 0) {
    pluralRules = new Intl.PluralRules(locales, { type: pluralType })
  } else {
    var locale = lookupClosestLocale(locales, plurals)
    var select = (locale && plurals[locale][pluralType]) || returnOther
    pluralRules = { select: select }
  }

  return function (value, args) {
    var clause =
      children['=' + +value] ||
      children[pluralRules.select(value - offset)] ||
      children.other
    return clause(args)
  }
}

function returnOther (/*:: n:number */) { return 'other' }

function interpretSelect (element/*: Placeholder */, locales/*: Locales */) {
  var children = element[2]
  return function (value, args) {
    var clause = children[value] || children.other
    return clause(args)
  }
}

var defaults/*: Types */ = {
  number: interpretNumber,
  ordinal: interpretNumber, // TODO: support rbnf
  spellout: interpretNumber, // TODO: support rbnf
  duration: interpretDuration,
  date: interpretDateTime,
  time: interpretDateTime,
  plural: interpretPlural,
  selectordinal: interpretPlural,
  select: interpretSelect
}
exports.types = defaults


/***/ }),

/***/ "./node_modules/format-message-interpret/plurals.js":
/*!**********************************************************!*\
  !*** ./node_modules/format-message-interpret/plurals.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @flow


/*:: export type Rule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' */
var zero = 'zero', one = 'one', two = 'two', few = 'few', many = 'many', other = 'other'
var f = [
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return 0 <= n && n <= 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var n = +s
    return i === 0 || n === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 0 ? zero
      : n === 1 ? one
      : n === 2 ? two
      : 3 <= n % 100 && n % 100 <= 10 ? few
      : 11 <= n % 100 && n % 100 <= 99 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return i === 1 && v === 0 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n % 10 === 1 && n % 100 !== 11 ? one
      : (2 <= n % 10 && n % 10 <= 4) && (n % 100 < 12 || 14 < n % 100) ? few
      : n % 10 === 0 || (5 <= n % 10 && n % 10 <= 9) || (11 <= n % 100 && n % 100 <= 14) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n % 10 === 1 && (n % 100 !== 11 && n % 100 !== 71 && n % 100 !== 91) ? one
      : n % 10 === 2 && (n % 100 !== 12 && n % 100 !== 72 && n % 100 !== 92) ? two
      : ((3 <= n % 10 && n % 10 <= 4) || n % 10 === 9) && ((n % 100 < 10 || 19 < n % 100) && (n % 100 < 70 || 79 < n % 100) && (n % 100 < 90 || 99 < n % 100)) ? few
      : n !== 0 && n % 1000000 === 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var f = +(s + '.').split('.')[1]
    return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one
      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) || (2 <= f % 10 && f % 10 <= 4) && (f % 100 < 12 || 14 < f % 100) ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return i === 1 && v === 0 ? one
      : (2 <= i && i <= 4) && v === 0 ? few
      : v !== 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 0 ? zero
      : n === 1 ? one
      : n === 2 ? two
      : n === 3 ? few
      : n === 6 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var t = +('' + s).replace(/^[^.]*.?|0+$/g, '')
    var n = +s
    return n === 1 || t !== 0 && (i === 0 || i === 1) ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var f = +(s + '.').split('.')[1]
    return v === 0 && i % 100 === 1 || f % 100 === 1 ? one
      : v === 0 && i % 100 === 2 || f % 100 === 2 ? two
      : v === 0 && (3 <= i % 100 && i % 100 <= 4) || (3 <= f % 100 && f % 100 <= 4) ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    return i === 0 || i === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var f = +(s + '.').split('.')[1]
    return v === 0 && (i === 1 || i === 2 || i === 3) || v === 0 && (i % 10 !== 4 && i % 10 !== 6 && i % 10 !== 9) || v !== 0 && (f % 10 !== 4 && f % 10 !== 6 && f % 10 !== 9) ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n === 2 ? two
      : 3 <= n && n <= 6 ? few
      : 7 <= n && n <= 10 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 || n === 11 ? one
      : n === 2 || n === 12 ? two
      : ((3 <= n && n <= 10) || (13 <= n && n <= 19)) ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return v === 0 && i % 10 === 1 ? one
      : v === 0 && i % 10 === 2 ? two
      : v === 0 && (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? few
      : v !== 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var n = +s
    return i === 1 && v === 0 ? one
      : i === 2 && v === 0 ? two
      : v === 0 && (n < 0 || 10 < n) && n % 10 === 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var t = +('' + s).replace(/^[^.]*.?|0+$/g, '')
    return t === 0 && i % 10 === 1 && i % 100 !== 11 || t !== 0 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n === 2 ? two
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 0 ? zero
      : n === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var n = +s
    return n === 0 ? zero
      : (i === 0 || i === 1) && n !== 0 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var f = +(s + '.').split('.')[1]
    var n = +s
    return n % 10 === 1 && (n % 100 < 11 || 19 < n % 100) ? one
      : (2 <= n % 10 && n % 10 <= 9) && (n % 100 < 11 || 19 < n % 100) ? few
      : f !== 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var v = (s + '.').split('.')[1].length
    var f = +(s + '.').split('.')[1]
    var n = +s
    return n % 10 === 0 || (11 <= n % 100 && n % 100 <= 19) || v === 2 && (11 <= f % 100 && f % 100 <= 19) ? zero
      : n % 10 === 1 && n % 100 !== 11 || v === 2 && f % 10 === 1 && f % 100 !== 11 || v !== 2 && f % 10 === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var f = +(s + '.').split('.')[1]
    return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    var n = +s
    return i === 1 && v === 0 ? one
      : v !== 0 || n === 0 || n !== 1 && (1 <= n % 100 && n % 100 <= 19) ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n === 0 || (2 <= n % 100 && n % 100 <= 10) ? few
      : 11 <= n % 100 && n % 100 <= 19 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return i === 1 && v === 0 ? one
      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) ? few
      : v === 0 && i !== 1 && (0 <= i % 10 && i % 10 <= 1) || v === 0 && (5 <= i % 10 && i % 10 <= 9) || v === 0 && (12 <= i % 100 && i % 100 <= 14) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    return 0 <= i && i <= 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return v === 0 && i % 10 === 1 && i % 100 !== 11 ? one
      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) ? few
      : v === 0 && i % 10 === 0 || v === 0 && (5 <= i % 10 && i % 10 <= 9) || v === 0 && (11 <= i % 100 && i % 100 <= 14) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var n = +s
    return i === 0 || n === 1 ? one
      : 2 <= n && n <= 10 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var f = +(s + '.').split('.')[1]
    var n = +s
    return (n === 0 || n === 1) || i === 0 && f === 1 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    var v = (s + '.').split('.')[1].length
    return v === 0 && i % 100 === 1 ? one
      : v === 0 && i % 100 === 2 ? two
      : v === 0 && (3 <= i % 100 && i % 100 <= 4) || v !== 0 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return (0 <= n && n <= 1) || (11 <= n && n <= 99) ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 || n === 5 || n === 7 || n === 8 || n === 9 || n === 10 ? one
      : n === 2 || n === 3 ? two
      : n === 4 ? few
      : n === 6 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    return (i % 10 === 1 || i % 10 === 2 || i % 10 === 5 || i % 10 === 7 || i % 10 === 8) || (i % 100 === 20 || i % 100 === 50 || i % 100 === 70 || i % 100 === 80) ? one
      : (i % 10 === 3 || i % 10 === 4) || (i % 1000 === 100 || i % 1000 === 200 || i % 1000 === 300 || i % 1000 === 400 || i % 1000 === 500 || i % 1000 === 600 || i % 1000 === 700 || i % 1000 === 800 || i % 1000 === 900) ? few
      : i === 0 || i % 10 === 6 || (i % 100 === 40 || i % 100 === 60 || i % 100 === 90) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return (n % 10 === 2 || n % 10 === 3) && (n % 100 !== 12 && n % 100 !== 13) ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 || n === 3 ? one
      : n === 2 ? two
      : n === 4 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 0 || n === 7 || n === 8 || n === 9 ? zero
      : n === 1 ? one
      : n === 2 ? two
      : n === 3 || n === 4 ? few
      : n === 5 || n === 6 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n % 10 === 1 && n % 100 !== 11 ? one
      : n % 10 === 2 && n % 100 !== 12 ? two
      : n % 10 === 3 && n % 100 !== 13 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 || n === 11 ? one
      : n === 2 || n === 12 ? two
      : n === 3 || n === 13 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n === 2 || n === 3 ? two
      : n === 4 ? few
      : n === 6 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 || n === 5 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 11 || n === 8 || n === 80 || n === 800 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    return i === 1 ? one
      : i === 0 || ((2 <= i % 100 && i % 100 <= 20) || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n % 10 === 6 || n % 10 === 9 || n % 10 === 0 && n !== 0 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var i = Math.floor(Math.abs(+s))
    return i % 10 === 1 && i % 100 !== 11 ? one
      : i % 10 === 2 && i % 100 !== 12 ? two
      : (i % 10 === 7 || i % 10 === 8) && (i % 100 !== 17 && i % 100 !== 18) ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n === 2 || n === 3 ? two
      : n === 4 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return 1 <= n && n <= 4 ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return (n === 1 || n === 5 || (7 <= n && n <= 9)) ? one
      : n === 2 || n === 3 ? two
      : n === 4 ? few
      : n === 6 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n === 1 ? one
      : n % 10 === 4 && n % 100 !== 14 ? many
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return (n % 10 === 1 || n % 10 === 2) && (n % 100 !== 11 && n % 100 !== 12) ? one
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return (n % 10 === 6 || n % 10 === 9) || n === 10 ? few
      : other
  },
  function (s/*: string | number */)/*: Rule */ {
    var n = +s
    return n % 10 === 3 && n % 100 !== 13 ? few
      : other
  }
]

module.exports = {
  af: { cardinal: f[0] },
  ak: { cardinal: f[1] },
  am: { cardinal: f[2] },
  ar: { cardinal: f[3] },
  ars: { cardinal: f[3] },
  as: { cardinal: f[2], ordinal: f[34] },
  asa: { cardinal: f[0] },
  ast: { cardinal: f[4] },
  az: { cardinal: f[0], ordinal: f[35] },
  be: { cardinal: f[5], ordinal: f[36] },
  bem: { cardinal: f[0] },
  bez: { cardinal: f[0] },
  bg: { cardinal: f[0] },
  bh: { cardinal: f[1] },
  bn: { cardinal: f[2], ordinal: f[34] },
  br: { cardinal: f[6] },
  brx: { cardinal: f[0] },
  bs: { cardinal: f[7] },
  ca: { cardinal: f[4], ordinal: f[37] },
  ce: { cardinal: f[0] },
  cgg: { cardinal: f[0] },
  chr: { cardinal: f[0] },
  ckb: { cardinal: f[0] },
  cs: { cardinal: f[8] },
  cy: { cardinal: f[9], ordinal: f[38] },
  da: { cardinal: f[10] },
  de: { cardinal: f[4] },
  dsb: { cardinal: f[11] },
  dv: { cardinal: f[0] },
  ee: { cardinal: f[0] },
  el: { cardinal: f[0] },
  en: { cardinal: f[4], ordinal: f[39] },
  eo: { cardinal: f[0] },
  es: { cardinal: f[0] },
  et: { cardinal: f[4] },
  eu: { cardinal: f[0] },
  fa: { cardinal: f[2] },
  ff: { cardinal: f[12] },
  fi: { cardinal: f[4] },
  fil: { cardinal: f[13], ordinal: f[0] },
  fo: { cardinal: f[0] },
  fr: { cardinal: f[12], ordinal: f[0] },
  fur: { cardinal: f[0] },
  fy: { cardinal: f[4] },
  ga: { cardinal: f[14], ordinal: f[0] },
  gd: { cardinal: f[15], ordinal: f[40] },
  gl: { cardinal: f[4] },
  gsw: { cardinal: f[0] },
  gu: { cardinal: f[2], ordinal: f[41] },
  guw: { cardinal: f[1] },
  gv: { cardinal: f[16] },
  ha: { cardinal: f[0] },
  haw: { cardinal: f[0] },
  he: { cardinal: f[17] },
  hi: { cardinal: f[2], ordinal: f[41] },
  hr: { cardinal: f[7] },
  hsb: { cardinal: f[11] },
  hu: { cardinal: f[0], ordinal: f[42] },
  hy: { cardinal: f[12], ordinal: f[0] },
  ia: { cardinal: f[4] },
  io: { cardinal: f[4] },
  is: { cardinal: f[18] },
  it: { cardinal: f[4], ordinal: f[43] },
  iu: { cardinal: f[19] },
  iw: { cardinal: f[17] },
  jgo: { cardinal: f[0] },
  ji: { cardinal: f[4] },
  jmc: { cardinal: f[0] },
  ka: { cardinal: f[0], ordinal: f[44] },
  kab: { cardinal: f[12] },
  kaj: { cardinal: f[0] },
  kcg: { cardinal: f[0] },
  kk: { cardinal: f[0], ordinal: f[45] },
  kkj: { cardinal: f[0] },
  kl: { cardinal: f[0] },
  kn: { cardinal: f[2] },
  ks: { cardinal: f[0] },
  ksb: { cardinal: f[0] },
  ksh: { cardinal: f[20] },
  ku: { cardinal: f[0] },
  kw: { cardinal: f[19] },
  ky: { cardinal: f[0] },
  lag: { cardinal: f[21] },
  lb: { cardinal: f[0] },
  lg: { cardinal: f[0] },
  ln: { cardinal: f[1] },
  lt: { cardinal: f[22] },
  lv: { cardinal: f[23] },
  mas: { cardinal: f[0] },
  mg: { cardinal: f[1] },
  mgo: { cardinal: f[0] },
  mk: { cardinal: f[24], ordinal: f[46] },
  ml: { cardinal: f[0] },
  mn: { cardinal: f[0] },
  mo: { cardinal: f[25], ordinal: f[0] },
  mr: { cardinal: f[2], ordinal: f[47] },
  mt: { cardinal: f[26] },
  nah: { cardinal: f[0] },
  naq: { cardinal: f[19] },
  nb: { cardinal: f[0] },
  nd: { cardinal: f[0] },
  ne: { cardinal: f[0], ordinal: f[48] },
  nl: { cardinal: f[4] },
  nn: { cardinal: f[0] },
  nnh: { cardinal: f[0] },
  no: { cardinal: f[0] },
  nr: { cardinal: f[0] },
  nso: { cardinal: f[1] },
  ny: { cardinal: f[0] },
  nyn: { cardinal: f[0] },
  om: { cardinal: f[0] },
  or: { cardinal: f[0], ordinal: f[49] },
  os: { cardinal: f[0] },
  pa: { cardinal: f[1] },
  pap: { cardinal: f[0] },
  pl: { cardinal: f[27] },
  prg: { cardinal: f[23] },
  ps: { cardinal: f[0] },
  pt: { cardinal: f[28] },
  'pt-PT': { cardinal: f[4] },
  rm: { cardinal: f[0] },
  ro: { cardinal: f[25], ordinal: f[0] },
  rof: { cardinal: f[0] },
  ru: { cardinal: f[29] },
  rwk: { cardinal: f[0] },
  saq: { cardinal: f[0] },
  sc: { cardinal: f[4], ordinal: f[43] },
  scn: { cardinal: f[4], ordinal: f[43] },
  sd: { cardinal: f[0] },
  sdh: { cardinal: f[0] },
  se: { cardinal: f[19] },
  seh: { cardinal: f[0] },
  sh: { cardinal: f[7] },
  shi: { cardinal: f[30] },
  si: { cardinal: f[31] },
  sk: { cardinal: f[8] },
  sl: { cardinal: f[32] },
  sma: { cardinal: f[19] },
  smi: { cardinal: f[19] },
  smj: { cardinal: f[19] },
  smn: { cardinal: f[19] },
  sms: { cardinal: f[19] },
  sn: { cardinal: f[0] },
  so: { cardinal: f[0] },
  sq: { cardinal: f[0], ordinal: f[50] },
  sr: { cardinal: f[7] },
  ss: { cardinal: f[0] },
  ssy: { cardinal: f[0] },
  st: { cardinal: f[0] },
  sv: { cardinal: f[4], ordinal: f[51] },
  sw: { cardinal: f[4] },
  syr: { cardinal: f[0] },
  ta: { cardinal: f[0] },
  te: { cardinal: f[0] },
  teo: { cardinal: f[0] },
  ti: { cardinal: f[1] },
  tig: { cardinal: f[0] },
  tk: { cardinal: f[0], ordinal: f[52] },
  tl: { cardinal: f[13], ordinal: f[0] },
  tn: { cardinal: f[0] },
  tr: { cardinal: f[0] },
  ts: { cardinal: f[0] },
  tzm: { cardinal: f[33] },
  ug: { cardinal: f[0] },
  uk: { cardinal: f[29], ordinal: f[53] },
  ur: { cardinal: f[4] },
  uz: { cardinal: f[0] },
  ve: { cardinal: f[0] },
  vo: { cardinal: f[0] },
  vun: { cardinal: f[0] },
  wa: { cardinal: f[1] },
  wae: { cardinal: f[0] },
  xh: { cardinal: f[0] },
  xog: { cardinal: f[0] },
  yi: { cardinal: f[4] },
  zu: { cardinal: f[2] },
  lo: { ordinal: f[0] },
  ms: { ordinal: f[0] },
  vi: { ordinal: f[0] }
}


/***/ }),

/***/ "./node_modules/format-message-parse/index.js":
/*!****************************************************!*\
  !*** ./node_modules/format-message-parse/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @flow


/*::
export type AST = Element[]
export type Element = string | Placeholder
export type Placeholder = Plural | Styled | Typed | Simple
export type Plural = [ string, 'plural' | 'selectordinal', number, SubMessages ]
export type Styled = [ string, string, string | SubMessages ]
export type Typed = [ string, string ]
export type Simple = [ string ]
export type SubMessages = { [string]: AST }
export type Token = [ TokenType, string ]
export type TokenType = 'text' | 'space' | 'id' | 'type' | 'style' | 'offset' | 'number' | 'selector' | 'syntax'
type Context = {|
  pattern: string,
  index: number,
  tagsType: ?string,
  tokens: ?Token[]
|}
*/

var ARG_OPN = '{'
var ARG_CLS = '}'
var ARG_SEP = ','
var NUM_ARG = '#'
var TAG_OPN = '<'
var TAG_CLS = '>'
var TAG_END = '</'
var TAG_SELF_CLS = '/>'
var ESC = '\''
var OFFSET = 'offset:'
var simpleTypes = [
  'number',
  'date',
  'time',
  'ordinal',
  'duration',
  'spellout'
]
var submTypes = [
  'plural',
  'select',
  'selectordinal'
]

/**
 * parse
 *
 * Turns this:
 *  `You have { numBananas, plural,
 *       =0 {no bananas}
 *      one {a banana}
 *    other {# bananas}
 *  } for sale`
 *
 * into this:
 *  [ "You have ", [ "numBananas", "plural", 0, {
 *       "=0": [ "no bananas" ],
 *      "one": [ "a banana" ],
 *    "other": [ [ '#' ], " bananas" ]
 *  } ], " for sale." ]
 *
 * tokens:
 *  [
 *    [ "text", "You have " ],
 *    [ "syntax", "{" ],
 *    [ "space", " " ],
 *    [ "id", "numBananas" ],
 *    [ "syntax", ", " ],
 *    [ "space", " " ],
 *    [ "type", "plural" ],
 *    [ "syntax", "," ],
 *    [ "space", "\n     " ],
 *    [ "selector", "=0" ],
 *    [ "space", " " ],
 *    [ "syntax", "{" ],
 *    [ "text", "no bananas" ],
 *    [ "syntax", "}" ],
 *    [ "space", "\n    " ],
 *    [ "selector", "one" ],
 *    [ "space", " " ],
 *    [ "syntax", "{" ],
 *    [ "text", "a banana" ],
 *    [ "syntax", "}" ],
 *    [ "space", "\n  " ],
 *    [ "selector", "other" ],
 *    [ "space", " " ],
 *    [ "syntax", "{" ],
 *    [ "syntax", "#" ],
 *    [ "text", " bananas" ],
 *    [ "syntax", "}" ],
 *    [ "space", "\n" ],
 *    [ "syntax", "}" ],
 *    [ "text", " for sale." ]
 *  ]
 **/
exports = module.exports = function parse (
  pattern/*: string */,
  options/*:: ?: { tagsType?: string, tokens?: Token[] } */
)/*: AST */ {
  return parseAST({
    pattern: String(pattern),
    index: 0,
    tagsType: (options && options.tagsType) || null,
    tokens: (options && options.tokens) || null
  }, '')
}

function parseAST (current/*: Context */, parentType/*: string */)/*: AST */ {
  var pattern = current.pattern
  var length = pattern.length
  var elements/*: AST */ = []
  var start = current.index
  var text = parseText(current, parentType)
  if (text) elements.push(text)
  if (text && current.tokens) current.tokens.push([ 'text', pattern.slice(start, current.index) ])
  while (current.index < length) {
    if (pattern[current.index] === ARG_CLS) {
      if (!parentType) throw expected(current)
      break
    }
    if (parentType && current.tagsType && pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) break
    elements.push(parsePlaceholder(current))
    start = current.index
    text = parseText(current, parentType)
    if (text) elements.push(text)
    if (text && current.tokens) current.tokens.push([ 'text', pattern.slice(start, current.index) ])
  }
  return elements
}

function parseText (current/*: Context */, parentType/*: string */)/*: string */ {
  var pattern = current.pattern
  var length = pattern.length
  var isHashSpecial = (parentType === 'plural' || parentType === 'selectordinal')
  var isAngleSpecial = !!current.tagsType
  var isArgStyle = (parentType === '{style}')
  var text = ''
  while (current.index < length) {
    var char = pattern[current.index]
    if (
      char === ARG_OPN || char === ARG_CLS ||
      (isHashSpecial && char === NUM_ARG) ||
      (isAngleSpecial && char === TAG_OPN) ||
      (isArgStyle && isWhitespace(char.charCodeAt(0)))
    ) {
      break
    } else if (char === ESC) {
      char = pattern[++current.index]
      if (char === ESC) { // double is always 1 '
        text += char
        ++current.index
      } else if (
        // only when necessary
        char === ARG_OPN || char === ARG_CLS ||
        (isHashSpecial && char === NUM_ARG) ||
        (isAngleSpecial && char === TAG_OPN) ||
        isArgStyle
      ) {
        text += char
        while (++current.index < length) {
          char = pattern[current.index]
          if (char === ESC && pattern[current.index + 1] === ESC) { // double is always 1 '
            text += ESC
            ++current.index
          } else if (char === ESC) { // end of quoted
            ++current.index
            break
          } else {
            text += char
          }
        }
      } else { // lone ' is just a '
        text += ESC
        // already incremented
      }
    } else {
      text += char
      ++current.index
    }
  }
  return text
}

function isWhitespace (code/*: number */)/*: boolean */ {
  return (
    (code >= 0x09 && code <= 0x0D) ||
    code === 0x20 || code === 0x85 || code === 0xA0 || code === 0x180E ||
    (code >= 0x2000 && code <= 0x200D) ||
    code === 0x2028 || code === 0x2029 || code === 0x202F || code === 0x205F ||
    code === 0x2060 || code === 0x3000 || code === 0xFEFF
  )
}

function skipWhitespace (current/*: Context */)/*: void */ {
  var pattern = current.pattern
  var length = pattern.length
  var start = current.index
  while (current.index < length && isWhitespace(pattern.charCodeAt(current.index))) {
    ++current.index
  }
  if (start < current.index && current.tokens) {
    current.tokens.push([ 'space', current.pattern.slice(start, current.index) ])
  }
}

function parsePlaceholder (current/*: Context */)/*: Placeholder */ {
  var pattern = current.pattern
  if (pattern[current.index] === NUM_ARG) {
    if (current.tokens) current.tokens.push([ 'syntax', NUM_ARG ])
    ++current.index // move passed #
    return [ NUM_ARG ]
  }

  var tag = parseTag(current)
  if (tag) return tag

  /* istanbul ignore if should be unreachable if parseAST and parseText are right */
  if (pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN)
  if (current.tokens) current.tokens.push([ 'syntax', ARG_OPN ])
  ++current.index // move passed {
  skipWhitespace(current)

  var id = parseId(current)
  if (!id) throw expected(current, 'placeholder id')
  if (current.tokens) current.tokens.push([ 'id', id ])
  skipWhitespace(current)

  var char = pattern[current.index]
  if (char === ARG_CLS) { // end placeholder
    if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])
    ++current.index // move passed }
    return [ id ]
  }

  if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', ARG_SEP ])
  ++current.index // move passed ,
  skipWhitespace(current)

  var type = parseId(current)
  if (!type) throw expected(current, 'placeholder type')
  if (current.tokens) current.tokens.push([ 'type', type ])
  skipWhitespace(current)
  char = pattern[current.index]
  if (char === ARG_CLS) { // end placeholder
    if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])
    if (type === 'plural' || type === 'selectordinal' || type === 'select') {
      throw expected(current, type + ' sub-messages')
    }
    ++current.index // move passed }
    return [ id, type ]
  }

  if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', ARG_SEP ])
  ++current.index // move passed ,
  skipWhitespace(current)

  var arg
  if (type === 'plural' || type === 'selectordinal') {
    var offset = parsePluralOffset(current)
    skipWhitespace(current)
    arg = [ id, type, offset, parseSubMessages(current, type) ]
  } else if (type === 'select') {
    arg = [ id, type, parseSubMessages(current, type) ]
  } else if (simpleTypes.indexOf(type) >= 0) {
    arg = [ id, type, parseSimpleFormat(current) ]
  } else { // custom placeholder type
    var index = current.index
    var format/*: string | SubMessages */ = parseSimpleFormat(current)
    skipWhitespace(current)
    if (pattern[current.index] === ARG_OPN) {
      current.index = index // rewind, since should have been submessages
      format = parseSubMessages(current, type)
    }
    arg = [ id, type, format ]
  }

  skipWhitespace(current)
  if (pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])
  ++current.index // move passed }
  return arg
}

function parseTag (current/*: Context */)/*: ?Placeholder */ {
  var tagsType = current.tagsType
  if (!tagsType || current.pattern[current.index] !== TAG_OPN) return

  if (current.pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) {
    throw expected(current, null, 'closing tag without matching opening tag')
  }
  if (current.tokens) current.tokens.push([ 'syntax', TAG_OPN ])
  ++current.index // move passed <

  var id = parseId(current, true)
  if (!id) throw expected(current, 'placeholder id')
  if (current.tokens) current.tokens.push([ 'id', id ])
  skipWhitespace(current)

  if (current.pattern.slice(current.index, current.index + TAG_SELF_CLS.length) === TAG_SELF_CLS) {
    if (current.tokens) current.tokens.push([ 'syntax', TAG_SELF_CLS ])
    current.index += TAG_SELF_CLS.length
    return [ id, tagsType ]
  }
  if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', TAG_CLS ])
  ++current.index // move passed >

  var children = parseAST(current, tagsType)

  var end = current.index
  if (current.pattern.slice(current.index, current.index + TAG_END.length) !== TAG_END) throw expected(current, TAG_END + id + TAG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', TAG_END ])
  current.index += TAG_END.length
  var closeId = parseId(current, true)
  if (closeId && current.tokens) current.tokens.push([ 'id', closeId ])
  if (id !== closeId) {
    current.index = end // rewind for better error message
    throw expected(current, TAG_END + id + TAG_CLS, TAG_END + closeId + TAG_CLS)
  }
  skipWhitespace(current)
  if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS)
  if (current.tokens) current.tokens.push([ 'syntax', TAG_CLS ])
  ++current.index // move passed >

  return [ id, tagsType, { children: children } ]
}

function parseId (current/*: Context */, isTag/*:: ?: boolean */)/*: string */ {
  var pattern = current.pattern
  var length = pattern.length
  var id = ''
  while (current.index < length) {
    var char = pattern[current.index]
    if (
      char === ARG_OPN || char === ARG_CLS || char === ARG_SEP ||
      char === NUM_ARG || char === ESC || isWhitespace(char.charCodeAt(0)) ||
      (isTag && (char === TAG_OPN || char === TAG_CLS || char === '/'))
    ) break
    id += char
    ++current.index
  }
  return id
}

function parseSimpleFormat (current/*: Context */)/*: string */ {
  var start = current.index
  var style = parseText(current, '{style}')
  if (!style) throw expected(current, 'placeholder style name')
  if (current.tokens) current.tokens.push([ 'style', current.pattern.slice(start, current.index) ])
  return style
}

function parsePluralOffset (current/*: Context */)/*: number */ {
  var pattern = current.pattern
  var length = pattern.length
  var offset = 0
  if (pattern.slice(current.index, current.index + OFFSET.length) === OFFSET) {
    if (current.tokens) current.tokens.push([ 'offset', 'offset' ], [ 'syntax', ':' ])
    current.index += OFFSET.length // move passed offset:
    skipWhitespace(current)
    var start = current.index
    while (current.index < length && isDigit(pattern.charCodeAt(current.index))) {
      ++current.index
    }
    if (start === current.index) throw expected(current, 'offset number')
    if (current.tokens) current.tokens.push([ 'number', pattern.slice(start, current.index) ])
    offset = +pattern.slice(start, current.index)
  }
  return offset
}

function isDigit (code/*: number */)/*: boolean */ {
  return (code >= 0x30 && code <= 0x39)
}

function parseSubMessages (current/*: Context */, parentType/*: string */)/*: SubMessages */ {
  var pattern = current.pattern
  var length = pattern.length
  var options/*: SubMessages */ = {}
  while (current.index < length && pattern[current.index] !== ARG_CLS) {
    var selector = parseId(current)
    if (!selector) throw expected(current, 'sub-message selector')
    if (current.tokens) current.tokens.push([ 'selector', selector ])
    skipWhitespace(current)
    options[selector] = parseSubMessage(current, parentType)
    skipWhitespace(current)
  }
  if (!options.other && submTypes.indexOf(parentType) >= 0) {
    throw expected(current, null, null, '"other" sub-message must be specified in ' + parentType)
  }
  return options
}

function parseSubMessage (current/*: Context */, parentType/*: string */)/*: AST */ {
  if (current.pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN + ' to start sub-message')
  if (current.tokens) current.tokens.push([ 'syntax', ARG_OPN ])
  ++current.index // move passed {
  var message = parseAST(current, parentType)
  if (current.pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS + ' to end sub-message')
  if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])
  ++current.index // move passed }
  return message
}

function expected (current/*: Context */, expected/*:: ?: ?string */, found/*:: ?: ?string */, message/*:: ?: string */) {
  var pattern = current.pattern
  var lines = pattern.slice(0, current.index).split(/\r?\n/)
  var offset = current.index
  var line = lines.length
  var column = lines.slice(-1)[0].length
  found = found || (
    (current.index >= pattern.length) ? 'end of message pattern'
      : (parseId(current) || pattern[current.index])
  )
  if (!message) message = errorMessage(expected, found)
  message += ' in ' + pattern.replace(/\r?\n/g, '\n')
  return new SyntaxError(message, expected, found, offset, line, column)
}

function errorMessage (expected/*: ?string */, found/* string */) {
  if (!expected) return 'Unexpected ' + found + ' found'
  return 'Expected ' + expected + ' but found ' + found
}

/**
 * SyntaxError
 *  Holds information about bad syntax found in a message pattern
 **/
function SyntaxError (message/*: string */, expected/*: ?string */, found/*: ?string */, offset/*: number */, line/*: number */, column/*: number */) {
  Error.call(this, message)
  this.name = 'SyntaxError'
  this.message = message
  this.expected = expected
  this.found = found
  this.offset = offset
  this.line = line
  this.column = column
}
SyntaxError.prototype = Object.create(Error.prototype)
exports.SyntaxError = SyntaxError


/***/ }),

/***/ "./node_modules/format-message/index.js":
/*!**********************************************!*\
  !*** ./node_modules/format-message/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @flow

var parse = __webpack_require__(/*! format-message-parse */ "./node_modules/format-message-parse/index.js")
var interpret = __webpack_require__(/*! format-message-interpret */ "./node_modules/format-message-interpret/index.js")
var plurals = __webpack_require__(/*! format-message-interpret/plurals */ "./node_modules/format-message-interpret/plurals.js")
var lookupClosestLocale = __webpack_require__(/*! lookup-closest-locale */ "./node_modules/lookup-closest-locale/index.js")
var origFormats = __webpack_require__(/*! format-message-formats */ "./node_modules/format-message-formats/index.js")

/*::
import type { Types } from 'format-message-interpret'
type Locale = string
type Locales = Locale | Locale[]
type Message = string | {|
  id?: string,
  default: string,
  description?: string
|}
type Translations = { [string]: ?{ [string]: string | Translation } }
type Translation = {
  message: string,
  format?: (args?: Object) => string,
  toParts?: (args?: Object) => any[],
}
type Replacement = ?string | (string, string, locales?: Locales) => ?string
type GenerateId = (string) => string
type MissingTranslation = 'ignore' | 'warning' | 'error'
type FormatObject = { [string]: * }
type Options = {
  locale?: Locales,
  translations?: ?Translations,
  generateId?: GenerateId,
  missingReplacement?: Replacement,
  missingTranslation?: MissingTranslation,
  formats?: {
    number?: FormatObject,
    date?: FormatObject,
    time?: FormatObject
  },
  types?: Types
}
type Setup = {|
  locale: Locales,
  translations: Translations,
  generateId: GenerateId,
  missingReplacement: Replacement,
  missingTranslation: MissingTranslation,
  formats: {
    number: FormatObject,
    date: FormatObject,
    time: FormatObject
  },
  types: Types
|}
type FormatMessage = {
  (msg: Message, args?: Object, locales?: Locales): string,
  rich (msg: Message, args?: Object, locales?: Locales): any[],
  setup (opt?: Options): Setup,
  number (value: number, style?: string, locales?: Locales): string,
  date (value: number | Date, style?: string, locales?: Locales): string,
  time (value: number | Date, style?: string, locales?: Locales): string,
  select (value: any, options: Object): any,
  custom (placeholder: any[], locales: Locales, value: any, args: Object): any,
  plural (value: number, offset: any, options: any, locale: any): any,
  selectordinal (value: number, offset: any, options: any, locale: any): any,
  namespace (): FormatMessage
}
*/

function assign/*:: <T: Object> */ (target/*: T */, source/*: Object */) {
  Object.keys(source).forEach(function (key) { target[key] = source[key] })
  return target
}

function namespace ()/*: FormatMessage */ {
  var formats = assign({}, origFormats)
  var currentLocales/*: Locales */ = 'en'
  var translations/*: Translations */ = {}
  var generateId/*: GenerateId */ = function (pattern) { return pattern }
  var missingReplacement/*: Replacement */ = null
  var missingTranslation/*: MissingTranslation */ = 'warning'
  var types/*: Types */ = {}

  function formatMessage (msg/*: Message */, args/*:: ?: Object */, locales/*:: ?: Locales */) {
    var pattern = typeof msg === 'string' ? msg : msg.default
    var id = (typeof msg === 'object' && msg.id) || generateId(pattern)
    var translated = translate(pattern, id, locales || currentLocales)
    var format = translated.format || (
      translated.format = interpret(parse(translated.message), locales || currentLocales, types)
    )
    return format(args)
  }

  formatMessage.rich = function rich (msg/*: Message */, args/*:: ?: Object */, locales/*:: ?: Locales */) {
    var pattern = typeof msg === 'string' ? msg : msg.default
    var id = (typeof msg === 'object' && msg.id) || generateId(pattern)
    var translated = translate(pattern, id, locales || currentLocales)
    var format = translated.toParts || (
      translated.toParts = interpret.toParts(parse(translated.message, { tagsType: tagsType }), locales || currentLocales, types)
    )
    return format(args)
  }

  var tagsType = '<>'
  function richType (node/*: any[] */, locales/*: Locales */) {
    var style = node[2]
    return function (fn, args) {
      var props = typeof style === 'object' ? mapObject(style, args) : style
      return typeof fn === 'function' ? fn(props) : fn
    }
  }
  types[tagsType] = richType

  function mapObject (object/* { [string]: (args?: Object) => any } */, args/*: ?Object */) {
    return Object.keys(object).reduce(function (mapped, key) {
      mapped[key] = object[key](args)
      return mapped
    }, {})
  }

  function translate (pattern/*: string */, id/*: string */, locales/*: Locales */)/*: Translation */ {
    var locale = lookupClosestLocale(locales, translations) || 'en'
    var messages = translations[locale] || (translations[locale] = {})
    var translated = messages[id]
    if (typeof translated === 'string') {
      translated = messages[id] = { message: translated }
    }
    if (!translated) {
      var message = 'Translation for "' + id + '" in "' + locale + '" is missing'
      if (missingTranslation === 'warning') {
        /* istanbul ignore else */
        if (typeof console !== 'undefined') console.warn(message)
      } else if (missingTranslation !== 'ignore') { // 'error'
        throw new Error(message)
      }
      var replacement = typeof missingReplacement === 'function'
        ? missingReplacement(pattern, id, locale) || pattern
        : missingReplacement || pattern
      translated = messages[id] = { message: replacement }
    }
    return translated
  }

  formatMessage.setup = function setup (opt/*:: ?: Options */) {
    opt = opt || {}
    if (opt.locale) currentLocales = opt.locale
    if ('translations' in opt) translations = opt.translations || {}
    if (opt.generateId) generateId = opt.generateId
    if ('missingReplacement' in opt) missingReplacement = opt.missingReplacement
    if (opt.missingTranslation) missingTranslation = opt.missingTranslation
    if (opt.formats) {
      if (opt.formats.number) assign(formats.number, opt.formats.number)
      if (opt.formats.date) assign(formats.date, opt.formats.date)
      if (opt.formats.time) assign(formats.time, opt.formats.time)
    }
    if (opt.types) {
      types = opt.types
      types[tagsType] = richType
    }
    return {
      locale: currentLocales,
      translations: translations,
      generateId: generateId,
      missingReplacement: missingReplacement,
      missingTranslation: missingTranslation,
      formats: formats,
      types: types
    }
  }

  formatMessage.number = function (value/*: number */, style/*:: ?: string */, locales/*:: ?: Locales */) {
    var options = (style && formats.number[style]) ||
      formats.parseNumberPattern(style) ||
      formats.number.default
    return new Intl.NumberFormat(locales || currentLocales, options).format(value)
  }

  formatMessage.date = function (value/*:: ?: number | Date */, style/*:: ?: string */, locales/*:: ?: Locales */) {
    var options = (style && formats.date[style]) ||
      formats.parseDatePattern(style) ||
      formats.date.default
    return new Intl.DateTimeFormat(locales || currentLocales, options).format(value)
  }

  formatMessage.time = function (value/*:: ?: number | Date */, style/*:: ?: string */, locales/*:: ?: Locales */) {
    var options = (style && formats.time[style]) ||
      formats.parseDatePattern(style) ||
      formats.time.default
    return new Intl.DateTimeFormat(locales || currentLocales, options).format(value)
  }

  formatMessage.select = function (value/*: any */, options/*: Object */) {
    return options[value] || options.other
  }

  formatMessage.custom = function (placeholder/*: any[] */, locales/*: Locales */, value/*: any */, args/*: Object */) {
    if (!(placeholder[1] in types)) return value
    return types[placeholder[1]](placeholder, locales)(value, args)
  }

  formatMessage.plural = plural.bind(null, 'cardinal')
  formatMessage.selectordinal = plural.bind(null, 'ordinal')
  function plural (
    pluralType/*: 'cardinal' | 'ordinal' */,
    value/*: number */,
    offset/*: any */,
    options/*: any */,
    locale/*: any */
  ) {
    if (typeof offset === 'object' && typeof options !== 'object') { // offset is optional
      locale = options
      options = offset
      offset = 0
    }
    var closest = lookupClosestLocale(locale || currentLocales, plurals)
    var plural = (closest && plurals[closest][pluralType]) || returnOther
    return options['=' + +value] || options[plural(value - offset)] || options.other
  }
  function returnOther (/*:: n:number */) { return 'other' }

  formatMessage.namespace = namespace

  return formatMessage
}

module.exports = exports = namespace()


/***/ }),

/***/ "./node_modules/global/window.js":
/*!***************************************!*\
  !*** ./node_modules/global/window.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/htmlparser2/lib/CollectingHandler.js":
/*!***********************************************************!*\
  !*** ./node_modules/htmlparser2/lib/CollectingHandler.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = CollectingHandler;

function CollectingHandler(cbs){
	this._cbs = cbs || {};
	this.events = [];
}

var EVENTS = __webpack_require__(/*! ./ */ "./node_modules/htmlparser2/lib/index.js").EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(){
			this.events.push([name]);
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(a){
			this.events.push([name, a]);
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		CollectingHandler.prototype[name] = function(a, b){
			this.events.push([name, a, b]);
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});

CollectingHandler.prototype.onreset = function(){
	this.events = [];
	if(this._cbs.onreset) this._cbs.onreset();
};

CollectingHandler.prototype.restart = function(){
	if(this._cbs.onreset) this._cbs.onreset();

	for(var i = 0, len = this.events.length; i < len; i++){
		if(this._cbs[this.events[i][0]]){

			var num = this.events[i].length;

			if(num === 1){
				this._cbs[this.events[i][0]]();
			} else if(num === 2){
				this._cbs[this.events[i][0]](this.events[i][1]);
			} else {
				this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
			}
		}
	}
};


/***/ }),

/***/ "./node_modules/htmlparser2/lib/FeedHandler.js":
/*!*****************************************************!*\
  !*** ./node_modules/htmlparser2/lib/FeedHandler.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var index = __webpack_require__(/*! ./index.js */ "./node_modules/htmlparser2/lib/index.js");
var DomHandler = index.DomHandler;
var DomUtils = index.DomUtils;

//TODO: make this a streamable handler
function FeedHandler(callback, options){
	this.init(callback, options);
}

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(FeedHandler, DomHandler);

FeedHandler.prototype.init = DomHandler;

function getElements(what, where){
	return DomUtils.getElementsByTagName(what, where, true);
}
function getOneElement(what, where){
	return DomUtils.getElementsByTagName(what, where, true, 1)[0];
}
function fetch(what, where, recurse){
	return DomUtils.getText(
		DomUtils.getElementsByTagName(what, where, recurse, 1)
	).trim();
}

function addConditionally(obj, prop, what, where, recurse){
	var tmp = fetch(what, where, recurse);
	if(tmp) obj[prop] = tmp;
}

var isValidFeed = function(value){
	return value === "rss" || value === "feed" || value === "rdf:RDF";
};

FeedHandler.prototype.onend = function(){
	var feed = {},
	    feedRoot = getOneElement(isValidFeed, this.dom),
	    tmp, childs;

	if(feedRoot){
		if(feedRoot.name === "feed"){
			childs = feedRoot.children;

			feed.type = "atom";
			addConditionally(feed, "id", "id", childs);
			addConditionally(feed, "title", "title", childs);
			if((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
			addConditionally(feed, "description", "subtitle", childs);
			if((tmp = fetch("updated", childs))) feed.updated = new Date(tmp);
			addConditionally(feed, "author", "email", childs, true);

			feed.items = getElements("entry", childs).map(function(item){
				var entry = {}, tmp;

				item = item.children;

				addConditionally(entry, "id", "id", item);
				addConditionally(entry, "title", "title", item);
				if((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
				if((tmp = fetch("summary", item) || fetch("content", item))) entry.description = tmp;
				if((tmp = fetch("updated", item))) entry.pubDate = new Date(tmp);
				return entry;
			});
		} else {
			childs = getOneElement("channel", feedRoot.children).children;

			feed.type = feedRoot.name.substr(0, 3);
			feed.id = "";
			addConditionally(feed, "title", "title", childs);
			addConditionally(feed, "link", "link", childs);
			addConditionally(feed, "description", "description", childs);
			if((tmp = fetch("lastBuildDate", childs))) feed.updated = new Date(tmp);
			addConditionally(feed, "author", "managingEditor", childs, true);

			feed.items = getElements("item", feedRoot.children).map(function(item){
				var entry = {}, tmp;

				item = item.children;

				addConditionally(entry, "id", "guid", item);
				addConditionally(entry, "title", "title", item);
				addConditionally(entry, "link", "link", item);
				addConditionally(entry, "description", "description", item);
				if((tmp = fetch("pubDate", item))) entry.pubDate = new Date(tmp);
				return entry;
			});
		}
	}
	this.dom = feed;
	DomHandler.prototype._handleCallback.call(
		this, feedRoot ? null : Error("couldn't find root of feed")
	);
};

module.exports = FeedHandler;


/***/ }),

/***/ "./node_modules/htmlparser2/lib/Parser.js":
/*!************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Parser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Tokenizer = __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/htmlparser2/lib/Tokenizer.js");

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var openImpliesClose = {
	tr      : { tr:true, th:true, td:true },
	th      : { th:true },
	td      : { thead:true, th:true, td:true },
	body    : { head:true, link:true, script:true },
	li      : { li:true },
	p       : { p:true },
	h1      : { p:true },
	h2      : { p:true },
	h3      : { p:true },
	h4      : { p:true },
	h5      : { p:true },
	h6      : { p:true },
	select  : formTags,
	input   : formTags,
	output  : formTags,
	button  : formTags,
	datalist: formTags,
	textarea: formTags,
	option  : { option:true },
	optgroup: { optgroup:true }
};

var voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,
};

var foreignContextElements = {
	__proto__: null,
	math: true,
	svg: true
}
var htmlIntegrationElements = {
	__proto__: null,
	mi: true,
	mo: true,
	mn: true,
	ms: true,
	mtext: true,
	"annotation-xml": true,
	foreignObject: true,
	desc: true,
	title: true
}

var re_nameEnd = /\s|\//;

function Parser(cbs, options){
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];
	this._foreignContext = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
		!!this._options.lowerCaseTags :
		!this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
		!!this._options.lowerCaseAttributeNames :
		!this._options.xmlMode;

	if(this._options.Tokenizer) {
		Tokenizer = this._options.Tokenizer;
	}
	this._tokenizer = new Tokenizer(this._options, this);

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
}

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Parser, __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

Parser.prototype._updatePosition = function(initialOffset){
	if(this.endIndex === null){
		if(this._tokenizer._sectionStart <= initialOffset){
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	}
	else this.startIndex = this.endIndex + 1;
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
Parser.prototype.ontext = function(data){
	this._updatePosition(1);
	this.endIndex--;

	if(this._cbs.ontext) this._cbs.ontext(data);
};

Parser.prototype.onopentagname = function(name){
	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	this._tagname = name;

	if(!this._options.xmlMode && name in openImpliesClose) {
		for(
			var el;
			(el = this._stack[this._stack.length - 1]) in openImpliesClose[name];
			this.onclosetag(el)
		);
	}

	if(this._options.xmlMode || !(name in voidElements)){
		this._stack.push(name);
		if(name in foreignContextElements) this._foreignContext.push(true);
		else if(name in htmlIntegrationElements) this._foreignContext.push(false);
	}

	if(this._cbs.onopentagname) this._cbs.onopentagname(name);
	if(this._cbs.onopentag) this._attribs = {};
};

Parser.prototype.onopentagend = function(){
	this._updatePosition(1);

	if(this._attribs){
		if(this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
		this._attribs = null;
	}

	if(!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements){
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

Parser.prototype.onclosetag = function(name){
	this._updatePosition(1);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	if(this._stack.length && (!(name in voidElements) || this._options.xmlMode)){
		var pos = this._stack.lastIndexOf(name);
		if(pos !== -1){
			if(this._cbs.onclosetag){
				pos = this._stack.length - pos;
				while(pos--) this._cbs.onclosetag(this._stack.pop());
			}
			else this._stack.length = pos;
		} else if(name === "p" && !this._options.xmlMode){
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	} else if(!this._options.xmlMode && (name === "br" || name === "p")){
		this.onopentagname(name);
		this._closeCurrentTag();
	}
};

Parser.prototype.onselfclosingtag = function(){
	if(this._options.xmlMode || this._options.recognizeSelfClosing
		|| this._foreignContext[this._foreignContext.length - 1]){
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

Parser.prototype._closeCurrentTag = function(){
	var name = this._tagname;

	this.onopentagend();

	//self-closing tags will be on the top of the stack
	//(cheaper check than in onclosetag)
	if(this._stack[this._stack.length - 1] === name){
		if(this._cbs.onclosetag){
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
		if((name in foreignContextElements) || (name in htmlIntegrationElements)){
			this._foreignContext.pop();
		}
	}
};

Parser.prototype.onattribname = function(name){
	if(this._lowerCaseAttributeNames){
		name = name.toLowerCase();
	}
	this._attribname = name;
};

Parser.prototype.onattribdata = function(value){
	this._attribvalue += value;
};

Parser.prototype.onattribend = function(){
	if(this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
	if(
		this._attribs &&
		!Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)
	){
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

Parser.prototype._getInstructionName = function(value){
	var idx = value.search(re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	return name;
};

Parser.prototype.ondeclaration = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

Parser.prototype.onprocessinginstruction = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

Parser.prototype.oncomment = function(value){
	this._updatePosition(4);

	if(this._cbs.oncomment) this._cbs.oncomment(value);
	if(this._cbs.oncommentend) this._cbs.oncommentend();
};

Parser.prototype.oncdata = function(value){
	this._updatePosition(1);

	if(this._options.xmlMode || this._options.recognizeCDATA){
		if(this._cbs.oncdatastart) this._cbs.oncdatastart();
		if(this._cbs.ontext) this._cbs.ontext(value);
		if(this._cbs.oncdataend) this._cbs.oncdataend();
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

Parser.prototype.onerror = function(err){
	if(this._cbs.onerror) this._cbs.onerror(err);
};

Parser.prototype.onend = function(){
	if(this._cbs.onclosetag){
		for(
			var i = this._stack.length;
			i > 0;
			this._cbs.onclosetag(this._stack[--i])
		);
	}
	if(this._cbs.onend) this._cbs.onend();
};


//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset = function(){
	if(this._cbs.onreset) this._cbs.onreset();
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete = function(data){
	this.reset();
	this.end(data);
};

Parser.prototype.write = function(chunk){
	this._tokenizer.write(chunk);
};

Parser.prototype.end = function(chunk){
	this._tokenizer.end(chunk);
};

Parser.prototype.pause = function(){
	this._tokenizer.pause();
};

Parser.prototype.resume = function(){
	this._tokenizer.resume();
};

//alias for backwards compat
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;

module.exports = Parser;


/***/ }),

/***/ "./node_modules/htmlparser2/lib/ProxyHandler.js":
/*!******************************************************!*\
  !*** ./node_modules/htmlparser2/lib/ProxyHandler.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = ProxyHandler;

function ProxyHandler(cbs){
	this._cbs = cbs || {};
}

var EVENTS = __webpack_require__(/*! ./ */ "./node_modules/htmlparser2/lib/index.js").EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(){
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a){
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a, b){
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});

/***/ }),

/***/ "./node_modules/htmlparser2/lib/Stream.js":
/*!************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Stream.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Stream;

var Parser = __webpack_require__(/*! ./WritableStream.js */ "./node_modules/htmlparser2/lib/WritableStream.js");

function Stream(options){
	Parser.call(this, new Cbs(this), options);
}

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Stream, Parser);

Stream.prototype.readable = true;

function Cbs(scope){
	this.scope = scope;
}

var EVENTS = __webpack_require__(/*! ../ */ "./node_modules/htmlparser2/lib/index.js").EVENTS;

Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		Cbs.prototype["on" + name] = function(){
			this.scope.emit(name);
		};
	} else if(EVENTS[name] === 1){
		Cbs.prototype["on" + name] = function(a){
			this.scope.emit(name, a);
		};
	} else if(EVENTS[name] === 2){
		Cbs.prototype["on" + name] = function(a, b){
			this.scope.emit(name, a, b);
		};
	} else {
		throw Error("wrong number of arguments!");
	}
});

/***/ }),

/***/ "./node_modules/htmlparser2/lib/Tokenizer.js":
/*!***************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Tokenizer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Tokenizer;

var decodeCodePoint = __webpack_require__(/*! entities/lib/decode_codepoint.js */ "./node_modules/entities/lib/decode_codepoint.js");
var entityMap = __webpack_require__(/*! entities/maps/entities.json */ "./node_modules/entities/maps/entities.json");
var legacyMap = __webpack_require__(/*! entities/maps/legacy.json */ "./node_modules/entities/maps/legacy.json");
var xmlMap    = __webpack_require__(/*! entities/maps/xml.json */ "./node_modules/entities/maps/xml.json");

var i = 0;

var TEXT                      = i++;
var BEFORE_TAG_NAME           = i++; //after <
var IN_TAG_NAME               = i++;
var IN_SELF_CLOSING_TAG       = i++;
var BEFORE_CLOSING_TAG_NAME   = i++;
var IN_CLOSING_TAG_NAME       = i++;
var AFTER_CLOSING_TAG_NAME    = i++;

//attributes
var BEFORE_ATTRIBUTE_NAME     = i++;
var IN_ATTRIBUTE_NAME         = i++;
var AFTER_ATTRIBUTE_NAME      = i++;
var BEFORE_ATTRIBUTE_VALUE    = i++;
var IN_ATTRIBUTE_VALUE_DQ     = i++; // "
var IN_ATTRIBUTE_VALUE_SQ     = i++; // '
var IN_ATTRIBUTE_VALUE_NQ     = i++;

//declarations
var BEFORE_DECLARATION        = i++; // !
var IN_DECLARATION            = i++;

//processing instructions
var IN_PROCESSING_INSTRUCTION = i++; // ?

//comments
var BEFORE_COMMENT            = i++;
var IN_COMMENT                = i++;
var AFTER_COMMENT_1           = i++;
var AFTER_COMMENT_2           = i++;

//cdata
var BEFORE_CDATA_1            = i++; // [
var BEFORE_CDATA_2            = i++; // C
var BEFORE_CDATA_3            = i++; // D
var BEFORE_CDATA_4            = i++; // A
var BEFORE_CDATA_5            = i++; // T
var BEFORE_CDATA_6            = i++; // A
var IN_CDATA                  = i++; // [
var AFTER_CDATA_1             = i++; // ]
var AFTER_CDATA_2             = i++; // ]

//special tags
var BEFORE_SPECIAL            = i++; //S
var BEFORE_SPECIAL_END        = i++;   //S

var BEFORE_SCRIPT_1           = i++; //C
var BEFORE_SCRIPT_2           = i++; //R
var BEFORE_SCRIPT_3           = i++; //I
var BEFORE_SCRIPT_4           = i++; //P
var BEFORE_SCRIPT_5           = i++; //T
var AFTER_SCRIPT_1            = i++; //C
var AFTER_SCRIPT_2            = i++; //R
var AFTER_SCRIPT_3            = i++; //I
var AFTER_SCRIPT_4            = i++; //P
var AFTER_SCRIPT_5            = i++; //T

var BEFORE_STYLE_1            = i++; //T
var BEFORE_STYLE_2            = i++; //Y
var BEFORE_STYLE_3            = i++; //L
var BEFORE_STYLE_4            = i++; //E
var AFTER_STYLE_1             = i++; //T
var AFTER_STYLE_2             = i++; //Y
var AFTER_STYLE_3             = i++; //L
var AFTER_STYLE_4             = i++; //E

var BEFORE_ENTITY             = i++; //&
var BEFORE_NUMERIC_ENTITY     = i++; //#
var IN_NAMED_ENTITY           = i++;
var IN_NUMERIC_ENTITY         = i++;
var IN_HEX_ENTITY             = i++; //X

var j = 0;

var SPECIAL_NONE              = j++;
var SPECIAL_SCRIPT            = j++;
var SPECIAL_STYLE             = j++;

function whitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function ifElseState(upper, SUCCESS, FAILURE){
	var lower = upper.toLowerCase();

	if(upper === lower){
		return function(c){
			if(c === lower){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	} else {
		return function(c){
			if(c === lower || c === upper){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	}
}

function consumeSpecialNameChar(upper, NEXT_STATE){
	var lower = upper.toLowerCase();

	return function(c){
		if(c === lower || c === upper){
			this._state = NEXT_STATE;
		} else {
			this._state = IN_TAG_NAME;
			this._index--; //consume the token again
		}
	};
}

function Tokenizer(options, cbs){
	this._state = TEXT;
	this._buffer = "";
	this._sectionStart = 0;
	this._index = 0;
	this._bufferOffset = 0; //chars removed from _buffer
	this._baseState = TEXT;
	this._special = SPECIAL_NONE;
	this._cbs = cbs;
	this._running = true;
	this._ended = false;
	this._xmlMode = !!(options && options.xmlMode);
	this._decodeEntities = !!(options && options.decodeEntities);
}

Tokenizer.prototype._stateText = function(c){
	if(c === "<"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._state = BEFORE_TAG_NAME;
		this._sectionStart = this._index;
	} else if(this._decodeEntities && this._special === SPECIAL_NONE && c === "&"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._baseState = TEXT;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeTagName = function(c){
	if(c === "/"){
		this._state = BEFORE_CLOSING_TAG_NAME;
	} else if(c === "<"){
		this._cbs.ontext(this._getSection());
		this._sectionStart = this._index;
	} else if(c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
		this._state = TEXT;
	} else if(c === "!"){
		this._state = BEFORE_DECLARATION;
		this._sectionStart = this._index + 1;
	} else if(c === "?"){
		this._state = IN_PROCESSING_INSTRUCTION;
		this._sectionStart = this._index + 1;
	} else {
		this._state = (!this._xmlMode && (c === "s" || c === "S")) ?
			BEFORE_SPECIAL : IN_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInTagName = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._emitToken("onopentagname");
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateBeforeCloseingTagName = function(c){
	if(whitespace(c));
	else if(c === ">"){
		this._state = TEXT;
	} else if(this._special !== SPECIAL_NONE){
		if(c === "s" || c === "S"){
			this._state = BEFORE_SPECIAL_END;
		} else {
			this._state = TEXT;
			this._index--;
		}
	} else {
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInCloseingTagName = function(c){
	if(c === ">" || whitespace(c)){
		this._emitToken("onclosetag");
		this._state = AFTER_CLOSING_TAG_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterCloseingTagName = function(c){
	//skip everything until ">"
	if(c === ">"){
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeAttributeName = function(c){
	if(c === ">"){
		this._cbs.onopentagend();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c === "/"){
		this._state = IN_SELF_CLOSING_TAG;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInSelfClosingTag = function(c){
	if(c === ">"){
		this._cbs.onselfclosingtag();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateInAttributeName = function(c){
	if(c === "=" || c === "/" || c === ">" || whitespace(c)){
		this._cbs.onattribname(this._getSection());
		this._sectionStart = -1;
		this._state = AFTER_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer.prototype._stateAfterAttributeName = function(c){
	if(c === "="){
		this._state = BEFORE_ATTRIBUTE_VALUE;
	} else if(c === "/" || c === ">"){
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(!whitespace(c)){
		this._cbs.onattribend();
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeAttributeValue = function(c){
	if(c === "\""){
		this._state = IN_ATTRIBUTE_VALUE_DQ;
		this._sectionStart = this._index + 1;
	} else if(c === "'"){
		this._state = IN_ATTRIBUTE_VALUE_SQ;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_VALUE_NQ;
		this._sectionStart = this._index;
		this._index--; //reconsume token
	}
};

Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c){
	if(c === "\""){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c){
	if(c === "'"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c){
	if(whitespace(c) || c === ">"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer.prototype._stateBeforeDeclaration = function(c){
	this._state = c === "[" ? BEFORE_CDATA_1 :
		c === "-" ? BEFORE_COMMENT :
			IN_DECLARATION;
};

Tokenizer.prototype._stateInDeclaration = function(c){
	if(c === ">"){
		this._cbs.ondeclaration(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateInProcessingInstruction = function(c){
	if(c === ">"){
		this._cbs.onprocessinginstruction(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer.prototype._stateBeforeComment = function(c){
	if(c === "-"){
		this._state = IN_COMMENT;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
	}
};

Tokenizer.prototype._stateInComment = function(c){
	if(c === "-") this._state = AFTER_COMMENT_1;
};

Tokenizer.prototype._stateAfterComment1 = function(c){
	if(c === "-"){
		this._state = AFTER_COMMENT_2;
	} else {
		this._state = IN_COMMENT;
	}
};

Tokenizer.prototype._stateAfterComment2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "-"){
		this._state = IN_COMMENT;
	}
	// else: stay in AFTER_COMMENT_2 (`--->`)
};

Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);

Tokenizer.prototype._stateBeforeCdata6 = function(c){
	if(c === "["){
		this._state = IN_CDATA;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
		this._index--;
	}
};

Tokenizer.prototype._stateInCdata = function(c){
	if(c === "]") this._state = AFTER_CDATA_1;
};

Tokenizer.prototype._stateAfterCdata1 = function(c){
	if(c === "]") this._state = AFTER_CDATA_2;
	else this._state = IN_CDATA;
};

Tokenizer.prototype._stateAfterCdata2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "]") {
		this._state = IN_CDATA;
	}
	//else: stay in AFTER_CDATA_2 (`]]]>`)
};

Tokenizer.prototype._stateBeforeSpecial = function(c){
	if(c === "c" || c === "C"){
		this._state = BEFORE_SCRIPT_1;
	} else if(c === "t" || c === "T"){
		this._state = BEFORE_STYLE_1;
	} else {
		this._state = IN_TAG_NAME;
		this._index--; //consume the token again
	}
};

Tokenizer.prototype._stateBeforeSpecialEnd = function(c){
	if(this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")){
		this._state = AFTER_SCRIPT_1;
	} else if(this._special === SPECIAL_STYLE && (c === "t" || c === "T")){
		this._state = AFTER_STYLE_1;
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);

Tokenizer.prototype._stateBeforeScript5 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_SCRIPT;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);

Tokenizer.prototype._stateAfterScript5 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 6;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);

Tokenizer.prototype._stateBeforeStyle4 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_STYLE;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);

Tokenizer.prototype._stateAfterStyle4 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 5;
		this._index--; //reconsume the token
	}
	else this._state = TEXT;
};

Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
Tokenizer.prototype._parseNamedEntityStrict = function(){
	//offset = 1
	if(this._sectionStart + 1 < this._index){
		var entity = this._buffer.substring(this._sectionStart + 1, this._index),
		    map = this._xmlMode ? xmlMap : entityMap;

		if(map.hasOwnProperty(entity)){
			this._emitPartial(map[entity]);
			this._sectionStart = this._index + 1;
		}
	}
};


//parses legacy entities (without trailing semicolon)
Tokenizer.prototype._parseLegacyEntity = function(){
	var start = this._sectionStart + 1,
	    limit = this._index - start;

	if(limit > 6) limit = 6; //the max length of legacy entities is 6

	while(limit >= 2){ //the min length of legacy entities is 2
		var entity = this._buffer.substr(start, limit);

		if(legacyMap.hasOwnProperty(entity)){
			this._emitPartial(legacyMap[entity]);
			this._sectionStart += limit + 1;
			return;
		} else {
			limit--;
		}
	}
};

Tokenizer.prototype._stateInNamedEntity = function(c){
	if(c === ";"){
		this._parseNamedEntityStrict();
		if(this._sectionStart + 1 < this._index && !this._xmlMode){
			this._parseLegacyEntity();
		}
		this._state = this._baseState;
	} else if((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")){
		if(this._xmlMode);
		else if(this._sectionStart + 1 === this._index);
		else if(this._baseState !== TEXT){
			if(c !== "="){
				this._parseNamedEntityStrict();
			}
		} else {
			this._parseLegacyEntity();
		}

		this._state = this._baseState;
		this._index--;
	}
};

Tokenizer.prototype._decodeNumericEntity = function(offset, base){
	var sectionStart = this._sectionStart + offset;

	if(sectionStart !== this._index){
		//parse entity
		var entity = this._buffer.substring(sectionStart, this._index);
		var parsed = parseInt(entity, base);

		this._emitPartial(decodeCodePoint(parsed));
		this._sectionStart = this._index;
	} else {
		this._sectionStart--;
	}

	this._state = this._baseState;
};

Tokenizer.prototype._stateInNumericEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(2, 10);
		this._sectionStart++;
	} else if(c < "0" || c > "9"){
		if(!this._xmlMode){
			this._decodeNumericEntity(2, 10);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._stateInHexEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(3, 16);
		this._sectionStart++;
	} else if((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")){
		if(!this._xmlMode){
			this._decodeNumericEntity(3, 16);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer.prototype._cleanup = function (){
	if(this._sectionStart < 0){
		this._buffer = "";
		this._bufferOffset += this._index;
		this._index = 0;
	} else if(this._running){
		if(this._state === TEXT){
			if(this._sectionStart !== this._index){
				this._cbs.ontext(this._buffer.substr(this._sectionStart));
			}
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else if(this._sectionStart === this._index){
			//the section just started
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else {
			//remove everything unnecessary
			this._buffer = this._buffer.substr(this._sectionStart);
			this._index -= this._sectionStart;
			this._bufferOffset += this._sectionStart;
		}

		this._sectionStart = 0;
	}
};

//TODO make events conditional
Tokenizer.prototype.write = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".write() after done!"));

	this._buffer += chunk;
	this._parse();
};

Tokenizer.prototype._parse = function(){
	while(this._index < this._buffer.length && this._running){
		var c = this._buffer.charAt(this._index);
		if(this._state === TEXT) {
			this._stateText(c);
		} else if(this._state === BEFORE_TAG_NAME){
			this._stateBeforeTagName(c);
		} else if(this._state === IN_TAG_NAME) {
			this._stateInTagName(c);
		} else if(this._state === BEFORE_CLOSING_TAG_NAME){
			this._stateBeforeCloseingTagName(c);
		} else if(this._state === IN_CLOSING_TAG_NAME){
			this._stateInCloseingTagName(c);
		} else if(this._state === AFTER_CLOSING_TAG_NAME){
			this._stateAfterCloseingTagName(c);
		} else if(this._state === IN_SELF_CLOSING_TAG){
			this._stateInSelfClosingTag(c);
		}

		/*
		*	attributes
		*/
		else if(this._state === BEFORE_ATTRIBUTE_NAME){
			this._stateBeforeAttributeName(c);
		} else if(this._state === IN_ATTRIBUTE_NAME){
			this._stateInAttributeName(c);
		} else if(this._state === AFTER_ATTRIBUTE_NAME){
			this._stateAfterAttributeName(c);
		} else if(this._state === BEFORE_ATTRIBUTE_VALUE){
			this._stateBeforeAttributeValue(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_DQ){
			this._stateInAttributeValueDoubleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_SQ){
			this._stateInAttributeValueSingleQuotes(c);
		} else if(this._state === IN_ATTRIBUTE_VALUE_NQ){
			this._stateInAttributeValueNoQuotes(c);
		}

		/*
		*	declarations
		*/
		else if(this._state === BEFORE_DECLARATION){
			this._stateBeforeDeclaration(c);
		} else if(this._state === IN_DECLARATION){
			this._stateInDeclaration(c);
		}

		/*
		*	processing instructions
		*/
		else if(this._state === IN_PROCESSING_INSTRUCTION){
			this._stateInProcessingInstruction(c);
		}

		/*
		*	comments
		*/
		else if(this._state === BEFORE_COMMENT){
			this._stateBeforeComment(c);
		} else if(this._state === IN_COMMENT){
			this._stateInComment(c);
		} else if(this._state === AFTER_COMMENT_1){
			this._stateAfterComment1(c);
		} else if(this._state === AFTER_COMMENT_2){
			this._stateAfterComment2(c);
		}

		/*
		*	cdata
		*/
		else if(this._state === BEFORE_CDATA_1){
			this._stateBeforeCdata1(c);
		} else if(this._state === BEFORE_CDATA_2){
			this._stateBeforeCdata2(c);
		} else if(this._state === BEFORE_CDATA_3){
			this._stateBeforeCdata3(c);
		} else if(this._state === BEFORE_CDATA_4){
			this._stateBeforeCdata4(c);
		} else if(this._state === BEFORE_CDATA_5){
			this._stateBeforeCdata5(c);
		} else if(this._state === BEFORE_CDATA_6){
			this._stateBeforeCdata6(c);
		} else if(this._state === IN_CDATA){
			this._stateInCdata(c);
		} else if(this._state === AFTER_CDATA_1){
			this._stateAfterCdata1(c);
		} else if(this._state === AFTER_CDATA_2){
			this._stateAfterCdata2(c);
		}

		/*
		* special tags
		*/
		else if(this._state === BEFORE_SPECIAL){
			this._stateBeforeSpecial(c);
		} else if(this._state === BEFORE_SPECIAL_END){
			this._stateBeforeSpecialEnd(c);
		}

		/*
		* script
		*/
		else if(this._state === BEFORE_SCRIPT_1){
			this._stateBeforeScript1(c);
		} else if(this._state === BEFORE_SCRIPT_2){
			this._stateBeforeScript2(c);
		} else if(this._state === BEFORE_SCRIPT_3){
			this._stateBeforeScript3(c);
		} else if(this._state === BEFORE_SCRIPT_4){
			this._stateBeforeScript4(c);
		} else if(this._state === BEFORE_SCRIPT_5){
			this._stateBeforeScript5(c);
		}

		else if(this._state === AFTER_SCRIPT_1){
			this._stateAfterScript1(c);
		} else if(this._state === AFTER_SCRIPT_2){
			this._stateAfterScript2(c);
		} else if(this._state === AFTER_SCRIPT_3){
			this._stateAfterScript3(c);
		} else if(this._state === AFTER_SCRIPT_4){
			this._stateAfterScript4(c);
		} else if(this._state === AFTER_SCRIPT_5){
			this._stateAfterScript5(c);
		}

		/*
		* style
		*/
		else if(this._state === BEFORE_STYLE_1){
			this._stateBeforeStyle1(c);
		} else if(this._state === BEFORE_STYLE_2){
			this._stateBeforeStyle2(c);
		} else if(this._state === BEFORE_STYLE_3){
			this._stateBeforeStyle3(c);
		} else if(this._state === BEFORE_STYLE_4){
			this._stateBeforeStyle4(c);
		}

		else if(this._state === AFTER_STYLE_1){
			this._stateAfterStyle1(c);
		} else if(this._state === AFTER_STYLE_2){
			this._stateAfterStyle2(c);
		} else if(this._state === AFTER_STYLE_3){
			this._stateAfterStyle3(c);
		} else if(this._state === AFTER_STYLE_4){
			this._stateAfterStyle4(c);
		}

		/*
		* entities
		*/
		else if(this._state === BEFORE_ENTITY){
			this._stateBeforeEntity(c);
		} else if(this._state === BEFORE_NUMERIC_ENTITY){
			this._stateBeforeNumericEntity(c);
		} else if(this._state === IN_NAMED_ENTITY){
			this._stateInNamedEntity(c);
		} else if(this._state === IN_NUMERIC_ENTITY){
			this._stateInNumericEntity(c);
		} else if(this._state === IN_HEX_ENTITY){
			this._stateInHexEntity(c);
		}

		else {
			this._cbs.onerror(Error("unknown _state"), this._state);
		}

		this._index++;
	}

	this._cleanup();
};

Tokenizer.prototype.pause = function(){
	this._running = false;
};
Tokenizer.prototype.resume = function(){
	this._running = true;

	if(this._index < this._buffer.length){
		this._parse();
	}
	if(this._ended){
		this._finish();
	}
};

Tokenizer.prototype.end = function(chunk){
	if(this._ended) this._cbs.onerror(Error(".end() after done!"));
	if(chunk) this.write(chunk);

	this._ended = true;

	if(this._running) this._finish();
};

Tokenizer.prototype._finish = function(){
	//if there is remaining data, emit it in a reasonable way
	if(this._sectionStart < this._index){
		this._handleTrailingData();
	}

	this._cbs.onend();
};

Tokenizer.prototype._handleTrailingData = function(){
	var data = this._buffer.substr(this._sectionStart);

	if(this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2){
		this._cbs.oncdata(data);
	} else if(this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2){
		this._cbs.oncomment(data);
	} else if(this._state === IN_NAMED_ENTITY && !this._xmlMode){
		this._parseLegacyEntity();
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_NUMERIC_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(2, 10);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_HEX_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(3, 16);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(
		this._state !== IN_TAG_NAME &&
		this._state !== BEFORE_ATTRIBUTE_NAME &&
		this._state !== BEFORE_ATTRIBUTE_VALUE &&
		this._state !== AFTER_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_VALUE_SQ &&
		this._state !== IN_ATTRIBUTE_VALUE_DQ &&
		this._state !== IN_ATTRIBUTE_VALUE_NQ &&
		this._state !== IN_CLOSING_TAG_NAME
	){
		this._cbs.ontext(data);
	}
	//else, ignore remaining data
	//TODO add a way to remove current tag
};

Tokenizer.prototype.reset = function(){
	Tokenizer.call(this, {xmlMode: this._xmlMode, decodeEntities: this._decodeEntities}, this._cbs);
};

Tokenizer.prototype.getAbsoluteIndex = function(){
	return this._bufferOffset + this._index;
};

Tokenizer.prototype._getSection = function(){
	return this._buffer.substring(this._sectionStart, this._index);
};

Tokenizer.prototype._emitToken = function(name){
	this._cbs[name](this._getSection());
	this._sectionStart = -1;
};

Tokenizer.prototype._emitPartial = function(value){
	if(this._baseState !== TEXT){
		this._cbs.onattribdata(value); //TODO implement the new event
	} else {
		this._cbs.ontext(value);
	}
};


/***/ }),

/***/ "./node_modules/htmlparser2/lib/WritableStream.js":
/*!********************************************************!*\
  !*** ./node_modules/htmlparser2/lib/WritableStream.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = Stream;

var Parser = __webpack_require__(/*! ./Parser.js */ "./node_modules/htmlparser2/lib/Parser.js");
var WritableStream = __webpack_require__(/*! readable-stream */ 0).Writable;
var StringDecoder = __webpack_require__(/*! string_decoder */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

function Stream(cbs, options){
	var parser = this._parser = new Parser(cbs, options);
	var decoder = this._decoder = new StringDecoder();

	WritableStream.call(this, {decodeStrings: false});

	this.once("finish", function(){
		parser.end(decoder.end());
	});
}

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Stream, WritableStream);

WritableStream.prototype._write = function(chunk, encoding, cb){
	if(chunk instanceof Buffer) chunk = this._decoder.write(chunk);
	this._parser.write(chunk);
	cb();
};


/***/ }),

/***/ "./node_modules/htmlparser2/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/htmlparser2/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Parser = __webpack_require__(/*! ./Parser.js */ "./node_modules/htmlparser2/lib/Parser.js");
var DomHandler = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/index.js");

function defineProp(name, value){
	delete module.exports[name];
	module.exports[name] = value;
	return value;
}

module.exports = {
	Parser: Parser,
	Tokenizer: __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/htmlparser2/lib/Tokenizer.js"),
	ElementType: __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/index.js"),
	DomHandler: DomHandler,
	get FeedHandler(){
		return defineProp("FeedHandler", __webpack_require__(/*! ./FeedHandler.js */ "./node_modules/htmlparser2/lib/FeedHandler.js"));
	},
	get Stream(){
		return defineProp("Stream", __webpack_require__(/*! ./Stream.js */ "./node_modules/htmlparser2/lib/Stream.js"));
	},
	get WritableStream(){
		return defineProp("WritableStream", __webpack_require__(/*! ./WritableStream.js */ "./node_modules/htmlparser2/lib/WritableStream.js"));
	},
	get ProxyHandler(){
		return defineProp("ProxyHandler", __webpack_require__(/*! ./ProxyHandler.js */ "./node_modules/htmlparser2/lib/ProxyHandler.js"));
	},
	get DomUtils(){
		return defineProp("DomUtils", __webpack_require__(/*! domutils */ "./node_modules/domutils/index.js"));
	},
	get CollectingHandler(){
		return defineProp("CollectingHandler", __webpack_require__(/*! ./CollectingHandler.js */ "./node_modules/htmlparser2/lib/CollectingHandler.js"));
	},
	// For legacy support
	DefaultHandler: DomHandler,
	get RssHandler(){
		return defineProp("RssHandler", this.FeedHandler);
	},
	//helper methods
	parseDOM: function(data, options){
		var handler = new DomHandler(options);
		new Parser(handler, options).end(data);
		return handler.dom;
	},
	parseFeed: function(feed, options){
		var handler = new module.exports.FeedHandler(options);
		new Parser(handler, options).end(feed);
		return handler.dom;
	},
	createDomStream: function(cb, options, elementCb){
		var handler = new DomHandler(cb, options, elementCb);
		return new Parser(handler, options);
	},
	// List of all events that the parser emits
	EVENTS: { /* Format: eventname: number of arguments */
		attribute: 2,
		cdatastart: 0,
		cdataend: 0,
		text: 1,
		processinginstruction: 2,
		comment: 1,
		commentend: 0,
		closetag: 1,
		opentag: 2,
		opentagname: 1,
		error: 1,
		end: 0
	}
};


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/immutable/dist/immutable.js":
/*!**************************************************!*\
  !*** ./node_modules/immutable/dist/immutable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 *  Copyright (c) 2014-2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

  function createClass(ctor, superClass) {
    if (superClass) {
      ctor.prototype = Object.create(superClass.prototype);
    }
    ctor.prototype.constructor = ctor;
  }

  function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }


  createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }


  createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }


  createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }



  function isIterable(maybeIterable) {
    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  }

  function isKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  }

  function isIndexed(maybeIndexed) {
    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  function isOrdered(maybeOrdered) {
    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  }

  Iterable.isIterable = isIterable;
  Iterable.isKeyed = isKeyed;
  Iterable.isIndexed = isIndexed;
  Iterable.isAssociative = isAssociative;
  Iterable.isOrdered = isOrdered;

  Iterable.Keyed = KeyedIterable;
  Iterable.Indexed = IndexedIterable;
  Iterable.Set = SetIterable;


  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  // Used for setting prototype methods that IE8 chokes on.
  var DELETE = 'delete';

  // Constants describing the size of trie nodes.
  var SHIFT = 5; // Resulted in best performance after ______?
  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1;

  // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.
  var NOT_SET = {};

  // Boolean references, Rough equivalent of `bool &`.
  var CHANGE_LENGTH = { value: false };
  var DID_ALTER = { value: false };

  function MakeRef(ref) {
    ref.value = false;
    return ref;
  }

  function SetRef(ref) {
    ref && (ref.value = true);
  }

  // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.
  function OwnerID() {}

  // http://jsperf.com/copy-array-inline
  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }
    return newArr;
  }

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^32−1.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }
      index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (begin === 0 || (size !== undefined && begin <= -size)) &&
      (end === undefined || (size !== undefined && end >= size));
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    return index === undefined ?
      defaultIndex :
      index < 0 ?
        Math.max(0, size + index) :
        size === undefined ?
          index :
          Math.min(size, index);
  }

  /* global Symbol */

  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;

  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


  function Iterator(next) {
      this.next = next;
    }

    Iterator.prototype.toString = function() {
      return '[Iterator]';
    };


  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect =
  Iterator.prototype.toSource = function () { return this.toString(); }
  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };


  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
      value: value, done: false
    });
    return iteratorResult;
  }

  function iteratorDone() {
    return { value: undefined, done: true };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn = iterable && (
      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]
    );
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isArrayLike(value) {
    return value && typeof value.length === 'number';
  }

  createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() :
        isIterable(value) ? value.toSeq() : seqFromValue(value);
    }

    Seq.of = function(/*...values*/) {
      return Seq(arguments);
    };

    Seq.prototype.toSeq = function() {
      return this;
    };

    Seq.prototype.toString = function() {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, true);
    };



  createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ?
        emptySequence().toKeyedSeq() :
        isIterable(value) ?
          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
          keyedSeqFromValue(value);
    }

    KeyedSeq.prototype.toKeyedSeq = function() {
      return this;
    };



  createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }

    IndexedSeq.of = function(/*...values*/) {
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function() {
      return this;
    };

    IndexedSeq.prototype.toString = function() {
      return this.__toString('Seq [', ']');
    };

    IndexedSeq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };

    IndexedSeq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, false);
    };



  createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (
        value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value
      ).toSetSeq();
    }

    SetSeq.of = function(/*...values*/) {
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function() {
      return this;
    };



  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;

  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

  Seq.prototype[IS_SEQ_SENTINEL] = true;



  createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    ArraySeq.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function(fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ArraySeq.prototype.__iterator = function(type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(function() 
        {return ii > maxIndex ?
          iteratorDone() :
          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
      );
    };



  createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    ObjectSeq.prototype.get = function(key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };

    ObjectSeq.prototype.__iterate = function(fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ObjectSeq.prototype.__iterator = function(type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, key, object[key]);
      });
    };

  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }

    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };



  createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }

    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };

    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function()  {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };




  // # pragma Helper functions

  function isSeq(maybeSeq) {
    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  }

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq =
      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
      typeof value === 'object' ? new ObjectSeq(value) :
      undefined;
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of [k, v] entries, '+
        'or keyed object: ' + value
      );
    }
    return seq;
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values: ' + value
      );
    }
    return seq;
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value) ||
      (typeof value === 'object' && new ObjectSeq(value));
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values, or keyed object: ' + value
      );
    }
    return seq;
  }

  function maybeIndexedSeqFromValue(value) {
    return (
      isArrayLike(value) ? new ArraySeq(value) :
      isIterator(value) ? new IteratorSeq(value) :
      hasIterator(value) ? new IterableSeq(value) :
      undefined
    );
  }

  function seqIterate(seq, fn, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var entry = cache[reverse ? maxIndex - ii : ii];
        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
          return ii + 1;
        }
      }
      return ii;
    }
    return seq.__iterateUncached(fn, reverse);
  }

  function seqIterator(seq, type, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var entry = cache[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
      });
    }
    return seq.__iteratorUncached(type, reverse);
  }

  function fromJS(json, converter) {
    return converter ?
      fromJSWith(converter, json, '', {'': json}) :
      fromJSDefault(json);
  }

  function fromJSWith(converter, json, key, parentJSON) {
    if (Array.isArray(json)) {
      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    if (isPlainObj(json)) {
      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    return json;
  }

  function fromJSDefault(json) {
    if (Array.isArray(json)) {
      return IndexedSeq(json).map(fromJSDefault).toList();
    }
    if (isPlainObj(json)) {
      return KeyedSeq(json).map(fromJSDefault).toMap();
    }
    return json;
  }

  function isPlainObj(value) {
    return value && (value.constructor === Object || value.constructor === undefined);
  }

  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if the it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections implement `equals` and `hashCode`.
   *
   */
  function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
    if (typeof valueA.valueOf === 'function' &&
        typeof valueB.valueOf === 'function') {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
    }
    if (typeof valueA.equals === 'function' &&
        typeof valueB.equals === 'function' &&
        valueA.equals(valueB)) {
      return true;
    }
    return false;
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (
      !isIterable(b) ||
      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
      isKeyed(a) !== isKeyed(b) ||
      isIndexed(a) !== isIndexed(b) ||
      isOrdered(a) !== isOrdered(b)
    ) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return b.every(function(v, k)  {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done;
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;
    var bSize = b.__iterate(function(v, k)  {
      if (notAssociative ? !a.has(v) :
          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  createClass(Repeat, IndexedSeq);

    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    Repeat.prototype.toString = function() {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function(searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this :
        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };

    Repeat.prototype.reverse = function() {
      return this;
    };

    Repeat.prototype.indexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function(fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
      var ii = 0;
      return new Iterator(function() 
        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
      );
    };

    Repeat.prototype.equals = function(other) {
      return other instanceof Repeat ?
        is(this._value, other._value) :
        deepEqual(other);
    };


  var EMPTY_REPEAT;

  function invariant(condition, error) {
    if (!condition) throw new Error(error);
  }

  createClass(Range, IndexedSeq);

    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    Range.prototype.toString = function() {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' +
        this._start + '...' + this._end +
        (this._step !== 1 ? ' by ' + this._step : '') +
      ' ]';
    };

    Range.prototype.get = function(index, notSetValue) {
      return this.has(index) ?
        this._start + wrapIndex(this, index) * this._step :
        notSetValue;
    };

    Range.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 &&
        possibleIndex < this.size &&
        possibleIndex === Math.floor(possibleIndex);
    };

    Range.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };

    Range.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function(fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };

    Range.prototype.__iterator = function(type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function()  {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };

    Range.prototype.equals = function(other) {
      return other instanceof Range ?
        this._start === other._start &&
        this._end === other._end &&
        this._step === other._step :
        deepEqual(this, other);
    };


  var EMPTY_RANGE;

  createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }


  createClass(KeyedCollection, Collection);function KeyedCollection() {}

  createClass(IndexedCollection, Collection);function IndexedCollection() {}

  createClass(SetCollection, Collection);function SetCollection() {}


  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;

  var imul =
    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
    Math.imul :
    function imul(a, b) {
      a = a | 0; // int
      b = b | 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
    };

  // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.
  function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }
    if (typeof o.valueOf === 'function') {
      o = o.valueOf();
      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }
    if (o === true) {
      return 1;
    }
    var type = typeof o;
    if (type === 'number') {
      if (o !== o || o === Infinity) {
        return 0;
      }
      var h = o | 0;
      if (h !== o) {
        h ^= o * 0xFFFFFFFF;
      }
      while (o > 0xFFFFFFFF) {
        o /= 0xFFFFFFFF;
        h ^= o;
      }
      return smi(h);
    }
    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
    }
    if (typeof o.hashCode === 'function') {
      return o.hashCode();
    }
    if (type === 'object') {
      return hashJSObj(o);
    }
    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }
    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hash = stringHashCache[string];
    if (hash === undefined) {
      hash = hashString(string);
      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }
      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hash;
    }
    return hash;
  }

  // http://jsperf.com/hashing-strings
  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hash = 0;
    for (var ii = 0; ii < string.length; ii++) {
      hash = 31 * hash + string.charCodeAt(ii) | 0;
    }
    return smi(hash);
  }

  function hashJSObj(obj) {
    var hash;
    if (usingWeakMap) {
      hash = weakMap.get(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = obj[UID_HASH_KEY];
    if (hash !== undefined) {
      return hash;
    }

    if (!canDefineProperty) {
      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }

      hash = getIENodeHash(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = ++objHashUID;
    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hash);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': hash
      });
    } else if (obj.propertyIsEnumerable !== undefined &&
               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function() {
        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
      };
      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hash;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hash;
  }

  // Get references to ES5 object methods.
  var isExtensible = Object.isExtensible;

  // True if Object.defineProperty works as expected. IE8 fails this test.
  var canDefineProperty = (function() {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  }());

  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.
  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1: // Element
          return node.uniqueID;
        case 9: // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  }

  // If possible, use a WeakMap.
  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;
  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;

  var UID_HASH_KEY = '__immutablehash__';
  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  function assertNotInfinite(size) {
    invariant(
      size !== Infinity,
      'Cannot perform this action with an infinite size.'
    );
  }

  createClass(Map, KeyedCollection);

    // @pragma Construction

    function Map(value) {
      return value === null || value === undefined ? emptyMap() :
        isMap(value) && !isOrdered(value) ? value :
        emptyMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
      return emptyMap().withMutations(function(map ) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };

    Map.prototype.toString = function() {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function(k, notSetValue) {
      return this._root ?
        this._root.get(0, undefined, k, notSetValue) :
        notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function(k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function()  {return v});
    };

    Map.prototype.remove = function(k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function()  {return NOT_SET});
    };

    Map.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ?
        k(this) :
        this.updateIn([k], notSetValue, updater);
    };

    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(
        this,
        forceIterator(keyPath),
        notSetValue,
        updater
      );
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };

    Map.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.merge = function(/*...iters*/) {
      return mergeIntoMapWith(this, undefined, arguments);
    };

    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };

    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.merge === 'function' ?
          m.merge.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };

    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };

    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.mergeDeep === 'function' ?
          m.mergeDeep.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.sort = function(comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    // @pragma Mutability

    Map.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };

    Map.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };

    Map.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };

    Map.prototype.wasAltered = function() {
      return this.__altered;
    };

    Map.prototype.__iterator = function(type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry ) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };


  function isMap(maybeMap) {
    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  }

  Map.isMap = isMap;

  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SENTINEL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeIn = MapPrototype.deleteIn;


  // #pragma Trie Nodes



    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }

    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && entries.length === 1) {
        return; // undefined
      }

      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new ArrayMapNode(ownerID, newEntries);
    };




    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }

    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue :
        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
    };

    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;

      if (!exists && value === NOT_SET) {
        return this;
      }

      var idx = popCount(bitmap & (bit - 1));
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

      if (newNode === node) {
        return this;
      }

      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }

      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }

      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ?
        setIn(nodes, idx, newNode, isEditable) :
        spliceOut(nodes, idx, isEditable) :
        spliceIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }

      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };




    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }

    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };

    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];

      if (removed && !node) {
        return this;
      }

      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }

      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }

      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };




    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }

    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }

      var removed = value === NOT_SET;

      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };




    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }

    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };

    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }

      SetRef(didAlter);

      if (removed) {
        SetRef(didChangeSize);
        return; // undefined
      }

      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }

      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };



  // #pragma Iterators

  ArrayMapNode.prototype.iterate =
  HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;
    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  }

  BitmapIndexedNode.prototype.iterate =
  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  }

  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  }

  createClass(MapIterator, Iterator);

    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    MapIterator.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };


  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;
  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }
      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef(CHANGE_LENGTH);
      var didAlter = MakeRef(DID_ALTER);
      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
      if (!didAlter.value) {
        return map;
      }
      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }
    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  }

  function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

    var newNode;
    var nodes = idx1 === idx2 ?
      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];
      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function mergeIntoMapWith(map, merger, iterables) {
    var iters = [];
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = KeyedIterable(value);
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    return mergeIntoCollectionWith(map, merger, iters);
  }

  function deepMerger(existing, value, key) {
    return existing && existing.mergeDeep && isIterable(value) ?
      existing.mergeDeep(value) :
      is(existing, value) ? existing : value;
  }

  function deepMergerWith(merger) {
    return function(existing, value, key)  {
      if (existing && existing.mergeDeepWith && isIterable(value)) {
        return existing.mergeDeepWith(merger, value);
      }
      var nextValue = merger(existing, value, key);
      return is(existing, nextValue) ? existing : nextValue;
    };
  }

  function mergeIntoCollectionWith(collection, merger, iters) {
    iters = iters.filter(function(x ) {return x.size !== 0});
    if (iters.length === 0) {
      return collection;
    }
    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
      return collection.constructor(iters[0]);
    }
    return collection.withMutations(function(collection ) {
      var mergeIntoMap = merger ?
        function(value, key)  {
          collection.update(key, NOT_SET, function(existing )
            {return existing === NOT_SET ? value : merger(existing, value, key)}
          );
        } :
        function(value, key)  {
          collection.set(key, value);
        }
      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoMap);
      }
    });
  }

  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
    var isNotSet = existing === NOT_SET;
    var step = keyPathIter.next();
    if (step.done) {
      var existingValue = isNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }
    invariant(
      isNotSet || (existing && existing.set),
      'invalid keyPath'
    );
    var key = step.value;
    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
    var nextUpdated = updateInDeepMap(
      nextExisting,
      keyPathIter,
      notSetValue,
      updater
    );
    return nextUpdated === nextExisting ? existing :
      nextUpdated === NOT_SET ? existing.remove(key) :
      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  }

  function popCount(x) {
    x = x - ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x7f;
  }

  function setIn(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }
    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }
      newArray[ii] = array[ii + after];
    }
    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  createClass(List, IndexedCollection);

    // @pragma Construction

    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function(list ) {
        list.setSize(size);
        iter.forEach(function(v, i)  {return list.set(i, v)});
      });
    }

    List.of = function(/*...values*/) {
      return this(arguments);
    };

    List.prototype.toString = function() {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function(index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function(index) {
      return !this.has(index) ? this :
        index === 0 ? this.shift() :
        index === this.size - 1 ? this.pop() :
        this.splice(index, 1);
    };

    List.prototype.insert = function(index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function(/*...values*/) {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list ) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function() {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function(/*...values*/) {
      var values = arguments;
      return this.withMutations(function(list ) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function() {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.merge = function(/*...iters*/) {
      return mergeIntoListWith(this, undefined, arguments);
    };

    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };

    List.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoListWith(this, deepMerger, arguments);
    };

    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };

    List.prototype.setSize = function(size) {
      return setListBounds(this, 0, size);
    };

    // @pragma Iteration

    List.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };

    List.prototype.__iterator = function(type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function()  {
        var value = values();
        return value === DONE ?
          iteratorDone() :
          iteratorValue(type, index++, value);
      });
    };

    List.prototype.__iterate = function(fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };


  function isList(maybeList) {
    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  }

  List.isList = isList;

  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SENTINEL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.setIn = MapPrototype.setIn;
  ListPrototype.deleteIn =
  ListPrototype.removeIn = MapPrototype.removeIn;
  ListPrototype.update = MapPrototype.update;
  ListPrototype.updateIn = MapPrototype.updateIn;
  ListPrototype.mergeIn = MapPrototype.mergeIn;
  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  ListPrototype.withMutations = MapPrototype.withMutations;
  ListPrototype.asMutable = MapPrototype.asMutable;
  ListPrototype.asImmutable = MapPrototype.asImmutable;
  ListPrototype.wasAltered = MapPrototype.wasAltered;



    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }

    // TODO: seems like these methods are very similar

    VNode.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level :  false || this.array.length === 0) {
        return this;
      }
      var originIndex = (index >>> level) & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };

    VNode.prototype.removeAfter = function(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = ((index - 1) >>> level) & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }

      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }

      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };



  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;

    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0 ?
        iterateLeaf(node, offset) :
        iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : (left - offset) >> level;
      var to = ((right - offset) >> level) + 1;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        do {
          if (values) {
            var value = values();
            if (value !== DONE) {
              return value;
            }
            values = null;
          }
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(
            array && array[idx], level - SHIFT, offset + (idx << level)
          );
        } while (true);
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;
  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function(list ) {
        index < 0 ?
          setListBounds(list, index).set(0, value) :
          setListBounds(list, 0, index + 1).set(index, value)
      });
    }

    index += list._origin;

    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef(DID_ALTER);
    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
      if (newLowerNode === lowerNode) {
        return node;
      }
      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    SetRef(didAlter);

    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }
    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
      var node = list._root;
      var level = list._level;
      while (node && level > 0) {
        node = node.array[(rawIndex >>> level) & MASK];
        level -= SHIFT;
      }
      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      end = end | 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    }

    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root;

    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);

    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
      newLevel += SHIFT;
    }

    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset ?
      listNodeFor(list, newCapacity - 1) :
      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

    // Merge Tail into tree.
    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;
      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = (oldTailOffset >>> level) & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }
      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }

    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }

    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0;

      // Identify the new top root node of the subtree of the old root.
      while (newRoot) {
        var beginIndex = (newOrigin >>> newLevel) & MASK;
        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
          break;
        }
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      }

      // Trim the new sides of the new root.
      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }
      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
      }
      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function mergeIntoListWith(list, merger, iterables) {
    var iters = [];
    var maxSize = 0;
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = IndexedIterable(value);
      if (iter.size > maxSize) {
        maxSize = iter.size;
      }
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    if (maxSize > list.size) {
      list = list.setSize(maxSize);
    }
    return mergeIntoCollectionWith(list, merger, iters);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
  }

  createClass(OrderedMap, Map);

    // @pragma Construction

    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() :
        isOrderedMap(value) ? value :
        emptyOrderedMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    OrderedMap.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedMap.prototype.toString = function() {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function(k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function(k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };

    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._list.__iterate(
        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
        reverse
      );
    };

    OrderedMap.prototype.__iterator = function(type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };


  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  OrderedMap.isOrderedMap = isOrderedMap;

  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;
  function emptyOrderedMap() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) { // removed
      if (!has) {
        return omap;
      }
      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else {
      if (has) {
        if (v === list.get(i)[1]) {
          return omap;
        }
        newMap = map;
        newList = list.set(i, [k, v]);
      } else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
      }
    }
    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }
    return makeOrderedMap(newMap, newList);
  }

  createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    ToKeyedSequence.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function(key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var ii;
      return this._iter.__iterate(
        this._useKeys ?
          function(v, k)  {return fn(v, k, this$0)} :
          ((ii = reverse ? resolveSize(this) : 0),
            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
        reverse
      );
    };

    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };

  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToIndexedSequence.prototype.includes = function(value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
    };

    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, iterations++, step.value, step)
      });
    };



  createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToSetSequence.prototype.has = function(key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
    };

    ToSetSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, step.value, step.value, step);
      });
    };



  createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    FromEntriesSequence.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(entry ) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(
            indexedIterable ? entry.get(1) : entry[1],
            indexedIterable ? entry.get(0) : entry[0],
            this$0
          );
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(
              type,
              indexedIterable ? entry.get(0) : entry[0],
              indexedIterable ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };


  ToIndexedSequence.prototype.cacheResult =
  ToKeyedSequence.prototype.cacheResult =
  ToSetSequence.prototype.cacheResult =
  FromEntriesSequence.prototype.cacheResult =
    cacheResultThrough;


  function flipFactory(iterable) {
    var flipSequence = makeSequence(iterable);
    flipSequence._iter = iterable;
    flipSequence.size = iterable.size;
    flipSequence.flip = function()  {return iterable};
    flipSequence.reverse = function () {
      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
      reversedSequence.flip = function()  {return iterable.reverse()};
      return reversedSequence;
    };
    flipSequence.has = function(key ) {return iterable.includes(key)};
    flipSequence.includes = function(key ) {return iterable.has(key)};
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
    }
    flipSequence.__iteratorUncached = function(type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = iterable.__iterator(type, reverse);
        return new Iterator(function()  {
          var step = iterator.next();
          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }
          return step;
        });
      }
      return iterable.__iterator(
        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
        reverse
      );
    }
    return flipSequence;
  }


  function mapFactory(iterable, mapper, context) {
    var mappedSequence = makeSequence(iterable);
    mappedSequence.size = iterable.size;
    mappedSequence.has = function(key ) {return iterable.has(key)};
    mappedSequence.get = function(key, notSetValue)  {
      var v = iterable.get(key, NOT_SET);
      return v === NOT_SET ?
        notSetValue :
        mapper.call(context, v, key, iterable);
    };
    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(
        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
        reverse
      );
    }
    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        return iteratorValue(
          type,
          key,
          mapper.call(context, entry[1], key, iterable),
          step
        );
      });
    }
    return mappedSequence;
  }


  function reverseFactory(iterable, useKeys) {
    var reversedSequence = makeSequence(iterable);
    reversedSequence._iter = iterable;
    reversedSequence.size = iterable.size;
    reversedSequence.reverse = function()  {return iterable};
    if (iterable.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(iterable);
        flipSequence.reverse = function()  {return iterable.flip()};
        return flipSequence;
      };
    }
    reversedSequence.get = function(key, notSetValue) 
      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
    reversedSequence.has = function(key )
      {return iterable.has(useKeys ? key : -1 - key)};
    reversedSequence.includes = function(value ) {return iterable.includes(value)};
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
    };
    reversedSequence.__iterator =
      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
    return reversedSequence;
  }


  function filterFactory(iterable, predicate, context, useKeys) {
    var filterSequence = makeSequence(iterable);
    if (useKeys) {
      filterSequence.has = function(key ) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
      };
      filterSequence.get = function(key, notSetValue)  {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
          v : notSetValue;
      };
    }
    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      }, reverse);
      return iterations;
    };
    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          var value = entry[1];
          if (predicate.call(context, value, key, iterable)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    }
    return filterSequence;
  }


  function countByFactory(iterable, grouper, context) {
    var groups = Map().asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        0,
        function(a ) {return a + 1}
      );
    });
    return groups.asImmutable();
  }


  function groupByFactory(iterable, grouper, context) {
    var isKeyedIter = isKeyed(iterable);
    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
      );
    });
    var coerce = iterableClass(iterable);
    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
  }


  function sliceFactory(iterable, begin, end, useKeys) {
    var originalSize = iterable.size;

    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      if (end === Infinity) {
        end = originalSize;
      } else {
        end = end | 0;
      }
    }

    if (wholeSlice(begin, end, originalSize)) {
      return iterable;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);

    // begin or end will be NaN if they were provided as negative numbers and
    // this iterable's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
    }

    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(iterable);

    // If iterable.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize ?
          iterable.get(index + resolvedBegin, notSetValue) :
          notSetValue;
      }
    }

    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (sliceSize === 0) {
        return 0;
      }
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k)  {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
                 iterations !== sliceSize;
        }
      });
      return iterations;
    };

    sliceSeq.__iteratorUncached = function(type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      // Don't bother instantiating parent iterator if taking 0.
      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
      var skipped = 0;
      var iterations = 0;
      return new Iterator(function()  {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }
        if (++iterations > sliceSize) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (useKeys || type === ITERATE_VALUES) {
          return step;
        } else if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        } else {
          return iteratorValue(type, iterations - 1, step.value[1], step);
        }
      });
    }

    return sliceSeq;
  }


  function takeWhileFactory(iterable, predicate, context) {
    var takeSequence = makeSequence(iterable);
    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      iterable.__iterate(function(v, k, c) 
        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
      );
      return iterations;
    };
    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterating = true;
      return new Iterator(function()  {
        if (!iterating) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var k = entry[0];
        var v = entry[1];
        if (!predicate.call(context, v, k, this$0)) {
          iterating = false;
          return iteratorDone();
        }
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return takeSequence;
  }


  function skipWhileFactory(iterable, predicate, context, useKeys) {
    var skipSequence = makeSequence(iterable);
    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      });
      return iterations;
    };
    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var skipping = true;
      var iterations = 0;
      return new Iterator(function()  {
        var step, k, v;
        do {
          step = iterator.next();
          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            } else if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            } else {
              return iteratorValue(type, iterations++, step.value[1], step);
            }
          }
          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$0));
        } while (skipping);
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return skipSequence;
  }


  function concatFactory(iterable, values) {
    var isKeyedIterable = isKeyed(iterable);
    var iters = [iterable].concat(values).map(function(v ) {
      if (!isIterable(v)) {
        v = isKeyedIterable ?
          keyedSeqFromValue(v) :
          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedIterable) {
        v = KeyedIterable(v);
      }
      return v;
    }).filter(function(v ) {return v.size !== 0});

    if (iters.length === 0) {
      return iterable;
    }

    if (iters.length === 1) {
      var singleton = iters[0];
      if (singleton === iterable ||
          isKeyedIterable && isKeyed(singleton) ||
          isIndexed(iterable) && isIndexed(singleton)) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);
    if (isKeyedIterable) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(iterable)) {
      concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(
      function(sum, seq)  {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      },
      0
    );
    return concatSeq;
  }


  function flattenFactory(iterable, depth, useKeys) {
    var flatSequence = makeSequence(iterable);
    flatSequence.__iterateUncached = function(fn, reverse) {
      var iterations = 0;
      var stopped = false;
      function flatDeep(iter, currentDepth) {var this$0 = this;
        iter.__iterate(function(v, k)  {
          if ((!depth || currentDepth < depth) && isIterable(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
            stopped = true;
          }
          return !stopped;
        }, reverse);
      }
      flatDeep(iterable, 0);
      return iterations;
    }
    flatSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(type, reverse);
      var stack = [];
      var iterations = 0;
      return new Iterator(function()  {
        while (iterator) {
          var step = iterator.next();
          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }
          var v = step.value;
          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }
          if ((!depth || stack.length < depth) && isIterable(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }
        return iteratorDone();
      });
    }
    return flatSequence;
  }


  function flatMapFactory(iterable, mapper, context) {
    var coerce = iterableClass(iterable);
    return iterable.toSeq().map(
      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
    ).flatten(true);
  }


  function interposeFactory(iterable, separator) {
    var interposedSequence = makeSequence(iterable);
    interposedSequence.size = iterable.size && iterable.size * 2 -1;
    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k) 
        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
        fn(v, iterations++, this$0) !== false},
        reverse
      );
      return iterations;
    };
    interposedSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      var step;
      return new Iterator(function()  {
        if (!step || iterations % 2) {
          step = iterator.next();
          if (step.done) {
            return step;
          }
        }
        return iterations % 2 ?
          iteratorValue(type, iterations++, separator) :
          iteratorValue(type, iterations++, step.value, step);
      });
    };
    return interposedSequence;
  }


  function sortFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    var isKeyedIterable = isKeyed(iterable);
    var index = 0;
    var entries = iterable.toSeq().map(
      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
    ).toArray();
    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
      isKeyedIterable ?
      function(v, i)  { entries[i].length = 2; } :
      function(v, i)  { entries[i] = v[1]; }
    );
    return isKeyedIterable ? KeyedSeq(entries) :
      isIndexed(iterable) ? IndexedSeq(entries) :
      SetSeq(entries);
  }


  function maxFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    if (mapper) {
      var entry = iterable.toSeq()
        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
      return entry && entry[0];
    } else {
      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
    }
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
  }


  function zipWithFactory(keyIter, zipper, iters) {
    var zipSequence = makeSequence(keyIter);
    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function(fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    zipSequence.__iteratorUncached = function(type, reverse) {
      var iterators = iters.map(function(i )
        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
      );
      var iterations = 0;
      var isDone = false;
      return new Iterator(function()  {
        var steps;
        if (!isDone) {
          steps = iterators.map(function(i ) {return i.next()});
          isDone = steps.some(function(s ) {return s.done});
        }
        if (isDone) {
          return iteratorDone();
        }
        return iteratorValue(
          type,
          iterations++,
          zipper.apply(null, steps.map(function(s ) {return s.value}))
        );
      });
    };
    return zipSequence
  }


  // #pragma Helper Functions

  function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function resolveSize(iter) {
    assertNotInfinite(iter.size);
    return ensureSize(iter);
  }

  function iterableClass(iterable) {
    return isKeyed(iterable) ? KeyedIterable :
      isIndexed(iterable) ? IndexedIterable :
      SetIterable;
  }

  function makeSequence(iterable) {
    return Object.create(
      (
        isKeyed(iterable) ? KeyedSeq :
        isIndexed(iterable) ? IndexedSeq :
        SetSeq
      ).prototype
    );
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  }

  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  function forceIterator(keyPath) {
    var iter = getIterator(keyPath);
    if (!iter) {
      // Array might not be iterable in this environment, so we need a fallback
      // to our wrapped type.
      if (!isArrayLike(keyPath)) {
        throw new TypeError('Expected iterable or array-like: ' + keyPath);
      }
      iter = getIterator(Iterable(keyPath));
    }
    return iter;
  }

  createClass(Record, KeyedCollection);

    function Record(defaultValues, name) {
      var hasInitialized;

      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map(values);
      };

      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;

      return RecordType;
    }

    Record.prototype.toString = function() {
      return this.__toString(recordName(this) + ' {', '}');
    };

    // @pragma Access

    Record.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };

    Record.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };

    // @pragma Modification

    Record.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };

    Record.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      if (this._map && !this._map.has(k)) {
        var defaultVal = this._defaultValues[k];
        if (v === defaultVal) {
          return this;
        }
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
    };

    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
    };

    Record.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };


  var RecordPrototype = Record.prototype;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn =
  RecordPrototype.removeIn = MapPrototype.removeIn;
  RecordPrototype.merge = MapPrototype.merge;
  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  RecordPrototype.setIn = MapPrototype.setIn;
  RecordPrototype.update = MapPrototype.update;
  RecordPrototype.updateIn = MapPrototype.updateIn;
  RecordPrototype.withMutations = MapPrototype.withMutations;
  RecordPrototype.asMutable = MapPrototype.asMutable;
  RecordPrototype.asImmutable = MapPrototype.asImmutable;


  function makeRecord(likeRecord, map, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._map = map;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function setProps(prototype, names) {
    try {
      names.forEach(setProp.bind(undefined, prototype));
    } catch (error) {
      // Object.defineProperty failed. Probably IE8.
    }
  }

  function setProp(prototype, name) {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  }

  createClass(Set, SetCollection);

    // @pragma Construction

    function Set(value) {
      return value === null || value === undefined ? emptySet() :
        isSet(value) && !isOrdered(value) ? value :
        emptySet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    Set.of = function(/*...values*/) {
      return this(arguments);
    };

    Set.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    Set.prototype.toString = function() {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function(value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function(value) {
      return updateSet(this, this._map.set(value, true));
    };

    Set.prototype.remove = function(value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function() {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x ) {return x.size !== 0});
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set ) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
        }
      });
    };

    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (!iters.every(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (iters.some(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };

    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };

    Set.prototype.sort = function(comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
    };

    Set.prototype.__iterator = function(type, reverse) {
      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };


  function isSet(maybeSet) {
    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  }

  Set.isSet = isSet;

  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SENTINEL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.mergeDeep = SetPrototype.merge;
  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  SetPrototype.withMutations = MapPrototype.withMutations;
  SetPrototype.asMutable = MapPrototype.asMutable;
  SetPrototype.asImmutable = MapPrototype.asImmutable;

  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }
    return newMap === set._map ? set :
      newMap.size === 0 ? set.__empty() :
      set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;
  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  createClass(OrderedSet, Set);

    // @pragma Construction

    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() :
        isOrderedSet(value) ? value :
        emptyOrderedSet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    OrderedSet.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedSet.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    OrderedSet.prototype.toString = function() {
      return this.__toString('OrderedSet {', '}');
    };


  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  OrderedSet.isOrderedSet = isOrderedSet;

  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;
  function emptyOrderedSet() {
    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  }

  createClass(Stack, IndexedCollection);

    // @pragma Construction

    function Stack(value) {
      return value === null || value === undefined ? emptyStack() :
        isStack(value) ? value :
        emptyStack().unshiftAll(value);
    }

    Stack.of = function(/*...values*/) {
      return this(arguments);
    };

    Stack.prototype.toString = function() {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function() {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function(/*...values*/) {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value ) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function() {
      return this.slice(1);
    };

    Stack.prototype.unshift = function(/*...values*/) {
      return this.push.apply(this, arguments);
    };

    Stack.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };

    Stack.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };

    Stack.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function(fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function(type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function()  {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };


  function isStack(maybeStack) {
    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  }

  Stack.isStack = isStack;

  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SENTINEL] = true;
  StackPrototype.withMutations = MapPrototype.withMutations;
  StackPrototype.asMutable = MapPrototype.asMutable;
  StackPrototype.asImmutable = MapPrototype.asImmutable;
  StackPrototype.wasAltered = MapPrototype.wasAltered;


  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;
  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }

  /**
   * Contributes additional methods to a constructor
   */
  function mixin(ctor, methods) {
    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  Iterable.Iterator = Iterator;

  mixin(Iterable, {

    // ### Conversion to other types

    toArray: function() {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);
      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
      return array;
    },

    toIndexedSeq: function() {
      return new ToIndexedSequence(this);
    },

    toJS: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
      ).__toJS();
    },

    toJSON: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
      ).__toJS();
    },

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, true);
    },

    toMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },

    toObject: function() {
      assertNotInfinite(this.size);
      var object = {};
      this.__iterate(function(v, k)  { object[k] = v; });
      return object;
    },

    toOrderedMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },

    toOrderedSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },

    toSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },

    toSetSeq: function() {
      return new ToSetSequence(this);
    },

    toSeq: function() {
      return isIndexed(this) ? this.toIndexedSeq() :
        isKeyed(this) ? this.toKeyedSeq() :
        this.toSetSeq();
    },

    toStack: function() {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },

    toList: function() {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },


    // ### Common JavaScript methods and properties

    toString: function() {
      return '[Iterable]';
    },

    __toString: function(head, tail) {
      if (this.size === 0) {
        return head + tail;
      }
      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    concat: function() {var values = SLICE$0.call(arguments, 0);
      return reify(this, concatFactory(this, values));
    },

    includes: function(searchValue) {
      return this.some(function(value ) {return is(value, searchValue)});
    },

    entries: function() {
      return this.__iterator(ITERATE_ENTRIES);
    },

    every: function(predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;
      this.__iterate(function(v, k, c)  {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });
      return returnValue;
    },

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },

    find: function(predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },

    forEach: function(sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },

    join: function(separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;
      this.__iterate(function(v ) {
        isFirst ? (isFirst = false) : (joined += separator);
        joined += v !== null && v !== undefined ? v.toString() : '';
      });
      return joined;
    },

    keys: function() {
      return this.__iterator(ITERATE_KEYS);
    },

    map: function(mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },

    reduce: function(reducer, initialReduction, context) {
      assertNotInfinite(this.size);
      var reduction;
      var useFirst;
      if (arguments.length < 2) {
        useFirst = true;
      } else {
        reduction = initialReduction;
      }
      this.__iterate(function(v, k, c)  {
        if (useFirst) {
          useFirst = false;
          reduction = v;
        } else {
          reduction = reducer.call(context, reduction, v, k, c);
        }
      });
      return reduction;
    },

    reduceRight: function(reducer, initialReduction, context) {
      var reversed = this.toKeyedSeq().reverse();
      return reversed.reduce.apply(reversed, arguments);
    },

    reverse: function() {
      return reify(this, reverseFactory(this, true));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },

    some: function(predicate, context) {
      return !this.every(not(predicate), context);
    },

    sort: function(comparator) {
      return reify(this, sortFactory(this, comparator));
    },

    values: function() {
      return this.__iterator(ITERATE_VALUES);
    },


    // ### More sequential methods

    butLast: function() {
      return this.slice(0, -1);
    },

    isEmpty: function() {
      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
    },

    count: function(predicate, context) {
      return ensureSize(
        predicate ? this.toSeq().filter(predicate, context) : this
      );
    },

    countBy: function(grouper, context) {
      return countByFactory(this, grouper, context);
    },

    equals: function(other) {
      return deepEqual(this, other);
    },

    entrySeq: function() {
      var iterable = this;
      if (iterable._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(iterable._cache);
      }
      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
      return entriesSequence;
    },

    filterNot: function(predicate, context) {
      return this.filter(not(predicate), context);
    },

    findEntry: function(predicate, context, notSetValue) {
      var found = notSetValue;
      this.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });
      return found;
    },

    findKey: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },

    findLast: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },

    findLastEntry: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
    },

    findLastKey: function(predicate, context) {
      return this.toKeyedSeq().reverse().findKey(predicate, context);
    },

    first: function() {
      return this.find(returnTrue);
    },

    flatMap: function(mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, true));
    },

    fromEntrySeq: function() {
      return new FromEntriesSequence(this);
    },

    get: function(searchKey, notSetValue) {
      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
    },

    getIn: function(searchKeyPath, notSetValue) {
      var nested = this;
      // Note: in an ES6 environment, we would prefer:
      // for (var key of searchKeyPath) {
      var iter = forceIterator(searchKeyPath);
      var step;
      while (!(step = iter.next()).done) {
        var key = step.value;
        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
        if (nested === NOT_SET) {
          return notSetValue;
        }
      }
      return nested;
    },

    groupBy: function(grouper, context) {
      return groupByFactory(this, grouper, context);
    },

    has: function(searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },

    hasIn: function(searchKeyPath) {
      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
    },

    isSubset: function(iter) {
      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
      return this.every(function(value ) {return iter.includes(value)});
    },

    isSuperset: function(iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
      return iter.isSubset(this);
    },

    keyOf: function(searchValue) {
      return this.findKey(function(value ) {return is(value, searchValue)});
    },

    keySeq: function() {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },

    last: function() {
      return this.toSeq().reverse().first();
    },

    lastKeyOf: function(searchValue) {
      return this.toKeyedSeq().reverse().keyOf(searchValue);
    },

    max: function(comparator) {
      return maxFactory(this, comparator);
    },

    maxBy: function(mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },

    min: function(comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },

    minBy: function(mapper, comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },

    rest: function() {
      return this.slice(1);
    },

    skip: function(amount) {
      return this.slice(Math.max(0, amount));
    },

    skipLast: function(amount) {
      return reify(this, this.toSeq().reverse().skip(amount).reverse());
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },

    skipUntil: function(predicate, context) {
      return this.skipWhile(not(predicate), context);
    },

    sortBy: function(mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },

    take: function(amount) {
      return this.slice(0, Math.max(0, amount));
    },

    takeLast: function(amount) {
      return reify(this, this.toSeq().reverse().take(amount).reverse());
    },

    takeWhile: function(predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },

    takeUntil: function(predicate, context) {
      return this.takeWhile(not(predicate), context);
    },

    valueSeq: function() {
      return this.toIndexedSeq();
    },


    // ### Hashable Object

    hashCode: function() {
      return this.__hash || (this.__hash = hashIterable(this));
    }


    // ### Internal

    // abstract __iterate(fn, reverse)

    // abstract __iterator(type, reverse)
  });

  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  var IterablePrototype = Iterable.prototype;
  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  IterablePrototype.__toJS = IterablePrototype.toArray;
  IterablePrototype.__toStringMapper = quoteString;
  IterablePrototype.inspect =
  IterablePrototype.toSource = function() { return this.toString(); };
  IterablePrototype.chain = IterablePrototype.flatMap;
  IterablePrototype.contains = IterablePrototype.includes;

  mixin(KeyedIterable, {

    // ### More sequential methods

    flip: function() {
      return reify(this, flipFactory(this));
    },

    mapEntries: function(mapper, context) {var this$0 = this;
      var iterations = 0;
      return reify(this,
        this.toSeq().map(
          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
        ).fromEntrySeq()
      );
    },

    mapKeys: function(mapper, context) {var this$0 = this;
      return reify(this,
        this.toSeq().flip().map(
          function(k, v)  {return mapper.call(context, k, v, this$0)}
        ).flip()
      );
    }

  });

  var KeyedIterablePrototype = KeyedIterable.prototype;
  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



  mixin(IndexedIterable, {

    // ### Conversion to other types

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, false);
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },

    findIndex: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    indexOf: function(searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    lastIndexOf: function(searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    reverse: function() {
      return reify(this, reverseFactory(this, false));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },

    splice: function(index, removeNum /*, ...values*/) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum | 0, 0);
      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
        return this;
      }
      // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.
      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(
        this,
        numArgs === 1 ?
          spliced :
          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
      );
    },


    // ### More collection methods

    findLastIndex: function(predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    first: function() {
      return this.get(0);
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, false));
    },

    get: function(index, notSetValue) {
      index = wrapIndex(this, index);
      return (index < 0 || (this.size === Infinity ||
          (this.size !== undefined && index > this.size))) ?
        notSetValue :
        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
    },

    has: function(index) {
      index = wrapIndex(this, index);
      return index >= 0 && (this.size !== undefined ?
        this.size === Infinity || index < this.size :
        this.indexOf(index) !== -1
      );
    },

    interpose: function(separator) {
      return reify(this, interposeFactory(this, separator));
    },

    interleave: function(/*...iterables*/) {
      var iterables = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
      var interleaved = zipped.flatten(true);
      if (zipped.size) {
        interleaved.size = zipped.size * iterables.length;
      }
      return reify(this, interleaved);
    },

    keySeq: function() {
      return Range(0, this.size);
    },

    last: function() {
      return this.get(-1);
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },

    zip: function(/*, ...iterables */) {
      var iterables = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, iterables));
    },

    zipWith: function(zipper/*, ...iterables */) {
      var iterables = arrCopy(arguments);
      iterables[0] = this;
      return reify(this, zipWithFactory(this, zipper, iterables));
    }

  });

  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



  mixin(SetIterable, {

    // ### ES6 Collection methods (ES6 Array and Map)

    get: function(value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },

    includes: function(value) {
      return this.has(value);
    },


    // ### More sequential methods

    keySeq: function() {
      return this.valueSeq();
    }

  });

  SetIterable.prototype.has = IterablePrototype.includes;
  SetIterable.prototype.contains = SetIterable.prototype.includes;


  // Mixin subclasses

  mixin(KeyedSeq, KeyedIterable.prototype);
  mixin(IndexedSeq, IndexedIterable.prototype);
  mixin(SetSeq, SetIterable.prototype);

  mixin(KeyedCollection, KeyedIterable.prototype);
  mixin(IndexedCollection, IndexedIterable.prototype);
  mixin(SetCollection, SetIterable.prototype);


  // #pragma Helper functions

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    }
  }

  function neg(predicate) {
    return function() {
      return -predicate.apply(this, arguments);
    }
  }

  function quoteString(value) {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashIterable(iterable) {
    if (iterable.size === Infinity) {
      return 0;
    }
    var ordered = isOrdered(iterable);
    var keyed = isKeyed(iterable);
    var h = ordered ? 1 : 0;
    var size = iterable.__iterate(
      keyed ?
        ordered ?
          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
        ordered ?
          function(v ) { h = 31 * h + hash(v) | 0; } :
          function(v ) { h = h + hash(v) | 0; }
    );
    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xCC9E2D51);
    h = imul(h << 15 | h >>> -15, 0x1B873593);
    h = imul(h << 13 | h >>> -13, 5);
    h = (h + 0xE6546B64 | 0) ^ size;
    h = imul(h ^ h >>> 16, 0x85EBCA6B);
    h = imul(h ^ h >>> 13, 0xC2B2AE35);
    h = smi(h ^ h >>> 16);
    return h;
  }

  function hashMerge(a, b) {
    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  }

  var Immutable = {

    Iterable: Iterable,

    Seq: Seq,
    Collection: Collection,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,

    Record: Record,
    Range: Range,
    Repeat: Repeat,

    is: is,
    fromJS: fromJS

  };

  return Immutable;

}));

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/is-function/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-function/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  if (!fn) {
    return false
  }
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/jszip/dist/jszip.min.js":
/*!**********************************************!*\
  !*** ./node_modules/jszip/dist/jszip.min.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, global, setImmediate) {var require;var require;/*!

JSZip v3.5.0 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

!function(t){if(true)module.exports=t();else {}}(function(){return function s(a,o,h){function u(r,t){if(!o[r]){if(!a[r]){var e="function"==typeof require&&require;if(!t&&e)return require(r,!0);if(l)return l(r,!0);var i=new Error("Cannot find module '"+r+"'");throw i.code="MODULE_NOT_FOUND",i}var n=o[r]={exports:{}};a[r][0].call(n.exports,function(t){var e=a[r][1][t];return u(e||t)},n,n.exports,s,a,o,h)}return o[r].exports}for(var l="function"==typeof require&&require,t=0;t<h.length;t++)u(h[t]);return u}({1:[function(t,e,r){"use strict";var c=t("./utils"),d=t("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(t){for(var e,r,i,n,s,a,o,h=[],u=0,l=t.length,f=l,d="string"!==c.getTypeOf(t);u<t.length;)f=l-u,i=d?(e=t[u++],r=u<l?t[u++]:0,u<l?t[u++]:0):(e=t.charCodeAt(u++),r=u<l?t.charCodeAt(u++):0,u<l?t.charCodeAt(u++):0),n=e>>2,s=(3&e)<<4|r>>4,a=1<f?(15&r)<<2|i>>6:64,o=2<f?63&i:64,h.push(p.charAt(n)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(t){var e,r,i,n,s,a,o=0,h=0,u="data:";if(t.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(t=t.replace(/[^A-Za-z0-9\+\/\=]/g,"")).length/4;if(t.charAt(t.length-1)===p.charAt(64)&&f--,t.charAt(t.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=d.uint8array?new Uint8Array(0|f):new Array(0|f);o<t.length;)e=p.indexOf(t.charAt(o++))<<2|(n=p.indexOf(t.charAt(o++)))>>4,r=(15&n)<<4|(s=p.indexOf(t.charAt(o++)))>>2,i=(3&s)<<6|(a=p.indexOf(t.charAt(o++))),l[h++]=e,64!==s&&(l[h++]=r),64!==a&&(l[h++]=i);return l}},{"./support":30,"./utils":32}],2:[function(t,e,r){"use strict";var i=t("./external"),n=t("./stream/DataWorker"),s=t("./stream/DataLengthProbe"),a=t("./stream/Crc32Probe");s=t("./stream/DataLengthProbe");function o(t,e,r,i,n){this.compressedSize=t,this.uncompressedSize=e,this.crc32=r,this.compression=i,this.compressedContent=n}o.prototype={getContentWorker:function(){var t=new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new s("data_length")),e=this;return t.on("end",function(){if(this.streamInfo.data_length!==e.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),t},getCompressedWorker:function(){return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(t,e,r){return t.pipe(new a).pipe(new s("uncompressedSize")).pipe(e.compressWorker(r)).pipe(new s("compressedSize")).withStreamInfo("compression",e)},e.exports=o},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(t,e,r){"use strict";var i=t("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(t){return new i("STORE compression")},uncompressWorker:function(){return new i("STORE decompression")}},r.DEFLATE=t("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(t,e,r){"use strict";var i=t("./utils");var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e){return void 0!==t&&t.length?"string"!==i.getTypeOf(t)?function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}(0|e,t,t.length,0):function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e.charCodeAt(a))];return-1^t}(0|e,t,t.length,0):0}},{"./utils":32}],5:[function(t,e,r){"use strict";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(t,e,r){"use strict";var i=null;i="undefined"!=typeof Promise?Promise:t("lie"),e.exports={Promise:i}},{lie:37}],7:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,n=t("pako"),s=t("./utils"),a=t("./stream/GenericWorker"),o=i?"uint8array":"array";function h(t,e){a.call(this,"FlateWorker/"+t),this._pako=null,this._pakoAction=t,this._pakoOptions=e,this.meta={}}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(t){this.meta=t.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,t.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new n[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},r.compressWorker=function(t){return new h("Deflate",t)},r.uncompressWorker=function(){return new h("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(t,e,r){"use strict";function A(t,e){var r,i="";for(r=0;r<e;r++)i+=String.fromCharCode(255&t),t>>>=8;return i}function i(t,e,r,i,n,s){var a,o,h=t.file,u=t.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),d=I.transformTo("string",O.utf8encode(h.name)),c=h.comment,p=I.transformTo("string",s(c)),m=I.transformTo("string",O.utf8encode(c)),_=d.length!==h.name.length,g=m.length!==c.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};e&&!r||(x.crc32=t.crc32,x.compressedSize=t.compressedSize,x.uncompressedSize=t.uncompressedSize);var S=0;e&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===n?(C=798,z|=function(t,e){var r=t;return t||(r=e?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(t){return 63&(t||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+d,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(i,4)+f+b+p}}var I=t("../utils"),n=t("../stream/GenericWorker"),O=t("../utf8"),B=t("../crc32"),R=t("../signature");function s(t,e,r,i){n.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=e,this.zipPlatform=r,this.encodeFileName=i,this.streamFiles=t,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,n),s.prototype.push=function(t){var e=t.meta.percent||0,r=this.entriesCount,i=this._sources.length;this.accumulate?this.contentBuffer.push(t):(this.bytesWritten+=t.data.length,n.prototype.push.call(this,{data:t.data,meta:{currentFile:this.currentFile,percent:r?(e+100*(r-i-1))/r:100}}))},s.prototype.openedSource=function(t){this.currentSourceOffset=this.bytesWritten,this.currentFile=t.file.name;var e=this.streamFiles&&!t.file.dir;if(e){var r=i(t,e,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(t){this.accumulate=!1;var e=this.streamFiles&&!t.file.dir,r=i(t,e,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),e)this.push({data:function(t){return R.DATA_DESCRIPTOR+A(t.crc32,4)+A(t.compressedSize,4)+A(t.uncompressedSize,4)}(t),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var t=this.bytesWritten,e=0;e<this.dirRecords.length;e++)this.push({data:this.dirRecords[e],meta:{percent:100}});var r=this.bytesWritten-t,i=function(t,e,r,i,n){var s=I.transformTo("string",n(i));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(t,2)+A(t,2)+A(e,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,t,this.zipComment,this.encodeFileName);this.push({data:i,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(t){this._sources.push(t);var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.closedSource(e.previous.streamInfo),e._sources.length?e.prepareNextSource():e.end()}),t.on("error",function(t){e.error(t)}),this},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(t){var e=this._sources;if(!n.prototype.error.call(this,t))return!1;for(var r=0;r<e.length;r++)try{e[r].error(t)}catch(t){}return!0},s.prototype.lock=function(){n.prototype.lock.call(this);for(var t=this._sources,e=0;e<t.length;e++)t[e].lock()},e.exports=s},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(t,e,r){"use strict";var u=t("../compressions"),i=t("./ZipFileWorker");r.generateWorker=function(t,a,e){var o=new i(a.streamFiles,e,a.platform,a.encodeFileName),h=0;try{t.forEach(function(t,e){h++;var r=function(t,e){var r=t||e,i=u[r];if(!i)throw new Error(r+" is not a valid compression method !");return i}(e.options.compression,a.compression),i=e.options.compressionOptions||a.compressionOptions||{},n=e.dir,s=e.date;e._compressWorker(r,i).withStreamInfo("file",{name:t,dir:n,date:s,comment:e.comment||"",unixPermissions:e.unixPermissions,dosPermissions:e.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(t){o.error(t)}return o}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(t,e,r){"use strict";function i(){if(!(this instanceof i))return new i;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var t=new i;for(var e in this)"function"!=typeof this[e]&&(t[e]=this[e]);return t}}(i.prototype=t("./object")).loadAsync=t("./load"),i.support=t("./support"),i.defaults=t("./defaults"),i.version="3.5.0",i.loadAsync=function(t,e){return(new i).loadAsync(t,e)},i.external=t("./external"),e.exports=i},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(t,e,r){"use strict";var i=t("./utils"),n=t("./external"),o=t("./utf8"),h=(i=t("./utils"),t("./zipEntries")),s=t("./stream/Crc32Probe"),u=t("./nodejsUtils");function l(i){return new n.Promise(function(t,e){var r=i.decompressed.getContentWorker().pipe(new s);r.on("error",function(t){e(t)}).on("end",function(){r.streamInfo.crc32!==i.decompressed.crc32?e(new Error("Corrupted zip : CRC32 mismatch")):t()}).resume()})}e.exports=function(t,s){var a=this;return s=i.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),u.isNode&&u.isStream(t)?n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):i.prepareContent("the loaded zip file",t,!0,s.optimizedBinaryString,s.base64).then(function(t){var e=new h(s);return e.load(t),e}).then(function(t){var e=[n.Promise.resolve(t)],r=t.files;if(s.checkCRC32)for(var i=0;i<r.length;i++)e.push(l(r[i]));return n.Promise.all(e)}).then(function(t){for(var e=t.shift(),r=e.files,i=0;i<r.length;i++){var n=r[i];a.file(n.fileNameStr,n.decompressed,{binary:!0,optimizedBinaryString:!0,date:n.date,dir:n.dir,comment:n.fileCommentStr.length?n.fileCommentStr:null,unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions,createFolders:s.createFolders})}return e.zipComment.length&&(a.comment=e.zipComment),a})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../stream/GenericWorker");function s(t,e){n.call(this,"Nodejs stream input adapter for "+t),this._upstreamEnded=!1,this._bindStream(e)}i.inherits(s,n),s.prototype._bindStream=function(t){var e=this;(this._stream=t).pause(),t.on("data",function(t){e.push({data:t,meta:{percent:0}})}).on("error",function(t){e.isPaused?this.generatedError=t:e.error(t)}).on("end",function(){e.isPaused?e._upstreamEnded=!0:e.end()})},s.prototype.pause=function(){return!!n.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},e.exports=s},{"../stream/GenericWorker":28,"../utils":32}],13:[function(t,e,r){"use strict";var n=t("readable-stream").Readable;function i(t,e,r){n.call(this,e),this._helper=t;var i=this;t.on("data",function(t,e){i.push(t)||i._helper.pause(),r&&r(e)}).on("error",function(t){i.emit("error",t)}).on("end",function(){i.push(null)})}t("../utils").inherits(i,n),i.prototype._read=function(){this._helper.resume()},e.exports=i},{"../utils":32,"readable-stream":16}],14:[function(t,e,r){"use strict";e.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(t,e){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(t,e);if("number"==typeof t)throw new Error('The "data" argument must not be a number');return new Buffer(t,e)},allocBuffer:function(t){if(Buffer.alloc)return Buffer.alloc(t);var e=new Buffer(t);return e.fill(0),e},isBuffer:function(t){return Buffer.isBuffer(t)},isStream:function(t){return t&&"function"==typeof t.on&&"function"==typeof t.pause&&"function"==typeof t.resume}}},{}],15:[function(t,e,r){"use strict";function s(t,e,r){var i,n=u.getTypeOf(e),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(t=g(t)),s.createFolders&&(i=_(t))&&b.call(this,i,!0);var a="string"===n&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(e instanceof d&&0===e.uncompressedSize||s.dir||!e||0===e.length)&&(s.base64=!1,s.binary=!0,e="",s.compression="STORE",n="string");var o=null;o=e instanceof d||e instanceof l?e:p.isNode&&p.isStream(e)?new m(t,e):u.prepareContent(t,e,s.binary,s.optimizedBinaryString,s.base64);var h=new c(t,o,s);this.files[t]=h}var n=t("./utf8"),u=t("./utils"),l=t("./stream/GenericWorker"),a=t("./stream/StreamHelper"),f=t("./defaults"),d=t("./compressedObject"),c=t("./zipObject"),o=t("./generate"),p=t("./nodejsUtils"),m=t("./nodejs/NodejsStreamInputAdapter"),_=function(t){"/"===t.slice(-1)&&(t=t.substring(0,t.length-1));var e=t.lastIndexOf("/");return 0<e?t.substring(0,e):""},g=function(t){return"/"!==t.slice(-1)&&(t+="/"),t},b=function(t,e){return e=void 0!==e?e:f.createFolders,t=g(t),this.files[t]||s.call(this,t,null,{dir:!0,createFolders:e}),this.files[t]};function h(t){return"[object RegExp]"===Object.prototype.toString.call(t)}var i={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(t){var e,r,i;for(e in this.files)this.files.hasOwnProperty(e)&&(i=this.files[e],(r=e.slice(this.root.length,e.length))&&e.slice(0,this.root.length)===this.root&&t(r,i))},filter:function(r){var i=[];return this.forEach(function(t,e){r(t,e)&&i.push(e)}),i},file:function(t,e,r){if(1!==arguments.length)return t=this.root+t,s.call(this,t,e,r),this;if(h(t)){var i=t;return this.filter(function(t,e){return!e.dir&&i.test(t)})}var n=this.files[this.root+t];return n&&!n.dir?n:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(t,e){return e.dir&&r.test(t)});var t=this.root+r,e=b.call(this,t),i=this.clone();return i.root=e.name,i},remove:function(r){r=this.root+r;var t=this.files[r];if(t||("/"!==r.slice(-1)&&(r+="/"),t=this.files[r]),t&&!t.dir)delete this.files[r];else for(var e=this.filter(function(t,e){return e.name.slice(0,r.length)===r}),i=0;i<e.length;i++)delete this.files[e[i].name];return this},generate:function(t){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(t){var e,r={};try{if((r=u.extend(t||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:n.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var i=r.comment||this.comment||"";e=o.generateWorker(this,r,i)}catch(t){(e=new l("error")).error(t)}return new a(e,r.type||"string",r.mimeType)},generateAsync:function(t,e){return this.generateInternalStream(t).accumulate(e)},generateNodeStream:function(t,e){return(t=t||{}).type||(t.type="nodebuffer"),this.generateInternalStream(t).toNodejsStream(e)}};e.exports=i},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(t,e,r){e.exports=t("stream")},{stream:void 0}],17:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t);for(var e=0;e<this.data.length;e++)t[e]=255&t[e]}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data[this.zero+t]},n.prototype.lastIndexOfSignature=function(t){for(var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===e&&this.data[s+1]===r&&this.data[s+2]===i&&this.data[s+3]===n)return s-this.zero;return-1},n.prototype.readAndCheckSignature=function(t){var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.readData(4);return e===s[0]&&r===s[1]&&i===s[2]&&n===s[3]},n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return[];var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],18:[function(t,e,r){"use strict";var i=t("../utils");function n(t){this.data=t,this.length=t.length,this.index=0,this.zero=0}n.prototype={checkOffset:function(t){this.checkIndex(this.index+t)},checkIndex:function(t){if(this.length<this.zero+t||t<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+t+"). Corrupted zip ?")},setIndex:function(t){this.checkIndex(t),this.index=t},skip:function(t){this.setIndex(this.index+t)},byteAt:function(t){},readInt:function(t){var e,r=0;for(this.checkOffset(t),e=this.index+t-1;e>=this.index;e--)r=(r<<8)+this.byteAt(e);return this.index+=t,r},readString:function(t){return i.transformTo("string",this.readData(t))},readData:function(t){},lastIndexOfSignature:function(t){},readAndCheckSignature:function(t){},readDate:function(){var t=this.readInt(4);return new Date(Date.UTC(1980+(t>>25&127),(t>>21&15)-1,t>>16&31,t>>11&31,t>>5&63,(31&t)<<1))}},e.exports=n},{"../utils":32}],19:[function(t,e,r){"use strict";var i=t("./Uint8ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data.charCodeAt(this.zero+t)},n.prototype.lastIndexOfSignature=function(t){return this.data.lastIndexOf(t)-this.zero},n.prototype.readAndCheckSignature=function(t){return t===this.readData(4)},n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],21:[function(t,e,r){"use strict";var i=t("./ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return new Uint8Array(0);var e=this.data.subarray(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./ArrayReader":17}],22:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../support"),s=t("./ArrayReader"),a=t("./StringReader"),o=t("./NodeBufferReader"),h=t("./Uint8ArrayReader");e.exports=function(t){var e=i.getTypeOf(t);return i.checkSupport(e),"string"!==e||n.uint8array?"nodebuffer"===e?new o(t):n.uint8array?new h(i.transformTo("uint8array",t)):new s(i.transformTo("array",t)):new a(t)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(t,e,r){"use strict";r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b"},{}],24:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../utils");function s(t){i.call(this,"ConvertWorker to "+t),this.destType=t}n.inherits(s,i),s.prototype.processChunk=function(t){this.push({data:n.transformTo(this.destType,t.data),meta:t.meta})},e.exports=s},{"../utils":32,"./GenericWorker":28}],25:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../crc32");function s(){i.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}t("../utils").inherits(s,i),s.prototype.processChunk=function(t){this.streamInfo.crc32=n(t.data,this.streamInfo.crc32||0),this.push(t)},e.exports=s},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataLengthProbe for "+t),this.propName=t,this.withStreamInfo(t,0)}i.inherits(s,n),s.prototype.processChunk=function(t){if(t){var e=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=e+t.data.length}n.prototype.processChunk.call(this,t)},e.exports=s},{"../utils":32,"./GenericWorker":28}],27:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataWorker");var e=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,t.then(function(t){e.dataIsReady=!0,e.data=t,e.max=t&&t.length||0,e.type=i.getTypeOf(t),e.isPaused||e._tickAndRepeat()},function(t){e.error(t)})}i.inherits(s,n),s.prototype.cleanUp=function(){n.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,i.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(i.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var t=null,e=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":t=this.data.substring(this.index,e);break;case"uint8array":t=this.data.subarray(this.index,e);break;case"array":case"nodebuffer":t=this.data.slice(this.index,e)}return this.index=e,this.push({data:t,meta:{percent:this.max?this.index/this.max*100:0}})},e.exports=s},{"../utils":32,"./GenericWorker":28}],28:[function(t,e,r){"use strict";function i(t){this.name=t||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}i.prototype={push:function(t){this.emit("data",t)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(t){this.emit("error",t)}return!0},error:function(t){return!this.isFinished&&(this.isPaused?this.generatedError=t:(this.isFinished=!0,this.emit("error",t),this.previous&&this.previous.error(t),this.cleanUp()),!0)},on:function(t,e){return this._listeners[t].push(e),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(t,e){if(this._listeners[t])for(var r=0;r<this._listeners[t].length;r++)this._listeners[t][r].call(this,e)},pipe:function(t){return t.registerPrevious(this)},registerPrevious:function(t){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=t.streamInfo,this.mergeStreamInfo(),this.previous=t;var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.end()}),t.on("error",function(t){e.error(t)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var t=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),t=!0),this.previous&&this.previous.resume(),!t},flush:function(){},processChunk:function(t){this.push(t)},withStreamInfo:function(t,e){return this.extraStreamInfo[t]=e,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var t in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(t)&&(this.streamInfo[t]=this.extraStreamInfo[t])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var t="Worker "+this.name;return this.previous?this.previous+" -> "+t:t}},e.exports=i},{}],29:[function(t,e,r){"use strict";var h=t("../utils"),n=t("./ConvertWorker"),s=t("./GenericWorker"),u=t("../base64"),i=t("../support"),a=t("../external"),o=null;if(i.nodestream)try{o=t("../nodejs/NodejsStreamOutputAdapter")}catch(t){}function l(t,o){return new a.Promise(function(e,r){var i=[],n=t._internalType,s=t._outputType,a=t._mimeType;t.on("data",function(t,e){i.push(t),o&&o(e)}).on("error",function(t){i=[],r(t)}).on("end",function(){try{var t=function(t,e,r){switch(t){case"blob":return h.newBlob(h.transformTo("arraybuffer",e),r);case"base64":return u.encode(e);default:return h.transformTo(t,e)}}(s,function(t,e){var r,i=0,n=null,s=0;for(r=0;r<e.length;r++)s+=e[r].length;switch(t){case"string":return e.join("");case"array":return Array.prototype.concat.apply([],e);case"uint8array":for(n=new Uint8Array(s),r=0;r<e.length;r++)n.set(e[r],i),i+=e[r].length;return n;case"nodebuffer":return Buffer.concat(e);default:throw new Error("concat : unsupported type '"+t+"'")}}(n,i),a);e(t)}catch(t){r(t)}i=[]}).resume()})}function f(t,e,r){var i=e;switch(e){case"blob":case"arraybuffer":i="uint8array";break;case"base64":i="string"}try{this._internalType=i,this._outputType=e,this._mimeType=r,h.checkSupport(i),this._worker=t.pipe(new n(i)),t.lock()}catch(t){this._worker=new s("error"),this._worker.error(t)}}f.prototype={accumulate:function(t){return l(this,t)},on:function(t,e){var r=this;return"data"===t?this._worker.on(t,function(t){e.call(r,t.data,t.meta)}):this._worker.on(t,function(){h.delay(e,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(t){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},t)}},e.exports=f},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(t,e,r){"use strict";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else{var i=new ArrayBuffer(0);try{r.blob=0===new Blob([i],{type:"application/zip"}).size}catch(t){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);n.append(i),r.blob=0===n.getBlob("application/zip").size}catch(t){r.blob=!1}}}try{r.nodestream=!!t("readable-stream").Readable}catch(t){r.nodestream=!1}},{"readable-stream":16}],31:[function(t,e,s){"use strict";for(var o=t("./utils"),h=t("./support"),r=t("./nodejsUtils"),i=t("./stream/GenericWorker"),u=new Array(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;u[254]=u[254]=1;function a(){i.call(this,"utf-8 decode"),this.leftOver=null}function l(){i.call(this,"utf-8 encode")}s.utf8encode=function(t){return h.nodebuffer?r.newBufferFrom(t,"utf-8"):function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=h.uint8array?new Uint8Array(o):new Array(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e}(t)},s.utf8decode=function(t){return h.nodebuffer?o.transformTo("nodebuffer",t).toString("utf-8"):function(t){var e,r,i,n,s=t.length,a=new Array(2*s);for(e=r=0;e<s;)if((i=t[e++])<128)a[r++]=i;else if(4<(n=u[i]))a[r++]=65533,e+=n-1;else{for(i&=2===n?31:3===n?15:7;1<n&&e<s;)i=i<<6|63&t[e++],n--;1<n?a[r++]=65533:i<65536?a[r++]=i:(i-=65536,a[r++]=55296|i>>10&1023,a[r++]=56320|1023&i)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(t=o.transformTo(h.uint8array?"uint8array":"array",t))},o.inherits(a,i),a.prototype.processChunk=function(t){var e=o.transformTo(h.uint8array?"uint8array":"array",t.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=e;(e=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),e.set(r,this.leftOver.length)}else e=this.leftOver.concat(e);this.leftOver=null}var i=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}(e),n=e;i!==e.length&&(h.uint8array?(n=e.subarray(0,i),this.leftOver=e.subarray(i,e.length)):(n=e.slice(0,i),this.leftOver=e.slice(i,e.length))),this.push({data:s.utf8decode(n),meta:t.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,i),l.prototype.processChunk=function(t){this.push({data:s.utf8encode(t.data),meta:t.meta})},s.Utf8EncodeWorker=l},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(t,e,a){"use strict";var o=t("./support"),h=t("./base64"),r=t("./nodejsUtils"),i=t("set-immediate-shim"),u=t("./external");function n(t){return t}function l(t,e){for(var r=0;r<t.length;++r)e[r]=255&t.charCodeAt(r);return e}a.newBlob=function(e,r){a.checkSupport("blob");try{return new Blob([e],{type:r})}catch(t){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return i.append(e),i.getBlob(r)}catch(t){throw new Error("Bug : can't construct the Blob.")}}};var s={stringifyByChunk:function(t,e,r){var i=[],n=0,s=t.length;if(s<=r)return String.fromCharCode.apply(null,t);for(;n<s;)"array"===e||"nodebuffer"===e?i.push(String.fromCharCode.apply(null,t.slice(n,Math.min(n+r,s)))):i.push(String.fromCharCode.apply(null,t.subarray(n,Math.min(n+r,s)))),n+=r;return i.join("")},stringifyByChar:function(t){for(var e="",r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(t){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(t){return!1}}()}};function f(t){var e=65536,r=a.getTypeOf(t),i=!0;if("uint8array"===r?i=s.applyCanBeUsed.uint8array:"nodebuffer"===r&&(i=s.applyCanBeUsed.nodebuffer),i)for(;1<e;)try{return s.stringifyByChunk(t,r,e)}catch(t){e=Math.floor(e/2)}return s.stringifyByChar(t)}function d(t,e){for(var r=0;r<t.length;r++)e[r]=t[r];return e}a.applyFromCharCode=f;var c={};c.string={string:n,array:function(t){return l(t,new Array(t.length))},arraybuffer:function(t){return c.string.uint8array(t).buffer},uint8array:function(t){return l(t,new Uint8Array(t.length))},nodebuffer:function(t){return l(t,r.allocBuffer(t.length))}},c.array={string:f,array:n,arraybuffer:function(t){return new Uint8Array(t).buffer},uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(t)}},c.arraybuffer={string:function(t){return f(new Uint8Array(t))},array:function(t){return d(new Uint8Array(t),new Array(t.byteLength))},arraybuffer:n,uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(new Uint8Array(t))}},c.uint8array={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return t.buffer},uint8array:n,nodebuffer:function(t){return r.newBufferFrom(t)}},c.nodebuffer={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return c.nodebuffer.uint8array(t).buffer},uint8array:function(t){return d(t,new Uint8Array(t.length))},nodebuffer:n},a.transformTo=function(t,e){if(e=e||"",!t)return e;a.checkSupport(t);var r=a.getTypeOf(e);return c[r][t](e)},a.getTypeOf=function(t){return"string"==typeof t?"string":"[object Array]"===Object.prototype.toString.call(t)?"array":o.nodebuffer&&r.isBuffer(t)?"nodebuffer":o.uint8array&&t instanceof Uint8Array?"uint8array":o.arraybuffer&&t instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(t){if(!o[t.toLowerCase()])throw new Error(t+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(t){var e,r,i="";for(r=0;r<(t||"").length;r++)i+="\\x"+((e=t.charCodeAt(r))<16?"0":"")+e.toString(16).toUpperCase();return i},a.delay=function(t,e,r){i(function(){t.apply(r||null,e||[])})},a.inherits=function(t,e){function r(){}r.prototype=e.prototype,t.prototype=new r},a.extend=function(){var t,e,r={};for(t=0;t<arguments.length;t++)for(e in arguments[t])arguments[t].hasOwnProperty(e)&&void 0===r[e]&&(r[e]=arguments[t][e]);return r},a.prepareContent=function(r,t,i,n,s){return u.Promise.resolve(t).then(function(i){return o.blob&&(i instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(i)))&&"undefined"!=typeof FileReader?new u.Promise(function(e,r){var t=new FileReader;t.onload=function(t){e(t.target.result)},t.onerror=function(t){r(t.target.error)},t.readAsArrayBuffer(i)}):i}).then(function(t){var e=a.getTypeOf(t);return e?("arraybuffer"===e?t=a.transformTo("uint8array",t):"string"===e&&(s?t=h.decode(t):i&&!0!==n&&(t=function(t){return l(t,o.uint8array?new Uint8Array(t.length):new Array(t.length))}(t))),t):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),n=t("./utils"),s=t("./signature"),a=t("./zipEntry"),o=(t("./utf8"),t("./support"));function h(t){this.files=[],this.loadOptions=t}h.prototype={checkSignature:function(t){if(!this.reader.readAndCheckSignature(t)){this.reader.index-=4;var e=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+n.pretty(e)+", expected "+n.pretty(t)+")")}},isSignature:function(t,e){var r=this.reader.index;this.reader.setIndex(t);var i=this.reader.readString(4)===e;return this.reader.setIndex(r),i},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var t=this.reader.readData(this.zipCommentLength),e=o.uint8array?"uint8array":"array",r=n.transformTo(e,t);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var t,e,r,i=this.zip64EndOfCentralSize-44;0<i;)t=this.reader.readInt(2),e=this.reader.readInt(4),r=this.reader.readData(e),this.zip64ExtensibleData[t]={id:t,length:e,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var t,e;for(t=0;t<this.files.length;t++)e=this.files[t],this.reader.setIndex(e.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),e.readLocalPart(this.reader),e.handleUTF8(),e.processAttributes()},readCentralDir:function(){var t;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(t=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(t);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var t=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(t<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(t);var e=t;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===n.MAX_VALUE_16BITS||this.diskWithCentralDirStart===n.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===n.MAX_VALUE_16BITS||this.centralDirRecords===n.MAX_VALUE_16BITS||this.centralDirSize===n.MAX_VALUE_32BITS||this.centralDirOffset===n.MAX_VALUE_32BITS){if(this.zip64=!0,(t=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(t),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var i=e-r;if(0<i)this.isSignature(e,s.CENTRAL_FILE_HEADER)||(this.reader.zero=i);else if(i<0)throw new Error("Corrupted zip: missing "+Math.abs(i)+" bytes.")},prepareReader:function(t){this.reader=i(t)},load:function(t){this.prepareReader(t),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},e.exports=h},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),s=t("./utils"),n=t("./compressedObject"),a=t("./crc32"),o=t("./utf8"),h=t("./compressions"),u=t("./support");function l(t,e){this.options=t,this.loadOptions=e}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(t){var e,r;if(t.skip(22),this.fileNameLength=t.readInt(2),r=t.readInt(2),this.fileName=t.readData(this.fileNameLength),t.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(e=function(t){for(var e in h)if(h.hasOwnProperty(e)&&h[e].magic===t)return h[e];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new n(this.compressedSize,this.uncompressedSize,this.crc32,e,t.readData(this.compressedSize))},readCentralPart:function(t){this.versionMadeBy=t.readInt(2),t.skip(2),this.bitFlag=t.readInt(2),this.compressionMethod=t.readString(2),this.date=t.readDate(),this.crc32=t.readInt(4),this.compressedSize=t.readInt(4),this.uncompressedSize=t.readInt(4);var e=t.readInt(2);if(this.extraFieldsLength=t.readInt(2),this.fileCommentLength=t.readInt(2),this.diskNumberStart=t.readInt(2),this.internalFileAttributes=t.readInt(2),this.externalFileAttributes=t.readInt(4),this.localHeaderOffset=t.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");t.skip(e),this.readExtraFields(t),this.parseZIP64ExtraField(t),this.fileComment=t.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var t=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==t&&(this.dosPermissions=63&this.externalFileAttributes),3==t&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(t){if(this.extraFields[1]){var e=i(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(t){var e,r,i,n=t.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});t.index+4<n;)e=t.readInt(2),r=t.readInt(2),i=t.readData(r),this.extraFields[e]={id:e,length:r,value:i};t.setIndex(n)},handleUTF8:function(){var t=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var e=this.findExtraFieldUnicodePath();if(null!==e)this.fileNameStr=e;else{var r=s.transformTo(t,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var i=this.findExtraFieldUnicodeComment();if(null!==i)this.fileCommentStr=i;else{var n=s.transformTo(t,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(n)}}},findExtraFieldUnicodePath:function(){var t=this.extraFields[28789];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileName)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null},findExtraFieldUnicodeComment:function(){var t=this.extraFields[25461];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileComment)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null}},e.exports=l},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(t,e,r){"use strict";function i(t,e,r){this.name=t,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=e,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=t("./stream/StreamHelper"),n=t("./stream/DataWorker"),a=t("./utf8"),o=t("./compressedObject"),h=t("./stream/GenericWorker");i.prototype={internalStream:function(t){var e=null,r="string";try{if(!t)throw new Error("No output type specified.");var i="string"===(r=t.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),e=this._decompressWorker();var n=!this._dataBinary;n&&!i&&(e=e.pipe(new a.Utf8EncodeWorker)),!n&&i&&(e=e.pipe(new a.Utf8DecodeWorker))}catch(t){(e=new h("error")).error(t)}return new s(e,r,"")},async:function(t,e){return this.internalStream(t).accumulate(e)},nodeStream:function(t,e){return this.internalStream(t||"nodebuffer").toNodejsStream(e)},_compressWorker:function(t,e){if(this._data instanceof o&&this._data.compression.magic===t.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,t,e)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new n(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)i.prototype[u[f]]=l;e.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(t,l,e){(function(e){"use strict";var r,i,t=e.MutationObserver||e.WebKitMutationObserver;if(t){var n=0,s=new t(u),a=e.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=n=++n%2}}else if(e.setImmediate||void 0===e.MessageChannel)r="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){u(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(u,0)};else{var o=new e.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var t,e;i=!0;for(var r=h.length;r;){for(e=h,h=[],t=-1;++t<r;)e[t]();r=h.length}i=!1}l.exports=function(t){1!==h.push(t)||i||r()}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],37:[function(t,e,r){"use strict";var n=t("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],i=["PENDING"];function o(t){if("function"!=typeof t)throw new TypeError("resolver must be a function");this.state=i,this.queue=[],this.outcome=void 0,t!==u&&c(this,t)}function h(t,e,r){this.promise=t,"function"==typeof e&&(this.onFulfilled=e,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(e,r,i){n(function(){var t;try{t=r(i)}catch(t){return l.reject(e,t)}t===e?l.reject(e,new TypeError("Cannot resolve promise with itself")):l.resolve(e,t)})}function d(t){var e=t&&t.then;if(t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof e)return function(){e.apply(t,arguments)}}function c(e,t){var r=!1;function i(t){r||(r=!0,l.reject(e,t))}function n(t){r||(r=!0,l.resolve(e,t))}var s=p(function(){t(n,i)});"error"===s.status&&i(s.value)}function p(t,e){var r={};try{r.value=t(e),r.status="success"}catch(t){r.status="error",r.value=t}return r}(e.exports=o).prototype.finally=function(e){if("function"!=typeof e)return this;var r=this.constructor;return this.then(function(t){return r.resolve(e()).then(function(){return t})},function(t){return r.resolve(e()).then(function(){throw t})})},o.prototype.catch=function(t){return this.then(null,t)},o.prototype.then=function(t,e){if("function"!=typeof t&&this.state===a||"function"!=typeof e&&this.state===s)return this;var r=new this.constructor(u);this.state!==i?f(r,this.state===a?t:e,this.outcome):this.queue.push(new h(r,t,e));return r},h.prototype.callFulfilled=function(t){l.resolve(this.promise,t)},h.prototype.otherCallFulfilled=function(t){f(this.promise,this.onFulfilled,t)},h.prototype.callRejected=function(t){l.reject(this.promise,t)},h.prototype.otherCallRejected=function(t){f(this.promise,this.onRejected,t)},l.resolve=function(t,e){var r=p(d,e);if("error"===r.status)return l.reject(t,r.value);var i=r.value;if(i)c(t,i);else{t.state=a,t.outcome=e;for(var n=-1,s=t.queue.length;++n<s;)t.queue[n].callFulfilled(e)}return t},l.reject=function(t,e){t.state=s,t.outcome=e;for(var r=-1,i=t.queue.length;++r<i;)t.queue[r].callRejected(e);return t},o.resolve=function(t){if(t instanceof this)return t;return l.resolve(new this(u),t)},o.reject=function(t){var e=new this(u);return l.reject(e,t)},o.all=function(t){var r=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var i=t.length,n=!1;if(!i)return this.resolve([]);var s=new Array(i),a=0,e=-1,o=new this(u);for(;++e<i;)h(t[e],e);return o;function h(t,e){r.resolve(t).then(function(t){s[e]=t,++a!==i||n||(n=!0,l.resolve(o,s))},function(t){n||(n=!0,l.reject(o,t))})}},o.race=function(t){var e=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var r=t.length,i=!1;if(!r)return this.resolve([]);var n=-1,s=new this(u);for(;++n<r;)a=t[n],e.resolve(a).then(function(t){i||(i=!0,l.resolve(s,t))},function(t){i||(i=!0,l.reject(s,t))});var a;return s}},{immediate:36}],38:[function(t,e,r){"use strict";var i={};(0,t("./lib/utils/common").assign)(i,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),e.exports=i},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(t,e,r){"use strict";var a=t("./zlib/deflate"),o=t("./utils/common"),h=t("./utils/strings"),n=t("./zlib/messages"),s=t("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,d=0,c=8;function p(t){if(!(this instanceof p))return new p(t);this.options=o.assign({level:f,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:""},t||{});var e=this.options;e.raw&&0<e.windowBits?e.windowBits=-e.windowBits:e.gzip&&0<e.windowBits&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==l)throw new Error(n[r]);if(e.header&&a.deflateSetHeader(this.strm,e.header),e.dictionary){var i;if(i="string"==typeof e.dictionary?h.string2buf(e.dictionary):"[object ArrayBuffer]"===u.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(r=a.deflateSetDictionary(this.strm,i))!==l)throw new Error(n[r]);this._dict_set=!0}}function i(t,e){var r=new p(e);if(r.push(t,!0),r.err)throw r.msg||n[r.err];return r.result}p.prototype.push=function(t,e){var r,i,n=this.strm,s=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:!0===e?4:0,"string"==typeof t?n.input=h.string2buf(t):"[object ArrayBuffer]"===u.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new o.Buf8(s),n.next_out=0,n.avail_out=s),1!==(r=a.deflate(n,i))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==n.avail_out&&(0!==n.avail_in||4!==i&&2!==i)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(n.output,n.next_out))):this.onData(o.shrinkBuf(n.output,n.next_out)))}while((0<n.avail_in||0===n.avail_out)&&1!==r);return 4===i?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==i||(this.onEnd(l),!(n.avail_out=0))},p.prototype.onData=function(t){this.chunks.push(t)},p.prototype.onEnd=function(t){t===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Deflate=p,r.deflate=i,r.deflateRaw=function(t,e){return(e=e||{}).raw=!0,i(t,e)},r.gzip=function(t,e){return(e=e||{}).gzip=!0,i(t,e)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(t,e,r){"use strict";var d=t("./zlib/inflate"),c=t("./utils/common"),p=t("./utils/strings"),m=t("./zlib/constants"),i=t("./zlib/messages"),n=t("./zlib/zstream"),s=t("./zlib/gzheader"),_=Object.prototype.toString;function a(t){if(!(this instanceof a))return new a(t);this.options=c.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&0<=e.windowBits&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(0<=e.windowBits&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),15<e.windowBits&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new n,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,e.windowBits);if(r!==m.Z_OK)throw new Error(i[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(t,e){var r=new a(e);if(r.push(t,!0),r.err)throw r.msg||i[r.err];return r.result}a.prototype.push=function(t,e){var r,i,n,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;i=e===~~e?e:!0===e?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof t?h.input=p.binstring2buf(t):"[object ArrayBuffer]"===_.call(t)?h.input=new Uint8Array(t):h.input=t,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new c.Buf8(u),h.next_out=0,h.avail_out=u),(r=d.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||i!==m.Z_FINISH&&i!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(n=p.utf8border(h.output,h.next_out),s=h.next_out-n,a=p.buf2string(h.output,n),h.next_out=s,h.avail_out=u-s,s&&c.arraySet(h.output,h.output,n,s,0),this.onData(a)):this.onData(c.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(i=m.Z_FINISH),i===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):i!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(t){this.chunks.push(t)},a.prototype.onEnd=function(t){t===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(t,e){return(e=e||{}).raw=!0,o(t,e)},r.ungzip=o},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var i in r)r.hasOwnProperty(i)&&(t[i]=r[i])}}return t},r.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){var e,r,i,n,s,a;for(e=i=0,r=t.length;e<r;e++)i+=t[e].length;for(a=new Uint8Array(i),e=n=0,r=t.length;e<r;e++)s=t[e],a.set(s,n),n+=s.length;return a}},s={arraySet:function(t,e,r,i,n){for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){return[].concat.apply([],t)}};r.setTyped=function(t){t?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,n)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(i)},{}],42:[function(t,e,r){"use strict";var h=t("./common"),n=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){n=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var u=new h.Buf8(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function l(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&n))return String.fromCharCode.apply(null,h.shrinkBuf(t,e));for(var r="",i=0;i<e;i++)r+=String.fromCharCode(t[i]);return r}u[254]=u[254]=1,r.string2buf=function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=new h.Buf8(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e},r.buf2binstring=function(t){return l(t,t.length)},r.binstring2buf=function(t){for(var e=new h.Buf8(t.length),r=0,i=e.length;r<i;r++)e[r]=t.charCodeAt(r);return e},r.buf2string=function(t,e){var r,i,n,s,a=e||t.length,o=new Array(2*a);for(r=i=0;r<a;)if((n=t[r++])<128)o[i++]=n;else if(4<(s=u[n]))o[i++]=65533,r+=s-1;else{for(n&=2===s?31:3===s?15:7;1<s&&r<a;)n=n<<6|63&t[r++],s--;1<s?o[i++]=65533:n<65536?o[i++]=n:(n-=65536,o[i++]=55296|n>>10&1023,o[i++]=56320|1023&n)}return l(o,i)},r.utf8border=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}},{"./common":41}],43:[function(t,e,r){"use strict";e.exports=function(t,e,r,i){for(var n=65535&t|0,s=t>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(n=n+e[i++]|0)|0,--a;);n%=65521,s%=65521}return n|s<<16|0}},{}],44:[function(t,e,r){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,e,r){"use strict";var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}},{}],46:[function(t,e,r){"use strict";var h,d=t("../utils/common"),u=t("./trees"),c=t("./adler32"),p=t("./crc32"),i=t("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,n=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(t,e){return t.msg=i[e],e}function T(t){return(t<<1)-(4<t?9:0)}function D(t){for(var e=t.length;0<=--e;)t[e]=0}function F(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(d.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function N(t,e){u._tr_flush_block(t,0<=t.block_start?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,F(t.strm)}function U(t,e){t.pending_buf[t.pending++]=e}function P(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function L(t,e){var r,i,n=t.max_chain_length,s=t.strstart,a=t.prev_length,o=t.nice_match,h=t.strstart>t.w_size-z?t.strstart-(t.w_size-z):0,u=t.window,l=t.w_mask,f=t.prev,d=t.strstart+S,c=u[s+a-1],p=u[s+a];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(u[(r=e)+a]===p&&u[r+a-1]===c&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<d);if(i=S-(d-s),s=d-S,a<i){if(t.match_start=e,o<=(a=i))break;c=u[s+a-1],p=u[s+a]}}}while((e=f[e&l])>h&&0!=--n);return a<=t.lookahead?a:t.lookahead}function j(t){var e,r,i,n,s,a,o,h,u,l,f=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=f+(f-z)){for(d.arraySet(t.window,t.window,f,f,0),t.match_start-=f,t.strstart-=f,t.block_start-=f,e=r=t.hash_size;i=t.head[--e],t.head[e]=f<=i?i-f:0,--r;);for(e=r=f;i=t.prev[--e],t.prev[e]=f<=i?i-f:0,--r;);n+=f}if(0===t.strm.avail_in)break;if(a=t.strm,o=t.window,h=t.strstart+t.lookahead,u=n,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,d.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=c(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),t.lookahead+=r,t.lookahead+t.insert>=x)for(s=t.strstart-t.insert,t.ins_h=t.window[s],t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+x-1])&t.hash_mask,t.prev[s&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=s,s++,t.insert--,!(t.lookahead+t.insert<x)););}while(t.lookahead<z&&0!==t.strm.avail_in)}function Z(t,e){for(var r,i;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r)),t.match_length>=x)if(i=u._tr_tally(t,t.strstart-t.match_start,t.match_length-x),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=x){for(t.match_length--;t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart,0!=--t.match_length;);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function W(t,e){for(var r,i,n;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=x-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r),t.match_length<=5&&(1===t.strategy||t.match_length===x&&4096<t.strstart-t.match_start)&&(t.match_length=x-1)),t.prev_length>=x&&t.match_length<=t.prev_length){for(n=t.strstart+t.lookahead-x,i=u._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-x),t.lookahead-=t.prev_length-1,t.prev_length-=2;++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!=--t.prev_length;);if(t.match_available=0,t.match_length=x-1,t.strstart++,i&&(N(t,!1),0===t.strm.avail_out))return A}else if(t.match_available){if((i=u._tr_tally(t,0,t.window[t.strstart-1]))&&N(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return A}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=u._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function M(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*w),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(k+1),this.heap=new d.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=n,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?C:E,t.adler=2===e.wrap?0:1,e.last_flush=l,u._tr_init(e),m):R(t,_)}function K(t){var e=G(t);return e===m&&function(t){t.window_size=2*t.w_size,D(t.head),t.max_lazy_match=h[t.level].max_lazy,t.good_match=h[t.level].good_length,t.nice_match=h[t.level].nice_length,t.max_chain_length=h[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=x-1,t.match_available=0,t.ins_h=0}(t.state),e}function Y(t,e,r,i,n,s){if(!t)return _;var a=1;if(e===g&&(e=6),i<0?(a=0,i=-i):15<i&&(a=2,i-=16),n<1||y<n||r!==v||i<8||15<i||e<0||9<e||s<0||b<s)return R(t,_);8===i&&(i=9);var o=new H;return(t.state=o).strm=t,o.wrap=a,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=e,o.strategy=s,o.method=r,K(t)}h=[new M(0,0,0,0,function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(j(t),0===t.lookahead&&e===l)return A;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,N(t,!1),0===t.strm.avail_out))return A;if(t.strstart-t.block_start>=t.w_size-z&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):(t.strstart>t.block_start&&(N(t,!1),t.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(t,e){return Y(t,e,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?_:(t.state.gzhead=e,m):_},r.deflate=function(t,e){var r,i,n,s;if(!t||!t.state||5<e||e<0)return t?R(t,_):_;if(i=t.state,!t.output||!t.input&&0!==t.avail_in||666===i.status&&e!==f)return R(t,0===t.avail_out?-5:_);if(i.strm=t,r=i.last_flush,i.last_flush=e,i.status===C)if(2===i.wrap)t.adler=0,U(i,31),U(i,139),U(i,8),i.gzhead?(U(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),U(i,255&i.gzhead.time),U(i,i.gzhead.time>>8&255),U(i,i.gzhead.time>>16&255),U(i,i.gzhead.time>>24&255),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(U(i,255&i.gzhead.extra.length),U(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(t.adler=p(t.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=69):(U(i,0),U(i,0),U(i,0),U(i,0),U(i,0),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,3),i.status=E);else{var a=v+(i.w_bits-8<<4)<<8;a|=(2<=i.strategy||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(a|=32),a+=31-a%31,i.status=E,P(i,a),0!==i.strstart&&(P(i,t.adler>>>16),P(i,65535&t.adler)),t.adler=1}if(69===i.status)if(i.gzhead.extra){for(n=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending!==i.pending_buf_size));)U(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=73)}else i.status=73;if(73===i.status)if(i.gzhead.name){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.gzindex=0,i.status=91)}else i.status=91;if(91===i.status)if(i.gzhead.comment){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.status=103)}else i.status=103;if(103===i.status&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&F(t),i.pending+2<=i.pending_buf_size&&(U(i,255&t.adler),U(i,t.adler>>8&255),t.adler=0,i.status=E)):i.status=E),0!==i.pending){if(F(t),0===t.avail_out)return i.last_flush=-1,m}else if(0===t.avail_in&&T(e)<=T(r)&&e!==f)return R(t,-5);if(666===i.status&&0!==t.avail_in)return R(t,-5);if(0!==t.avail_in||0!==i.lookahead||e!==l&&666!==i.status){var o=2===i.strategy?function(t,e){for(var r;;){if(0===t.lookahead&&(j(t),0===t.lookahead)){if(e===l)return A;break}if(t.match_length=0,r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):3===i.strategy?function(t,e){for(var r,i,n,s,a=t.window;;){if(t.lookahead<=S){if(j(t),t.lookahead<=S&&e===l)return A;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=x&&0<t.strstart&&(i=a[n=t.strstart-1])===a[++n]&&i===a[++n]&&i===a[++n]){s=t.strstart+S;do{}while(i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&n<s);t.match_length=S-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=x?(r=u._tr_tally(t,1,t.match_length-x),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):h[i.level].func(i,e);if(o!==O&&o!==B||(i.status=666),o===A||o===O)return 0===t.avail_out&&(i.last_flush=-1),m;if(o===I&&(1===e?u._tr_align(i):5!==e&&(u._tr_stored_block(i,0,0,!1),3===e&&(D(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),F(t),0===t.avail_out))return i.last_flush=-1,m}return e!==f?m:i.wrap<=0?1:(2===i.wrap?(U(i,255&t.adler),U(i,t.adler>>8&255),U(i,t.adler>>16&255),U(i,t.adler>>24&255),U(i,255&t.total_in),U(i,t.total_in>>8&255),U(i,t.total_in>>16&255),U(i,t.total_in>>24&255)):(P(i,t.adler>>>16),P(i,65535&t.adler)),F(t),0<i.wrap&&(i.wrap=-i.wrap),0!==i.pending?m:1)},r.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==C&&69!==e&&73!==e&&91!==e&&103!==e&&e!==E&&666!==e?R(t,_):(t.state=null,e===E?R(t,-3):m):_},r.deflateSetDictionary=function(t,e){var r,i,n,s,a,o,h,u,l=e.length;if(!t||!t.state)return _;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(t.adler=c(t.adler,e,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new d.Buf8(r.w_size),d.arraySet(u,e,l-r.w_size,r.w_size,0),e=u,l=r.w_size),a=t.avail_in,o=t.next_in,h=t.input,t.avail_in=l,t.next_in=0,t.input=e,j(r);r.lookahead>=x;){for(i=r.strstart,n=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+x-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++,--n;);r.strstart=i,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,t.next_in=o,t.input=h,t.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(t,e,r){"use strict";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(t,e,r){"use strict";e.exports=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C;r=t.state,i=t.next_in,z=t.input,n=i+(t.avail_in-5),s=t.next_out,C=t.output,a=s-(e-t.avail_out),o=s+(t.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;t:do{p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=m[c&g];e:for(;;){if(c>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(c&(1<<y)-1)];continue e}if(32&y){r.mode=12;break t}t.msg="invalid literal/length code",r.mode=30;break t}w=65535&v,(y&=15)&&(p<y&&(c+=z[i++]<<p,p+=8),w+=c&(1<<y)-1,c>>>=y,p-=y),p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=_[c&b];r:for(;;){if(c>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(c&(1<<y)-1)];continue r}t.msg="invalid distance code",r.mode=30;break t}if(k=65535&v,p<(y&=15)&&(c+=z[i++]<<p,(p+=8)<y&&(c+=z[i++]<<p,p+=8)),h<(k+=c&(1<<y)-1)){t.msg="invalid distance too far back",r.mode=30;break t}if(c>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){t.msg="invalid distance too far back",r.mode=30;break t}if(S=d,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=d[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=d[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(i<n&&s<o);i-=w=p>>3,c&=(1<<(p-=w<<3))-1,t.next_in=i,t.next_out=s,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(t,e,r){"use strict";var I=t("../utils/common"),O=t("./adler32"),B=t("./crc32"),R=t("./inffast"),T=t("./inftrees"),D=1,F=2,N=0,U=-2,P=1,i=852,n=592;function L(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=P,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new I.Buf32(i),e.distcode=e.distdyn=new I.Buf32(n),e.sane=1,e.back=-1,N):U}function o(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,a(t)):U}function h(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||15<e)?U:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,o(t))):U}function u(t,e){var r,i;return t?(i=new s,(t.state=i).window=null,(r=h(t,e))!==N&&(t.state=null),r):U}var l,f,d=!0;function j(t){if(d){var e;for(l=new I.Buf32(512),f=new I.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(T(D,t.lens,0,288,l,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;T(F,t.lens,0,32,f,0,t.work,{bits:5}),d=!1}t.lencode=l,t.lenbits=9,t.distcode=f,t.distbits=5}function Z(t,e,r,i){var n,s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),i>=s.wsize?(I.arraySet(s.window,e,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(i<(n=s.wsize-s.wnext)&&(n=i),I.arraySet(s.window,e,r-i,n,s.wnext),(i-=n)?(I.arraySet(s.window,e,r-i,i,0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(t){return u(t,15)},r.inflateInit2=u,r.inflate=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return U;12===(r=t.state).mode&&(r.mode=13),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,f=o,d=h,x=N;t:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){t.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){t.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){t.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,t.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){t.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){t.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,i,s,c,k)),512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,r.length-=c),r.length))break t;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(65535&r.check)){t.msg="header crc mismatch",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}t.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,2;t.adler=r.check=1,r.mode=12;case 12:if(5===e||6===e)break t;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==e)break;u>>>=2,l-=2;break t;case 2:r.mode=17;break;case 3:t.msg="invalid block type",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){t.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===e)break t;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),h<c&&(c=h),0===c)break t;I.arraySet(n,i,s,c,a),o-=c,s+=c,h-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){t.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){t.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+c>r.nlen+r.ndist){t.msg="invalid bit length repeat",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){t.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){t.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===e)break t;case 20:r.mode=21;case 21:if(6<=o&&258<=h){t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,R(t,d),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){t.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){t.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break t;if(c=d-h,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){t.msg="invalid distance too far back",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=n,p=a-r.offset,c=r.length;for(h<c&&(c=h),h-=c,r.length-=c;n[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break t;n[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break t;o--,u|=i[s++]<<l,l+=8}if(d-=h,t.total_out+=d,r.total+=d,d&&(t.adler=r.check=r.flags?B(r.check,n,d,a-d):O(r.check,n,d,a-d)),d=h,(r.flags?u:L(u))!==r.check){t.msg="incorrect data check",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(4294967295&r.total)){t.msg="incorrect length check",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break t;case 30:x=-3;break t;case 31:return-4;case 32:default:return U}return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,(r.wsize||d!==t.avail_out&&r.mode<30&&(r.mode<27||4!==e))&&Z(t,t.output,t.next_out,d-t.avail_out)?(r.mode=31,-4):(f-=t.avail_in,d-=t.avail_out,t.total_in+=f,t.total_out+=d,r.total+=d,r.wrap&&d&&(t.adler=r.check=r.flags?B(r.check,n,d,t.next_out-d):O(r.check,n,d,t.next_out-d)),t.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===d||4===e)&&x===N&&(x=-5),x)},r.inflateEnd=function(t){if(!t||!t.state)return U;var e=t.state;return e.window&&(e.window=null),t.state=null,N},r.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?U:((r.head=e).done=!1,N):U},r.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,e,i,0)!==r.check?-3:Z(t,e,i,i)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(t,e,r){"use strict";var D=t("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,r,i,n,s,a,o){var h,u,l,f,d,c,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<i;v++)O[e[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===t||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<i;v++)0!==e[r+v]&&(a[B[e[r+v]]++]=v);if(c=0===t?(A=R=a,19):1===t?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,d=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===t&&852<C||2===t&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<c?(m=0,a[v]):a[v]>c?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;n[d+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=e[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),d+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===t&&852<C||2===t&&592<C)return 1;n[l=E&f]=k<<24|x<<16|d-s|0}}return 0!==E&&(n[d+E]=b-S<<24|64<<16|0),o.bits=k,0}},{"../utils/common":41}],51:[function(t,e,r){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(t,e,r){"use strict";var n=t("../utils/common"),o=0,h=1;function i(t){for(var e=t.length;0<=--e;)t[e]=0}var s=0,a=29,u=256,l=u+1+a,f=30,d=19,_=2*l+1,g=15,c=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));i(z);var C=new Array(2*f);i(C);var E=new Array(512);i(E);var A=new Array(256);i(A);var I=new Array(a);i(I);var O,B,R,T=new Array(f);function D(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function F(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function N(t){return t<256?E[t]:E[256+(t>>>7)]}function U(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function P(t,e,r){t.bi_valid>c-r?(t.bi_buf|=e<<t.bi_valid&65535,U(t,t.bi_buf),t.bi_buf=e>>c-t.bi_valid,t.bi_valid+=r-c):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function L(t,e,r){P(t,r[2*e],r[2*e+1])}function j(t,e){for(var r=0;r|=1&t,t>>>=1,r<<=1,0<--e;);return r>>>1}function Z(t,e,r){var i,n,s=new Array(g+1),a=0;for(i=1;i<=g;i++)s[i]=a=a+r[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=j(s[o]++,o))}}function W(t){var e;for(e=0;e<l;e++)t.dyn_ltree[2*e]=0;for(e=0;e<f;e++)t.dyn_dtree[2*e]=0;for(e=0;e<d;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*m]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function M(t){8<t.bi_valid?U(t,t.bi_buf):0<t.bi_valid&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function H(t,e,r,i){var n=2*e,s=2*r;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[r]}function G(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&H(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!H(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function K(t,e,r){var i,n,s,a,o=0;if(0!==t.last_lit)for(;i=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],n=t.pending_buf[t.l_buf+o],o++,0===i?L(t,n,e):(L(t,(s=A[n])+u+1,e),0!==(a=w[s])&&P(t,n-=I[s],a),L(t,s=N(--i),r),0!==(a=k[s])&&P(t,i-=T[s],a)),o<t.last_lit;);L(t,m,e)}function Y(t,e){var r,i,n,s=e.dyn_tree,a=e.stat_desc.static_tree,o=e.stat_desc.has_stree,h=e.stat_desc.elems,u=-1;for(t.heap_len=0,t.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(t.heap[++t.heap_len]=u=r,t.depth[r]=0):s[2*r+1]=0;for(;t.heap_len<2;)s[2*(n=t.heap[++t.heap_len]=u<2?++u:0)]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=a[2*n+1]);for(e.max_code=u,r=t.heap_len>>1;1<=r;r--)G(t,s,r);for(n=h;r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],G(t,s,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,s[2*n]=s[2*r]+s[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,s[2*r+1]=s[2*i+1]=n,t.heap[1]=n++,G(t,s,1),2<=t.heap_len;);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,s,a,o,h=e.dyn_tree,u=e.max_code,l=e.stat_desc.static_tree,f=e.stat_desc.has_stree,d=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,m=0;for(s=0;s<=g;s++)t.bl_count[s]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<_;r++)p<(s=h[2*h[2*(i=t.heap[r])+1]+1]+1)&&(s=p,m++),h[2*i+1]=s,u<i||(t.bl_count[s]++,a=0,c<=i&&(a=d[i-c]),o=h[2*i],t.opt_len+=o*(s+a),f&&(t.static_len+=o*(l[2*i+1]+a)));if(0!==m){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(i=t.bl_count[s];0!==i;)u<(n=t.heap[--r])||(h[2*n+1]!==s&&(t.opt_len+=(s-h[2*n+1])*h[2*n],h[2*n+1]=s),i--)}}(t,e),Z(s,u,t.bl_count)}function X(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=a,a=e[2*(i+1)+1],++o<h&&n===a||(o<u?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[2*b]++):o<=10?t.bl_tree[2*v]++:t.bl_tree[2*y]++,s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4))}function V(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),i=0;i<=r;i++)if(n=a,a=e[2*(i+1)+1],!(++o<h&&n===a)){if(o<u)for(;L(t,n,t.bl_tree),0!=--o;);else 0!==n?(n!==s&&(L(t,n,t.bl_tree),o--),L(t,b,t.bl_tree),P(t,o-3,2)):o<=10?(L(t,v,t.bl_tree),P(t,o-3,3)):(L(t,y,t.bl_tree),P(t,o-11,7));s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4)}}i(T);var q=!1;function J(t,e,r,i){P(t,(s<<1)+(i?1:0),3),function(t,e,r,i){M(t),i&&(U(t,r),U(t,~r)),n.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r,!0)}r._tr_init=function(t){q||(function(){var t,e,r,i,n,s=new Array(g+1);for(i=r=0;i<a-1;i++)for(I[i]=r,t=0;t<1<<w[i];t++)A[r++]=i;for(A[r-1]=i,i=n=0;i<16;i++)for(T[i]=n,t=0;t<1<<k[i];t++)E[n++]=i;for(n>>=7;i<f;i++)for(T[i]=n<<7,t=0;t<1<<k[i]-7;t++)E[256+n++]=i;for(e=0;e<=g;e++)s[e]=0;for(t=0;t<=143;)z[2*t+1]=8,t++,s[8]++;for(;t<=255;)z[2*t+1]=9,t++,s[9]++;for(;t<=279;)z[2*t+1]=7,t++,s[7]++;for(;t<=287;)z[2*t+1]=8,t++,s[8]++;for(Z(z,l+1,s),t=0;t<f;t++)C[2*t+1]=5,C[2*t]=j(t,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,d,p)}(),q=!0),t.l_desc=new F(t.dyn_ltree,O),t.d_desc=new F(t.dyn_dtree,B),t.bl_desc=new F(t.bl_tree,R),t.bi_buf=0,t.bi_valid=0,W(t)},r._tr_stored_block=J,r._tr_flush_block=function(t,e,r,i){var n,s,a=0;0<t.level?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return o;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return h;for(e=32;e<u;e++)if(0!==t.dyn_ltree[2*e])return h;return o}(t)),Y(t,t.l_desc),Y(t,t.d_desc),a=function(t){var e;for(X(t,t.dyn_ltree,t.l_desc.max_code),X(t,t.dyn_dtree,t.d_desc.max_code),Y(t,t.bl_desc),e=d-1;3<=e&&0===t.bl_tree[2*S[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),n=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=n&&(n=s)):n=s=r+5,r+4<=n&&-1!==e?J(t,e,r,i):4===t.strategy||s===n?(P(t,2+(i?1:0),3),K(t,z,C)):(P(t,4+(i?1:0),3),function(t,e,r,i){var n;for(P(t,e-257,5),P(t,r-1,5),P(t,i-4,4),n=0;n<i;n++)P(t,t.bl_tree[2*S[n]+1],3);V(t,t.dyn_ltree,e-1),V(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,a+1),K(t,t.dyn_ltree,t.dyn_dtree)),W(t),i&&M(t)},r._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(A[r]+u+1)]++,t.dyn_dtree[2*N(e)]++),t.last_lit===t.lit_bufsize-1},r._tr_align=function(t){P(t,2,3),L(t,m,z),function(t){16===t.bi_valid?(U(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},{"../utils/common":41}],53:[function(t,e,r){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,e,r){"use strict";e.exports="function"==typeof setImmediate?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)}},{}]},{},[10])(10)});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/lookup-closest-locale/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/lookup-closest-locale/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// @flow
// "lookup" algorithm http://tools.ietf.org/html/rfc4647#section-3.4
// assumes normalized language tags, and matches in a case sensitive manner
module.exports = function lookupClosestLocale (locale/*: string | string[] | void */, available/*: { [string]: any } */)/*: ?string */ {
  if (typeof locale === 'string' && available[locale]) return locale
  var locales = [].concat(locale || [])
  for (var l = 0, ll = locales.length; l < ll; ++l) {
    var current = locales[l].split('-')
    while (current.length) {
      var candidate = current.join('-')
      if (available[candidate]) return candidate
      current.pop()
    }
  }
}


/***/ }),

/***/ "./node_modules/nets/index.js":
/*!************************************!*\
  !*** ./node_modules/nets/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer) {var req = __webpack_require__(/*! request */ "./node_modules/xhr/index.js")

module.exports = Nets

function Nets (opts, cb) {
  if (typeof opts === 'string') opts = { uri: opts }

  // in node, if encoding === null then response will be a Buffer. we want this to be the default
  if (!opts.hasOwnProperty('encoding')) opts.encoding = null

  // in browser, we should by default convert the arraybuffer into a Buffer
  if (process.browser && !opts.hasOwnProperty('json') && opts.encoding === null) {
    opts.responseType = 'arraybuffer'
    var originalCb = cb
    cb = bufferify
  }

  function bufferify (err, resp, body) {
    if (body) body = new Buffer(new Uint8Array(body))
    originalCb(err, resp, body)
  }

  return req(opts, cb)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js"), __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/parse-headers/parse-headers.js":
/*!*****************************************************!*\
  !*** ./node_modules/parse-headers/parse-headers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var trim = function(string) {
  return string.replace(/^\s+|\s+$/g, '');
}
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  var headersArr = trim(headers).split('\n')

  for (var i = 0; i < headersArr.length; i++) {
    var row = headersArr[i]
    var index = row.indexOf(':')
    , key = trim(row.slice(0, index)).toLowerCase()
    , value = trim(row.slice(index + 1))

    if (typeof(result[key]) === 'undefined') {
      result[key] = value
    } else if (isArray(result[key])) {
      result[key].push(value)
    } else {
      result[key] = [ result[key], value ]
    }
  }

  return result
}


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/scratch-translate-extension-languages/languages.json":
/*!***************************************************************************!*\
  !*** ./node_modules/scratch-translate-extension-languages/languages.json ***!
  \***************************************************************************/
/*! exports provided: menuMap, nameMap, scratchToGoogleMap, previouslySupported, spokenLanguages, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"menuMap\":{\"cs\":[{\"code\":\"am\",\"name\":\"amharština\"},{\"code\":\"en\",\"name\":\"angličtina\"},{\"code\":\"ar\",\"name\":\"arabština\"},{\"code\":\"az\",\"name\":\"ázerbájdžánština\"},{\"code\":\"eu\",\"name\":\"baskičtina\"},{\"code\":\"bg\",\"name\":\"bulharština\"},{\"code\":\"cs\",\"name\":\"čeština\"},{\"code\":\"zh-tw\",\"name\":\"čínština (tradiční)\"},{\"code\":\"zh-cn\",\"name\":\"čínština (zjednodušená)\"},{\"code\":\"da\",\"name\":\"dánština\"},{\"code\":\"et\",\"name\":\"estonština\"},{\"code\":\"fi\",\"name\":\"finština\"},{\"code\":\"fr\",\"name\":\"francouzština\"},{\"code\":\"gl\",\"name\":\"galicijština\"},{\"code\":\"he\",\"name\":\"hebrejština\"},{\"code\":\"nl\",\"name\":\"holandština\"},{\"code\":\"hr\",\"name\":\"chorvatština\"},{\"code\":\"id\",\"name\":\"indonéština\"},{\"code\":\"ga\",\"name\":\"irština\"},{\"code\":\"is\",\"name\":\"islandština\"},{\"code\":\"it\",\"name\":\"italština\"},{\"code\":\"ja\",\"name\":\"japonština\"},{\"code\":\"ca\",\"name\":\"katalánština\"},{\"code\":\"ko\",\"name\":\"korejština\"},{\"code\":\"lt\",\"name\":\"litevština\"},{\"code\":\"lv\",\"name\":\"lotyština\"},{\"code\":\"hu\",\"name\":\"maďarština\"},{\"code\":\"mi\",\"name\":\"maorština\"},{\"code\":\"de\",\"name\":\"němčina\"},{\"code\":\"nb\",\"name\":\"norština\"},{\"code\":\"fa\",\"name\":\"perština\"},{\"code\":\"pl\",\"name\":\"polština\"},{\"code\":\"pt\",\"name\":\"portugalština\"},{\"code\":\"ro\",\"name\":\"rumunština\"},{\"code\":\"ru\",\"name\":\"ruština\"},{\"code\":\"el\",\"name\":\"řečtina\"},{\"code\":\"gd\",\"name\":\"skotská gaelština\"},{\"code\":\"sk\",\"name\":\"slovenština\"},{\"code\":\"sl\",\"name\":\"slovinština\"},{\"code\":\"sr\",\"name\":\"srbština\"},{\"code\":\"es\",\"name\":\"španělština\"},{\"code\":\"sv\",\"name\":\"švédština\"},{\"code\":\"th\",\"name\":\"thajština\"},{\"code\":\"tr\",\"name\":\"turečtina\"},{\"code\":\"uk\",\"name\":\"ukrajinština\"},{\"code\":\"cy\",\"name\":\"velština\"},{\"code\":\"vi\",\"name\":\"vietnamština\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"da\":[{\"code\":\"am\",\"name\":\"Amharisk\"},{\"code\":\"ar\",\"name\":\"Arabisk\"},{\"code\":\"az\",\"name\":\"Aserbajdsjansk\"},{\"code\":\"eu\",\"name\":\"Baskisk\"},{\"code\":\"bg\",\"name\":\"Bulgarsk\"},{\"code\":\"da\",\"name\":\"Dansk\"},{\"code\":\"en\",\"name\":\"Engelsk\"},{\"code\":\"et\",\"name\":\"Estisk\"},{\"code\":\"fi\",\"name\":\"Finsk\"},{\"code\":\"fr\",\"name\":\"Fransk\"},{\"code\":\"gl\",\"name\":\"Galicisk\"},{\"code\":\"el\",\"name\":\"Græsk\"},{\"code\":\"he\",\"name\":\"Hebraisk\"},{\"code\":\"nl\",\"name\":\"Hollandsk\"},{\"code\":\"id\",\"name\":\"Indonesisk\"},{\"code\":\"ga\",\"name\":\"Irsk\"},{\"code\":\"is\",\"name\":\"Islandsk\"},{\"code\":\"it\",\"name\":\"Italiensk\"},{\"code\":\"ja\",\"name\":\"Japansk\"},{\"code\":\"ca\",\"name\":\"Katalansk\"},{\"code\":\"zh-cn\",\"name\":\"Kinesisk (forenklet)\"},{\"code\":\"zh-tw\",\"name\":\"Kinesisk (traditionelt)\"},{\"code\":\"ko\",\"name\":\"Koreansk\"},{\"code\":\"hr\",\"name\":\"Kroatisk\"},{\"code\":\"lv\",\"name\":\"Lettisk\"},{\"code\":\"lt\",\"name\":\"Litauisk\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norsk\"},{\"code\":\"fa\",\"name\":\"Persisk\"},{\"code\":\"pl\",\"name\":\"Polsk\"},{\"code\":\"pt\",\"name\":\"Portugisisk\"},{\"code\":\"ro\",\"name\":\"Rumænsk\"},{\"code\":\"ru\",\"name\":\"Russisk\"},{\"code\":\"sr\",\"name\":\"Serbisk\"},{\"code\":\"gd\",\"name\":\"Skotsk gælisk\"},{\"code\":\"sk\",\"name\":\"Slovakisk\"},{\"code\":\"sl\",\"name\":\"Slovensk\"},{\"code\":\"es\",\"name\":\"Spansk\"},{\"code\":\"sv\",\"name\":\"Svensk\"},{\"code\":\"th\",\"name\":\"Thailandsk\"},{\"code\":\"cs\",\"name\":\"Tjekkisk\"},{\"code\":\"tr\",\"name\":\"Tyrkisk\"},{\"code\":\"de\",\"name\":\"Tysk\"},{\"code\":\"uk\",\"name\":\"Ukrainsk\"},{\"code\":\"hu\",\"name\":\"Ungarsk\"},{\"code\":\"vi\",\"name\":\"Vietnamesisk\"},{\"code\":\"cy\",\"name\":\"Walisisk\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"gl\":[{\"code\":\"az\",\"name\":\"acerbaixano\"},{\"code\":\"de\",\"name\":\"alemán\"},{\"code\":\"am\",\"name\":\"amárico\"},{\"code\":\"ar\",\"name\":\"árabe\"},{\"code\":\"bg\",\"name\":\"búlgaro\"},{\"code\":\"ca\",\"name\":\"catalán\"},{\"code\":\"cs\",\"name\":\"checo\"},{\"code\":\"zh-cn\",\"name\":\"chinés (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"chinés (tradicional)\"},{\"code\":\"ko\",\"name\":\"coreano\"},{\"code\":\"hr\",\"name\":\"croata\"},{\"code\":\"da\",\"name\":\"dinamarqués\"},{\"code\":\"sk\",\"name\":\"eslovaco\"},{\"code\":\"sl\",\"name\":\"esloveno\"},{\"code\":\"es\",\"name\":\"español\"},{\"code\":\"et\",\"name\":\"estoniano\"},{\"code\":\"eu\",\"name\":\"éuscaro\"},{\"code\":\"fi\",\"name\":\"finés\"},{\"code\":\"fr\",\"name\":\"francés\"},{\"code\":\"gd\",\"name\":\"gaélico escocés\"},{\"code\":\"gl\",\"name\":\"galego\"},{\"code\":\"cy\",\"name\":\"galés\"},{\"code\":\"el\",\"name\":\"grego\"},{\"code\":\"he\",\"name\":\"hebreo\"},{\"code\":\"hu\",\"name\":\"húngaro\"},{\"code\":\"id\",\"name\":\"indonesio\"},{\"code\":\"en\",\"name\":\"inglés\"},{\"code\":\"ga\",\"name\":\"irlandés\"},{\"code\":\"is\",\"name\":\"islandés\"},{\"code\":\"it\",\"name\":\"italiano\"},{\"code\":\"lv\",\"name\":\"letón\"},{\"code\":\"lt\",\"name\":\"lituano\"},{\"code\":\"mi\",\"name\":\"maorí\"},{\"code\":\"nl\",\"name\":\"neerlandés\"},{\"code\":\"nb\",\"name\":\"noruegués\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polaco\"},{\"code\":\"pt\",\"name\":\"portugués\"},{\"code\":\"ro\",\"name\":\"romanés\"},{\"code\":\"ru\",\"name\":\"ruso\"},{\"code\":\"sr\",\"name\":\"serbio\"},{\"code\":\"sv\",\"name\":\"sueco\"},{\"code\":\"th\",\"name\":\"tailandés\"},{\"code\":\"tr\",\"name\":\"turco\"},{\"code\":\"uk\",\"name\":\"ucraíno\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"ja\",\"name\":\"xaponés\"},{\"code\":\"zu\",\"name\":\"zulú\"}],\"sl\":[{\"code\":\"am\",\"name\":\"amharščina\"},{\"code\":\"en\",\"name\":\"angleščina\"},{\"code\":\"ar\",\"name\":\"arabščina\"},{\"code\":\"az\",\"name\":\"azerbajdžanščina\"},{\"code\":\"eu\",\"name\":\"baskovščina\"},{\"code\":\"bg\",\"name\":\"bolgarščina\"},{\"code\":\"cs\",\"name\":\"češčina\"},{\"code\":\"da\",\"name\":\"danščina\"},{\"code\":\"et\",\"name\":\"estonščina\"},{\"code\":\"fi\",\"name\":\"finščina\"},{\"code\":\"fr\",\"name\":\"francoščina\"},{\"code\":\"gl\",\"name\":\"galicijščina\"},{\"code\":\"el\",\"name\":\"grščina\"},{\"code\":\"he\",\"name\":\"hebrejščina\"},{\"code\":\"hr\",\"name\":\"hrvaščina\"},{\"code\":\"id\",\"name\":\"indonezijščina\"},{\"code\":\"ga\",\"name\":\"irščina\"},{\"code\":\"is\",\"name\":\"islandščina\"},{\"code\":\"it\",\"name\":\"italijanščina\"},{\"code\":\"ja\",\"name\":\"japonščina\"},{\"code\":\"ca\",\"name\":\"katalonščina\"},{\"code\":\"zh-cn\",\"name\":\"kitajščina (poenostavljena)\"},{\"code\":\"zh-tw\",\"name\":\"kitajščina (tradicionalna)\"},{\"code\":\"ko\",\"name\":\"korejščina\"},{\"code\":\"lv\",\"name\":\"latvijščina\"},{\"code\":\"lt\",\"name\":\"litovščina\"},{\"code\":\"hu\",\"name\":\"madžarščina\"},{\"code\":\"mi\",\"name\":\"maorščina\"},{\"code\":\"de\",\"name\":\"nemščina\"},{\"code\":\"nl\",\"name\":\"nizozemščina\"},{\"code\":\"nb\",\"name\":\"norveščina\"},{\"code\":\"fa\",\"name\":\"perzijščina\"},{\"code\":\"pl\",\"name\":\"poljščina\"},{\"code\":\"pt\",\"name\":\"portugalščina\"},{\"code\":\"ro\",\"name\":\"romunščina\"},{\"code\":\"ru\",\"name\":\"ruščina\"},{\"code\":\"sk\",\"name\":\"slovaščina\"},{\"code\":\"sl\",\"name\":\"slovenščina\"},{\"code\":\"sr\",\"name\":\"srbščina\"},{\"code\":\"gd\",\"name\":\"škotska gelščina\"},{\"code\":\"es\",\"name\":\"španščina\"},{\"code\":\"sv\",\"name\":\"švedščina\"},{\"code\":\"th\",\"name\":\"tajščina\"},{\"code\":\"tr\",\"name\":\"turščina\"},{\"code\":\"uk\",\"name\":\"ukrajinščina\"},{\"code\":\"cy\",\"name\":\"valižanščina\"},{\"code\":\"vi\",\"name\":\"vietnamščina\"},{\"code\":\"zu\",\"name\":\"zulujščina\"}],\"fr\":[{\"code\":\"de\",\"name\":\"Allemand\"},{\"code\":\"am\",\"name\":\"Amharique\"},{\"code\":\"en\",\"name\":\"Anglais\"},{\"code\":\"ar\",\"name\":\"Arabe\"},{\"code\":\"az\",\"name\":\"Azéri\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"bg\",\"name\":\"Bulgare\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"zh-cn\",\"name\":\"Chinois (simplifié)\"},{\"code\":\"zh-tw\",\"name\":\"Chinois (traditionnel)\"},{\"code\":\"ko\",\"name\":\"Coréen\"},{\"code\":\"hr\",\"name\":\"Croate\"},{\"code\":\"da\",\"name\":\"Danois\"},{\"code\":\"es\",\"name\":\"Espagnol\"},{\"code\":\"et\",\"name\":\"Estonien\"},{\"code\":\"fi\",\"name\":\"Finnois\"},{\"code\":\"fr\",\"name\":\"Français\"},{\"code\":\"gd\",\"name\":\"Gaélique (Écosse)\"},{\"code\":\"gl\",\"name\":\"Galicien\"},{\"code\":\"cy\",\"name\":\"Gallois\"},{\"code\":\"el\",\"name\":\"Grec\"},{\"code\":\"he\",\"name\":\"Hébreu\"},{\"code\":\"hu\",\"name\":\"Hongrois\"},{\"code\":\"id\",\"name\":\"Indonésien\"},{\"code\":\"ga\",\"name\":\"Irlandais\"},{\"code\":\"is\",\"name\":\"Islandais\"},{\"code\":\"it\",\"name\":\"Italien\"},{\"code\":\"ja\",\"name\":\"Japonais\"},{\"code\":\"lv\",\"name\":\"Letton\"},{\"code\":\"lt\",\"name\":\"Lituanien\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Néerlandais\"},{\"code\":\"nb\",\"name\":\"Norvégien\"},{\"code\":\"fa\",\"name\":\"Persan\"},{\"code\":\"pl\",\"name\":\"Polonais\"},{\"code\":\"pt\",\"name\":\"Portugais\"},{\"code\":\"ro\",\"name\":\"Roumain\"},{\"code\":\"ru\",\"name\":\"Russe\"},{\"code\":\"sr\",\"name\":\"Serbe\"},{\"code\":\"sk\",\"name\":\"Slovaque\"},{\"code\":\"sl\",\"name\":\"Slovène\"},{\"code\":\"sv\",\"name\":\"Suédois\"},{\"code\":\"cs\",\"name\":\"Tchèque\"},{\"code\":\"th\",\"name\":\"Thaï\"},{\"code\":\"tr\",\"name\":\"Turc\"},{\"code\":\"uk\",\"name\":\"Ukrainien\"},{\"code\":\"vi\",\"name\":\"Vietnamien\"},{\"code\":\"zu\",\"name\":\"Zoulou\"}],\"hu\":[{\"code\":\"am\",\"name\":\"amhara\"},{\"code\":\"en\",\"name\":\"angol\"},{\"code\":\"ar\",\"name\":\"arab\"},{\"code\":\"az\",\"name\":\"azeri\"},{\"code\":\"eu\",\"name\":\"baszk\"},{\"code\":\"bg\",\"name\":\"bolgár\"},{\"code\":\"cs\",\"name\":\"cseh\"},{\"code\":\"da\",\"name\":\"dán\"},{\"code\":\"et\",\"name\":\"észt\"},{\"code\":\"fi\",\"name\":\"finn\"},{\"code\":\"fr\",\"name\":\"francia\"},{\"code\":\"gl\",\"name\":\"galíciai\"},{\"code\":\"el\",\"name\":\"görög\"},{\"code\":\"he\",\"name\":\"héber\"},{\"code\":\"nl\",\"name\":\"holland\"},{\"code\":\"hr\",\"name\":\"horvát\"},{\"code\":\"id\",\"name\":\"indonéz\"},{\"code\":\"ga\",\"name\":\"ír\"},{\"code\":\"is\",\"name\":\"izlandi\"},{\"code\":\"ja\",\"name\":\"japán\"},{\"code\":\"ca\",\"name\":\"katalán\"},{\"code\":\"zh-cn\",\"name\":\"kínai (egyszerűsített)\"},{\"code\":\"zh-tw\",\"name\":\"kínai (hagyományos)\"},{\"code\":\"ko\",\"name\":\"koreai\"},{\"code\":\"pl\",\"name\":\"lengyel\"},{\"code\":\"lv\",\"name\":\"lett\"},{\"code\":\"lt\",\"name\":\"litván\"},{\"code\":\"hu\",\"name\":\"magyar\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"de\",\"name\":\"német\"},{\"code\":\"nb\",\"name\":\"norvég\"},{\"code\":\"it\",\"name\":\"olasz\"},{\"code\":\"ru\",\"name\":\"orosz\"},{\"code\":\"fa\",\"name\":\"perzsa\"},{\"code\":\"pt\",\"name\":\"portugál\"},{\"code\":\"ro\",\"name\":\"román\"},{\"code\":\"gd\",\"name\":\"skót-gael\"},{\"code\":\"es\",\"name\":\"spanyol\"},{\"code\":\"sv\",\"name\":\"svéd\"},{\"code\":\"sr\",\"name\":\"szerb\"},{\"code\":\"sk\",\"name\":\"szlovák\"},{\"code\":\"sl\",\"name\":\"szlovén\"},{\"code\":\"th\",\"name\":\"thai\"},{\"code\":\"tr\",\"name\":\"török\"},{\"code\":\"uk\",\"name\":\"ukrán\"},{\"code\":\"vi\",\"name\":\"vietnami\"},{\"code\":\"cy\",\"name\":\"walesi\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"uk\":[{\"code\":\"az\",\"name\":\"азербайджанська\"},{\"code\":\"am\",\"name\":\"амхарська\"},{\"code\":\"en\",\"name\":\"англійська\"},{\"code\":\"ar\",\"name\":\"арабська\"},{\"code\":\"eu\",\"name\":\"баскська\"},{\"code\":\"bg\",\"name\":\"болгарська\"},{\"code\":\"vi\",\"name\":\"в’єтнамська\"},{\"code\":\"cy\",\"name\":\"валлійська\"},{\"code\":\"el\",\"name\":\"грецька\"},{\"code\":\"gl\",\"name\":\"ґалісійська\"},{\"code\":\"da\",\"name\":\"данська\"},{\"code\":\"et\",\"name\":\"естонська\"},{\"code\":\"zu\",\"name\":\"зулу\"},{\"code\":\"he\",\"name\":\"іврит\"},{\"code\":\"id\",\"name\":\"індонезійська\"},{\"code\":\"ga\",\"name\":\"ірландська\"},{\"code\":\"is\",\"name\":\"ісландська\"},{\"code\":\"es\",\"name\":\"іспанська\"},{\"code\":\"it\",\"name\":\"італійська\"},{\"code\":\"ca\",\"name\":\"каталанська\"},{\"code\":\"zh-cn\",\"name\":\"китайська (спрощена)\"},{\"code\":\"zh-tw\",\"name\":\"китайська (традиційна)\"},{\"code\":\"ko\",\"name\":\"корейська\"},{\"code\":\"lv\",\"name\":\"латиська\"},{\"code\":\"lt\",\"name\":\"литовська\"},{\"code\":\"mi\",\"name\":\"маорі\"},{\"code\":\"nl\",\"name\":\"нідерландська\"},{\"code\":\"de\",\"name\":\"німецька\"},{\"code\":\"nb\",\"name\":\"норвезька\"},{\"code\":\"fa\",\"name\":\"перська\"},{\"code\":\"pl\",\"name\":\"польська\"},{\"code\":\"pt\",\"name\":\"португальська\"},{\"code\":\"ru\",\"name\":\"російська\"},{\"code\":\"ro\",\"name\":\"румунська\"},{\"code\":\"sr\",\"name\":\"сербська\"},{\"code\":\"sk\",\"name\":\"словацька\"},{\"code\":\"sl\",\"name\":\"словенська\"},{\"code\":\"th\",\"name\":\"тайська\"},{\"code\":\"tr\",\"name\":\"турецька\"},{\"code\":\"hu\",\"name\":\"угорська\"},{\"code\":\"uk\",\"name\":\"українська\"},{\"code\":\"fi\",\"name\":\"фінська\"},{\"code\":\"fr\",\"name\":\"французька\"},{\"code\":\"hr\",\"name\":\"хорватська\"},{\"code\":\"cs\",\"name\":\"чеська\"},{\"code\":\"sv\",\"name\":\"шведська\"},{\"code\":\"gd\",\"name\":\"шотландська (ґельська)\"},{\"code\":\"ja\",\"name\":\"японська\"}],\"zh-tw\":[{\"code\":\"tr\",\"name\":\"土耳其文\"},{\"code\":\"zh-tw\",\"name\":\"中文(繁體)\"},{\"code\":\"zh-cn\",\"name\":\"中文(簡體)\"},{\"code\":\"da\",\"name\":\"丹麥文\"},{\"code\":\"eu\",\"name\":\"巴斯克文\"},{\"code\":\"ja\",\"name\":\"日文\"},{\"code\":\"mi\",\"name\":\"毛利文\"},{\"code\":\"gl\",\"name\":\"加里西亞文\"},{\"code\":\"ca\",\"name\":\"加泰羅尼亞文\"},{\"code\":\"lt\",\"name\":\"立陶宛文\"},{\"code\":\"is\",\"name\":\"冰島文\"},{\"code\":\"hu\",\"name\":\"匈牙利文\"},{\"code\":\"id\",\"name\":\"印尼文\"},{\"code\":\"es\",\"name\":\"西班牙文\"},{\"code\":\"hr\",\"name\":\"克羅埃西亞文\"},{\"code\":\"he\",\"name\":\"希伯來文\"},{\"code\":\"el\",\"name\":\"希臘文\"},{\"code\":\"az\",\"name\":\"亞塞拜然文\"},{\"code\":\"lv\",\"name\":\"拉脫維亞文\"},{\"code\":\"fr\",\"name\":\"法文\"},{\"code\":\"fa\",\"name\":\"波斯文\"},{\"code\":\"pl\",\"name\":\"波蘭文\"},{\"code\":\"fi\",\"name\":\"芬蘭文\"},{\"code\":\"am\",\"name\":\"阿姆哈拉文\"},{\"code\":\"ar\",\"name\":\"阿拉伯文\"},{\"code\":\"ru\",\"name\":\"俄文\"},{\"code\":\"bg\",\"name\":\"保加利亞文\"},{\"code\":\"zu\",\"name\":\"南非祖魯文\"},{\"code\":\"cy\",\"name\":\"威爾斯文\"},{\"code\":\"en\",\"name\":\"英文\"},{\"code\":\"nb\",\"name\":\"挪威文\"},{\"code\":\"th\",\"name\":\"泰文\"},{\"code\":\"uk\",\"name\":\"烏克蘭文\"},{\"code\":\"cs\",\"name\":\"捷克文\"},{\"code\":\"nl\",\"name\":\"荷蘭文\"},{\"code\":\"sk\",\"name\":\"斯洛伐克文\"},{\"code\":\"sl\",\"name\":\"斯洛維尼亞文\"},{\"code\":\"vi\",\"name\":\"越南文\"},{\"code\":\"sr\",\"name\":\"塞爾維亞文\"},{\"code\":\"et\",\"name\":\"愛沙尼亞文\"},{\"code\":\"ga\",\"name\":\"愛爾蘭文\"},{\"code\":\"sv\",\"name\":\"瑞典文\"},{\"code\":\"it\",\"name\":\"義大利文\"},{\"code\":\"pt\",\"name\":\"葡萄牙文\"},{\"code\":\"de\",\"name\":\"德文\"},{\"code\":\"ko\",\"name\":\"韓文\"},{\"code\":\"ro\",\"name\":\"羅馬尼亞文\"},{\"code\":\"gd\",\"name\":\"蘇格蘭的蓋爾文\"}],\"pt\":[{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arabic\"},{\"code\":\"az\",\"name\":\"Azerbaijani\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"bg\",\"name\":\"Bulgarian\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"zh-cn\",\"name\":\"Chinese (Simplified)\"},{\"code\":\"zh-tw\",\"name\":\"Chinese (Traditional)\"},{\"code\":\"hr\",\"name\":\"Croatian\"},{\"code\":\"cs\",\"name\":\"Czech\"},{\"code\":\"da\",\"name\":\"Danish\"},{\"code\":\"nl\",\"name\":\"Dutch\"},{\"code\":\"en\",\"name\":\"English\"},{\"code\":\"et\",\"name\":\"Estonian\"},{\"code\":\"fi\",\"name\":\"Finnish\"},{\"code\":\"fr\",\"name\":\"French\"},{\"code\":\"gl\",\"name\":\"Galician\"},{\"code\":\"de\",\"name\":\"German\"},{\"code\":\"el\",\"name\":\"Greek\"},{\"code\":\"he\",\"name\":\"Hebrew\"},{\"code\":\"hu\",\"name\":\"Hungarian\"},{\"code\":\"is\",\"name\":\"Icelandic\"},{\"code\":\"id\",\"name\":\"Indonesian\"},{\"code\":\"ga\",\"name\":\"Irish\"},{\"code\":\"it\",\"name\":\"Italian\"},{\"code\":\"ja\",\"name\":\"Japanese\"},{\"code\":\"ko\",\"name\":\"Korean\"},{\"code\":\"lv\",\"name\":\"Latvian\"},{\"code\":\"lt\",\"name\":\"Lithuanian\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norwegian\"},{\"code\":\"fa\",\"name\":\"Persian\"},{\"code\":\"pl\",\"name\":\"Polish\"},{\"code\":\"pt\",\"name\":\"Portuguese\"},{\"code\":\"ro\",\"name\":\"Romanian\"},{\"code\":\"ru\",\"name\":\"Russian\"},{\"code\":\"gd\",\"name\":\"Scots Gaelic\"},{\"code\":\"sr\",\"name\":\"Serbian\"},{\"code\":\"sk\",\"name\":\"Slovak\"},{\"code\":\"sl\",\"name\":\"Slovenian\"},{\"code\":\"es\",\"name\":\"Spanish\"},{\"code\":\"sv\",\"name\":\"Swedish\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"tr\",\"name\":\"Turkish\"},{\"code\":\"uk\",\"name\":\"Ukrainian\"},{\"code\":\"vi\",\"name\":\"Vietnamese\"},{\"code\":\"cy\",\"name\":\"Welsh\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"pt-br\":[{\"code\":\"de\",\"name\":\"Alemão\"},{\"code\":\"am\",\"name\":\"Amárico\"},{\"code\":\"ar\",\"name\":\"Árabe\"},{\"code\":\"az\",\"name\":\"Azerbaijano\"},{\"code\":\"eu\",\"name\":\"Basco\"},{\"code\":\"bg\",\"name\":\"Búlgaro\"},{\"code\":\"ca\",\"name\":\"Catalão\"},{\"code\":\"zh-cn\",\"name\":\"Chinês (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"Chinês (tradicional)\"},{\"code\":\"ko\",\"name\":\"Coreano\"},{\"code\":\"hr\",\"name\":\"Croata\"},{\"code\":\"da\",\"name\":\"Dinamarquês\"},{\"code\":\"sk\",\"name\":\"Eslovaco\"},{\"code\":\"sl\",\"name\":\"Esloveno\"},{\"code\":\"es\",\"name\":\"Espanhol\"},{\"code\":\"et\",\"name\":\"Estoniano\"},{\"code\":\"fi\",\"name\":\"Finlandês\"},{\"code\":\"fr\",\"name\":\"Francês\"},{\"code\":\"gd\",\"name\":\"Gaélico escocês\"},{\"code\":\"gl\",\"name\":\"Galego\"},{\"code\":\"cy\",\"name\":\"Galês\"},{\"code\":\"el\",\"name\":\"Grego\"},{\"code\":\"he\",\"name\":\"Hebraico\"},{\"code\":\"nl\",\"name\":\"Holandês\"},{\"code\":\"hu\",\"name\":\"Húngaro\"},{\"code\":\"id\",\"name\":\"Indonésio\"},{\"code\":\"en\",\"name\":\"Inglês\"},{\"code\":\"ga\",\"name\":\"Irlandês\"},{\"code\":\"is\",\"name\":\"Islandês\"},{\"code\":\"it\",\"name\":\"Italiano\"},{\"code\":\"ja\",\"name\":\"Japonês\"},{\"code\":\"lv\",\"name\":\"Letão\"},{\"code\":\"lt\",\"name\":\"Lituano\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norueguês\"},{\"code\":\"fa\",\"name\":\"Persa\"},{\"code\":\"pl\",\"name\":\"Polonês\"},{\"code\":\"pt\",\"name\":\"Português\"},{\"code\":\"ro\",\"name\":\"Romeno\"},{\"code\":\"ru\",\"name\":\"Russo\"},{\"code\":\"sr\",\"name\":\"Sérvio\"},{\"code\":\"sv\",\"name\":\"Sueco\"},{\"code\":\"th\",\"name\":\"Tailandês\"},{\"code\":\"cs\",\"name\":\"Tcheco\"},{\"code\":\"tr\",\"name\":\"Turco\"},{\"code\":\"uk\",\"name\":\"Ucraniano\"},{\"code\":\"vi\",\"name\":\"Vietnamita\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"tr\":[{\"code\":\"de\",\"name\":\"Almanca\"},{\"code\":\"ar\",\"name\":\"Arapça\"},{\"code\":\"az\",\"name\":\"Azerice\"},{\"code\":\"eu\",\"name\":\"Baskça\"},{\"code\":\"bg\",\"name\":\"Bulgarca\"},{\"code\":\"cs\",\"name\":\"Çekçe\"},{\"code\":\"zh-cn\",\"name\":\"Çince (Basitleştirilmiş)\"},{\"code\":\"zh-tw\",\"name\":\"Çince (Geleneksel)\"},{\"code\":\"da\",\"name\":\"Danca\"},{\"code\":\"id\",\"name\":\"Endonezya Dili\"},{\"code\":\"et\",\"name\":\"Estonyaca\"},{\"code\":\"fa\",\"name\":\"Farsça\"},{\"code\":\"nl\",\"name\":\"Felemenkçe\"},{\"code\":\"fi\",\"name\":\"Fince\"},{\"code\":\"fr\",\"name\":\"Fransızca\"},{\"code\":\"cy\",\"name\":\"Galce\"},{\"code\":\"gl\",\"name\":\"Galiçyaca\"},{\"code\":\"am\",\"name\":\"Habeşçe\"},{\"code\":\"hr\",\"name\":\"Hırvatça\"},{\"code\":\"he\",\"name\":\"İbranice\"},{\"code\":\"en\",\"name\":\"İngilizce\"},{\"code\":\"ga\",\"name\":\"İrlandaca\"},{\"code\":\"es\",\"name\":\"İspanyolca\"},{\"code\":\"sv\",\"name\":\"İsveççe\"},{\"code\":\"it\",\"name\":\"İtalyanca\"},{\"code\":\"is\",\"name\":\"İzlandaca\"},{\"code\":\"ja\",\"name\":\"Japonca\"},{\"code\":\"ca\",\"name\":\"Katalanca\"},{\"code\":\"ko\",\"name\":\"Korece\"},{\"code\":\"gd\",\"name\":\"Kuzey İskoç Dili\"},{\"code\":\"pl\",\"name\":\"Lehçe\"},{\"code\":\"lv\",\"name\":\"Letonca\"},{\"code\":\"lt\",\"name\":\"Litvanca\"},{\"code\":\"hu\",\"name\":\"Macarca\"},{\"code\":\"mi\",\"name\":\"Maori Dili\"},{\"code\":\"nb\",\"name\":\"Norveççe\"},{\"code\":\"pt\",\"name\":\"Portekizce\"},{\"code\":\"ro\",\"name\":\"Romence\"},{\"code\":\"ru\",\"name\":\"Rusça\"},{\"code\":\"sr\",\"name\":\"Sırpça\"},{\"code\":\"sk\",\"name\":\"Slovakça\"},{\"code\":\"sl\",\"name\":\"Slovence\"},{\"code\":\"th\",\"name\":\"Tay Dili\"},{\"code\":\"tr\",\"name\":\"Türkçe\"},{\"code\":\"uk\",\"name\":\"Ukraynaca\"},{\"code\":\"vi\",\"name\":\"Vietnamca\"},{\"code\":\"el\",\"name\":\"Yunanca\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"ga\":[{\"code\":\"am\",\"name\":\"Amárais\"},{\"code\":\"ar\",\"name\":\"Araibis\"},{\"code\":\"az\",\"name\":\"Asarbaiseáinis\"},{\"code\":\"eu\",\"name\":\"Bascais\"},{\"code\":\"en\",\"name\":\"Béarla\"},{\"code\":\"cy\",\"name\":\"Breatnais\"},{\"code\":\"bg\",\"name\":\"Bulgáiris\"},{\"code\":\"ca\",\"name\":\"Catalóinis\"},{\"code\":\"ko\",\"name\":\"Cóiréis\"},{\"code\":\"hr\",\"name\":\"Cróitis\"},{\"code\":\"da\",\"name\":\"Danmhairgis\"},{\"code\":\"he\",\"name\":\"Eabhrais\"},{\"code\":\"et\",\"name\":\"Eastóinis\"},{\"code\":\"fi\",\"name\":\"Fionlainnis\"},{\"code\":\"fr\",\"name\":\"Fraincis\"},{\"code\":\"ga\",\"name\":\"Gaeilge\"},{\"code\":\"gd\",\"name\":\"Gaeilge na hAlban\"},{\"code\":\"gl\",\"name\":\"Gailísis\"},{\"code\":\"de\",\"name\":\"Gearmáinis\"},{\"code\":\"el\",\"name\":\"Gréigis\"},{\"code\":\"id\",\"name\":\"Indinéisis\"},{\"code\":\"it\",\"name\":\"Iodáilis\"},{\"code\":\"nb\",\"name\":\"Ioruais\"},{\"code\":\"is\",\"name\":\"Íoslainnis\"},{\"code\":\"lv\",\"name\":\"Laitvis\"},{\"code\":\"lt\",\"name\":\"Liotuáinis\"},{\"code\":\"mi\",\"name\":\"Maorais\"},{\"code\":\"nl\",\"name\":\"Ollainnis\"},{\"code\":\"fa\",\"name\":\"Peirsis\"},{\"code\":\"pl\",\"name\":\"Polainnis\"},{\"code\":\"pt\",\"name\":\"Portaingéilis\"},{\"code\":\"ro\",\"name\":\"Rómáinis\"},{\"code\":\"ru\",\"name\":\"Rúisis\"},{\"code\":\"ja\",\"name\":\"Seapáinis\"},{\"code\":\"cs\",\"name\":\"Seicis\"},{\"code\":\"sr\",\"name\":\"Seirbis\"},{\"code\":\"zh-cn\",\"name\":\"Sínis (Simplithe)\"},{\"code\":\"zh-tw\",\"name\":\"Sínis (Traidisiúnta)\"},{\"code\":\"sl\",\"name\":\"Slóivéinis\"},{\"code\":\"sk\",\"name\":\"Slóvaicis\"},{\"code\":\"es\",\"name\":\"Spáinnis\"},{\"code\":\"sv\",\"name\":\"Sualainnis\"},{\"code\":\"zu\",\"name\":\"Súlúis\"},{\"code\":\"th\",\"name\":\"Téalainnis\"},{\"code\":\"tr\",\"name\":\"Tuircis\"},{\"code\":\"uk\",\"name\":\"Úcráinis\"},{\"code\":\"hu\",\"name\":\"Ungáiris\"},{\"code\":\"vi\",\"name\":\"Vítneaimis\"}],\"th\":[{\"code\":\"el\",\"name\":\"ภาษากรีก\"},{\"code\":\"gl\",\"name\":\"ภาษากาลิเชียน\"},{\"code\":\"gd\",\"name\":\"ภาษาเกลิกในสก็อต\"},{\"code\":\"ko\",\"name\":\"ภาษาเกาหลี\"},{\"code\":\"ca\",\"name\":\"ภาษาคาตาลัน\"},{\"code\":\"hr\",\"name\":\"ภาษาโครเอเชีย\"},{\"code\":\"zh-tw\",\"name\":\"ภาษาจีน (ดั้งเดิม)\"},{\"code\":\"zh-cn\",\"name\":\"ภาษาจีน (แบบย่อ)\"},{\"code\":\"cs\",\"name\":\"ภาษาเช็ก\"},{\"code\":\"zu\",\"name\":\"ภาษาซูลู\"},{\"code\":\"sr\",\"name\":\"ภาษาเซอร์เบียน\"},{\"code\":\"ja\",\"name\":\"ภาษาญี่ปุ่น\"},{\"code\":\"nl\",\"name\":\"ภาษาดัตช์\"},{\"code\":\"da\",\"name\":\"ภาษาเดนมาร์ก\"},{\"code\":\"tr\",\"name\":\"ภาษาตุรกี\"},{\"code\":\"th\",\"name\":\"ภาษาไทย\"},{\"code\":\"nb\",\"name\":\"ภาษานอร์เวย์\"},{\"code\":\"bg\",\"name\":\"ภาษาบัลกาเรีย\"},{\"code\":\"eu\",\"name\":\"ภาษาบาสก์\"},{\"code\":\"fa\",\"name\":\"ภาษาเปอร์เซีย\"},{\"code\":\"pt\",\"name\":\"ภาษาโปรตุเกส\"},{\"code\":\"pl\",\"name\":\"ภาษาโปแลนด์\"},{\"code\":\"fr\",\"name\":\"ภาษาฝรั่งเศส\"},{\"code\":\"fi\",\"name\":\"ภาษาฟินแลนด์\"},{\"code\":\"mi\",\"name\":\"ภาษาเมารี\"},{\"code\":\"uk\",\"name\":\"ภาษายูเครน\"},{\"code\":\"de\",\"name\":\"ภาษาเยอรมัน\"},{\"code\":\"ru\",\"name\":\"ภาษารัสเซีย\"},{\"code\":\"ro\",\"name\":\"ภาษาโรมาเนีย\"},{\"code\":\"lv\",\"name\":\"ภาษาลัทเวีย\"},{\"code\":\"lt\",\"name\":\"ภาษาลิทัวเนีย\"},{\"code\":\"cy\",\"name\":\"ภาษาเวลส์\"},{\"code\":\"vi\",\"name\":\"ภาษาเวียดนาม\"},{\"code\":\"es\",\"name\":\"ภาษาสเปน\"},{\"code\":\"sk\",\"name\":\"ภาษาสโลวัก\"},{\"code\":\"sl\",\"name\":\"ภาษาสโลเวเนีย\"},{\"code\":\"sv\",\"name\":\"ภาษาสวีเดน\"},{\"code\":\"en\",\"name\":\"ภาษาอังกฤษ\"},{\"code\":\"am\",\"name\":\"ภาษาอัมฮาริก\"},{\"code\":\"az\",\"name\":\"ภาษาอาร์เซอร์ไบจัน\"},{\"code\":\"ar\",\"name\":\"ภาษาอาหรับ\"},{\"code\":\"it\",\"name\":\"ภาษาอิตาลี\"},{\"code\":\"id\",\"name\":\"ภาษาอินโดนีเซีย\"},{\"code\":\"et\",\"name\":\"ภาษาเอสโทเนีย\"},{\"code\":\"is\",\"name\":\"ภาษาไอซ์แลนดิก\"},{\"code\":\"ga\",\"name\":\"ภาษาไอริช\"},{\"code\":\"hu\",\"name\":\"ภาษาฮังการี\"},{\"code\":\"he\",\"name\":\"ภาษาฮิบรู\"}],\"ja\":[{\"code\":\"is\",\"name\":\"アイスランド語\"},{\"code\":\"ga\",\"name\":\"アイルランド語\"},{\"code\":\"az\",\"name\":\"アゼルバイジャン語\"},{\"code\":\"am\",\"name\":\"アムハラ語\"},{\"code\":\"ar\",\"name\":\"アラビア語\"},{\"code\":\"it\",\"name\":\"イタリア語\"},{\"code\":\"id\",\"name\":\"インドネシア語\"},{\"code\":\"cy\",\"name\":\"ウェールズ語\"},{\"code\":\"uk\",\"name\":\"ウクライナ語\"},{\"code\":\"et\",\"name\":\"エストニア語\"},{\"code\":\"nl\",\"name\":\"オランダ語\"},{\"code\":\"ca\",\"name\":\"カタルーニャ語\"},{\"code\":\"gl\",\"name\":\"ガリシア語\"},{\"code\":\"el\",\"name\":\"ギリシャ語\"},{\"code\":\"hr\",\"name\":\"クロアチア語\"},{\"code\":\"sv\",\"name\":\"スウェーデン語\"},{\"code\":\"zu\",\"name\":\"ズールー語\"},{\"code\":\"gd\",\"name\":\"スコットランド ゲール語\"},{\"code\":\"es\",\"name\":\"スペイン語\"},{\"code\":\"sk\",\"name\":\"スロバキア語\"},{\"code\":\"sl\",\"name\":\"スロベニア語\"},{\"code\":\"sr\",\"name\":\"セルビア語\"},{\"code\":\"th\",\"name\":\"タイ語\"},{\"code\":\"cs\",\"name\":\"チェコ語\"},{\"code\":\"da\",\"name\":\"デンマーク語\"},{\"code\":\"de\",\"name\":\"ドイツ語\"},{\"code\":\"tr\",\"name\":\"トルコ語\"},{\"code\":\"nb\",\"name\":\"ノルウェー語\"},{\"code\":\"eu\",\"name\":\"バスク語\"},{\"code\":\"hu\",\"name\":\"ハンガリー語\"},{\"code\":\"fi\",\"name\":\"フィンランド語\"},{\"code\":\"fr\",\"name\":\"フランス語\"},{\"code\":\"bg\",\"name\":\"ブルガリア語\"},{\"code\":\"vi\",\"name\":\"ベトナム語\"},{\"code\":\"he\",\"name\":\"ヘブライ語\"},{\"code\":\"fa\",\"name\":\"ペルシャ語\"},{\"code\":\"pl\",\"name\":\"ポーランド語\"},{\"code\":\"pt\",\"name\":\"ポルトガル語\"},{\"code\":\"mi\",\"name\":\"マオリ語\"},{\"code\":\"lv\",\"name\":\"ラトビア語\"},{\"code\":\"lt\",\"name\":\"リトアニア語\"},{\"code\":\"ro\",\"name\":\"ルーマニア語\"},{\"code\":\"ru\",\"name\":\"ロシア語\"},{\"code\":\"en\",\"name\":\"英語\"},{\"code\":\"ko\",\"name\":\"韓国語\"},{\"code\":\"zh-cn\",\"name\":\"中国語(簡体)\"},{\"code\":\"zh-tw\",\"name\":\"中国語(繁体)\"},{\"code\":\"ja\",\"name\":\"日本語\"}],\"ja-hira\":[{\"code\":\"is\",\"name\":\"アイスランド語\"},{\"code\":\"ga\",\"name\":\"アイルランド語\"},{\"code\":\"az\",\"name\":\"アゼルバイジャン語\"},{\"code\":\"am\",\"name\":\"アムハラ語\"},{\"code\":\"ar\",\"name\":\"アラビア語\"},{\"code\":\"it\",\"name\":\"イタリア語\"},{\"code\":\"id\",\"name\":\"インドネシア語\"},{\"code\":\"cy\",\"name\":\"ウェールズ語\"},{\"code\":\"uk\",\"name\":\"ウクライナ語\"},{\"code\":\"et\",\"name\":\"エストニア語\"},{\"code\":\"nl\",\"name\":\"オランダ語\"},{\"code\":\"ca\",\"name\":\"カタルーニャ語\"},{\"code\":\"gl\",\"name\":\"ガリシア語\"},{\"code\":\"el\",\"name\":\"ギリシャ語\"},{\"code\":\"hr\",\"name\":\"クロアチア語\"},{\"code\":\"sv\",\"name\":\"スウェーデン語\"},{\"code\":\"zu\",\"name\":\"ズールー語\"},{\"code\":\"gd\",\"name\":\"スコットランド ゲール語\"},{\"code\":\"es\",\"name\":\"スペイン語\"},{\"code\":\"sk\",\"name\":\"スロバキア語\"},{\"code\":\"sl\",\"name\":\"スロベニア語\"},{\"code\":\"sr\",\"name\":\"セルビア語\"},{\"code\":\"th\",\"name\":\"タイ語\"},{\"code\":\"cs\",\"name\":\"チェコ語\"},{\"code\":\"da\",\"name\":\"デンマーク語\"},{\"code\":\"de\",\"name\":\"ドイツ語\"},{\"code\":\"tr\",\"name\":\"トルコ語\"},{\"code\":\"nb\",\"name\":\"ノルウェー語\"},{\"code\":\"eu\",\"name\":\"バスク語\"},{\"code\":\"hu\",\"name\":\"ハンガリー語\"},{\"code\":\"fi\",\"name\":\"フィンランド語\"},{\"code\":\"fr\",\"name\":\"フランス語\"},{\"code\":\"bg\",\"name\":\"ブルガリア語\"},{\"code\":\"vi\",\"name\":\"ベトナム語\"},{\"code\":\"he\",\"name\":\"ヘブライ語\"},{\"code\":\"fa\",\"name\":\"ペルシャ語\"},{\"code\":\"pl\",\"name\":\"ポーランド語\"},{\"code\":\"pt\",\"name\":\"ポルトガル語\"},{\"code\":\"mi\",\"name\":\"マオリ語\"},{\"code\":\"lv\",\"name\":\"ラトビア語\"},{\"code\":\"lt\",\"name\":\"リトアニア語\"},{\"code\":\"ro\",\"name\":\"ルーマニア語\"},{\"code\":\"ru\",\"name\":\"ロシア語\"},{\"code\":\"en\",\"name\":\"英語\"},{\"code\":\"ko\",\"name\":\"韓国語\"},{\"code\":\"zh-cn\",\"name\":\"中国語(簡体)\"},{\"code\":\"zh-tw\",\"name\":\"中国語(繁体)\"},{\"code\":\"ja\",\"name\":\"日本語\"}],\"nl\":[{\"code\":\"am\",\"name\":\"Amharisch\"},{\"code\":\"ar\",\"name\":\"Arabisch\"},{\"code\":\"az\",\"name\":\"Azerbeidzjaans\"},{\"code\":\"eu\",\"name\":\"Baskisch\"},{\"code\":\"bg\",\"name\":\"Bulgaars\"},{\"code\":\"ca\",\"name\":\"Catalaans\"},{\"code\":\"zh-tw\",\"name\":\"Chinees (traditioneel)\"},{\"code\":\"zh-cn\",\"name\":\"Chinees (vereenvoudigd)\"},{\"code\":\"da\",\"name\":\"Deens\"},{\"code\":\"de\",\"name\":\"Duits\"},{\"code\":\"en\",\"name\":\"Engels\"},{\"code\":\"et\",\"name\":\"Ests\"},{\"code\":\"fi\",\"name\":\"Fins\"},{\"code\":\"fr\",\"name\":\"Frans\"},{\"code\":\"gl\",\"name\":\"Galicisch\"},{\"code\":\"el\",\"name\":\"Grieks\"},{\"code\":\"he\",\"name\":\"Hebreeuws\"},{\"code\":\"hu\",\"name\":\"Hongaars\"},{\"code\":\"ga\",\"name\":\"Iers\"},{\"code\":\"is\",\"name\":\"IJslands\"},{\"code\":\"id\",\"name\":\"Indonesisch\"},{\"code\":\"it\",\"name\":\"Italiaans\"},{\"code\":\"ja\",\"name\":\"Japans\"},{\"code\":\"ko\",\"name\":\"Koreaans\"},{\"code\":\"hr\",\"name\":\"Kroatisch\"},{\"code\":\"lv\",\"name\":\"Lets\"},{\"code\":\"lt\",\"name\":\"Litouws\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Nederlands\"},{\"code\":\"nb\",\"name\":\"Noors\"},{\"code\":\"uk\",\"name\":\"Oekraïens\"},{\"code\":\"fa\",\"name\":\"Perzisch\"},{\"code\":\"pl\",\"name\":\"Pools\"},{\"code\":\"pt\",\"name\":\"Portugees\"},{\"code\":\"ro\",\"name\":\"Roemeens\"},{\"code\":\"ru\",\"name\":\"Russisch\"},{\"code\":\"gd\",\"name\":\"Schots Keltisch\"},{\"code\":\"sr\",\"name\":\"Servisch\"},{\"code\":\"sk\",\"name\":\"Slovaaks\"},{\"code\":\"sl\",\"name\":\"Sloveens\"},{\"code\":\"es\",\"name\":\"Spaans\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"cs\",\"name\":\"Tsjechisch\"},{\"code\":\"tr\",\"name\":\"Turks\"},{\"code\":\"vi\",\"name\":\"Vietnamees\"},{\"code\":\"cy\",\"name\":\"Wels\"},{\"code\":\"zu\",\"name\":\"Zoeloe\"},{\"code\":\"sv\",\"name\":\"Zweeds\"}],\"gd\":[{\"code\":\"am\",\"name\":\"Amtharais\"},{\"code\":\"ar\",\"name\":\"Arabais\"},{\"code\":\"az\",\"name\":\"Asarbaideànais\"},{\"code\":\"eu\",\"name\":\"Basgais\"},{\"code\":\"en\",\"name\":\"Beurla\"},{\"code\":\"vi\",\"name\":\"Bhiet-Namais\"},{\"code\":\"bg\",\"name\":\"Bulgarais\"},{\"code\":\"th\",\"name\":\"Cànan nan Tàidh\"},{\"code\":\"ca\",\"name\":\"Catalanais\"},{\"code\":\"ko\",\"name\":\"Coirèanais\"},{\"code\":\"hr\",\"name\":\"Cròthaisis\"},{\"code\":\"cy\",\"name\":\"Cuimris\"},{\"code\":\"da\",\"name\":\"Danmhairgis\"},{\"code\":\"nl\",\"name\":\"Duitsis\"},{\"code\":\"he\",\"name\":\"Eabhra\"},{\"code\":\"it\",\"name\":\"Eadailtis\"},{\"code\":\"et\",\"name\":\"Eastoinis\"},{\"code\":\"fi\",\"name\":\"Fionnlannais\"},{\"code\":\"fr\",\"name\":\"Fraingis\"},{\"code\":\"ga\",\"name\":\"Gaeilge\"},{\"code\":\"gd\",\"name\":\"Gàidhlig\"},{\"code\":\"gl\",\"name\":\"Gailìsis\"},{\"code\":\"de\",\"name\":\"Gearmailtis\"},{\"code\":\"el\",\"name\":\"Grèigis\"},{\"code\":\"id\",\"name\":\"Innd-Innsis\"},{\"code\":\"is\",\"name\":\"Innis-Tìlis\"},{\"code\":\"lv\",\"name\":\"Laitbheis\"},{\"code\":\"lt\",\"name\":\"Liotuainis\"},{\"code\":\"mi\",\"name\":\"Māori\"},{\"code\":\"nb\",\"name\":\"Nirribhis\"},{\"code\":\"fa\",\"name\":\"Peirsis\"},{\"code\":\"pl\",\"name\":\"Pòlainnis\"},{\"code\":\"pt\",\"name\":\"Portagailis\"},{\"code\":\"ro\",\"name\":\"Romàinis\"},{\"code\":\"ru\",\"name\":\"Ruisis\"},{\"code\":\"cs\",\"name\":\"Seacais\"},{\"code\":\"ja\",\"name\":\"Seapanais\"},{\"code\":\"sr\",\"name\":\"Sèirbis\"},{\"code\":\"zh-tw\",\"name\":\"Sìonais (seann-nòsach)\"},{\"code\":\"zh-cn\",\"name\":\"Sìonais (sìmplichte)\"},{\"code\":\"sk\",\"name\":\"Slòbhacais\"},{\"code\":\"sl\",\"name\":\"Slòbhainis\"},{\"code\":\"es\",\"name\":\"Spàinntis\"},{\"code\":\"sv\",\"name\":\"Suainis\"},{\"code\":\"tr\",\"name\":\"Turcais\"},{\"code\":\"uk\",\"name\":\"Ucràinis\"},{\"code\":\"hu\",\"name\":\"Ungairis\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"nb\":[{\"code\":\"am\",\"name\":\"amharisk\"},{\"code\":\"ar\",\"name\":\"arabisk\"},{\"code\":\"az\",\"name\":\"aserbajdsjansk\"},{\"code\":\"eu\",\"name\":\"baskisk\"},{\"code\":\"bg\",\"name\":\"bulgarsk\"},{\"code\":\"da\",\"name\":\"dansk\"},{\"code\":\"en\",\"name\":\"engelsk\"},{\"code\":\"et\",\"name\":\"estisk\"},{\"code\":\"fa\",\"name\":\"farsi\"},{\"code\":\"fi\",\"name\":\"finsk\"},{\"code\":\"fr\",\"name\":\"fransk\"},{\"code\":\"gl\",\"name\":\"galisisk\"},{\"code\":\"el\",\"name\":\"gresk\"},{\"code\":\"he\",\"name\":\"hebraisk\"},{\"code\":\"id\",\"name\":\"indonesisk\"},{\"code\":\"ga\",\"name\":\"irsk\"},{\"code\":\"is\",\"name\":\"islandsk\"},{\"code\":\"it\",\"name\":\"italiensk\"},{\"code\":\"ja\",\"name\":\"japansk\"},{\"code\":\"ca\",\"name\":\"katalansk\"},{\"code\":\"zh-cn\",\"name\":\"kinesisk (forenklet)\"},{\"code\":\"zh-tw\",\"name\":\"kinesisk (tradisjonell)\"},{\"code\":\"ko\",\"name\":\"koreansk\"},{\"code\":\"hr\",\"name\":\"kroatisk\"},{\"code\":\"lv\",\"name\":\"latvisk\"},{\"code\":\"lt\",\"name\":\"litauisk\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"nederlandsk\"},{\"code\":\"nb\",\"name\":\"norsk\"},{\"code\":\"pl\",\"name\":\"polsk\"},{\"code\":\"pt\",\"name\":\"portugisisk\"},{\"code\":\"ro\",\"name\":\"rumensk\"},{\"code\":\"ru\",\"name\":\"russisk\"},{\"code\":\"sr\",\"name\":\"serbisk\"},{\"code\":\"gd\",\"name\":\"skotsk gælisk\"},{\"code\":\"sk\",\"name\":\"slovakisk\"},{\"code\":\"sl\",\"name\":\"slovensk\"},{\"code\":\"es\",\"name\":\"spansk\"},{\"code\":\"sv\",\"name\":\"svensk\"},{\"code\":\"th\",\"name\":\"thai\"},{\"code\":\"cs\",\"name\":\"tsjekkisk\"},{\"code\":\"tr\",\"name\":\"tyrkisk\"},{\"code\":\"de\",\"name\":\"tysk\"},{\"code\":\"uk\",\"name\":\"ukrainsk\"},{\"code\":\"hu\",\"name\":\"ungarsk\"},{\"code\":\"vi\",\"name\":\"vietnamesisk\"},{\"code\":\"cy\",\"name\":\"walisisk\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"de\":[{\"code\":\"am\",\"name\":\"Amharisch\"},{\"code\":\"ar\",\"name\":\"Arabisch\"},{\"code\":\"az\",\"name\":\"Aserbaidschanisch\"},{\"code\":\"eu\",\"name\":\"Baskisch\"},{\"code\":\"bg\",\"name\":\"Bulgarisch\"},{\"code\":\"zh-tw\",\"name\":\"Chinesisch (traditionell)\"},{\"code\":\"zh-cn\",\"name\":\"Chinesisch (vereinfacht)\"},{\"code\":\"da\",\"name\":\"Dänisch\"},{\"code\":\"de\",\"name\":\"Deutsch\"},{\"code\":\"en\",\"name\":\"Englisch\"},{\"code\":\"et\",\"name\":\"Estnisch\"},{\"code\":\"fi\",\"name\":\"Finnisch\"},{\"code\":\"fr\",\"name\":\"Französisch\"},{\"code\":\"gl\",\"name\":\"Galizisch\"},{\"code\":\"el\",\"name\":\"Griechisch\"},{\"code\":\"he\",\"name\":\"Hebräisch\"},{\"code\":\"id\",\"name\":\"Indonesisch\"},{\"code\":\"ga\",\"name\":\"Irisch\"},{\"code\":\"is\",\"name\":\"Isländisch\"},{\"code\":\"it\",\"name\":\"Italienisch\"},{\"code\":\"ja\",\"name\":\"Japanisch\"},{\"code\":\"ca\",\"name\":\"Katalanisch\"},{\"code\":\"ko\",\"name\":\"Koreanisch\"},{\"code\":\"hr\",\"name\":\"Kroatisch\"},{\"code\":\"lv\",\"name\":\"Lettisch\"},{\"code\":\"lt\",\"name\":\"Litauisch\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Niederländisch\"},{\"code\":\"nb\",\"name\":\"Norwegisch\"},{\"code\":\"fa\",\"name\":\"Persisch\"},{\"code\":\"pl\",\"name\":\"Polnisch\"},{\"code\":\"pt\",\"name\":\"Portugiesisch\"},{\"code\":\"ro\",\"name\":\"Rumänisch\"},{\"code\":\"ru\",\"name\":\"Russisch\"},{\"code\":\"gd\",\"name\":\"Schottisch-Gälisch\"},{\"code\":\"sv\",\"name\":\"Schwedisch\"},{\"code\":\"sr\",\"name\":\"Serbisch\"},{\"code\":\"sk\",\"name\":\"Slowakisch\"},{\"code\":\"sl\",\"name\":\"Slowenisch\"},{\"code\":\"es\",\"name\":\"Spanisch\"},{\"code\":\"th\",\"name\":\"Thailändisch\"},{\"code\":\"cs\",\"name\":\"Tschechisch\"},{\"code\":\"tr\",\"name\":\"Türkisch\"},{\"code\":\"uk\",\"name\":\"Ukrainisch\"},{\"code\":\"hu\",\"name\":\"Ungarisch\"},{\"code\":\"vi\",\"name\":\"Vietnamesisch\"},{\"code\":\"cy\",\"name\":\"Walisisch\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"he\":[{\"code\":\"uk\",\"name\":\"אוקראינית\"},{\"code\":\"az\",\"name\":\"אזרית\"},{\"code\":\"it\",\"name\":\"איטלקית\"},{\"code\":\"id\",\"name\":\"אינדונזית\"},{\"code\":\"is\",\"name\":\"איסלנדית\"},{\"code\":\"ga\",\"name\":\"אירית\"},{\"code\":\"am\",\"name\":\"אמהרית\"},{\"code\":\"en\",\"name\":\"אנגלית\"},{\"code\":\"et\",\"name\":\"אסטונית\"},{\"code\":\"eu\",\"name\":\"באסקית\"},{\"code\":\"bg\",\"name\":\"בולגרית\"},{\"code\":\"gl\",\"name\":\"גליציאנית\"},{\"code\":\"de\",\"name\":\"גרמנית\"},{\"code\":\"da\",\"name\":\"דנית\"},{\"code\":\"nl\",\"name\":\"הולנדית\"},{\"code\":\"hu\",\"name\":\"הונגרית\"},{\"code\":\"cy\",\"name\":\"וולשית\"},{\"code\":\"vi\",\"name\":\"וייטנאמית\"},{\"code\":\"zu\",\"name\":\"זולו\"},{\"code\":\"tr\",\"name\":\"טורקית\"},{\"code\":\"el\",\"name\":\"יוונית\"},{\"code\":\"ja\",\"name\":\"יפנית\"},{\"code\":\"lv\",\"name\":\"לטווית\"},{\"code\":\"lt\",\"name\":\"ליטאית\"},{\"code\":\"mi\",\"name\":\"מאורית\"},{\"code\":\"nb\",\"name\":\"נורווגית\"},{\"code\":\"zh-tw\",\"name\":\"סינית (מסורתית)\"},{\"code\":\"zh-cn\",\"name\":\"סינית (פשוטה)\"},{\"code\":\"sl\",\"name\":\"סלובנית\"},{\"code\":\"sk\",\"name\":\"סלובקית\"},{\"code\":\"es\",\"name\":\"ספרדית\"},{\"code\":\"gd\",\"name\":\"סקוטית גאלית\"},{\"code\":\"sr\",\"name\":\"סרבית\"},{\"code\":\"he\",\"name\":\"עברית\"},{\"code\":\"ar\",\"name\":\"ערבית\"},{\"code\":\"pl\",\"name\":\"פולנית\"},{\"code\":\"pt\",\"name\":\"פורטוגזית\"},{\"code\":\"fi\",\"name\":\"פינית\"},{\"code\":\"fa\",\"name\":\"פרסית\"},{\"code\":\"cs\",\"name\":\"צ'כית\"},{\"code\":\"fr\",\"name\":\"צרפתית\"},{\"code\":\"ko\",\"name\":\"קוריאנית\"},{\"code\":\"ca\",\"name\":\"קטלאנית\"},{\"code\":\"hr\",\"name\":\"קרואטית\"},{\"code\":\"ro\",\"name\":\"רומנית\"},{\"code\":\"ru\",\"name\":\"רוסית\"},{\"code\":\"sv\",\"name\":\"שוודית\"},{\"code\":\"th\",\"name\":\"תאילנדית\"}],\"sk\":[{\"code\":\"am\",\"name\":\"amharčina\"},{\"code\":\"en\",\"name\":\"angličtina\"},{\"code\":\"ar\",\"name\":\"arabčina\"},{\"code\":\"az\",\"name\":\"azerbajdžančina\"},{\"code\":\"eu\",\"name\":\"baskičtina\"},{\"code\":\"bg\",\"name\":\"bulharčina\"},{\"code\":\"cs\",\"name\":\"čeština\"},{\"code\":\"zh-tw\",\"name\":\"čínština (tradičná)\"},{\"code\":\"zh-cn\",\"name\":\"čínština (zjednodušená)\"},{\"code\":\"da\",\"name\":\"dánčina\"},{\"code\":\"et\",\"name\":\"estónčina\"},{\"code\":\"fi\",\"name\":\"fínčina\"},{\"code\":\"fr\",\"name\":\"francúzština\"},{\"code\":\"gl\",\"name\":\"galícijčina\"},{\"code\":\"el\",\"name\":\"gréčtina\"},{\"code\":\"he\",\"name\":\"hebrejčina\"},{\"code\":\"nl\",\"name\":\"holandčina\"},{\"code\":\"hr\",\"name\":\"chorvátčina\"},{\"code\":\"id\",\"name\":\"indonézština\"},{\"code\":\"ga\",\"name\":\"írčina\"},{\"code\":\"is\",\"name\":\"islandčina\"},{\"code\":\"ja\",\"name\":\"japončina\"},{\"code\":\"ca\",\"name\":\"katalánčina\"},{\"code\":\"ko\",\"name\":\"kórejčina\"},{\"code\":\"lt\",\"name\":\"litovčina\"},{\"code\":\"lv\",\"name\":\"lotyština\"},{\"code\":\"hu\",\"name\":\"maďarčina\"},{\"code\":\"mi\",\"name\":\"maorijčina\"},{\"code\":\"de\",\"name\":\"nemčina\"},{\"code\":\"nb\",\"name\":\"nórčina\"},{\"code\":\"fa\",\"name\":\"perzština\"},{\"code\":\"pl\",\"name\":\"poľština\"},{\"code\":\"pt\",\"name\":\"portugalčina\"},{\"code\":\"ro\",\"name\":\"rumunčina\"},{\"code\":\"ru\",\"name\":\"ruština\"},{\"code\":\"sk\",\"name\":\"slovenčina\"},{\"code\":\"sl\",\"name\":\"slovinčina\"},{\"code\":\"sr\",\"name\":\"srbčina\"},{\"code\":\"gd\",\"name\":\"škótska gaelčina\"},{\"code\":\"es\",\"name\":\"španielčina\"},{\"code\":\"sv\",\"name\":\"švédčina\"},{\"code\":\"it\",\"name\":\"taliančina\"},{\"code\":\"th\",\"name\":\"thajčina\"},{\"code\":\"tr\",\"name\":\"turečtina\"},{\"code\":\"uk\",\"name\":\"ukrajinčina\"},{\"code\":\"vi\",\"name\":\"vietnamčina\"},{\"code\":\"cy\",\"name\":\"waleština\"},{\"code\":\"zu\",\"name\":\"zuluština\"}],\"zu\":[{\"code\":\"am\",\"name\":\"isi-Amharic\"},{\"code\":\"ar\",\"name\":\"isi-Arabic\"},{\"code\":\"az\",\"name\":\"Isi-Azerbaijani\"},{\"code\":\"eu\",\"name\":\"isi-Basque\"},{\"code\":\"bg\",\"name\":\"isi-Bulgarian\"},{\"code\":\"ca\",\"name\":\"isi-Catalan\"},{\"code\":\"zh-cn\",\"name\":\"isi-Chinese (Simplified)\"},{\"code\":\"zh-tw\",\"name\":\"isi-Chinese (Traditional)\"},{\"code\":\"hr\",\"name\":\"isi-Croatian\"},{\"code\":\"cs\",\"name\":\"isi-Czech\"},{\"code\":\"da\",\"name\":\"isi-Danish\"},{\"code\":\"nl\",\"name\":\"isi-Dutch\"},{\"code\":\"en\",\"name\":\"isi-English\"},{\"code\":\"et\",\"name\":\"isi-Estonian\"},{\"code\":\"fi\",\"name\":\"isi-Finnish\"},{\"code\":\"fr\",\"name\":\"isi-French\"},{\"code\":\"gl\",\"name\":\"isi-Galician\"},{\"code\":\"de\",\"name\":\"isi-German\"},{\"code\":\"el\",\"name\":\"isi-Greek\"},{\"code\":\"hu\",\"name\":\"isi-Hangarian\"},{\"code\":\"he\",\"name\":\"isi-Hebrew\"},{\"code\":\"is\",\"name\":\"isi-Icelandic\"},{\"code\":\"id\",\"name\":\"isi-Indonesian\"},{\"code\":\"ga\",\"name\":\"isi-Irish\"},{\"code\":\"it\",\"name\":\"isi-Italian\"},{\"code\":\"ja\",\"name\":\"isi-Japanese\"},{\"code\":\"ko\",\"name\":\"isi-Korean\"},{\"code\":\"lv\",\"name\":\"isi-Latvian\"},{\"code\":\"lt\",\"name\":\"isi-Lithuanian\"},{\"code\":\"mi\",\"name\":\"isi-Maori\"},{\"code\":\"nb\",\"name\":\"isi-Norwegian\"},{\"code\":\"fa\",\"name\":\"isi-Persian\"},{\"code\":\"pl\",\"name\":\"isi-Polish\"},{\"code\":\"pt\",\"name\":\"isi-Portuguese\"},{\"code\":\"ro\",\"name\":\"isi-Romanian\"},{\"code\":\"ru\",\"name\":\"isi-Russian\"},{\"code\":\"gd\",\"name\":\"isi-Scots Gaelic\"},{\"code\":\"sr\",\"name\":\"isi-Serbian\"},{\"code\":\"sk\",\"name\":\"isi-Slovak\"},{\"code\":\"sl\",\"name\":\"isi-Slovenian\"},{\"code\":\"es\",\"name\":\"isi-Spanish\"},{\"code\":\"sv\",\"name\":\"isi-Swedish\"},{\"code\":\"th\",\"name\":\"isi-Thai\"},{\"code\":\"tr\",\"name\":\"isi-Turkish\"},{\"code\":\"uk\",\"name\":\"isi-Ukrainian\"},{\"code\":\"vi\",\"name\":\"isi-Vietnamese\"},{\"code\":\"cy\",\"name\":\"isi-Welsh\"},{\"code\":\"zu\",\"name\":\"isiZulu\"}],\"ru\":[{\"code\":\"az\",\"name\":\"азербайджанский\"},{\"code\":\"am\",\"name\":\"амхарский\"},{\"code\":\"en\",\"name\":\"английский\"},{\"code\":\"ar\",\"name\":\"арабский\"},{\"code\":\"eu\",\"name\":\"баскский\"},{\"code\":\"bg\",\"name\":\"болгарский\"},{\"code\":\"cy\",\"name\":\"валлийский\"},{\"code\":\"hu\",\"name\":\"венгерский\"},{\"code\":\"vi\",\"name\":\"вьетнамский\"},{\"code\":\"gl\",\"name\":\"галисийский\"},{\"code\":\"el\",\"name\":\"греческий\"},{\"code\":\"da\",\"name\":\"датский\"},{\"code\":\"zu\",\"name\":\"зулу\"},{\"code\":\"he\",\"name\":\"иврит\"},{\"code\":\"id\",\"name\":\"индонезийский\"},{\"code\":\"ga\",\"name\":\"ирландский\"},{\"code\":\"is\",\"name\":\"исландский\"},{\"code\":\"es\",\"name\":\"испанский\"},{\"code\":\"it\",\"name\":\"итальянский\"},{\"code\":\"ca\",\"name\":\"каталанский\"},{\"code\":\"zh-tw\",\"name\":\"китайский (традиционный)\"},{\"code\":\"zh-cn\",\"name\":\"китайский (упрощенный)\"},{\"code\":\"ko\",\"name\":\"корейский\"},{\"code\":\"lv\",\"name\":\"латышский\"},{\"code\":\"lt\",\"name\":\"литовский\"},{\"code\":\"mi\",\"name\":\"маори\"},{\"code\":\"de\",\"name\":\"немецкий\"},{\"code\":\"nl\",\"name\":\"нидерландский\"},{\"code\":\"nb\",\"name\":\"норвежский\"},{\"code\":\"fa\",\"name\":\"персидский\"},{\"code\":\"pl\",\"name\":\"польский\"},{\"code\":\"pt\",\"name\":\"португальский\"},{\"code\":\"ro\",\"name\":\"румынский\"},{\"code\":\"ru\",\"name\":\"русский\"},{\"code\":\"sr\",\"name\":\"сербский\"},{\"code\":\"sk\",\"name\":\"словацкий\"},{\"code\":\"sl\",\"name\":\"словенский\"},{\"code\":\"th\",\"name\":\"тайский\"},{\"code\":\"tr\",\"name\":\"турецкий\"},{\"code\":\"uk\",\"name\":\"украинский\"},{\"code\":\"fi\",\"name\":\"финский\"},{\"code\":\"fr\",\"name\":\"французский\"},{\"code\":\"hr\",\"name\":\"хорватский\"},{\"code\":\"cs\",\"name\":\"чешский\"},{\"code\":\"sv\",\"name\":\"шведский\"},{\"code\":\"gd\",\"name\":\"шотландский (гэльский)\"},{\"code\":\"et\",\"name\":\"эстонский\"},{\"code\":\"ja\",\"name\":\"японский\"}],\"pl\":[{\"code\":\"am\",\"name\":\"amharski\"},{\"code\":\"en\",\"name\":\"angielski\"},{\"code\":\"ar\",\"name\":\"arabski\"},{\"code\":\"az\",\"name\":\"azerski\"},{\"code\":\"eu\",\"name\":\"baskijski\"},{\"code\":\"bg\",\"name\":\"bułgarski\"},{\"code\":\"zh-tw\",\"name\":\"chiński (tradycyjny)\"},{\"code\":\"zh-cn\",\"name\":\"chiński (uproszczony)\"},{\"code\":\"hr\",\"name\":\"chorwacki\"},{\"code\":\"cs\",\"name\":\"czeski\"},{\"code\":\"da\",\"name\":\"duński\"},{\"code\":\"et\",\"name\":\"estoński\"},{\"code\":\"fi\",\"name\":\"fiński\"},{\"code\":\"fr\",\"name\":\"francuski\"},{\"code\":\"gl\",\"name\":\"galicyjski\"},{\"code\":\"el\",\"name\":\"grecki\"},{\"code\":\"he\",\"name\":\"hebrajski\"},{\"code\":\"es\",\"name\":\"hiszpański\"},{\"code\":\"id\",\"name\":\"indonezyjski\"},{\"code\":\"ga\",\"name\":\"irlandzki\"},{\"code\":\"is\",\"name\":\"islandzki\"},{\"code\":\"ja\",\"name\":\"japoński\"},{\"code\":\"ca\",\"name\":\"kataloński\"},{\"code\":\"ko\",\"name\":\"koreański\"},{\"code\":\"lt\",\"name\":\"litewski\"},{\"code\":\"lv\",\"name\":\"łotewski\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"niderlandzki\"},{\"code\":\"de\",\"name\":\"niemiecki\"},{\"code\":\"nb\",\"name\":\"norweski\"},{\"code\":\"fa\",\"name\":\"perski\"},{\"code\":\"pl\",\"name\":\"polski\"},{\"code\":\"pt\",\"name\":\"portugalski\"},{\"code\":\"ru\",\"name\":\"rosyjski\"},{\"code\":\"ro\",\"name\":\"rumuński\"},{\"code\":\"sr\",\"name\":\"serbski\"},{\"code\":\"sk\",\"name\":\"słowacki\"},{\"code\":\"sl\",\"name\":\"słoweński\"},{\"code\":\"gd\",\"name\":\"szkocki gaelicki\"},{\"code\":\"sv\",\"name\":\"szwedzki\"},{\"code\":\"th\",\"name\":\"tajski\"},{\"code\":\"tr\",\"name\":\"turecki\"},{\"code\":\"uk\",\"name\":\"ukraiński\"},{\"code\":\"cy\",\"name\":\"walijski\"},{\"code\":\"hu\",\"name\":\"węgierski\"},{\"code\":\"vi\",\"name\":\"wietnamski\"},{\"code\":\"it\",\"name\":\"włoski\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"am\":[{\"code\":\"hu\",\"name\":\"ሀንጋሪኛ\"},{\"code\":\"lt\",\"name\":\"ሊትዌንኛ\"},{\"code\":\"lv\",\"name\":\"ላትቪያኛ\"},{\"code\":\"mi\",\"name\":\"ማዮሪኛ\"},{\"code\":\"ru\",\"name\":\"ራሽያኛ\"},{\"code\":\"ro\",\"name\":\"ሮማኒያንኛ\"},{\"code\":\"sr\",\"name\":\"ሰርቢያኛ\"},{\"code\":\"sk\",\"name\":\"ስሎቫክኛ\"},{\"code\":\"sl\",\"name\":\"ስሎቬንያኛ\"},{\"code\":\"sv\",\"name\":\"ስዊድንኛ\"},{\"code\":\"es\",\"name\":\"ስፓኒሽኛ\"},{\"code\":\"bg\",\"name\":\"ቡልጋሪያኛ\"},{\"code\":\"eu\",\"name\":\"ባስክኛ\"},{\"code\":\"vi\",\"name\":\"ቪትናምኛ\"},{\"code\":\"tr\",\"name\":\"ቱርክኛ\"},{\"code\":\"th\",\"name\":\"ታይኛ\"},{\"code\":\"zh-cn\",\"name\":\"ቻይንኛ   (ቀላሉ)\"},{\"code\":\"zh-tw\",\"name\":\"ቻይንኛ  (ባሕላዊው)\"},{\"code\":\"cs\",\"name\":\"ቼክኛ\"},{\"code\":\"nb\",\"name\":\"ኖርዌጅያንኛ\"},{\"code\":\"am\",\"name\":\"አማርኛ\"},{\"code\":\"az\",\"name\":\"አዜርባይጃንኛ\"},{\"code\":\"ga\",\"name\":\"አይሪሽ\"},{\"code\":\"is\",\"name\":\"አይስላንድኛ\"},{\"code\":\"et\",\"name\":\"ኤስቶኒያኛ\"},{\"code\":\"id\",\"name\":\"እንዶኔዢያኛ\"},{\"code\":\"en\",\"name\":\"እንግሊዝኛ\"},{\"code\":\"ca\",\"name\":\"ካታላንኛ\"},{\"code\":\"hr\",\"name\":\"ክሮኤሽያኛ\"},{\"code\":\"ko\",\"name\":\"ኮሪያኛ\"},{\"code\":\"cy\",\"name\":\"ዌልሽ\"},{\"code\":\"ar\",\"name\":\"ዐረብኛ\"},{\"code\":\"he\",\"name\":\"ዕብራይስጥ\"},{\"code\":\"zu\",\"name\":\"ዙሉኛ\"},{\"code\":\"gd\",\"name\":\"የስኮት ጌልክኛ\"},{\"code\":\"uk\",\"name\":\"ዩክሬንኛ\"},{\"code\":\"nl\",\"name\":\"ደችኛ\"},{\"code\":\"da\",\"name\":\"ዴንሽኛ\"},{\"code\":\"de\",\"name\":\"ጀርመንኛ\"},{\"code\":\"ja\",\"name\":\"ጃፓንኛ\"},{\"code\":\"gl\",\"name\":\"ጋሊሺያኛ\"},{\"code\":\"el\",\"name\":\"ግሪክኛ\"},{\"code\":\"it\",\"name\":\"ጣሊያንኛ\"},{\"code\":\"fr\",\"name\":\"ፈረንሳይኛ\"},{\"code\":\"fi\",\"name\":\"ፊኒሽኛ\"},{\"code\":\"fa\",\"name\":\"ፐርሺያኛ\"},{\"code\":\"pl\",\"name\":\"ፖሊሽኛ\"},{\"code\":\"pt\",\"name\":\"ፖርቱጋሊኛ\"}],\"az\":[{\"code\":\"de\",\"name\":\"Alman\"},{\"code\":\"am\",\"name\":\"Amarikcə\"},{\"code\":\"az\",\"name\":\"Azərbaycan dili\"},{\"code\":\"eu\",\"name\":\"Bask\"},{\"code\":\"bg\",\"name\":\"Bolqar\"},{\"code\":\"cs\",\"name\":\"Çex\"},{\"code\":\"zh-tw\",\"name\":\"Çin (Ən'ənəvi)\"},{\"code\":\"zh-cn\",\"name\":\"Çin (Sadələşdirilmiş)\"},{\"code\":\"da\",\"name\":\"Danimarka\"},{\"code\":\"et\",\"name\":\"Eston\"},{\"code\":\"ar\",\"name\":\"Ərəb\"},{\"code\":\"fa\",\"name\":\"Fars Dili\"},{\"code\":\"fi\",\"name\":\"Fin\"},{\"code\":\"fr\",\"name\":\"Fransız\"},{\"code\":\"nl\",\"name\":\"Holland\"},{\"code\":\"hr\",\"name\":\"Xorvat\"},{\"code\":\"es\",\"name\":\"Ispan\"},{\"code\":\"id\",\"name\":\"İndoneziya\"},{\"code\":\"en\",\"name\":\"İngilis\"},{\"code\":\"ga\",\"name\":\"İrland\"},{\"code\":\"is\",\"name\":\"İsland\"},{\"code\":\"sv\",\"name\":\"İsveç\"},{\"code\":\"it\",\"name\":\"İtalyan\"},{\"code\":\"he\",\"name\":\"İvrit\"},{\"code\":\"ca\",\"name\":\"Katalan\"},{\"code\":\"ko\",\"name\":\"Koreya\"},{\"code\":\"gl\",\"name\":\"Qalisian\"},{\"code\":\"lv\",\"name\":\"Latış\"},{\"code\":\"lt\",\"name\":\"Litva\"},{\"code\":\"hu\",\"name\":\"Macar\"},{\"code\":\"mi\",\"name\":\"Maoricə\"},{\"code\":\"nb\",\"name\":\"Norveç\"},{\"code\":\"pl\",\"name\":\"Polyak\"},{\"code\":\"pt\",\"name\":\"Portuqal\"},{\"code\":\"ro\",\"name\":\"Rumın\"},{\"code\":\"ru\",\"name\":\"Rus\"},{\"code\":\"sr\",\"name\":\"Serb\"},{\"code\":\"sk\",\"name\":\"Slovak\"},{\"code\":\"sl\",\"name\":\"Sloven\"},{\"code\":\"gd\",\"name\":\"Şotland (Kelt)\"},{\"code\":\"th\",\"name\":\"Tayca\"},{\"code\":\"tr\",\"name\":\"Türk\"},{\"code\":\"cy\",\"name\":\"Uels\"},{\"code\":\"uk\",\"name\":\"Ukrayna\"},{\"code\":\"vi\",\"name\":\"Vyetnam\"},{\"code\":\"ja\",\"name\":\"Yapon\"},{\"code\":\"el\",\"name\":\"Yunan\"},{\"code\":\"zu\",\"name\":\"Zulu dili\"}],\"hr\":[{\"code\":\"am\",\"name\":\"amharik\"},{\"code\":\"ar\",\"name\":\"arapski\"},{\"code\":\"az\",\"name\":\"azerbajdžanski\"},{\"code\":\"eu\",\"name\":\"baskijski\"},{\"code\":\"bg\",\"name\":\"bugarski\"},{\"code\":\"cs\",\"name\":\"češki\"},{\"code\":\"da\",\"name\":\"danski\"},{\"code\":\"en\",\"name\":\"engleski\"},{\"code\":\"et\",\"name\":\"estonski\"},{\"code\":\"fi\",\"name\":\"finski\"},{\"code\":\"fr\",\"name\":\"francuski\"},{\"code\":\"gl\",\"name\":\"galski\"},{\"code\":\"el\",\"name\":\"grčki\"},{\"code\":\"he\",\"name\":\"hebrejski\"},{\"code\":\"hr\",\"name\":\"hrvatski\"},{\"code\":\"id\",\"name\":\"indonezijski\"},{\"code\":\"ga\",\"name\":\"irski\"},{\"code\":\"is\",\"name\":\"islandski\"},{\"code\":\"ja\",\"name\":\"japanski\"},{\"code\":\"ca\",\"name\":\"katalonski\"},{\"code\":\"zh-cn\",\"name\":\"kineski (pojednost.)\"},{\"code\":\"zh-tw\",\"name\":\"kineski (tradicionalni)\"},{\"code\":\"ko\",\"name\":\"korejski\"},{\"code\":\"lv\",\"name\":\"latvijski/letonski\"},{\"code\":\"lt\",\"name\":\"litvanski\"},{\"code\":\"hu\",\"name\":\"mađarski\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"nizozemski\"},{\"code\":\"nb\",\"name\":\"norveški\"},{\"code\":\"de\",\"name\":\"njemački\"},{\"code\":\"fa\",\"name\":\"perzijski\"},{\"code\":\"pl\",\"name\":\"poljski\"},{\"code\":\"pt\",\"name\":\"portugalski\"},{\"code\":\"ro\",\"name\":\"rumunjski\"},{\"code\":\"ru\",\"name\":\"ruski\"},{\"code\":\"sk\",\"name\":\"slovački\"},{\"code\":\"sl\",\"name\":\"slovenski\"},{\"code\":\"sr\",\"name\":\"srpski\"},{\"code\":\"gd\",\"name\":\"škotski keltski\"},{\"code\":\"es\",\"name\":\"španjolski\"},{\"code\":\"sv\",\"name\":\"švedski\"},{\"code\":\"th\",\"name\":\"tajlandski\"},{\"code\":\"it\",\"name\":\"talijanski\"},{\"code\":\"tr\",\"name\":\"turski\"},{\"code\":\"uk\",\"name\":\"ukrajinski\"},{\"code\":\"cy\",\"name\":\"velški\"},{\"code\":\"vi\",\"name\":\"vijetnamski\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"fa\":[{\"code\":\"az\",\"name\":\"آذرباﻳﺠﺎﻧﻰ\"},{\"code\":\"de\",\"name\":\"آلمانی\"},{\"code\":\"es\",\"name\":\"اسپانیایی\"},{\"code\":\"et\",\"name\":\"استونيايی\"},{\"code\":\"sk\",\"name\":\"اسلواکی\"},{\"code\":\"sl\",\"name\":\"اسلونیایی\"},{\"code\":\"uk\",\"name\":\"اکراينی\"},{\"code\":\"am\",\"name\":\"امهری\"},{\"code\":\"id\",\"name\":\"اندونزيايی\"},{\"code\":\"en\",\"name\":\"انگلیسی\"},{\"code\":\"it\",\"name\":\"ایتالیایی\"},{\"code\":\"ga\",\"name\":\"ایرلندی\"},{\"code\":\"is\",\"name\":\"ايسلندی\"},{\"code\":\"eu\",\"name\":\"باسکی\"},{\"code\":\"bg\",\"name\":\"بلغاری\"},{\"code\":\"pt\",\"name\":\"پرتغالی\"},{\"code\":\"th\",\"name\":\"تايلندی\"},{\"code\":\"tr\",\"name\":\"ترکی استانبولی\"},{\"code\":\"cs\",\"name\":\"چک\"},{\"code\":\"zh-cn\",\"name\":\"چینی (ساده‌شده)\"},{\"code\":\"zh-tw\",\"name\":\"چینی (سنتی)\"},{\"code\":\"da\",\"name\":\"دانمارکی\"},{\"code\":\"ru\",\"name\":\"روسی\"},{\"code\":\"ro\",\"name\":\"رومانيايی\"},{\"code\":\"zu\",\"name\":\"زولو\"},{\"code\":\"ja\",\"name\":\"ژاپنی\"},{\"code\":\"sv\",\"name\":\"سوئدی\"},{\"code\":\"sr\",\"name\":\"صربی\"},{\"code\":\"he\",\"name\":\"عبری\"},{\"code\":\"ar\",\"name\":\"عربی\"},{\"code\":\"fa\",\"name\":\"فارسی\"},{\"code\":\"fr\",\"name\":\"فرانسوی\"},{\"code\":\"fi\",\"name\":\"فنلاندی\"},{\"code\":\"ca\",\"name\":\"کاتالان\"},{\"code\":\"hr\",\"name\":\"کرواتی\"},{\"code\":\"ko\",\"name\":\"کره‌ای\"},{\"code\":\"gl\",\"name\":\"گالیسی\"},{\"code\":\"gd\",\"name\":\"گاليک اسکاتلندی\"},{\"code\":\"lv\",\"name\":\"لتونيايی\"},{\"code\":\"pl\",\"name\":\"لهستانی\"},{\"code\":\"lt\",\"name\":\"ليتوانيايی\"},{\"code\":\"mi\",\"name\":\"مائوری\"},{\"code\":\"hu\",\"name\":\"مجاری\"},{\"code\":\"nb\",\"name\":\"نروژی\"},{\"code\":\"cy\",\"name\":\"ولزی\"},{\"code\":\"vi\",\"name\":\"ويتنامی\"},{\"code\":\"nl\",\"name\":\"هلندی\"},{\"code\":\"el\",\"name\":\"يونانی\"}],\"mi\":[{\"code\":\"az\",\"name\":\"Ahepaitani\"},{\"code\":\"ga\",\"name\":\"Airihi\"},{\"code\":\"am\",\"name\":\"Amariki\"},{\"code\":\"ar\",\"name\":\"Arapi\"},{\"code\":\"et\",\"name\":\"Etōnia\"},{\"code\":\"zh-tw\",\"name\":\"Haina (Onamata)\"},{\"code\":\"zh-cn\",\"name\":\"Hainamana (Kua whakamāmātia)\"},{\"code\":\"hu\",\"name\":\"Hanekeria\"},{\"code\":\"ja\",\"name\":\"Hapanihi\"},{\"code\":\"sr\",\"name\":\"Herepia\"},{\"code\":\"fi\",\"name\":\"Hinerangi\"},{\"code\":\"he\",\"name\":\"Hiperu\"},{\"code\":\"sk\",\"name\":\"Horowākia\"},{\"code\":\"sl\",\"name\":\"Horowinia\"},{\"code\":\"sv\",\"name\":\"Huitene\"},{\"code\":\"zu\",\"name\":\"Huru\"},{\"code\":\"en\",\"name\":\"Ingarihi\"},{\"code\":\"id\",\"name\":\"Initonīhia\"},{\"code\":\"it\",\"name\":\"Itāriana\"},{\"code\":\"gl\",\"name\":\"Karihia\"},{\"code\":\"ca\",\"name\":\"Katarāna\"},{\"code\":\"el\",\"name\":\"Kiriki\"},{\"code\":\"ko\",\"name\":\"Kōreana\"},{\"code\":\"hr\",\"name\":\"Koroātiana\"},{\"code\":\"tr\",\"name\":\"Korukoru\"},{\"code\":\"mi\",\"name\":\"Māori\"},{\"code\":\"nb\",\"name\":\"Nōwei\"},{\"code\":\"eu\",\"name\":\"Pākihi\"},{\"code\":\"es\",\"name\":\"Pāniora\"},{\"code\":\"fa\",\"name\":\"Perēhia\"},{\"code\":\"pl\",\"name\":\"Pōrana\"},{\"code\":\"pt\",\"name\":\"Potukīhi\"},{\"code\":\"bg\",\"name\":\"Purukāriana\"},{\"code\":\"lv\",\"name\":\"Rāwhiana\"},{\"code\":\"lt\",\"name\":\"Rituānia\"},{\"code\":\"ro\",\"name\":\"Romānia\"},{\"code\":\"ru\",\"name\":\"Rūhia\"},{\"code\":\"th\",\"name\":\"Tai\"},{\"code\":\"nl\",\"name\":\"Tati\"},{\"code\":\"da\",\"name\":\"Tenemāka\"},{\"code\":\"de\",\"name\":\"Tiamana\"},{\"code\":\"cs\",\"name\":\"Tieke\"},{\"code\":\"is\",\"name\":\"Tiorangi\"},{\"code\":\"gd\",\"name\":\"Tuauri Kotarangi\"},{\"code\":\"uk\",\"name\":\"Ūkareiana\"},{\"code\":\"cy\",\"name\":\"Wēra\"},{\"code\":\"vi\",\"name\":\"Whitināmu\"},{\"code\":\"fr\",\"name\":\"Wīwī\"}],\"el\":[{\"code\":\"en\",\"name\":\"Αγγλικά\"},{\"code\":\"az\",\"name\":\"Αζερμπαϊτζανικά\"},{\"code\":\"am\",\"name\":\"Αμχαρικά\"},{\"code\":\"ar\",\"name\":\"Αραβικά\"},{\"code\":\"eu\",\"name\":\"Βασκικά\"},{\"code\":\"vi\",\"name\":\"Βιετναμεζικά\"},{\"code\":\"bg\",\"name\":\"Βουλγαρικά\"},{\"code\":\"gd\",\"name\":\"Γαελικά Σκοτίας\"},{\"code\":\"gl\",\"name\":\"Γαλικιακά\"},{\"code\":\"fr\",\"name\":\"Γαλλικά\"},{\"code\":\"de\",\"name\":\"Γερμανικά\"},{\"code\":\"da\",\"name\":\"Δανικά\"},{\"code\":\"he\",\"name\":\"Εβραϊκά\"},{\"code\":\"el\",\"name\":\"Ελληνικά\"},{\"code\":\"et\",\"name\":\"Εσθονικά\"},{\"code\":\"zu\",\"name\":\"Ζουλού\"},{\"code\":\"ja\",\"name\":\"Ιαπωνικά\"},{\"code\":\"id\",\"name\":\"Ινδονησιακά\"},{\"code\":\"ga\",\"name\":\"Ιρλανδικά\"},{\"code\":\"is\",\"name\":\"Ισλανδικά\"},{\"code\":\"es\",\"name\":\"Ισπανικά\"},{\"code\":\"it\",\"name\":\"Ιταλικά\"},{\"code\":\"ca\",\"name\":\"Καταλανικά\"},{\"code\":\"zh-cn\",\"name\":\"Κινέζικα (Απλοποιημένα)\"},{\"code\":\"zh-tw\",\"name\":\"Κινέζικα (Παραδοσιακά)\"},{\"code\":\"ko\",\"name\":\"Κορεατικά\"},{\"code\":\"hr\",\"name\":\"Κροατικά\"},{\"code\":\"lv\",\"name\":\"Λετονικά\"},{\"code\":\"lt\",\"name\":\"Λιθουανικά\"},{\"code\":\"mi\",\"name\":\"Μαορί\"},{\"code\":\"nb\",\"name\":\"Νορβηγικά\"},{\"code\":\"nl\",\"name\":\"Ολλανδικά\"},{\"code\":\"cy\",\"name\":\"Ουαλικά\"},{\"code\":\"hu\",\"name\":\"Ουγγρικά\"},{\"code\":\"uk\",\"name\":\"Ουκρανικά\"},{\"code\":\"fa\",\"name\":\"Περσικά\"},{\"code\":\"pl\",\"name\":\"Πολωνικά\"},{\"code\":\"pt\",\"name\":\"Πορτογαλικά\"},{\"code\":\"ro\",\"name\":\"Ρουμανικά\"},{\"code\":\"ru\",\"name\":\"Ρωσικά\"},{\"code\":\"sr\",\"name\":\"Σερβικά\"},{\"code\":\"sk\",\"name\":\"Σλοβακικά\"},{\"code\":\"sl\",\"name\":\"Σλοβενικά\"},{\"code\":\"sv\",\"name\":\"Σουηδικά\"},{\"code\":\"th\",\"name\":\"Ταϊλανδεζικά\"},{\"code\":\"tr\",\"name\":\"Τούρκικα\"},{\"code\":\"cs\",\"name\":\"Τσεχικά\"},{\"code\":\"fi\",\"name\":\"Φινλανδικά\"}],\"is\":[{\"code\":\"am\",\"name\":\"amharísku\"},{\"code\":\"ar\",\"name\":\"arabíska\"},{\"code\":\"az\",\"name\":\"aserska\"},{\"code\":\"eu\",\"name\":\"baskneska\"},{\"code\":\"bg\",\"name\":\"búlgarska\"},{\"code\":\"da\",\"name\":\"danska\"},{\"code\":\"et\",\"name\":\"eistneska\"},{\"code\":\"en\",\"name\":\"enska\"},{\"code\":\"fi\",\"name\":\"finnska\"},{\"code\":\"fr\",\"name\":\"franska\"},{\"code\":\"gl\",\"name\":\"galisíska\"},{\"code\":\"el\",\"name\":\"gríska\"},{\"code\":\"he\",\"name\":\"hebreska\"},{\"code\":\"nl\",\"name\":\"hollenska\"},{\"code\":\"id\",\"name\":\"indónesíska\"},{\"code\":\"ga\",\"name\":\"írska\"},{\"code\":\"is\",\"name\":\"íslenska\"},{\"code\":\"it\",\"name\":\"ítalska\"},{\"code\":\"ja\",\"name\":\"japanska\"},{\"code\":\"ca\",\"name\":\"katalónska\"},{\"code\":\"zh-cn\",\"name\":\"kínverska (einfölduð)\"},{\"code\":\"zh-tw\",\"name\":\"kínverska (hefðbundin)\"},{\"code\":\"ko\",\"name\":\"kóreska\"},{\"code\":\"hr\",\"name\":\"króatíska\"},{\"code\":\"lv\",\"name\":\"lettneska\"},{\"code\":\"lt\",\"name\":\"litháíska\"},{\"code\":\"mi\",\"name\":\"maoríska\"},{\"code\":\"nb\",\"name\":\"norska\"},{\"code\":\"fa\",\"name\":\"persneska\"},{\"code\":\"pt\",\"name\":\"portúgalska\"},{\"code\":\"pl\",\"name\":\"pólska\"},{\"code\":\"ro\",\"name\":\"rúmenska\"},{\"code\":\"ru\",\"name\":\"rússneska\"},{\"code\":\"sr\",\"name\":\"serbneska\"},{\"code\":\"gd\",\"name\":\"skosk-gelíska\"},{\"code\":\"sk\",\"name\":\"slóvakíska\"},{\"code\":\"sl\",\"name\":\"slóvenska\"},{\"code\":\"es\",\"name\":\"spænska\"},{\"code\":\"zu\",\"name\":\"súlú\"},{\"code\":\"sv\",\"name\":\"sænska\"},{\"code\":\"th\",\"name\":\"taílenska\"},{\"code\":\"cs\",\"name\":\"tékkneska\"},{\"code\":\"tr\",\"name\":\"tyrkneska\"},{\"code\":\"hu\",\"name\":\"ungverska\"},{\"code\":\"uk\",\"name\":\"úkraínska\"},{\"code\":\"cy\",\"name\":\"velska\"},{\"code\":\"vi\",\"name\":\"víetnamska\"},{\"code\":\"de\",\"name\":\"þýska\"}],\"fi\":[{\"code\":\"am\",\"name\":\"amhara\"},{\"code\":\"ar\",\"name\":\"arabia\"},{\"code\":\"az\",\"name\":\"azeri\"},{\"code\":\"eu\",\"name\":\"baski\"},{\"code\":\"bg\",\"name\":\"bulgaria\"},{\"code\":\"en\",\"name\":\"englanti\"},{\"code\":\"es\",\"name\":\"espanja\"},{\"code\":\"gl\",\"name\":\"galicia\"},{\"code\":\"he\",\"name\":\"heprea\"},{\"code\":\"nl\",\"name\":\"hollanti\"},{\"code\":\"ga\",\"name\":\"iiri\"},{\"code\":\"id\",\"name\":\"indonesia\"},{\"code\":\"is\",\"name\":\"islanti\"},{\"code\":\"it\",\"name\":\"italia\"},{\"code\":\"ja\",\"name\":\"japani\"},{\"code\":\"ca\",\"name\":\"katalaani\"},{\"code\":\"zh-tw\",\"name\":\"kiina (perinteinen)\"},{\"code\":\"zh-cn\",\"name\":\"kiina (yksinkert.)\"},{\"code\":\"ko\",\"name\":\"korea\"},{\"code\":\"el\",\"name\":\"kreikka\"},{\"code\":\"hr\",\"name\":\"kroatia\"},{\"code\":\"cy\",\"name\":\"kymri\"},{\"code\":\"lv\",\"name\":\"latvia\"},{\"code\":\"lt\",\"name\":\"liettua\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nb\",\"name\":\"norja\"},{\"code\":\"fa\",\"name\":\"persia\"},{\"code\":\"pt\",\"name\":\"portugali\"},{\"code\":\"pl\",\"name\":\"puola\"},{\"code\":\"fr\",\"name\":\"ranska\"},{\"code\":\"ro\",\"name\":\"romania\"},{\"code\":\"sv\",\"name\":\"ruotsi\"},{\"code\":\"de\",\"name\":\"saksa\"},{\"code\":\"sr\",\"name\":\"serbia\"},{\"code\":\"gd\",\"name\":\"skottigaeli\"},{\"code\":\"sk\",\"name\":\"slovakia\"},{\"code\":\"sl\",\"name\":\"slovenia\"},{\"code\":\"fi\",\"name\":\"suomi\"},{\"code\":\"da\",\"name\":\"tanska\"},{\"code\":\"th\",\"name\":\"thai\"},{\"code\":\"cs\",\"name\":\"tsekki\"},{\"code\":\"tr\",\"name\":\"turkki\"},{\"code\":\"uk\",\"name\":\"ukraina\"},{\"code\":\"hu\",\"name\":\"unkari\"},{\"code\":\"ru\",\"name\":\"venäjä\"},{\"code\":\"vi\",\"name\":\"vietnam\"},{\"code\":\"et\",\"name\":\"viro\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"eu\":[{\"code\":\"de\",\"name\":\"alemana\"},{\"code\":\"am\",\"name\":\"amharera\"},{\"code\":\"ar\",\"name\":\"arabiera\"},{\"code\":\"az\",\"name\":\"azerbaijanera\"},{\"code\":\"bg\",\"name\":\"bulgariera\"},{\"code\":\"da\",\"name\":\"daniera\"},{\"code\":\"ro\",\"name\":\"errumaniera\"},{\"code\":\"ru\",\"name\":\"errusiera\"},{\"code\":\"gd\",\"name\":\"Eskoziako gaelera\"},{\"code\":\"sk\",\"name\":\"eslovakiera\"},{\"code\":\"sl\",\"name\":\"esloveniera\"},{\"code\":\"et\",\"name\":\"estoniera\"},{\"code\":\"eu\",\"name\":\"euskara\"},{\"code\":\"fr\",\"name\":\"frantsesa\"},{\"code\":\"cy\",\"name\":\"gaelera\"},{\"code\":\"gl\",\"name\":\"galiziera\"},{\"code\":\"es\",\"name\":\"gaztelania\"},{\"code\":\"el\",\"name\":\"greziera\"},{\"code\":\"he\",\"name\":\"hebreera\"},{\"code\":\"hu\",\"name\":\"hungariera\"},{\"code\":\"id\",\"name\":\"indonesiera\"},{\"code\":\"en\",\"name\":\"ingelesa\"},{\"code\":\"ga\",\"name\":\"irlandera\"},{\"code\":\"is\",\"name\":\"islandiera\"},{\"code\":\"it\",\"name\":\"italiera\"},{\"code\":\"ja\",\"name\":\"japoniera\"},{\"code\":\"ca\",\"name\":\"katalana\"},{\"code\":\"ko\",\"name\":\"koreera\"},{\"code\":\"hr\",\"name\":\"kroaziera\"},{\"code\":\"lv\",\"name\":\"letoniera\"},{\"code\":\"lt\",\"name\":\"lituaniera\"},{\"code\":\"mi\",\"name\":\"maoriera\"},{\"code\":\"nl\",\"name\":\"nederlandera\"},{\"code\":\"nb\",\"name\":\"norvegiera\"},{\"code\":\"fa\",\"name\":\"persiera\"},{\"code\":\"pl\",\"name\":\"poloniera\"},{\"code\":\"pt\",\"name\":\"portugesa\"},{\"code\":\"sr\",\"name\":\"serbiera\"},{\"code\":\"sv\",\"name\":\"suediera\"},{\"code\":\"fi\",\"name\":\"suomiera\"},{\"code\":\"th\",\"name\":\"thaiera\"},{\"code\":\"tr\",\"name\":\"turkiera\"},{\"code\":\"cs\",\"name\":\"txekiera\"},{\"code\":\"zh-cn\",\"name\":\"txinera (soildua)\"},{\"code\":\"zh-tw\",\"name\":\"txinera (tradizionala)\"},{\"code\":\"uk\",\"name\":\"ukrainera\"},{\"code\":\"vi\",\"name\":\"vietnamera\"},{\"code\":\"zu\",\"name\":\"zuluera\"}],\"ca\":[{\"code\":\"de\",\"name\":\"alemany\"},{\"code\":\"am\",\"name\":\"amhàric\"},{\"code\":\"en\",\"name\":\"anglès\"},{\"code\":\"ar\",\"name\":\"àrab\"},{\"code\":\"az\",\"name\":\"àzeri\"},{\"code\":\"eu\",\"name\":\"basc\"},{\"code\":\"bg\",\"name\":\"búlgar\"},{\"code\":\"es\",\"name\":\"castellà\"},{\"code\":\"ca\",\"name\":\"català\"},{\"code\":\"ko\",\"name\":\"coreà\"},{\"code\":\"hr\",\"name\":\"croat\"},{\"code\":\"da\",\"name\":\"danès\"},{\"code\":\"sk\",\"name\":\"eslovac\"},{\"code\":\"sl\",\"name\":\"eslovè\"},{\"code\":\"et\",\"name\":\"estonià\"},{\"code\":\"fi\",\"name\":\"finès\"},{\"code\":\"fr\",\"name\":\"francès\"},{\"code\":\"gd\",\"name\":\"gaèlic escocès\"},{\"code\":\"gl\",\"name\":\"gallec\"},{\"code\":\"cy\",\"name\":\"gal·lès\"},{\"code\":\"el\",\"name\":\"grec\"},{\"code\":\"he\",\"name\":\"hebreu\"},{\"code\":\"hu\",\"name\":\"hongarès\"},{\"code\":\"id\",\"name\":\"indonesi\"},{\"code\":\"ga\",\"name\":\"irlandès\"},{\"code\":\"is\",\"name\":\"islandès\"},{\"code\":\"it\",\"name\":\"italià\"},{\"code\":\"ja\",\"name\":\"japonès\"},{\"code\":\"lv\",\"name\":\"letó\"},{\"code\":\"lt\",\"name\":\"lituà\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"neerlandès\"},{\"code\":\"nb\",\"name\":\"noruec\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polonès\"},{\"code\":\"pt\",\"name\":\"portuguès\"},{\"code\":\"ro\",\"name\":\"romanès\"},{\"code\":\"ru\",\"name\":\"rus\"},{\"code\":\"sr\",\"name\":\"serbi\"},{\"code\":\"sv\",\"name\":\"suec\"},{\"code\":\"th\",\"name\":\"tai\"},{\"code\":\"tr\",\"name\":\"turc\"},{\"code\":\"cs\",\"name\":\"txec\"},{\"code\":\"uk\",\"name\":\"ucraïnès\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"zh-cn\",\"name\":\"xinès (simplificat)\"},{\"code\":\"zh-tw\",\"name\":\"xinès (tradicional)\"},{\"code\":\"zu\",\"name\":\"zulú\"}],\"lv\":[{\"code\":\"am\",\"name\":\"amharu\"},{\"code\":\"en\",\"name\":\"angļu\"},{\"code\":\"ar\",\"name\":\"arābu\"},{\"code\":\"az\",\"name\":\"azerbaidžāņu\"},{\"code\":\"eu\",\"name\":\"basku\"},{\"code\":\"bg\",\"name\":\"bulgāru\"},{\"code\":\"cs\",\"name\":\"čehu\"},{\"code\":\"da\",\"name\":\"dāņu\"},{\"code\":\"he\",\"name\":\"ebreju (ivrits)\"},{\"code\":\"fr\",\"name\":\"franču\"},{\"code\":\"gl\",\"name\":\"galisiešu\"},{\"code\":\"el\",\"name\":\"grieķu\"},{\"code\":\"nl\",\"name\":\"holandiešu\"},{\"code\":\"hr\",\"name\":\"horvātu\"},{\"code\":\"et\",\"name\":\"igauņu\"},{\"code\":\"id\",\"name\":\"indonēziešu\"},{\"code\":\"ga\",\"name\":\"īru\"},{\"code\":\"is\",\"name\":\"īslandiešu\"},{\"code\":\"it\",\"name\":\"itāļu\"},{\"code\":\"ja\",\"name\":\"japāņu\"},{\"code\":\"ca\",\"name\":\"katalāņu\"},{\"code\":\"ko\",\"name\":\"korejiešu\"},{\"code\":\"ru\",\"name\":\"krievu\"},{\"code\":\"zh-tw\",\"name\":\"ķīniešu (tradicionālā)\"},{\"code\":\"zh-cn\",\"name\":\"ķīniešu (vienkāršotā)\"},{\"code\":\"lv\",\"name\":\"latviešu\"},{\"code\":\"lt\",\"name\":\"lietuviešu\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nb\",\"name\":\"norvēģu\"},{\"code\":\"fa\",\"name\":\"persiešu\"},{\"code\":\"pl\",\"name\":\"poļu\"},{\"code\":\"pt\",\"name\":\"portugāļu\"},{\"code\":\"ro\",\"name\":\"rumāņu\"},{\"code\":\"sr\",\"name\":\"serbu\"},{\"code\":\"gd\",\"name\":\"skotu gēlu\"},{\"code\":\"sk\",\"name\":\"slovāku\"},{\"code\":\"sl\",\"name\":\"slovēņu\"},{\"code\":\"fi\",\"name\":\"somu\"},{\"code\":\"es\",\"name\":\"spāņu\"},{\"code\":\"th\",\"name\":\"taju\"},{\"code\":\"tr\",\"name\":\"turku\"},{\"code\":\"uk\",\"name\":\"ukraiņu\"},{\"code\":\"hu\",\"name\":\"ungāru\"},{\"code\":\"de\",\"name\":\"vācu\"},{\"code\":\"cy\",\"name\":\"velsiešu\"},{\"code\":\"vi\",\"name\":\"vjetnamiešu\"},{\"code\":\"zu\",\"name\":\"zulu\"},{\"code\":\"sv\",\"name\":\"zviedru\"}],\"id\":[{\"code\":\"am\",\"name\":\"Amhara\"},{\"code\":\"ar\",\"name\":\"Arab\"},{\"code\":\"az\",\"name\":\"Azerbaijan\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"nl\",\"name\":\"Belanda\"},{\"code\":\"bg\",\"name\":\"Bulgaria\"},{\"code\":\"cs\",\"name\":\"Cek\"},{\"code\":\"zh-cn\",\"name\":\"China (Aks. Sederhana)\"},{\"code\":\"zh-tw\",\"name\":\"China (Aks. Tradisional)\"},{\"code\":\"da\",\"name\":\"Denmark\"},{\"code\":\"et\",\"name\":\"Estonia\"},{\"code\":\"fa\",\"name\":\"Farsi\"},{\"code\":\"fi\",\"name\":\"Finlandia\"},{\"code\":\"ga\",\"name\":\"Gaelig\"},{\"code\":\"gd\",\"name\":\"Gaelik Skotlandia\"},{\"code\":\"gl\",\"name\":\"Galisia\"},{\"code\":\"he\",\"name\":\"Ibrani\"},{\"code\":\"id\",\"name\":\"Indonesia\"},{\"code\":\"en\",\"name\":\"Inggris\"},{\"code\":\"is\",\"name\":\"Islan\"},{\"code\":\"it\",\"name\":\"Italia\"},{\"code\":\"ja\",\"name\":\"Jepang\"},{\"code\":\"de\",\"name\":\"Jerman\"},{\"code\":\"ca\",\"name\":\"Katala\"},{\"code\":\"ko\",\"name\":\"Korea\"},{\"code\":\"hr\",\"name\":\"Kroat\"},{\"code\":\"lv\",\"name\":\"Latvia\"},{\"code\":\"lt\",\"name\":\"Lituania\"},{\"code\":\"hu\",\"name\":\"Magyar\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norsk\"},{\"code\":\"pl\",\"name\":\"Polandia\"},{\"code\":\"pt\",\"name\":\"Portugis\"},{\"code\":\"fr\",\"name\":\"Prancis\"},{\"code\":\"ro\",\"name\":\"Rumania\"},{\"code\":\"ru\",\"name\":\"Rusia\"},{\"code\":\"sr\",\"name\":\"Serb\"},{\"code\":\"sk\",\"name\":\"Slovakia\"},{\"code\":\"sl\",\"name\":\"Slovenia\"},{\"code\":\"es\",\"name\":\"Spanyol\"},{\"code\":\"sv\",\"name\":\"Swensk\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"tr\",\"name\":\"Turki\"},{\"code\":\"uk\",\"name\":\"Ukraina\"},{\"code\":\"vi\",\"name\":\"Vietnam\"},{\"code\":\"cy\",\"name\":\"Wales\"},{\"code\":\"el\",\"name\":\"Yunani\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"es\":[{\"code\":\"de\",\"name\":\"alemán\"},{\"code\":\"am\",\"name\":\"amhárico\"},{\"code\":\"ar\",\"name\":\"árabe\"},{\"code\":\"az\",\"name\":\"azerí\"},{\"code\":\"bg\",\"name\":\"búlgaro\"},{\"code\":\"ca\",\"name\":\"catalán\"},{\"code\":\"cs\",\"name\":\"checo\"},{\"code\":\"zh-cn\",\"name\":\"chino (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"chino (tradicional)\"},{\"code\":\"ko\",\"name\":\"coreano\"},{\"code\":\"hr\",\"name\":\"croata\"},{\"code\":\"da\",\"name\":\"danés\"},{\"code\":\"sk\",\"name\":\"eslovaco\"},{\"code\":\"sl\",\"name\":\"esloveno\"},{\"code\":\"es\",\"name\":\"español\"},{\"code\":\"et\",\"name\":\"estonio\"},{\"code\":\"eu\",\"name\":\"euskera\"},{\"code\":\"fi\",\"name\":\"finlandés\"},{\"code\":\"fr\",\"name\":\"francés\"},{\"code\":\"gd\",\"name\":\"gaélico escocés\"},{\"code\":\"cy\",\"name\":\"galés\"},{\"code\":\"gl\",\"name\":\"gallego\"},{\"code\":\"el\",\"name\":\"griego\"},{\"code\":\"he\",\"name\":\"hebreo\"},{\"code\":\"hu\",\"name\":\"húngaro\"},{\"code\":\"id\",\"name\":\"indonesio\"},{\"code\":\"en\",\"name\":\"inglés\"},{\"code\":\"ga\",\"name\":\"irlandés\"},{\"code\":\"is\",\"name\":\"islandés\"},{\"code\":\"it\",\"name\":\"italiano\"},{\"code\":\"ja\",\"name\":\"japonés\"},{\"code\":\"lv\",\"name\":\"letón\"},{\"code\":\"lt\",\"name\":\"lituano\"},{\"code\":\"mi\",\"name\":\"maorí\"},{\"code\":\"nl\",\"name\":\"neerlandés\"},{\"code\":\"nb\",\"name\":\"noruego\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polaco\"},{\"code\":\"pt\",\"name\":\"portugués\"},{\"code\":\"ro\",\"name\":\"rumano\"},{\"code\":\"ru\",\"name\":\"ruso\"},{\"code\":\"sr\",\"name\":\"serbio\"},{\"code\":\"sv\",\"name\":\"sueco\"},{\"code\":\"th\",\"name\":\"tailandés\"},{\"code\":\"tr\",\"name\":\"turco\"},{\"code\":\"uk\",\"name\":\"ucraniano\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"zu\",\"name\":\"zulú\"}],\"es-419\":[{\"code\":\"de\",\"name\":\"alemán\"},{\"code\":\"am\",\"name\":\"amhárico\"},{\"code\":\"ar\",\"name\":\"árabe\"},{\"code\":\"az\",\"name\":\"azerí\"},{\"code\":\"bg\",\"name\":\"búlgaro\"},{\"code\":\"ca\",\"name\":\"catalán\"},{\"code\":\"cs\",\"name\":\"checo\"},{\"code\":\"zh-cn\",\"name\":\"chino (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"chino (tradicional)\"},{\"code\":\"ko\",\"name\":\"coreano\"},{\"code\":\"hr\",\"name\":\"croata\"},{\"code\":\"da\",\"name\":\"danés\"},{\"code\":\"sk\",\"name\":\"eslovaco\"},{\"code\":\"sl\",\"name\":\"esloveno\"},{\"code\":\"es\",\"name\":\"español\"},{\"code\":\"et\",\"name\":\"estonio\"},{\"code\":\"eu\",\"name\":\"euskera\"},{\"code\":\"fi\",\"name\":\"finlandés\"},{\"code\":\"fr\",\"name\":\"francés\"},{\"code\":\"gd\",\"name\":\"gaélico escocés\"},{\"code\":\"cy\",\"name\":\"galés\"},{\"code\":\"gl\",\"name\":\"gallego\"},{\"code\":\"el\",\"name\":\"griego\"},{\"code\":\"he\",\"name\":\"hebreo\"},{\"code\":\"hu\",\"name\":\"húngaro\"},{\"code\":\"id\",\"name\":\"indonesio\"},{\"code\":\"en\",\"name\":\"inglés\"},{\"code\":\"ga\",\"name\":\"irlandés\"},{\"code\":\"is\",\"name\":\"islandés\"},{\"code\":\"it\",\"name\":\"italiano\"},{\"code\":\"ja\",\"name\":\"japonés\"},{\"code\":\"lv\",\"name\":\"letón\"},{\"code\":\"lt\",\"name\":\"lituano\"},{\"code\":\"mi\",\"name\":\"maorí\"},{\"code\":\"nl\",\"name\":\"neerlandés\"},{\"code\":\"nb\",\"name\":\"noruego\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polaco\"},{\"code\":\"pt\",\"name\":\"portugués\"},{\"code\":\"ro\",\"name\":\"rumano\"},{\"code\":\"ru\",\"name\":\"ruso\"},{\"code\":\"sr\",\"name\":\"serbio\"},{\"code\":\"sv\",\"name\":\"sueco\"},{\"code\":\"th\",\"name\":\"tailandés\"},{\"code\":\"tr\",\"name\":\"turco\"},{\"code\":\"uk\",\"name\":\"ucraniano\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"zu\",\"name\":\"zulú\"}],\"et\":[{\"code\":\"am\",\"name\":\"amhaari\"},{\"code\":\"ar\",\"name\":\"araabia\"},{\"code\":\"az\",\"name\":\"aserbaidžaani\"},{\"code\":\"eu\",\"name\":\"baski\"},{\"code\":\"bg\",\"name\":\"bulgaaria\"},{\"code\":\"et\",\"name\":\"eesti\"},{\"code\":\"gl\",\"name\":\"galeegi\"},{\"code\":\"he\",\"name\":\"heebrea\"},{\"code\":\"es\",\"name\":\"hispaania\"},{\"code\":\"nl\",\"name\":\"hollandi\"},{\"code\":\"hr\",\"name\":\"horvaadi\"},{\"code\":\"ga\",\"name\":\"iiri\"},{\"code\":\"id\",\"name\":\"indoneesia\"},{\"code\":\"en\",\"name\":\"inglise\"},{\"code\":\"is\",\"name\":\"islandi\"},{\"code\":\"it\",\"name\":\"itaalia\"},{\"code\":\"ja\",\"name\":\"jaapani\"},{\"code\":\"ca\",\"name\":\"katalaani\"},{\"code\":\"ko\",\"name\":\"korea\"},{\"code\":\"el\",\"name\":\"kreeka\"},{\"code\":\"lt\",\"name\":\"leedu\"},{\"code\":\"zh-cn\",\"name\":\"lihtsustatud hiina\"},{\"code\":\"lv\",\"name\":\"läti\"},{\"code\":\"mi\",\"name\":\"maoori\"},{\"code\":\"nb\",\"name\":\"norra\"},{\"code\":\"pl\",\"name\":\"poola\"},{\"code\":\"pt\",\"name\":\"portugali\"},{\"code\":\"fr\",\"name\":\"prantsuse\"},{\"code\":\"fa\",\"name\":\"pärsia\"},{\"code\":\"sv\",\"name\":\"rootsi\"},{\"code\":\"ro\",\"name\":\"rumeenia\"},{\"code\":\"de\",\"name\":\"saksa\"},{\"code\":\"sr\",\"name\":\"serbia\"},{\"code\":\"sk\",\"name\":\"slovaki\"},{\"code\":\"sl\",\"name\":\"sloveeni\"},{\"code\":\"fi\",\"name\":\"soome\"},{\"code\":\"zu\",\"name\":\"suulu\"},{\"code\":\"gd\",\"name\":\"šoti\"},{\"code\":\"da\",\"name\":\"taani\"},{\"code\":\"th\",\"name\":\"tai\"},{\"code\":\"zh-tw\",\"name\":\"traditsiooniline hiina\"},{\"code\":\"cs\",\"name\":\"tšehhi\"},{\"code\":\"tr\",\"name\":\"türgi\"},{\"code\":\"cy\",\"name\":\"uelsi\"},{\"code\":\"uk\",\"name\":\"ukraina\"},{\"code\":\"hu\",\"name\":\"ungari\"},{\"code\":\"ru\",\"name\":\"vene\"},{\"code\":\"vi\",\"name\":\"vietnami\"}],\"cy\":[{\"code\":\"de\",\"name\":\"Almaeneg\"},{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arabeg\"},{\"code\":\"az\",\"name\":\"Aserbaijaneg\"},{\"code\":\"eu\",\"name\":\"Basgeg\"},{\"code\":\"bg\",\"name\":\"Bwlgaraidd\"},{\"code\":\"ca\",\"name\":\"Catalaneg\"},{\"code\":\"hr\",\"name\":\"Croateg\"},{\"code\":\"cy\",\"name\":\"Cymraeg\"},{\"code\":\"da\",\"name\":\"Daneg\"},{\"code\":\"it\",\"name\":\"Eidaleg\"},{\"code\":\"et\",\"name\":\"Estoneg\"},{\"code\":\"vi\",\"name\":\"Fietnameg\"},{\"code\":\"fi\",\"name\":\"Ffineg\"},{\"code\":\"nl\",\"name\":\"Fflemeg\"},{\"code\":\"fr\",\"name\":\"Ffrangeg\"},{\"code\":\"gd\",\"name\":\"Gaeleg yr Alban\"},{\"code\":\"gl\",\"name\":\"Galisaidd\"},{\"code\":\"el\",\"name\":\"Groeg\"},{\"code\":\"ga\",\"name\":\"Gwyddeleg\"},{\"code\":\"he\",\"name\":\"Hebraeg\"},{\"code\":\"hu\",\"name\":\"Hwngareg\"},{\"code\":\"ko\",\"name\":\"Iaith Corea\"},{\"code\":\"id\",\"name\":\"Indonesieg\"},{\"code\":\"is\",\"name\":\"Islandeg\"},{\"code\":\"uk\",\"name\":\"Iwcraineg\"},{\"code\":\"ja\",\"name\":\"Japaneg\"},{\"code\":\"lv\",\"name\":\"Latfieg\"},{\"code\":\"lt\",\"name\":\"Lithwaneg\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norwyeg\"},{\"code\":\"fa\",\"name\":\"Perseg\"},{\"code\":\"pt\",\"name\":\"Portiwgaleg\"},{\"code\":\"pl\",\"name\":\"Pwyleg\"},{\"code\":\"ro\",\"name\":\"Rwmaneg\"},{\"code\":\"ru\",\"name\":\"Rwsieg\"},{\"code\":\"en\",\"name\":\"Saesneg\"},{\"code\":\"es\",\"name\":\"Sbaeneg\"},{\"code\":\"sr\",\"name\":\"Serbeg\"},{\"code\":\"sk\",\"name\":\"Slofac\"},{\"code\":\"sl\",\"name\":\"Slofenia\"},{\"code\":\"sv\",\"name\":\"Swedeg\"},{\"code\":\"zu\",\"name\":\"Swlw\"},{\"code\":\"th\",\"name\":\"Tai\"},{\"code\":\"cs\",\"name\":\"Tsieceg\"},{\"code\":\"zh-tw\",\"name\":\"Tsieineeg (Traddodiadol)\"},{\"code\":\"zh-cn\",\"name\":\"Tsieineeg (Wedi symleiddio)\"},{\"code\":\"tr\",\"name\":\"Twrceg\"}],\"zh-cn\":[{\"code\":\"ar\",\"name\":\"阿拉伯语\"},{\"code\":\"am\",\"name\":\"阿姆哈拉语\"},{\"code\":\"az\",\"name\":\"阿塞拜疆语\"},{\"code\":\"ga\",\"name\":\"爱尔兰语\"},{\"code\":\"et\",\"name\":\"爱沙尼亚语\"},{\"code\":\"eu\",\"name\":\"巴斯克语\"},{\"code\":\"bg\",\"name\":\"保加利亚语\"},{\"code\":\"is\",\"name\":\"冰岛语\"},{\"code\":\"pl\",\"name\":\"波兰语\"},{\"code\":\"fa\",\"name\":\"波斯语\"},{\"code\":\"da\",\"name\":\"丹麦语\"},{\"code\":\"de\",\"name\":\"德语\"},{\"code\":\"ru\",\"name\":\"俄语\"},{\"code\":\"fr\",\"name\":\"法语\"},{\"code\":\"fi\",\"name\":\"芬兰语\"},{\"code\":\"ko\",\"name\":\"韩语\"},{\"code\":\"nl\",\"name\":\"荷兰语\"},{\"code\":\"gl\",\"name\":\"加利西亚语\"},{\"code\":\"ca\",\"name\":\"加泰罗尼亚语\"},{\"code\":\"cs\",\"name\":\"捷克语\"},{\"code\":\"hr\",\"name\":\"克罗地亚语\"},{\"code\":\"lv\",\"name\":\"拉脱维亚语\"},{\"code\":\"lt\",\"name\":\"立陶宛语\"},{\"code\":\"ro\",\"name\":\"罗马尼亚语\"},{\"code\":\"mi\",\"name\":\"毛利语\"},{\"code\":\"zu\",\"name\":\"南非祖鲁语\"},{\"code\":\"nb\",\"name\":\"挪威语\"},{\"code\":\"pt\",\"name\":\"葡萄牙语\"},{\"code\":\"ja\",\"name\":\"日语\"},{\"code\":\"sv\",\"name\":\"瑞典语\"},{\"code\":\"sr\",\"name\":\"塞尔维亚语\"},{\"code\":\"sk\",\"name\":\"斯洛伐克语\"},{\"code\":\"sl\",\"name\":\"斯洛文尼亚语\"},{\"code\":\"gd\",\"name\":\"苏格兰盖尔语\"},{\"code\":\"th\",\"name\":\"泰语\"},{\"code\":\"tr\",\"name\":\"土耳其语\"},{\"code\":\"cy\",\"name\":\"威尔士语\"},{\"code\":\"uk\",\"name\":\"乌克兰语\"},{\"code\":\"es\",\"name\":\"西班牙语\"},{\"code\":\"he\",\"name\":\"希伯来语\"},{\"code\":\"el\",\"name\":\"希腊语\"},{\"code\":\"hu\",\"name\":\"匈牙利语\"},{\"code\":\"it\",\"name\":\"意大利语\"},{\"code\":\"id\",\"name\":\"印尼语\"},{\"code\":\"en\",\"name\":\"英语\"},{\"code\":\"vi\",\"name\":\"越南语\"},{\"code\":\"zh-tw\",\"name\":\"中文(繁体)\"},{\"code\":\"zh-cn\",\"name\":\"中文(简体)\"}],\"bg\":[{\"code\":\"az\",\"name\":\"азербайджански\"},{\"code\":\"am\",\"name\":\"амхарски\"},{\"code\":\"en\",\"name\":\"английски\"},{\"code\":\"ar\",\"name\":\"арабски\"},{\"code\":\"eu\",\"name\":\"баски\"},{\"code\":\"bg\",\"name\":\"български\"},{\"code\":\"vi\",\"name\":\"виетнамски\"},{\"code\":\"gl\",\"name\":\"галисийски\"},{\"code\":\"el\",\"name\":\"гръцки\"},{\"code\":\"da\",\"name\":\"датски\"},{\"code\":\"et\",\"name\":\"естонски\"},{\"code\":\"zu\",\"name\":\"зулу\"},{\"code\":\"he\",\"name\":\"иврит\"},{\"code\":\"id\",\"name\":\"индонезийски\"},{\"code\":\"ga\",\"name\":\"ирландски\"},{\"code\":\"is\",\"name\":\"исландски\"},{\"code\":\"es\",\"name\":\"испански\"},{\"code\":\"it\",\"name\":\"италиански\"},{\"code\":\"ca\",\"name\":\"каталонски\"},{\"code\":\"zh-cn\",\"name\":\"китайски (опростен)\"},{\"code\":\"zh-tw\",\"name\":\"китайски (традиционен)\"},{\"code\":\"ko\",\"name\":\"корейски\"},{\"code\":\"lv\",\"name\":\"латвийски\"},{\"code\":\"lt\",\"name\":\"литовски\"},{\"code\":\"mi\",\"name\":\"маорски\"},{\"code\":\"de\",\"name\":\"немски\"},{\"code\":\"nl\",\"name\":\"нидерландски\"},{\"code\":\"nb\",\"name\":\"норвежки\"},{\"code\":\"fa\",\"name\":\"персийски\"},{\"code\":\"pl\",\"name\":\"полски\"},{\"code\":\"pt\",\"name\":\"португалски\"},{\"code\":\"ro\",\"name\":\"румънски\"},{\"code\":\"ru\",\"name\":\"руски\"},{\"code\":\"sk\",\"name\":\"словашки\"},{\"code\":\"sl\",\"name\":\"словенски\"},{\"code\":\"sr\",\"name\":\"сръбски\"},{\"code\":\"th\",\"name\":\"тайландски\"},{\"code\":\"tr\",\"name\":\"турски\"},{\"code\":\"cy\",\"name\":\"уелски\"},{\"code\":\"uk\",\"name\":\"украински\"},{\"code\":\"hu\",\"name\":\"унгарски\"},{\"code\":\"fi\",\"name\":\"финландски\"},{\"code\":\"fr\",\"name\":\"френски\"},{\"code\":\"hr\",\"name\":\"хърватски\"},{\"code\":\"cs\",\"name\":\"чешки\"},{\"code\":\"sv\",\"name\":\"шведски\"},{\"code\":\"gd\",\"name\":\"шотландски келтски\"},{\"code\":\"ja\",\"name\":\"японски\"}],\"ar\":[{\"code\":\"is\",\"name\":\"الآيسلندية\"},{\"code\":\"az\",\"name\":\"الأذرية\"},{\"code\":\"es\",\"name\":\"الإسبانية\"},{\"code\":\"et\",\"name\":\"الإستونية\"},{\"code\":\"gd\",\"name\":\"الاسكتلندية الغالية\"},{\"code\":\"de\",\"name\":\"الألمانية\"},{\"code\":\"am\",\"name\":\"الأمهرية\"},{\"code\":\"en\",\"name\":\"الإنجليزية\"},{\"code\":\"id\",\"name\":\"الإندونيسية\"},{\"code\":\"uk\",\"name\":\"الأوكرانية\"},{\"code\":\"ga\",\"name\":\"الأيرلندية\"},{\"code\":\"it\",\"name\":\"الإيطالية\"},{\"code\":\"eu\",\"name\":\"الباسكية\"},{\"code\":\"pt\",\"name\":\"البرتغالية\"},{\"code\":\"bg\",\"name\":\"البلغارية\"},{\"code\":\"pl\",\"name\":\"البولندية\"},{\"code\":\"th\",\"name\":\"التايلاندية\"},{\"code\":\"tr\",\"name\":\"التركية\"},{\"code\":\"cs\",\"name\":\"التشيكية\"},{\"code\":\"gl\",\"name\":\"الجاليكية\"},{\"code\":\"da\",\"name\":\"الدانماركية\"},{\"code\":\"ru\",\"name\":\"الروسية\"},{\"code\":\"ro\",\"name\":\"الرومانية\"},{\"code\":\"zu\",\"name\":\"الزولوية\"},{\"code\":\"sk\",\"name\":\"السلوفاكية\"},{\"code\":\"sl\",\"name\":\"السلوفينية\"},{\"code\":\"sv\",\"name\":\"السويدية\"},{\"code\":\"sr\",\"name\":\"الصربية\"},{\"code\":\"zh-tw\",\"name\":\"الصينية (التقليدية)\"},{\"code\":\"zh-cn\",\"name\":\"الصينية (المبسطة)\"},{\"code\":\"he\",\"name\":\"العبرية\"},{\"code\":\"ar\",\"name\":\"العربية\"},{\"code\":\"fa\",\"name\":\"الفارسية\"},{\"code\":\"fr\",\"name\":\"الفرنسية\"},{\"code\":\"fi\",\"name\":\"الفنلندية\"},{\"code\":\"vi\",\"name\":\"الفيتنامية\"},{\"code\":\"ca\",\"name\":\"القطلونية\"},{\"code\":\"hr\",\"name\":\"الكرواتية\"},{\"code\":\"ko\",\"name\":\"الكورية\"},{\"code\":\"lv\",\"name\":\"اللاتفية\"},{\"code\":\"lt\",\"name\":\"الليتوانية\"},{\"code\":\"mi\",\"name\":\"الماورية\"},{\"code\":\"nb\",\"name\":\"النرويجية\"},{\"code\":\"hu\",\"name\":\"الهنغارية\"},{\"code\":\"nl\",\"name\":\"الهولندية\"},{\"code\":\"cy\",\"name\":\"الويلزية\"},{\"code\":\"ja\",\"name\":\"اليابانية\"},{\"code\":\"el\",\"name\":\"اليونانية\"}],\"en\":[{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arabic\"},{\"code\":\"az\",\"name\":\"Azerbaijani\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"bg\",\"name\":\"Bulgarian\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"zh-cn\",\"name\":\"Chinese (Simplified)\"},{\"code\":\"zh-tw\",\"name\":\"Chinese (Traditional)\"},{\"code\":\"hr\",\"name\":\"Croatian\"},{\"code\":\"cs\",\"name\":\"Czech\"},{\"code\":\"da\",\"name\":\"Danish\"},{\"code\":\"nl\",\"name\":\"Dutch\"},{\"code\":\"en\",\"name\":\"English\"},{\"code\":\"et\",\"name\":\"Estonian\"},{\"code\":\"fi\",\"name\":\"Finnish\"},{\"code\":\"fr\",\"name\":\"French\"},{\"code\":\"gl\",\"name\":\"Galician\"},{\"code\":\"de\",\"name\":\"German\"},{\"code\":\"el\",\"name\":\"Greek\"},{\"code\":\"he\",\"name\":\"Hebrew\"},{\"code\":\"hu\",\"name\":\"Hungarian\"},{\"code\":\"is\",\"name\":\"Icelandic\"},{\"code\":\"id\",\"name\":\"Indonesian\"},{\"code\":\"ga\",\"name\":\"Irish\"},{\"code\":\"it\",\"name\":\"Italian\"},{\"code\":\"ja\",\"name\":\"Japanese\"},{\"code\":\"ko\",\"name\":\"Korean\"},{\"code\":\"lv\",\"name\":\"Latvian\"},{\"code\":\"lt\",\"name\":\"Lithuanian\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norwegian\"},{\"code\":\"fa\",\"name\":\"Persian\"},{\"code\":\"pl\",\"name\":\"Polish\"},{\"code\":\"pt\",\"name\":\"Portuguese\"},{\"code\":\"ro\",\"name\":\"Romanian\"},{\"code\":\"ru\",\"name\":\"Russian\"},{\"code\":\"gd\",\"name\":\"Scots Gaelic\"},{\"code\":\"sr\",\"name\":\"Serbian\"},{\"code\":\"sk\",\"name\":\"Slovak\"},{\"code\":\"sl\",\"name\":\"Slovenian\"},{\"code\":\"es\",\"name\":\"Spanish\"},{\"code\":\"sv\",\"name\":\"Swedish\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"tr\",\"name\":\"Turkish\"},{\"code\":\"uk\",\"name\":\"Ukrainian\"},{\"code\":\"vi\",\"name\":\"Vietnamese\"},{\"code\":\"cy\",\"name\":\"Welsh\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"sr\":[{\"code\":\"az\",\"name\":\"азербејџански\"},{\"code\":\"am\",\"name\":\"амхарски\"},{\"code\":\"ar\",\"name\":\"арапски\"},{\"code\":\"eu\",\"name\":\"баскијски\"},{\"code\":\"bg\",\"name\":\"бугарски\"},{\"code\":\"cy\",\"name\":\"велшки\"},{\"code\":\"vi\",\"name\":\"вијетнамски\"},{\"code\":\"gl\",\"name\":\"галски\"},{\"code\":\"el\",\"name\":\"грчки\"},{\"code\":\"da\",\"name\":\"дански\"},{\"code\":\"en\",\"name\":\"енглески\"},{\"code\":\"et\",\"name\":\"естонски\"},{\"code\":\"zu\",\"name\":\"зулу\"},{\"code\":\"id\",\"name\":\"индонежански\"},{\"code\":\"ga\",\"name\":\"ирски\"},{\"code\":\"is\",\"name\":\"исландски\"},{\"code\":\"it\",\"name\":\"италијански\"},{\"code\":\"ja\",\"name\":\"јапански\"},{\"code\":\"ca\",\"name\":\"каталонски\"},{\"code\":\"zh-cn\",\"name\":\"кинески (поједностављени)\"},{\"code\":\"zh-tw\",\"name\":\"кинески (традиционални)\"},{\"code\":\"ko\",\"name\":\"корејски\"},{\"code\":\"lv\",\"name\":\"летонски\"},{\"code\":\"lt\",\"name\":\"литвански\"},{\"code\":\"hu\",\"name\":\"мађарски\"},{\"code\":\"mi\",\"name\":\"маорски\"},{\"code\":\"de\",\"name\":\"немачки\"},{\"code\":\"nb\",\"name\":\"норвешки\"},{\"code\":\"fa\",\"name\":\"персијски\"},{\"code\":\"pl\",\"name\":\"пољски\"},{\"code\":\"pt\",\"name\":\"португалски\"},{\"code\":\"ro\",\"name\":\"румунски\"},{\"code\":\"ru\",\"name\":\"руски\"},{\"code\":\"sk\",\"name\":\"словачки\"},{\"code\":\"sl\",\"name\":\"словеначки\"},{\"code\":\"sr\",\"name\":\"српски\"},{\"code\":\"th\",\"name\":\"тајски\"},{\"code\":\"tr\",\"name\":\"турски\"},{\"code\":\"uk\",\"name\":\"украјински\"},{\"code\":\"fi\",\"name\":\"фински\"},{\"code\":\"fr\",\"name\":\"француски\"},{\"code\":\"he\",\"name\":\"хебрејски\"},{\"code\":\"nl\",\"name\":\"холандски\"},{\"code\":\"hr\",\"name\":\"хрватски\"},{\"code\":\"cs\",\"name\":\"чешки\"},{\"code\":\"sv\",\"name\":\"шведски\"},{\"code\":\"gd\",\"name\":\"шкотски галски\"},{\"code\":\"es\",\"name\":\"шпански\"}],\"sv\":[{\"code\":\"am\",\"name\":\"amhariska\"},{\"code\":\"ar\",\"name\":\"arabiska\"},{\"code\":\"az\",\"name\":\"azerbajdzjanska\"},{\"code\":\"eu\",\"name\":\"baskiska\"},{\"code\":\"bg\",\"name\":\"bulgariska\"},{\"code\":\"da\",\"name\":\"danska\"},{\"code\":\"en\",\"name\":\"engelska\"},{\"code\":\"et\",\"name\":\"estniska\"},{\"code\":\"fi\",\"name\":\"finska\"},{\"code\":\"fr\",\"name\":\"franska\"},{\"code\":\"gd\",\"name\":\"gaeliska\"},{\"code\":\"gl\",\"name\":\"galiciska\"},{\"code\":\"el\",\"name\":\"grekiska\"},{\"code\":\"he\",\"name\":\"hebreiska\"},{\"code\":\"id\",\"name\":\"indonesiska\"},{\"code\":\"ga\",\"name\":\"irländska\"},{\"code\":\"is\",\"name\":\"isländska\"},{\"code\":\"it\",\"name\":\"italienska\"},{\"code\":\"ja\",\"name\":\"japanska\"},{\"code\":\"ca\",\"name\":\"katalanska\"},{\"code\":\"zh-cn\",\"name\":\"kinesiska (förenklad)\"},{\"code\":\"zh-tw\",\"name\":\"kinesiska (traditionell)\"},{\"code\":\"ko\",\"name\":\"koreanska\"},{\"code\":\"hr\",\"name\":\"kroatiska\"},{\"code\":\"lv\",\"name\":\"lettiska\"},{\"code\":\"lt\",\"name\":\"litauiska\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"nederländska\"},{\"code\":\"nb\",\"name\":\"norska\"},{\"code\":\"fa\",\"name\":\"persiska\"},{\"code\":\"pl\",\"name\":\"polska\"},{\"code\":\"pt\",\"name\":\"portugisiska\"},{\"code\":\"ro\",\"name\":\"rumänska\"},{\"code\":\"ru\",\"name\":\"ryska\"},{\"code\":\"sr\",\"name\":\"serbiska\"},{\"code\":\"sk\",\"name\":\"slovakiska\"},{\"code\":\"sl\",\"name\":\"slovenska\"},{\"code\":\"es\",\"name\":\"spanska\"},{\"code\":\"sv\",\"name\":\"svenska\"},{\"code\":\"th\",\"name\":\"thailändska\"},{\"code\":\"cs\",\"name\":\"tjeckiska\"},{\"code\":\"tr\",\"name\":\"turkiska\"},{\"code\":\"de\",\"name\":\"tyska\"},{\"code\":\"uk\",\"name\":\"ukrainska\"},{\"code\":\"hu\",\"name\":\"ungerska\"},{\"code\":\"vi\",\"name\":\"vietnamesiska\"},{\"code\":\"cy\",\"name\":\"walesiska\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"ro\":[{\"code\":\"am\",\"name\":\"Amharică\"},{\"code\":\"ar\",\"name\":\"Arabă\"},{\"code\":\"az\",\"name\":\"Azerbaidjană\"},{\"code\":\"eu\",\"name\":\"Bască\"},{\"code\":\"bg\",\"name\":\"Bulgară\"},{\"code\":\"ca\",\"name\":\"Catalană\"},{\"code\":\"cs\",\"name\":\"Cehă\"},{\"code\":\"zh-cn\",\"name\":\"Chineză (Simplificată)\"},{\"code\":\"zh-tw\",\"name\":\"Chineză (Tradițională)\"},{\"code\":\"ko\",\"name\":\"Coreeană\"},{\"code\":\"hr\",\"name\":\"Croată\"},{\"code\":\"da\",\"name\":\"Daneză\"},{\"code\":\"he\",\"name\":\"Ebraică\"},{\"code\":\"en\",\"name\":\"Engleză\"},{\"code\":\"et\",\"name\":\"Estonă\"},{\"code\":\"fi\",\"name\":\"Finlandeză\"},{\"code\":\"fr\",\"name\":\"Franceză\"},{\"code\":\"cy\",\"name\":\"Galeză\"},{\"code\":\"gd\",\"name\":\"Galica scoțiană\"},{\"code\":\"gl\",\"name\":\"Galiciană\"},{\"code\":\"de\",\"name\":\"Germană\"},{\"code\":\"el\",\"name\":\"Greacă\"},{\"code\":\"id\",\"name\":\"Indoneziană\"},{\"code\":\"ga\",\"name\":\"Irlandeză\"},{\"code\":\"is\",\"name\":\"Islandeză\"},{\"code\":\"it\",\"name\":\"Italiană\"},{\"code\":\"ja\",\"name\":\"Japoneză\"},{\"code\":\"lv\",\"name\":\"Letonă\"},{\"code\":\"lt\",\"name\":\"Lituaniană\"},{\"code\":\"hu\",\"name\":\"Maghiară\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Neerlandeză\"},{\"code\":\"nb\",\"name\":\"Norvegiană\"},{\"code\":\"fa\",\"name\":\"Persană\"},{\"code\":\"pl\",\"name\":\"Poloneză\"},{\"code\":\"pt\",\"name\":\"Portugheză\"},{\"code\":\"ro\",\"name\":\"Română\"},{\"code\":\"ru\",\"name\":\"Rusă\"},{\"code\":\"sr\",\"name\":\"Sârbă\"},{\"code\":\"sk\",\"name\":\"Slovacă\"},{\"code\":\"sl\",\"name\":\"Slovenă\"},{\"code\":\"es\",\"name\":\"Spaniolă\"},{\"code\":\"sv\",\"name\":\"Suedeză\"},{\"code\":\"th\",\"name\":\"Thailandeză\"},{\"code\":\"tr\",\"name\":\"Turcă\"},{\"code\":\"uk\",\"name\":\"Ucraineană\"},{\"code\":\"vi\",\"name\":\"Vietnameză\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"lt\":[{\"code\":\"ga\",\"name\":\"airių\"},{\"code\":\"am\",\"name\":\"amharų\"},{\"code\":\"en\",\"name\":\"anglų\"},{\"code\":\"ar\",\"name\":\"arabų\"},{\"code\":\"az\",\"name\":\"Azerbaidžaniečių\"},{\"code\":\"eu\",\"name\":\"baskų\"},{\"code\":\"bg\",\"name\":\"bulgarų\"},{\"code\":\"cs\",\"name\":\"čekų\"},{\"code\":\"da\",\"name\":\"danų\"},{\"code\":\"et\",\"name\":\"estų\"},{\"code\":\"gl\",\"name\":\"galisų\"},{\"code\":\"el\",\"name\":\"graikų\"},{\"code\":\"he\",\"name\":\"hebrajų\"},{\"code\":\"id\",\"name\":\"indoneziečių\"},{\"code\":\"is\",\"name\":\"islandų\"},{\"code\":\"es\",\"name\":\"ispanų\"},{\"code\":\"it\",\"name\":\"italų\"},{\"code\":\"ja\",\"name\":\"japonų\"},{\"code\":\"ca\",\"name\":\"kataloniečių\"},{\"code\":\"zh-cn\",\"name\":\"kinų (supaprastinta)\"},{\"code\":\"zh-tw\",\"name\":\"kinų (tradicinė)\"},{\"code\":\"ko\",\"name\":\"korėjiečių\"},{\"code\":\"hr\",\"name\":\"kroatų\"},{\"code\":\"lv\",\"name\":\"latvių\"},{\"code\":\"pl\",\"name\":\"lenkų\"},{\"code\":\"lt\",\"name\":\"lietuvių\"},{\"code\":\"mi\",\"name\":\"maorių\"},{\"code\":\"nb\",\"name\":\"norvegų\"},{\"code\":\"nl\",\"name\":\"olandų\"},{\"code\":\"fa\",\"name\":\"persų\"},{\"code\":\"pt\",\"name\":\"portugalų\"},{\"code\":\"fr\",\"name\":\"prancūzų\"},{\"code\":\"ro\",\"name\":\"rumunų\"},{\"code\":\"ru\",\"name\":\"rusų\"},{\"code\":\"sr\",\"name\":\"serbų\"},{\"code\":\"sk\",\"name\":\"slovakų\"},{\"code\":\"sl\",\"name\":\"slovėnų\"},{\"code\":\"fi\",\"name\":\"suomių\"},{\"code\":\"gd\",\"name\":\"škotų (gėlų)\"},{\"code\":\"sv\",\"name\":\"švedų\"},{\"code\":\"th\",\"name\":\"tajų\"},{\"code\":\"tr\",\"name\":\"turkų\"},{\"code\":\"uk\",\"name\":\"ukrainiečių\"},{\"code\":\"cy\",\"name\":\"valų\"},{\"code\":\"hu\",\"name\":\"vengrų\"},{\"code\":\"vi\",\"name\":\"vietnamiečių\"},{\"code\":\"de\",\"name\":\"vokiečių\"},{\"code\":\"zu\",\"name\":\"zulusų\"}],\"ko\":[{\"code\":\"gl\",\"name\":\"갈리시아어\"},{\"code\":\"el\",\"name\":\"그리스어\"},{\"code\":\"nl\",\"name\":\"네덜란드어\"},{\"code\":\"nb\",\"name\":\"노르웨이어\"},{\"code\":\"da\",\"name\":\"덴마크어\"},{\"code\":\"de\",\"name\":\"독일어\"},{\"code\":\"lv\",\"name\":\"라트비아어\"},{\"code\":\"ru\",\"name\":\"러시아어\"},{\"code\":\"ro\",\"name\":\"루마니아어\"},{\"code\":\"lt\",\"name\":\"리투아니아어\"},{\"code\":\"mi\",\"name\":\"마오리어\"},{\"code\":\"eu\",\"name\":\"바스크어\"},{\"code\":\"vi\",\"name\":\"베트남어\"},{\"code\":\"bg\",\"name\":\"불가리아어\"},{\"code\":\"sr\",\"name\":\"세르비아어\"},{\"code\":\"sv\",\"name\":\"스웨덴어\"},{\"code\":\"gd\",\"name\":\"스코틀랜드 게일어\"},{\"code\":\"es\",\"name\":\"스페인어\"},{\"code\":\"sk\",\"name\":\"슬로바키아어\"},{\"code\":\"sl\",\"name\":\"슬로베니아어\"},{\"code\":\"ar\",\"name\":\"아랍어\"},{\"code\":\"is\",\"name\":\"아이슬란드어\"},{\"code\":\"ga\",\"name\":\"아일랜드어\"},{\"code\":\"az\",\"name\":\"아제르바이잔어\"},{\"code\":\"am\",\"name\":\"암하라어\"},{\"code\":\"et\",\"name\":\"에스토니아어\"},{\"code\":\"en\",\"name\":\"영어\"},{\"code\":\"uk\",\"name\":\"우크라이나어\"},{\"code\":\"cy\",\"name\":\"웨일즈어\"},{\"code\":\"it\",\"name\":\"이탈리아어\"},{\"code\":\"id\",\"name\":\"인도네시아어\"},{\"code\":\"ja\",\"name\":\"일본어\"},{\"code\":\"zu\",\"name\":\"줄루어\"},{\"code\":\"zh-cn\",\"name\":\"중국어(간체)\"},{\"code\":\"zh-tw\",\"name\":\"중국어(번체)\"},{\"code\":\"cs\",\"name\":\"체코어\"},{\"code\":\"ca\",\"name\":\"카탈로니아어\"},{\"code\":\"hr\",\"name\":\"크로아티아어\"},{\"code\":\"th\",\"name\":\"태국어\"},{\"code\":\"tr\",\"name\":\"터키어\"},{\"code\":\"fa\",\"name\":\"페르시아어\"},{\"code\":\"pt\",\"name\":\"포르투갈어\"},{\"code\":\"pl\",\"name\":\"폴란드어\"},{\"code\":\"fr\",\"name\":\"프랑스어\"},{\"code\":\"fi\",\"name\":\"핀란드어\"},{\"code\":\"ko\",\"name\":\"한국어\"},{\"code\":\"hu\",\"name\":\"헝가리어\"},{\"code\":\"he\",\"name\":\"히브리어\"}],\"it\":[{\"code\":\"am\",\"name\":\"Amarico\"},{\"code\":\"ar\",\"name\":\"Arabo\"},{\"code\":\"az\",\"name\":\"Azero\"},{\"code\":\"eu\",\"name\":\"Basco\"},{\"code\":\"bg\",\"name\":\"Bulgaro\"},{\"code\":\"ca\",\"name\":\"Catalano\"},{\"code\":\"cs\",\"name\":\"Ceco\"},{\"code\":\"zh-cn\",\"name\":\"Cinese (semplificato)\"},{\"code\":\"zh-tw\",\"name\":\"Cinese (tradizionale)\"},{\"code\":\"ko\",\"name\":\"Coreano\"},{\"code\":\"hr\",\"name\":\"Croato\"},{\"code\":\"da\",\"name\":\"Danese\"},{\"code\":\"he\",\"name\":\"Ebraico\"},{\"code\":\"et\",\"name\":\"Estone\"},{\"code\":\"fi\",\"name\":\"Finlandese\"},{\"code\":\"fr\",\"name\":\"Francese\"},{\"code\":\"gd\",\"name\":\"Gaelico scozzese\"},{\"code\":\"gl\",\"name\":\"Galiziano\"},{\"code\":\"cy\",\"name\":\"Gallese\"},{\"code\":\"ja\",\"name\":\"Giapponese\"},{\"code\":\"el\",\"name\":\"Greco\"},{\"code\":\"id\",\"name\":\"Indonesiano\"},{\"code\":\"en\",\"name\":\"Inglese\"},{\"code\":\"ga\",\"name\":\"Irlandese\"},{\"code\":\"is\",\"name\":\"Islandese\"},{\"code\":\"it\",\"name\":\"Italiano\"},{\"code\":\"lv\",\"name\":\"Lettone\"},{\"code\":\"lt\",\"name\":\"Lituano\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norvegese\"},{\"code\":\"nl\",\"name\":\"Olandese\"},{\"code\":\"fa\",\"name\":\"Persiano\"},{\"code\":\"pl\",\"name\":\"Polacco\"},{\"code\":\"pt\",\"name\":\"Portoghese\"},{\"code\":\"ro\",\"name\":\"Rumeno\"},{\"code\":\"ru\",\"name\":\"Russo\"},{\"code\":\"sr\",\"name\":\"Serbo\"},{\"code\":\"sk\",\"name\":\"Slovacco\"},{\"code\":\"sl\",\"name\":\"Sloveno\"},{\"code\":\"es\",\"name\":\"Spagnolo\"},{\"code\":\"sv\",\"name\":\"Svedese\"},{\"code\":\"th\",\"name\":\"Tailandese\"},{\"code\":\"de\",\"name\":\"Tedesco\"},{\"code\":\"tr\",\"name\":\"Turco\"},{\"code\":\"uk\",\"name\":\"Ucraino\"},{\"code\":\"hu\",\"name\":\"Ungherese\"},{\"code\":\"vi\",\"name\":\"Vietnamita\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"vi\":[{\"code\":\"ar\",\"name\":\"Tiếng Ả Rập\"},{\"code\":\"am\",\"name\":\"Tiếng Amharic\"},{\"code\":\"en\",\"name\":\"Tiếng Anh\"},{\"code\":\"az\",\"name\":\"Tiếng Azerbaijan\"},{\"code\":\"pl\",\"name\":\"Tiếng Ba Lan\"},{\"code\":\"fa\",\"name\":\"Tiếng Ba Tư\"},{\"code\":\"eu\",\"name\":\"Tiếng Basque\"},{\"code\":\"pt\",\"name\":\"Tiếng Bồ Đào Nha\"},{\"code\":\"bg\",\"name\":\"Tiếng Bulgaria\"},{\"code\":\"ca\",\"name\":\"Tiếng Catalan\"},{\"code\":\"hr\",\"name\":\"Tiếng Croatia\"},{\"code\":\"he\",\"name\":\"Tiếng Do Thái\"},{\"code\":\"da\",\"name\":\"Tiếng Đan Mạch\"},{\"code\":\"de\",\"name\":\"Tiếng Đức\"},{\"code\":\"et\",\"name\":\"Tiếng Estonia\"},{\"code\":\"gd\",\"name\":\"Tiếng Gael Scotland\"},{\"code\":\"gl\",\"name\":\"Tiếng Galicia\"},{\"code\":\"nl\",\"name\":\"Tiếng Hà Lan\"},{\"code\":\"ko\",\"name\":\"Tiếng Hàn\"},{\"code\":\"hu\",\"name\":\"Tiếng Hungary\"},{\"code\":\"el\",\"name\":\"Tiếng Hy Lạp\"},{\"code\":\"is\",\"name\":\"Tiếng Iceland\"},{\"code\":\"id\",\"name\":\"Tiếng Indonesia\"},{\"code\":\"ga\",\"name\":\"Tiếng Ireland\"},{\"code\":\"lv\",\"name\":\"Tiếng Latvia\"},{\"code\":\"lt\",\"name\":\"Tiếng Litva\"},{\"code\":\"mi\",\"name\":\"Tiếng Maori\"},{\"code\":\"nb\",\"name\":\"Tiếng Na Uy\"},{\"code\":\"ru\",\"name\":\"Tiếng Nga\"},{\"code\":\"ja\",\"name\":\"Tiếng Nhật\"},{\"code\":\"fr\",\"name\":\"Tiếng Pháp\"},{\"code\":\"fi\",\"name\":\"Tiếng Phần Lan\"},{\"code\":\"ro\",\"name\":\"Tiếng Rumani\"},{\"code\":\"cs\",\"name\":\"Tiếng Séc\"},{\"code\":\"sr\",\"name\":\"Tiếng Serbia\"},{\"code\":\"sk\",\"name\":\"Tiếng Slovak\"},{\"code\":\"sl\",\"name\":\"Tiếng Slovenia\"},{\"code\":\"es\",\"name\":\"Tiếng Tây Ban Nha\"},{\"code\":\"th\",\"name\":\"Tiếng Thái\"},{\"code\":\"tr\",\"name\":\"Tiếng Thổ Nhĩ Kỳ\"},{\"code\":\"sv\",\"name\":\"Tiếng Thụy Điển\"},{\"code\":\"zh-cn\",\"name\":\"Tiếng Trung (Giản Thể)\"},{\"code\":\"zh-tw\",\"name\":\"Tiếng Trung (Phồn thể)\"},{\"code\":\"uk\",\"name\":\"Tiếng Ukraina\"},{\"code\":\"vi\",\"name\":\"Tiếng Việt\"},{\"code\":\"cy\",\"name\":\"Tiếng Xứ Wales\"},{\"code\":\"it\",\"name\":\"Tiếng Ý\"},{\"code\":\"zu\",\"name\":\"Tiếng Zulu\"}]},\"nameMap\":{\"albánština\":\"sq\",\"amharština\":\"am\",\"angličtina\":\"en\",\"arabština\":\"ar\",\"arménština\":\"hy\",\"ázerbájdžánština\":\"az\",\"barmština\":\"my\",\"baskičtina\":\"eu\",\"běloruština\":\"be\",\"bulharština\":\"bg\",\"čeština\":\"cs\",\"čínština (tradiční)\":\"zh-tw\",\"čínština (zjednodušená)\":\"zh-cn\",\"dánština\":\"da\",\"esperanto\":\"eo\",\"estonština\":\"et\",\"finština\":\"fi\",\"francouzština\":\"fr\",\"galicijština\":\"gl\",\"haitská kreolština\":\"ht\",\"hebrejština\":\"he\",\"hindština\":\"hi\",\"holandština\":\"nl\",\"chorvatština\":\"hr\",\"indonéština\":\"id\",\"irština\":\"ga\",\"islandština\":\"is\",\"italština\":\"it\",\"japonština\":\"ja\",\"kannadština\":\"kn\",\"katalánština\":\"ca\",\"korejština\":\"ko\",\"kurdština\":\"ku\",\"latina\":\"la\",\"litevština\":\"lt\",\"lotyština\":\"lv\",\"maďarština\":\"hu\",\"makedonština\":\"mk\",\"malajálamština\":\"ml\",\"malajština\":\"ms\",\"maltština\":\"mt\",\"maorština\":\"mi\",\"marátština\":\"mr\",\"mongolština\":\"mn\",\"němčina\":\"de\",\"norština\":\"nb\",\"perština\":\"fa\",\"polština\":\"pl\",\"portugalština\":\"pt\",\"rumunština\":\"ro\",\"ruština\":\"ru\",\"řečtina\":\"el\",\"skotská gaelština\":\"gd\",\"slovenština\":\"sk\",\"slovinština\":\"sl\",\"srbština\":\"sr\",\"španělština\":\"es\",\"švédština\":\"sv\",\"telužština\":\"te\",\"thajština\":\"th\",\"turečtina\":\"tr\",\"ukrajinština\":\"uk\",\"uzbečtina\":\"uz\",\"velština\":\"cy\",\"vietnamština\":\"vi\",\"zulu\":\"zu\",\"albansk\":\"sq\",\"amharisk\":\"am\",\"arabisk\":\"ar\",\"armensk\":\"hy\",\"aserbajdsjansk\":\"az\",\"baskisk\":\"eu\",\"bulgarsk\":\"bg\",\"burmesisk\":\"my\",\"dansk\":\"da\",\"engelsk\":\"en\",\"estisk\":\"et\",\"finsk\":\"fi\",\"fransk\":\"fr\",\"galicisk\":\"gl\",\"græsk\":\"el\",\"haitisk kreolsk\":\"ht\",\"hebraisk\":\"he\",\"hindi\":\"hi\",\"hollandsk\":\"nl\",\"hviderussisk\":\"be\",\"indonesisk\":\"id\",\"irsk\":\"ga\",\"islandsk\":\"is\",\"italiensk\":\"it\",\"japansk\":\"ja\",\"kannada\":\"kn\",\"katalansk\":\"ca\",\"kinesisk (forenklet)\":\"zh-cn\",\"kinesisk (traditionelt)\":\"zh-tw\",\"koreansk\":\"ko\",\"kroatisk\":\"hr\",\"kurdisk\":\"ku\",\"latin\":\"la\",\"lettisk\":\"lv\",\"litauisk\":\"lt\",\"makedonsk\":\"mk\",\"malajisk\":\"ms\",\"malayalam\":\"ml\",\"maltesisk\":\"mt\",\"maori\":\"mi\",\"marathi\":\"mr\",\"mongolsk\":\"mn\",\"norsk\":\"nb\",\"persisk\":\"fa\",\"polsk\":\"pl\",\"portugisisk\":\"pt\",\"rumænsk\":\"ro\",\"russisk\":\"ru\",\"serbisk\":\"sr\",\"skotsk gælisk\":\"gd\",\"slovakisk\":\"sk\",\"slovensk\":\"sl\",\"spansk\":\"es\",\"svensk\":\"sv\",\"telugu\":\"te\",\"thailandsk\":\"th\",\"tjekkisk\":\"cs\",\"tyrkisk\":\"tr\",\"tysk\":\"de\",\"ukrainsk\":\"uk\",\"ungarsk\":\"hu\",\"usbekisk\":\"uz\",\"vietnamesisk\":\"vi\",\"walisisk\":\"cy\",\"acerbaixano\":\"az\",\"albanés\":\"sq\",\"alemán\":\"de\",\"amárico\":\"am\",\"árabe\":\"ar\",\"armenio\":\"hy\",\"bielorruso\":\"be\",\"birmano\":\"my\",\"búlgaro\":\"bg\",\"canarés\":\"kn\",\"catalán\":\"ca\",\"checo\":\"cs\",\"chinés (simplificado)\":\"zh-cn\",\"chinés (tradicional)\":\"zh-tw\",\"coreano\":\"ko\",\"crioulo haitiano\":\"ht\",\"croata\":\"hr\",\"curdo\":\"ku\",\"dinamarqués\":\"da\",\"eslovaco\":\"sk\",\"esloveno\":\"sl\",\"español\":\"es\",\"estoniano\":\"et\",\"éuscaro\":\"eu\",\"finés\":\"fi\",\"francés\":\"fr\",\"gaélico escocés\":\"gd\",\"galego\":\"gl\",\"galés\":\"cy\",\"grego\":\"el\",\"hebreo\":\"he\",\"húngaro\":\"hu\",\"indonesio\":\"id\",\"inglés\":\"en\",\"irlandés\":\"ga\",\"islandés\":\"is\",\"italiano\":\"it\",\"latín\":\"la\",\"letón\":\"lv\",\"lituano\":\"lt\",\"macedonio\":\"mk\",\"malabar\":\"ml\",\"malaio\":\"ms\",\"maltés\":\"mt\",\"maorí\":\"mi\",\"mongol\":\"mn\",\"neerlandés\":\"nl\",\"noruegués\":\"nb\",\"persa\":\"fa\",\"polaco\":\"pl\",\"portugués\":\"pt\",\"romanés\":\"ro\",\"ruso\":\"ru\",\"serbio\":\"sr\",\"sueco\":\"sv\",\"tailandés\":\"th\",\"telugú\":\"te\",\"turco\":\"tr\",\"ucraíno\":\"uk\",\"usbeco\":\"uz\",\"vietnamita\":\"vi\",\"xaponés\":\"ja\",\"zulú\":\"zu\",\"albanščina\":\"sq\",\"amharščina\":\"am\",\"angleščina\":\"en\",\"arabščina\":\"ar\",\"armenščina\":\"hy\",\"azerbajdžanščina\":\"az\",\"baskovščina\":\"eu\",\"beloruščina\":\"be\",\"bolgarščina\":\"bg\",\"burmanščina\":\"my\",\"češčina\":\"cs\",\"danščina\":\"da\",\"estonščina\":\"et\",\"finščina\":\"fi\",\"francoščina\":\"fr\",\"galicijščina\":\"gl\",\"grščina\":\"el\",\"haitijska kreolščina\":\"ht\",\"hebrejščina\":\"he\",\"hindijščina\":\"hi\",\"hrvaščina\":\"hr\",\"indonezijščina\":\"id\",\"irščina\":\"ga\",\"islandščina\":\"is\",\"italijanščina\":\"it\",\"japonščina\":\"ja\",\"kanareščina\":\"kn\",\"katalonščina\":\"ca\",\"kitajščina (poenostavljena)\":\"zh-cn\",\"kitajščina (tradicionalna)\":\"zh-tw\",\"korejščina\":\"ko\",\"kurdščina\":\"ku\",\"latinščina\":\"la\",\"latvijščina\":\"lv\",\"litovščina\":\"lt\",\"madžarščina\":\"hu\",\"makedonščina\":\"mk\",\"malajalščina\":\"ml\",\"malajščina\":\"ms\",\"malteščina\":\"mt\",\"maorščina\":\"mi\",\"maratščina\":\"mr\",\"mongolščina\":\"mn\",\"nemščina\":\"de\",\"nizozemščina\":\"nl\",\"norveščina\":\"nb\",\"perzijščina\":\"fa\",\"poljščina\":\"pl\",\"portugalščina\":\"pt\",\"romunščina\":\"ro\",\"ruščina\":\"ru\",\"slovaščina\":\"sk\",\"slovenščina\":\"sl\",\"srbščina\":\"sr\",\"škotska gelščina\":\"gd\",\"španščina\":\"es\",\"švedščina\":\"sv\",\"tajščina\":\"th\",\"teluščina\":\"te\",\"turščina\":\"tr\",\"ukrajinščina\":\"uk\",\"uzbeščina\":\"uz\",\"valižanščina\":\"cy\",\"vietnamščina\":\"vi\",\"zulujščina\":\"zu\",\"albanais\":\"sq\",\"allemand\":\"de\",\"amharique\":\"am\",\"anglais\":\"en\",\"arabe\":\"ar\",\"arménien\":\"hy\",\"azéri\":\"az\",\"basque\":\"eu\",\"biélorusse\":\"be\",\"birman\":\"my\",\"bulgare\":\"bg\",\"catalan\":\"ca\",\"chinois (simplifié)\":\"zh-cn\",\"chinois (traditionnel)\":\"zh-tw\",\"coréen\":\"ko\",\"créole haïtien\":\"ht\",\"croate\":\"hr\",\"danois\":\"da\",\"espagnol\":\"es\",\"espéranto\":\"eo\",\"estonien\":\"et\",\"finnois\":\"fi\",\"français\":\"fr\",\"gaélique (écosse)\":\"gd\",\"galicien\":\"gl\",\"gallois\":\"cy\",\"grec\":\"el\",\"hébreu\":\"he\",\"hongrois\":\"hu\",\"indonésien\":\"id\",\"irlandais\":\"ga\",\"islandais\":\"is\",\"italien\":\"it\",\"japonais\":\"ja\",\"kurde\":\"ku\",\"letton\":\"lv\",\"lituanien\":\"lt\",\"macédonien\":\"mk\",\"malaisien\":\"ms\",\"maltais\":\"mt\",\"néerlandais\":\"nl\",\"norvégien\":\"nb\",\"ouzbek\":\"uz\",\"persan\":\"fa\",\"polonais\":\"pl\",\"portugais\":\"pt\",\"roumain\":\"ro\",\"russe\":\"ru\",\"serbe\":\"sr\",\"slovaque\":\"sk\",\"slovène\":\"sl\",\"suédois\":\"sv\",\"tchèque\":\"cs\",\"thaï\":\"th\",\"turc\":\"tr\",\"ukrainien\":\"uk\",\"vietnamien\":\"vi\",\"zoulou\":\"zu\",\"albán\":\"sq\",\"amhara\":\"am\",\"angol\":\"en\",\"arab\":\"ar\",\"azeri\":\"az\",\"baszk\":\"eu\",\"belorusz\":\"be\",\"bolgár\":\"bg\",\"burmai\":\"my\",\"cseh\":\"cs\",\"dán\":\"da\",\"eszperantó\":\"eo\",\"észt\":\"et\",\"finn\":\"fi\",\"francia\":\"fr\",\"galíciai\":\"gl\",\"görög\":\"el\",\"haiti kreol\":\"ht\",\"héber\":\"he\",\"holland\":\"nl\",\"horvát\":\"hr\",\"indonéz\":\"id\",\"ír\":\"ga\",\"izlandi\":\"is\",\"japán\":\"ja\",\"katalán\":\"ca\",\"kínai (egyszerűsített)\":\"zh-cn\",\"kínai (hagyományos)\":\"zh-tw\",\"koreai\":\"ko\",\"kurd\":\"ku\",\"lengyel\":\"pl\",\"lett\":\"lv\",\"litván\":\"lt\",\"macedón\":\"mk\",\"magyar\":\"hu\",\"maláj\":\"ms\",\"malajálam\":\"ml\",\"máltai\":\"mt\",\"maráthi\":\"mr\",\"német\":\"de\",\"norvég\":\"nb\",\"olasz\":\"it\",\"orosz\":\"ru\",\"örmény\":\"hy\",\"perzsa\":\"fa\",\"portugál\":\"pt\",\"román\":\"ro\",\"skót-gael\":\"gd\",\"spanyol\":\"es\",\"svéd\":\"sv\",\"szerb\":\"sr\",\"szlovák\":\"sk\",\"szlovén\":\"sl\",\"thai\":\"th\",\"török\":\"tr\",\"ukrán\":\"uk\",\"üzbég\":\"uz\",\"vietnami\":\"vi\",\"walesi\":\"cy\",\"азербайджанська\":\"az\",\"албанська\":\"sq\",\"амхарська\":\"am\",\"англійська\":\"en\",\"арабська\":\"ar\",\"баскська\":\"eu\",\"білоруська\":\"be\",\"бірманська\":\"my\",\"болгарська\":\"bg\",\"в’єтнамська\":\"vi\",\"валлійська\":\"cy\",\"вірменська\":\"hy\",\"гаїтянська креольська\":\"ht\",\"гінді\":\"hi\",\"грецька\":\"el\",\"ґалісійська\":\"gl\",\"данська\":\"da\",\"есперанто\":\"eo\",\"естонська\":\"et\",\"зулу\":\"zu\",\"іврит\":\"he\",\"індонезійська\":\"id\",\"ірландська\":\"ga\",\"ісландська\":\"is\",\"іспанська\":\"es\",\"італійська\":\"it\",\"каннада\":\"kn\",\"каталанська\":\"ca\",\"китайська (спрощена)\":\"zh-cn\",\"китайська (традиційна)\":\"zh-tw\",\"корейська\":\"ko\",\"курдська\":\"ku\",\"латинська\":\"la\",\"латиська\":\"lv\",\"литовська\":\"lt\",\"македонська\":\"mk\",\"малайська\":\"ms\",\"малаялам\":\"ml\",\"мальтійська\":\"mt\",\"маорі\":\"mi\",\"маратхі\":\"mr\",\"монгольська\":\"mn\",\"нідерландська\":\"nl\",\"німецька\":\"de\",\"норвезька\":\"nb\",\"перська\":\"fa\",\"польська\":\"pl\",\"португальська\":\"pt\",\"російська\":\"ru\",\"румунська\":\"ro\",\"сербська\":\"sr\",\"словацька\":\"sk\",\"словенська\":\"sl\",\"тайська\":\"th\",\"телуґу\":\"te\",\"турецька\":\"tr\",\"угорська\":\"hu\",\"узбецька\":\"uz\",\"українська\":\"uk\",\"фінська\":\"fi\",\"французька\":\"fr\",\"хорватська\":\"hr\",\"чеська\":\"cs\",\"шведська\":\"sv\",\"шотландська (ґельська)\":\"gd\",\"японська\":\"ja\",\"土耳其文\":\"tr\",\"中文(繁體)\":\"zh-tw\",\"中文(簡體)\":\"zh-cn\",\"丹麥文\":\"da\",\"巴斯克文\":\"eu\",\"日文\":\"ja\",\"毛利文\":\"mi\",\"世界語\":\"eo\",\"加里西亞文\":\"gl\",\"加泰羅尼亞文\":\"ca\",\"卡納達文\":\"kn\",\"白俄羅斯文\":\"be\",\"立陶宛文\":\"lt\",\"冰島文\":\"is\",\"匈牙利文\":\"hu\",\"印尼文\":\"id\",\"印度文\":\"hi\",\"西班牙文\":\"es\",\"克羅埃西亞文\":\"hr\",\"希伯來文\":\"he\",\"希臘文\":\"el\",\"亞美尼亞文\":\"hy\",\"亞塞拜然文\":\"az\",\"拉丁文\":\"la\",\"拉脫維亞文\":\"lv\",\"法文\":\"fr\",\"波斯文\":\"fa\",\"波蘭文\":\"pl\",\"芬蘭文\":\"fi\",\"阿姆哈拉文\":\"am\",\"阿拉伯文\":\"ar\",\"阿爾巴尼亞文\":\"sq\",\"俄文\":\"ru\",\"保加利亞文\":\"bg\",\"南非祖魯文\":\"zu\",\"威爾斯文\":\"cy\",\"英文\":\"en\",\"庫德文\":\"ku\",\"挪威文\":\"nb\",\"泰文\":\"th\",\"泰盧固文\":\"te\",\"海地克里奧文\":\"ht\",\"烏克蘭文\":\"uk\",\"烏茲別克文\":\"uz\",\"馬耳他文\":\"mt\",\"馬來文\":\"ms\",\"馬其頓文\":\"mk\",\"馬拉地文\":\"mr\",\"馬拉雅拉姆文\":\"ml\",\"捷克文\":\"cs\",\"荷蘭文\":\"nl\",\"斯洛伐克文\":\"sk\",\"斯洛維尼亞文\":\"sl\",\"越南文\":\"vi\",\"塞爾維亞文\":\"sr\",\"愛沙尼亞文\":\"et\",\"愛爾蘭文\":\"ga\",\"瑞典文\":\"sv\",\"義大利文\":\"it\",\"葡萄牙文\":\"pt\",\"蒙古文\":\"mn\",\"德文\":\"de\",\"緬甸文\":\"my\",\"韓文\":\"ko\",\"羅馬尼亞文\":\"ro\",\"蘇格蘭的蓋爾文\":\"gd\",\"अझरबैजानी\":\"az\",\"अम्हारिक\":\"am\",\"अरबी\":\"ar\",\"अर्मेनियन\":\"hy\",\"अल्बानियन\":\"sq\",\"आइसलँडिक\":\"is\",\"आयरिश\":\"ga\",\"इंग्रजी\":\"en\",\"इंडोनेशियन\":\"id\",\"इटालियन\":\"it\",\"उझ्बेक\":\"uz\",\"एस्टोनियन\":\"et\",\"एस्परँटो\":\"eo\",\"कन्नड\":\"kn\",\"कुर्दिश (कुर्मांजी)\":\"ku\",\"कॅटलान\":\"ca\",\"कोरियन\":\"ko\",\"क्रोएशियन\":\"hr\",\"गॅलिशियन\":\"gl\",\"ग्रीक\":\"el\",\"चीनी (पारंपारिक)\":\"zh-tw\",\"चीनी (सरलीकृत)\":\"zh-cn\",\"जपानी\":\"ja\",\"जर्मन\":\"de\",\"झुलु\":\"zu\",\"झेक\":\"cs\",\"डच\":\"nl\",\"डॅनिश\":\"da\",\"तुर्की\":\"tr\",\"तेलगू\":\"te\",\"थाई\":\"th\",\"नॉर्वेजियन\":\"nb\",\"पोर्तुगीज\":\"pt\",\"पोलिश\":\"pl\",\"फारसी\":\"fa\",\"फिन्निश\":\"fi\",\"फ्रेंच\":\"fr\",\"बल्गेरियन\":\"bg\",\"बास्क\":\"eu\",\"बेलारुशियन\":\"be\",\"मंगोलियन\":\"mn\",\"मराठी\":\"mr\",\"मलय\":\"ms\",\"मल्याळम\":\"ml\",\"माओरी\":\"mi\",\"माल्टीज\":\"mt\",\"मॅसेडोनियन\":\"mk\",\"म्यानमार (बर्मीज)\":\"my\",\"युक्रेनियन\":\"uk\",\"रशियन\":\"ru\",\"रोमानियन\":\"ro\",\"लाट्वियन\":\"lv\",\"लिथुआनियन\":\"lt\",\"लॅटिन\":\"la\",\"वेल्श\":\"cy\",\"व्हिएतनामी\":\"vi\",\"सर्बियन\":\"sr\",\"स्कॉट्स गेलिक\":\"gd\",\"स्पॅनिश\":\"es\",\"स्लोव्हाक\":\"sk\",\"स्लोव्हेनियन\":\"sl\",\"स्वीडिश\":\"sv\",\"हंगेरियन\":\"hu\",\"हिन्दी\":\"hi\",\"हिब्रू\":\"he\",\"हैतीयन क्रेओल\":\"ht\",\"albanian\":\"sq\",\"amharic\":\"am\",\"arabic\":\"ar\",\"armenian\":\"hy\",\"azerbaijani\":\"az\",\"belarusian\":\"be\",\"bulgarian\":\"bg\",\"chinese (simplified)\":\"zh-cn\",\"chinese (traditional)\":\"zh-tw\",\"croatian\":\"hr\",\"czech\":\"cs\",\"danish\":\"da\",\"dutch\":\"nl\",\"english\":\"en\",\"estonian\":\"et\",\"finnish\":\"fi\",\"french\":\"fr\",\"galician\":\"gl\",\"german\":\"de\",\"greek\":\"el\",\"haitian creole\":\"ht\",\"hebrew\":\"he\",\"hungarian\":\"hu\",\"icelandic\":\"is\",\"indonesian\":\"id\",\"irish\":\"ga\",\"italian\":\"it\",\"japanese\":\"ja\",\"korean\":\"ko\",\"kurdish (kurmanji)\":\"ku\",\"latvian\":\"lv\",\"lithuanian\":\"lt\",\"macedonian\":\"mk\",\"malay\":\"ms\",\"maltese\":\"mt\",\"mongolian\":\"mn\",\"myanmar (burmese)\":\"my\",\"norwegian\":\"nb\",\"persian\":\"fa\",\"polish\":\"pl\",\"portuguese\":\"pt\",\"romanian\":\"ro\",\"russian\":\"ru\",\"scots gaelic\":\"gd\",\"serbian\":\"sr\",\"slovak\":\"sk\",\"slovenian\":\"sl\",\"spanish\":\"es\",\"swedish\":\"sv\",\"turkish\":\"tr\",\"ukrainian\":\"uk\",\"uzbek\":\"uz\",\"vietnamese\":\"vi\",\"welsh\":\"cy\",\"albanês\":\"sq\",\"alemão\":\"de\",\"armênio\":\"hy\",\"azerbaijano\":\"az\",\"basco\":\"eu\",\"bielo-russo\":\"be\",\"birmanês\":\"my\",\"canarês\":\"kn\",\"catalão\":\"ca\",\"chinês (simplificado)\":\"zh-cn\",\"chinês (tradicional)\":\"zh-tw\",\"dinamarquês\":\"da\",\"espanhol\":\"es\",\"finlandês\":\"fi\",\"francês\":\"fr\",\"gaélico escocês\":\"gd\",\"galês\":\"cy\",\"hebraico\":\"he\",\"holandês\":\"nl\",\"indonésio\":\"id\",\"inglês\":\"en\",\"irlandês\":\"ga\",\"islandês\":\"is\",\"japonês\":\"ja\",\"latim\":\"la\",\"letão\":\"lv\",\"macedônio\":\"mk\",\"malaiala\":\"ml\",\"maltês\":\"mt\",\"marata\":\"mr\",\"norueguês\":\"nb\",\"polonês\":\"pl\",\"português\":\"pt\",\"romeno\":\"ro\",\"russo\":\"ru\",\"sérvio\":\"sr\",\"tailandês\":\"th\",\"tcheco\":\"cs\",\"telugo\":\"te\",\"ucraniano\":\"uk\",\"uzbeque\":\"uz\",\"almanca\":\"de\",\"arapça\":\"ar\",\"arnavutça\":\"sq\",\"azerice\":\"az\",\"baskça\":\"eu\",\"belarusça\":\"be\",\"bulgarca\":\"bg\",\"burmaca\":\"my\",\"çekçe\":\"cs\",\"çince (basitleştirilmiş)\":\"zh-cn\",\"çince (geleneksel)\":\"zh-tw\",\"danca\":\"da\",\"endonezya dili\":\"id\",\"ermenice\":\"hy\",\"esperantoca\":\"eo\",\"estonyaca\":\"et\",\"farsça\":\"fa\",\"felemenkçe\":\"nl\",\"fince\":\"fi\",\"fransızca\":\"fr\",\"galce\":\"cy\",\"galiçyaca\":\"gl\",\"habeşçe\":\"am\",\"haiti creole dili\":\"ht\",\"hırvatça\":\"hr\",\"hintçe\":\"hi\",\"i̇branice\":\"he\",\"i̇ngilizce\":\"en\",\"i̇rlandaca\":\"ga\",\"i̇spanyolca\":\"es\",\"i̇sveççe\":\"sv\",\"i̇talyanca\":\"it\",\"i̇zlandaca\":\"is\",\"japonca\":\"ja\",\"katalanca\":\"ca\",\"korece\":\"ko\",\"kuzey i̇skoç dili\":\"gd\",\"kürtçe\":\"ku\",\"latince\":\"la\",\"lehçe\":\"pl\",\"letonca\":\"lv\",\"litvanca\":\"lt\",\"macarca\":\"hu\",\"makedonca\":\"mk\",\"malezya dili\":\"ms\",\"malta dili\":\"mt\",\"maori dili\":\"mi\",\"moğolca\":\"mn\",\"norveççe\":\"nb\",\"özbekçe\":\"uz\",\"portekizce\":\"pt\",\"romence\":\"ro\",\"rusça\":\"ru\",\"sırpça\":\"sr\",\"slovakça\":\"sk\",\"slovence\":\"sl\",\"tay dili\":\"th\",\"telugu dili\":\"te\",\"türkçe\":\"tr\",\"ukraynaca\":\"uk\",\"vietnamca\":\"vi\",\"yunanca\":\"el\",\"airméinis\":\"hy\",\"albáinis\":\"sq\",\"amárais\":\"am\",\"araibis\":\"ar\",\"asarbaiseáinis\":\"az\",\"bascais\":\"eu\",\"bealarúisis\":\"be\",\"béarla\":\"en\",\"breatnais\":\"cy\",\"bulgáiris\":\"bg\",\"cannadais\":\"kn\",\"catalóinis\":\"ca\",\"coirdis (curmainsis)\":\"ku\",\"cóiréis\":\"ko\",\"criól háítí\":\"ht\",\"cróitis\":\"hr\",\"danmhairgis\":\"da\",\"eabhrais\":\"he\",\"eastóinis\":\"et\",\"fionlainnis\":\"fi\",\"fraincis\":\"fr\",\"gaeilge\":\"ga\",\"gaeilge na halban\":\"gd\",\"gailísis\":\"gl\",\"gearmáinis\":\"de\",\"gréigis\":\"el\",\"hiondúis\":\"hi\",\"indinéisis\":\"id\",\"iodáilis\":\"it\",\"ioruais\":\"nb\",\"íoslainnis\":\"is\",\"laidin\":\"la\",\"laitvis\":\"lv\",\"liotuáinis\":\"lt\",\"macadóinis\":\"mk\",\"maenmar (burmais)\":\"my\",\"mailéalaimis\":\"ml\",\"malaeis\":\"ms\",\"máltais\":\"mt\",\"maorais\":\"mi\",\"maraitis\":\"mr\",\"mongóilis\":\"mn\",\"ollainnis\":\"nl\",\"peirsis\":\"fa\",\"polainnis\":\"pl\",\"portaingéilis\":\"pt\",\"rómáinis\":\"ro\",\"rúisis\":\"ru\",\"seapáinis\":\"ja\",\"seicis\":\"cs\",\"seirbis\":\"sr\",\"sínis (simplithe)\":\"zh-cn\",\"sínis (traidisiúnta)\":\"zh-tw\",\"slóivéinis\":\"sl\",\"slóvaicis\":\"sk\",\"spáinnis\":\"es\",\"sualainnis\":\"sv\",\"súlúis\":\"zu\",\"téalainnis\":\"th\",\"teileagúis\":\"te\",\"tuircis\":\"tr\",\"úcráinis\":\"uk\",\"úisbéiceastáinis\":\"uz\",\"ungáiris\":\"hu\",\"vítneaimis\":\"vi\",\"ภาษากรีก\":\"el\",\"ภาษากันนาดา\":\"kn\",\"ภาษากาลิเชียน\":\"gl\",\"ภาษาเกลิกในสก็อต\":\"gd\",\"ภาษาเกาหลี\":\"ko\",\"ภาษาคาตาลัน\":\"ca\",\"ภาษาเคิร์ด\":\"ku\",\"ภาษาโครเอเชีย\":\"hr\",\"ภาษาจีน (ดั้งเดิม)\":\"zh-tw\",\"ภาษาจีน (แบบย่อ)\":\"zh-cn\",\"ภาษาเช็ก\":\"cs\",\"ภาษาซูลู\":\"zu\",\"ภาษาเซอร์เบียน\":\"sr\",\"ภาษาญี่ปุ่น\":\"ja\",\"ภาษาดัตช์\":\"nl\",\"ภาษาเดนมาร์ก\":\"da\",\"ภาษาตุรกี\":\"tr\",\"ภาษาเตลูกู\":\"te\",\"ภาษาไทย\":\"th\",\"ภาษานอร์เวย์\":\"nb\",\"ภาษาบัลกาเรีย\":\"bg\",\"ภาษาบาสก์\":\"eu\",\"ภาษาเบลารูเชียน\":\"be\",\"ภาษาเปอร์เซีย\":\"fa\",\"ภาษาโปรตุเกส\":\"pt\",\"ภาษาโปแลนด์\":\"pl\",\"ภาษาฝรั่งเศส\":\"fr\",\"ภาษาฟินแลนด์\":\"fi\",\"ภาษามองโกเลีย\":\"mn\",\"ภาษามัลทีส\":\"mt\",\"ภาษามาซีโดเนีย\":\"mk\",\"ภาษามาราฐี\":\"mr\",\"ภาษามาลายาลัม\":\"ml\",\"ภาษามาเลย์\":\"ms\",\"ภาษาเมารี\":\"mi\",\"ภาษาเมียนมา (พม่า)\":\"my\",\"ภาษายูเครน\":\"uk\",\"ภาษาเยอรมัน\":\"de\",\"ภาษารัสเซีย\":\"ru\",\"ภาษาโรมาเนีย\":\"ro\",\"ภาษาละติน\":\"la\",\"ภาษาลัทเวีย\":\"lv\",\"ภาษาลิทัวเนีย\":\"lt\",\"ภาษาเวลส์\":\"cy\",\"ภาษาเวียดนาม\":\"vi\",\"ภาษาสเปน\":\"es\",\"ภาษาสโลวัก\":\"sk\",\"ภาษาสโลเวเนีย\":\"sl\",\"ภาษาสวีเดน\":\"sv\",\"ภาษาอังกฤษ\":\"en\",\"ภาษาอัมฮาริก\":\"am\",\"ภาษาอัลบาเนีย\":\"sq\",\"ภาษาอาร์เซอร์ไบจัน\":\"az\",\"ภาษาอาร์เมเนีย\":\"hy\",\"ภาษาอาหรับ\":\"ar\",\"ภาษาอิตาลี\":\"it\",\"ภาษาอินโดนีเซีย\":\"id\",\"ภาษาอุสเบกิสถาน\":\"uz\",\"ภาษาเอสโทเนีย\":\"et\",\"ภาษาเอสเปอแรนโต\":\"eo\",\"ภาษาไอซ์แลนดิก\":\"is\",\"ภาษาไอริช\":\"ga\",\"ภาษาฮังการี\":\"hu\",\"ภาษาฮินดี\":\"hi\",\"ภาษาฮิบรู\":\"he\",\"ภาษาเฮติครีโอล\":\"ht\",\"アイスランド語\":\"is\",\"アイルランド語\":\"ga\",\"アゼルバイジャン語\":\"az\",\"アムハラ語\":\"am\",\"アラビア語\":\"ar\",\"アルバニア語\":\"sq\",\"アルメニア語\":\"hy\",\"イタリア語\":\"it\",\"インドネシア語\":\"id\",\"ウェールズ語\":\"cy\",\"ウクライナ語\":\"uk\",\"ウズベク語\":\"uz\",\"エストニア語\":\"et\",\"エスペラント語\":\"eo\",\"オランダ語\":\"nl\",\"カタルーニャ語\":\"ca\",\"ガリシア語\":\"gl\",\"カンナダ語\":\"kn\",\"ギリシャ語\":\"el\",\"クルド語\":\"ku\",\"クロアチア語\":\"hr\",\"スウェーデン語\":\"sv\",\"ズールー語\":\"zu\",\"スコットランド ゲール語\":\"gd\",\"スペイン語\":\"es\",\"スロバキア語\":\"sk\",\"スロベニア語\":\"sl\",\"セルビア語\":\"sr\",\"タイ語\":\"th\",\"チェコ語\":\"cs\",\"テルグ語\":\"te\",\"デンマーク語\":\"da\",\"ドイツ語\":\"de\",\"トルコ語\":\"tr\",\"ノルウェー語\":\"nb\",\"ハイチ語\":\"ht\",\"バスク語\":\"eu\",\"ハンガリー語\":\"hu\",\"ヒンディー語\":\"hi\",\"フィンランド語\":\"fi\",\"フランス語\":\"fr\",\"ブルガリア語\":\"bg\",\"ベトナム語\":\"vi\",\"ヘブライ語\":\"he\",\"ベラルーシ語\":\"be\",\"ペルシャ語\":\"fa\",\"ポーランド語\":\"pl\",\"ポルトガル語\":\"pt\",\"マオリ語\":\"mi\",\"マケドニア語\":\"mk\",\"マラーティー語\":\"mr\",\"マラヤーラム語\":\"ml\",\"マルタ語\":\"mt\",\"マレー語\":\"ms\",\"ミャンマー語\":\"my\",\"モンゴル語\":\"mn\",\"ラテン語\":\"la\",\"ラトビア語\":\"lv\",\"リトアニア語\":\"lt\",\"ルーマニア語\":\"ro\",\"ロシア語\":\"ru\",\"英語\":\"en\",\"韓国語\":\"ko\",\"中国語(簡体)\":\"zh-cn\",\"中国語(繁体)\":\"zh-tw\",\"日本語\":\"ja\",\"albanees\":\"sq\",\"amharisch\":\"am\",\"arabisch\":\"ar\",\"armeens\":\"hy\",\"azerbeidzjaans\":\"az\",\"baskisch\":\"eu\",\"birmaans\":\"my\",\"bulgaars\":\"bg\",\"catalaans\":\"ca\",\"chinees (traditioneel)\":\"zh-tw\",\"chinees (vereenvoudigd)\":\"zh-cn\",\"deens\":\"da\",\"duits\":\"de\",\"engels\":\"en\",\"ests\":\"et\",\"fins\":\"fi\",\"frans\":\"fr\",\"galicisch\":\"gl\",\"grieks\":\"el\",\"haïtiaans creools\":\"ht\",\"hebreeuws\":\"he\",\"hongaars\":\"hu\",\"iers\":\"ga\",\"ijslands\":\"is\",\"indonesisch\":\"id\",\"italiaans\":\"it\",\"japans\":\"ja\",\"koerdisch\":\"ku\",\"koreaans\":\"ko\",\"kroatisch\":\"hr\",\"latijn\":\"la\",\"lets\":\"lv\",\"litouws\":\"lt\",\"macedonisch\":\"mk\",\"maleis\":\"ms\",\"maltees\":\"mt\",\"mongools\":\"mn\",\"nederlands\":\"nl\",\"noors\":\"nb\",\"oekraïens\":\"uk\",\"oezbeeks\":\"uz\",\"perzisch\":\"fa\",\"pools\":\"pl\",\"portugees\":\"pt\",\"roemeens\":\"ro\",\"russisch\":\"ru\",\"schots keltisch\":\"gd\",\"servisch\":\"sr\",\"slovaaks\":\"sk\",\"sloveens\":\"sl\",\"spaans\":\"es\",\"tsjechisch\":\"cs\",\"turks\":\"tr\",\"vietnamees\":\"vi\",\"wels\":\"cy\",\"wit-russisch\":\"be\",\"zoeloe\":\"zu\",\"zweeds\":\"sv\",\"airmeinis\":\"hy\",\"albàinis\":\"sq\",\"amtharais\":\"am\",\"arabais\":\"ar\",\"asarbaideànais\":\"az\",\"basgais\":\"eu\",\"bealaruisis\":\"be\",\"beurla\":\"en\",\"bhiet-namais\":\"vi\",\"bulgarais\":\"bg\",\"cànan nan tàidh\":\"th\",\"catalanais\":\"ca\",\"coirèanais\":\"ko\",\"crìtheol haidhti\":\"ht\",\"cròthaisis\":\"hr\",\"cuimris\":\"cy\",\"cùrdais (kurmanji)\":\"ku\",\"duitsis\":\"nl\",\"eabhra\":\"he\",\"eadailtis\":\"it\",\"eastoinis\":\"et\",\"fionnlannais\":\"fi\",\"fraingis\":\"fr\",\"gàidhlig\":\"gd\",\"gailìsis\":\"gl\",\"gearmailtis\":\"de\",\"grèigis\":\"el\",\"hindis\":\"hi\",\"innd-innsis\":\"id\",\"innis-tìlis\":\"is\",\"laideann\":\"la\",\"laitbheis\":\"lv\",\"liotuainis\":\"lt\",\"malaidhis\":\"ms\",\"māori\":\"mi\",\"masadonais\":\"mk\",\"miànmar (burmais)\":\"my\",\"mongolais\":\"mn\",\"nirribhis\":\"nb\",\"pòlainnis\":\"pl\",\"portagailis\":\"pt\",\"romàinis\":\"ro\",\"ruisis\":\"ru\",\"seacais\":\"cs\",\"seapanais\":\"ja\",\"sèirbis\":\"sr\",\"sìonais (seann-nòsach)\":\"zh-tw\",\"sìonais (sìmplichte)\":\"zh-cn\",\"slòbhacais\":\"sk\",\"slòbhainis\":\"sl\",\"spàinntis\":\"es\",\"suainis\":\"sv\",\"turcais\":\"tr\",\"ucràinis\":\"uk\",\"ungairis\":\"hu\",\"usbagais\":\"uz\",\"farsi\":\"fa\",\"galisisk\":\"gl\",\"gresk\":\"el\",\"hviterussisk\":\"be\",\"kinesisk (tradisjonell)\":\"zh-tw\",\"kreol (haiti)\":\"ht\",\"latvisk\":\"lv\",\"malayisk\":\"ms\",\"nederlandsk\":\"nl\",\"rumensk\":\"ro\",\"tsjekkisk\":\"cs\",\"albanisch\":\"sq\",\"armenisch\":\"hy\",\"aserbaidschanisch\":\"az\",\"birmanisch\":\"my\",\"bulgarisch\":\"bg\",\"chinesisch (traditionell)\":\"zh-tw\",\"chinesisch (vereinfacht)\":\"zh-cn\",\"dänisch\":\"da\",\"deutsch\":\"de\",\"englisch\":\"en\",\"estnisch\":\"et\",\"finnisch\":\"fi\",\"französisch\":\"fr\",\"galizisch\":\"gl\",\"griechisch\":\"el\",\"haitianisch\":\"ht\",\"hebräisch\":\"he\",\"irisch\":\"ga\",\"isländisch\":\"is\",\"italienisch\":\"it\",\"japanisch\":\"ja\",\"katalanisch\":\"ca\",\"koreanisch\":\"ko\",\"kurdisch (kurmandschi)\":\"ku\",\"lateinisch\":\"la\",\"lettisch\":\"lv\",\"litauisch\":\"lt\",\"malaysisch\":\"ms\",\"maltesisch\":\"mt\",\"mazedonisch\":\"mk\",\"mongolisch\":\"mn\",\"niederländisch\":\"nl\",\"norwegisch\":\"nb\",\"persisch\":\"fa\",\"polnisch\":\"pl\",\"portugiesisch\":\"pt\",\"rumänisch\":\"ro\",\"schottisch-gälisch\":\"gd\",\"schwedisch\":\"sv\",\"serbisch\":\"sr\",\"slowakisch\":\"sk\",\"slowenisch\":\"sl\",\"spanisch\":\"es\",\"thailändisch\":\"th\",\"tschechisch\":\"cs\",\"türkisch\":\"tr\",\"ukrainisch\":\"uk\",\"ungarisch\":\"hu\",\"usbekisch\":\"uz\",\"vietnamesisch\":\"vi\",\"walisisch\":\"cy\",\"weißrussisch\":\"be\",\"ကနာဒါ\":\"kn\",\"ကာ့ဒ် (ကာမန်ဂျီ)\":\"ku\",\"ကိုရီးယား\":\"ko\",\"ကက်တလန်\":\"ca\",\"ခရိုအေးရှား\":\"hr\",\"ချက်\":\"cs\",\"ဂရိ\":\"el\",\"ဂယ်လိရှ\":\"gl\",\"ဂျပန်\":\"ja\",\"ဂျာမန်\":\"de\",\"စကော့ ဂေးလစ်\":\"gd\",\"စပိန်\":\"es\",\"ဆလိုဗေးနီးယား\":\"sl\",\"ဆလိုဗက်\":\"sk\",\"ဆားဘီးယား\":\"sr\",\"ဆွီဒင်\":\"sv\",\"ဇူးလူး\":\"zu\",\"တရုတ် (ရိုးရာ)\":\"zh-tw\",\"တရုတ် (အလွယ်)\":\"zh-cn\",\"တူ​ရ​ကီ\":\"tr\",\"တယ်လူဂူ\":\"te\",\"ထိုင်း\":\"th\",\"ဒတ်ချ်\":\"nl\",\"ဒိန်းမတ်\":\"da\",\"နော်ဝေ\":\"nb\",\"ပါရှန်\":\"fa\",\"ပေါ်တူဂီ\":\"pt\",\"ပိုလန်\":\"pl\",\"ပြင်သစ်\":\"fr\",\"ဖင်လန်\":\"fi\",\"ဗီယက်နမ်\":\"vi\",\"ဘာ့စ်\":\"eu\",\"ဘူဂေးရီးယား\":\"bg\",\"ဘယ်လာရုစ်\":\"be\",\"မလေယာလမ်\":\"ml\",\"မလေး\":\"ms\",\"မာရာသီ\":\"mr\",\"မော်ရီ\":\"mi\",\"မော်လတာ\":\"mt\",\"မက်ဆီဒိုးနီးယား\":\"mk\",\"မြန်မာ (မြန်မာ)\":\"my\",\"မွန်ဂိုလီးယား\":\"mn\",\"ယူ​က​ရိန်း​\":\"uk\",\"ရုရှား\":\"ru\",\"ရိုမေးနီးယား\":\"ro\",\"လက်တင်\":\"la\",\"လစ်သူယေးနီးယား\":\"lt\",\"လတ်ဗီယာ\":\"lv\",\"ဝေလ\":\"cy\",\"ဟီဘရူး\":\"he\",\"ဟေတီ ခရီအိုး\":\"ht\",\"ဟင်ဒီ\":\"hi\",\"ဟန်ဂေရီ\":\"hu\",\"အဇာဘိုင်ဂျန်\":\"az\",\"အာမေးနီးယား\":\"hy\",\"အာရေဗျ\":\"ar\",\"အီတလီ\":\"it\",\"ဥဇဘက်\":\"uz\",\"အက်စတိုးနီးယား\":\"et\",\"အက်စ်ပဲရန်တို\":\"eo\",\"အိုက်စလန်\":\"is\",\"အင်္ဂလိပ်\":\"en\",\"အင်ဒိုနီးရှား\":\"id\",\"အိုင်းရစ်ရှ်\":\"ga\",\"အမ်ဟဲရစ်ခ်\":\"am\",\"အယ်လ်ဘေးနီးယား\":\"sq\",\"אוזבקית\":\"uz\",\"אוקראינית\":\"uk\",\"אזרית\":\"az\",\"איטלקית\":\"it\",\"אינדונזית\":\"id\",\"איסלנדית\":\"is\",\"אירית\":\"ga\",\"אלבנית\":\"sq\",\"אמהרית\":\"am\",\"אנגלית\":\"en\",\"אסטונית\":\"et\",\"אספרנטו\":\"eo\",\"ארמנית\":\"hy\",\"באסקית\":\"eu\",\"בולגרית\":\"bg\",\"בורמזית\":\"my\",\"בלארוסית\":\"be\",\"גליציאנית\":\"gl\",\"גרמנית\":\"de\",\"דנית\":\"da\",\"הולנדית\":\"nl\",\"הונגרית\":\"hu\",\"הינדי\":\"hi\",\"וולשית\":\"cy\",\"וייטנאמית\":\"vi\",\"זולו\":\"zu\",\"טורקית\":\"tr\",\"טלוגו\":\"te\",\"יוונית\":\"el\",\"יפנית\":\"ja\",\"כורדית\":\"ku\",\"לטווית\":\"lv\",\"לטינית\":\"la\",\"ליטאית\":\"lt\",\"מאורית\":\"mi\",\"מאלאיאלם\":\"ml\",\"מאלזית\":\"ms\",\"מאראתי\":\"mr\",\"מונגולית\":\"mn\",\"מלטית\":\"mt\",\"מקדונית\":\"mk\",\"נורווגית\":\"nb\",\"סינית (מסורתית)\":\"zh-tw\",\"סינית (פשוטה)\":\"zh-cn\",\"סלובנית\":\"sl\",\"סלובקית\":\"sk\",\"ספרדית\":\"es\",\"סקוטית גאלית\":\"gd\",\"סרבית\":\"sr\",\"עברית\":\"he\",\"ערבית\":\"ar\",\"פולנית\":\"pl\",\"פורטוגזית\":\"pt\",\"פינית\":\"fi\",\"פרסית\":\"fa\",\"צ'כית\":\"cs\",\"צרפתית\":\"fr\",\"קאנאדה\":\"kn\",\"קוריאנית\":\"ko\",\"קטלאנית\":\"ca\",\"קרואטית\":\"hr\",\"קריאולית האיטית\":\"ht\",\"רומנית\":\"ro\",\"רוסית\":\"ru\",\"שוודית\":\"sv\",\"תאילנדית\":\"th\",\"азербејџански\":\"az\",\"албански\":\"sq\",\"амхарски\":\"am\",\"англиски\":\"en\",\"арапски\":\"ar\",\"баскиски\":\"eu\",\"белоруски\":\"be\",\"бугарски\":\"bg\",\"бурмански\":\"my\",\"велшки\":\"cy\",\"виетнамски\":\"vi\",\"галициски\":\"gl\",\"германски\":\"de\",\"грчки\":\"el\",\"дански\":\"da\",\"ерменски\":\"hy\",\"естонски\":\"et\",\"индонезиски\":\"id\",\"ирски\":\"ga\",\"исландски\":\"is\",\"италијански\":\"it\",\"јапонски\":\"ja\",\"канада\":\"kn\",\"каталонски\":\"ca\",\"кинески (поедноставен)\":\"zh-cn\",\"кинески (традиционален)\":\"zh-tw\",\"корејски\":\"ko\",\"курдски\":\"ku\",\"латвиски\":\"lv\",\"латински\":\"la\",\"литвански\":\"lt\",\"македонски\":\"mk\",\"малајалам\":\"ml\",\"малајски\":\"ms\",\"малтешки\":\"mt\",\"маорски\":\"mi\",\"маратхи\":\"mr\",\"монголски\":\"mn\",\"норвешки\":\"nb\",\"персиски\":\"fa\",\"полски\":\"pl\",\"португалски\":\"pt\",\"романски\":\"ro\",\"руски\":\"ru\",\"словачки\":\"sk\",\"словенечки\":\"sl\",\"српски\":\"sr\",\"тајландски\":\"th\",\"телугу\":\"te\",\"турски\":\"tr\",\"узбечки\":\"uz\",\"украински\":\"uk\",\"унгарски\":\"hu\",\"фински\":\"fi\",\"француски\":\"fr\",\"хаитски креолски\":\"ht\",\"хебрејски\":\"he\",\"хиндиски\":\"hi\",\"холандски\":\"nl\",\"хрватски\":\"hr\",\"чешки\":\"cs\",\"шведски\":\"sv\",\"шкотски галски\":\"gd\",\"шпански\":\"es\",\"ಅಜರ್ಬೈಜಾನಿ\":\"az\",\"ಅಮಹಾರಿಕ್\":\"am\",\"ಅರಬ್ಬಿ\":\"ar\",\"ಆರ್ಮೇನಿಯನ್\":\"hy\",\"ಆಲ್ಬೇನಿಯನ್\":\"sq\",\"ಇಂಗ್ಲಿಷ್‌‌\":\"en\",\"ಇಂಡೋನೇಷಿಯನ್\":\"id\",\"ಇಟಾಲಿಯನ್\":\"it\",\"ಉಜ್ಬೆಕ್\":\"uz\",\"ಎಸ್ಟೋನಿಯನ್\":\"et\",\"ಎಸ್ಪೆರಾಂಟೋ\":\"eo\",\"ಐರಿಷ್\":\"ga\",\"ಐಸ್‌ಲ್ಯಾಂಡಿಕ್‌\":\"is\",\"ಕನ್ನಡ\":\"kn\",\"ಕುರ್ದಿಶ್\":\"ku\",\"ಕೊರಿಯನ್\":\"ko\",\"ಕ್ಯಾಟಲನ್\":\"ca\",\"ಕ್ರೊಯೇಷಿಯನ್\":\"hr\",\"ಗ್ಯಾಲೀಷಿಯನ್\":\"gl\",\"ಗ್ರೀಕ್\":\"el\",\"ಚೀನಿ (ಸರಳೀಕೃತ)\":\"zh-cn\",\"ಚೀನಿ (ಸಾಂಪ್ರದಾಯಿಕ)\":\"zh-tw\",\"ಜಪಾನಿ\":\"ja\",\"ಜರ್ಮನ್\":\"de\",\"ಜುಲು\":\"zu\",\"ಝೆಕ್‌\":\"cs\",\"ಟರ್ಕಿಷ್\":\"tr\",\"ಡಚ್\":\"nl\",\"ಡ್ಯಾನಿಷ್\":\"da\",\"ತೆಲುಗು\":\"te\",\"ಥಾಯ್\":\"th\",\"ನಾರ್ವೇಜಿಯನ್‌\":\"nb\",\"ಪೋರ್ಚುಗೀಸ್\":\"pt\",\"ಪೋಲಿಷ್\":\"pl\",\"ಫಾರ್ಸಿ\":\"fa\",\"ಫಿನ್ನಿಷ್\":\"fi\",\"ಫ್ರೆಂಚ್\":\"fr\",\"ಬರ್ಮೀಸ್\":\"my\",\"ಬಲ್ಗೇರಿಯನ್\":\"bg\",\"ಬಾಸ್ಕ್\":\"eu\",\"ಬೆಲರೂಸಿಯನ್\":\"be\",\"ಮಂಗೋಲಿಯನ್\":\"mn\",\"ಮರಾಠಿ\":\"mr\",\"ಮಲಯ\":\"ms\",\"ಮಲಯಾಳಂ\":\"ml\",\"ಮಾಲ್ಟೀಸ್\":\"mt\",\"ಮಾವೋರಿ\":\"mi\",\"ಮ್ಯಾಸೆಡೋನಿಯನ್\":\"mk\",\"ಯುಕ್ರೇನಿಯನ್\":\"uk\",\"ರಷಿಯನ್\":\"ru\",\"ರೊಮೇನಿಯನ್\":\"ro\",\"ಲಿಥುವೇನಿಯನ್\":\"lt\",\"ಲ್ಯಾಟಿನ್\":\"la\",\"ಲ್ಯಾಟ್ವಿಯನ್‌\":\"lv\",\"ವಿಯೆಟ್ನಾಮಿ\":\"vi\",\"ವೆಲ್ಶ್\":\"cy\",\"ಸರ್ಬಿಯನ್\":\"sr\",\"ಸ್ಕಾಟ್ಸ್ ಗ್ಯಾಲಿಕ್\":\"gd\",\"ಸ್ಪ್ಯಾನಿಷ್\":\"es\",\"ಸ್ಲೊವಾಕ್\":\"sk\",\"ಸ್ಲೊವೆನಿಯನ್\":\"sl\",\"ಸ್ವೀಡಿಷ್\":\"sv\",\"ಹಂಗೇರಿಯನ್\":\"hu\",\"ಹಯಥಿಯನ್‌ ಕ್ರಿಯೋಲ್‌\":\"ht\",\"ಹಿಂದಿ\":\"hi\",\"ಹೀಬ್ರೂ\":\"he\",\"അമാറിക്\":\"am\",\"അർമേനിയൻ\":\"hy\",\"അൽബേനിയൻ\":\"sq\",\"അസർബൈജാനി\":\"az\",\"അറബിക്\":\"ar\",\"ഇന്തോനേഷ്യൻ\":\"id\",\"ഇംഗ്ലീഷ്\":\"en\",\"ഇറ്റാലിയൻ\":\"it\",\"ഉക്രേനിയൻ\":\"uk\",\"ഉസ്ബെക്ക്\":\"uz\",\"എസ്‌പെരന്തോ\":\"eo\",\"എസ്റ്റോണിയൻ\":\"et\",\"ഐസ്‌ലാൻഡിക്\":\"is\",\"ഐറിഷ്\":\"ga\",\"കന്നട\":\"kn\",\"കാറ്റലൻ\":\"ca\",\"കുർദ്ദിഷ്\":\"ku\",\"കൊറിയൻ\":\"ko\",\"ക്രൊയേഷ്യൻ\":\"hr\",\"ഗലീഷ്യൻ\":\"gl\",\"ഗ്രീക്ക്\":\"el\",\"ചെക്ക്\":\"cs\",\"ചൈനീസ് (പരമ്പരാഗതം)\":\"zh-tw\",\"ചൈനീസ് (ലഘൂകരിച്ചത്)\":\"zh-cn\",\"ജർമ്മൻ\":\"de\",\"ജാപ്പനീസ്‌\":\"ja\",\"ടർക്കിഷ്\":\"tr\",\"ഡച്ച്\":\"nl\",\"ഡാനിഷ്\":\"da\",\"തായ്\":\"th\",\"തെലുങ്ക്\":\"te\",\"നോർവീജിയൻ\":\"nb\",\"പേർഷ്യൻ\":\"fa\",\"പോർച്ചുഗീസ്\":\"pt\",\"പോളിഷ്\":\"pl\",\"ഫിന്നിഷ്\":\"fi\",\"ഫ്രെഞ്ച്\":\"fr\",\"ബർമീസ്\":\"my\",\"ബൾഗേറിയൻ\":\"bg\",\"ബാസ്ക്\":\"eu\",\"ബെലാറുഷ്യൻ\":\"be\",\"മംഗോളിയൻ\":\"mn\",\"മലയാളം\":\"ml\",\"മലയ്\":\"ms\",\"മറാഠി\":\"mr\",\"മാസഡോണിയൻ\":\"mk\",\"മാൾട്ടീസ്\":\"mt\",\"മൗറി\":\"mi\",\"ലാറ്റിൻ\":\"la\",\"ലാറ്റ്‌വിയൻ\":\"lv\",\"ലിത്വേനിയൻ\":\"lt\",\"വിയറ്റ്നാമീസ്\":\"vi\",\"വെൽഷ്\":\"cy\",\"സുളു\":\"zu\",\"സെർബിയൻ\":\"sr\",\"സ്കോട്ട്സ് ഗ്യാലിക്\":\"gd\",\"സ്പാനിഷ്\":\"es\",\"സ്ലോവാക്\":\"sk\",\"സ്ലോവേനിയൻ\":\"sl\",\"സ്വീഡിഷ്\":\"sv\",\"ഹംഗേറിയൻ\":\"hu\",\"ഹിന്ദി\":\"hi\",\"ഹീബ്രു\":\"he\",\"ഹെയ്തിയൻ ക്രയോൾ\":\"ht\",\"റഷ്യൻ\":\"ru\",\"റൊമേനിയൻ\":\"ro\",\"albánčina\":\"sq\",\"amharčina\":\"am\",\"arabčina\":\"ar\",\"arménčina\":\"hy\",\"azerbajdžančina\":\"az\",\"barmčina\":\"my\",\"bieloruština\":\"be\",\"bulharčina\":\"bg\",\"čínština (tradičná)\":\"zh-tw\",\"dánčina\":\"da\",\"estónčina\":\"et\",\"fínčina\":\"fi\",\"francúzština\":\"fr\",\"galícijčina\":\"gl\",\"gréčtina\":\"el\",\"haitská kreolčina\":\"ht\",\"hebrejčina\":\"he\",\"hindčina\":\"hi\",\"holandčina\":\"nl\",\"chorvátčina\":\"hr\",\"indonézština\":\"id\",\"írčina\":\"ga\",\"islandčina\":\"is\",\"japončina\":\"ja\",\"kannadčina\":\"kn\",\"katalánčina\":\"ca\",\"kórejčina\":\"ko\",\"kurdčina\":\"ku\",\"latinčina\":\"la\",\"litovčina\":\"lt\",\"macedónčina\":\"mk\",\"maďarčina\":\"hu\",\"malajámčina\":\"ml\",\"malajčina\":\"ms\",\"maltčina\":\"mt\",\"maorijčina\":\"mi\",\"maratčina\":\"mr\",\"mongolčina\":\"mn\",\"nemčina\":\"de\",\"nórčina\":\"nb\",\"perzština\":\"fa\",\"poľština\":\"pl\",\"portugalčina\":\"pt\",\"rumunčina\":\"ro\",\"slovenčina\":\"sk\",\"slovinčina\":\"sl\",\"srbčina\":\"sr\",\"škótska gaelčina\":\"gd\",\"španielčina\":\"es\",\"švédčina\":\"sv\",\"taliančina\":\"it\",\"telugčina\":\"te\",\"thajčina\":\"th\",\"ukrajinčina\":\"uk\",\"vietnamčina\":\"vi\",\"waleština\":\"cy\",\"zuluština\":\"zu\",\"isi-albania\":\"sq\",\"isi-amharic\":\"am\",\"isi-arabic\":\"ar\",\"isi-armenian\":\"hy\",\"isi-azerbaijani\":\"az\",\"isi-basque\":\"eu\",\"isi-belarusian\":\"be\",\"isi-bulgarian\":\"bg\",\"isi-burmese\":\"my\",\"isi-catalan\":\"ca\",\"isi-chinese (simplified)\":\"zh-cn\",\"isi-chinese (traditional)\":\"zh-tw\",\"isi-croatian\":\"hr\",\"isi-czech\":\"cs\",\"isi-danish\":\"da\",\"isi-dutch\":\"nl\",\"isi-english\":\"en\",\"isi-esperanto\":\"eo\",\"isi-estonian\":\"et\",\"isi-finnish\":\"fi\",\"isi-french\":\"fr\",\"isi-galician\":\"gl\",\"isi-german\":\"de\",\"isi-greek\":\"el\",\"isi-haitian creole\":\"ht\",\"isi-hangarian\":\"hu\",\"isi-hebrew\":\"he\",\"isi-hindi\":\"hi\",\"isi-icelandic\":\"is\",\"isi-indonesian\":\"id\",\"isi-irish\":\"ga\",\"isi-italian\":\"it\",\"isi-japanese\":\"ja\",\"isi-kannada\":\"kn\",\"isi-korean\":\"ko\",\"isi-kurdish\":\"ku\",\"isi-latin\":\"la\",\"isi-latvian\":\"lv\",\"isi-lithuanian\":\"lt\",\"isi-macedonian\":\"mk\",\"isi-malay\":\"ms\",\"isi-malayalam\":\"ml\",\"isi-maltese\":\"mt\",\"isi-maori\":\"mi\",\"isi-marathi\":\"mr\",\"isi-mongolian\":\"mn\",\"isi-norwegian\":\"nb\",\"isi-persian\":\"fa\",\"isi-polish\":\"pl\",\"isi-portuguese\":\"pt\",\"isi-romanian\":\"ro\",\"isi-russian\":\"ru\",\"isi-scots gaelic\":\"gd\",\"isi-serbian\":\"sr\",\"isi-slovak\":\"sk\",\"isi-slovenian\":\"sl\",\"isi-spanish\":\"es\",\"isi-swedish\":\"sv\",\"isi-telugu\":\"te\",\"isi-thai\":\"th\",\"isi-turkish\":\"tr\",\"isi-ukrainian\":\"uk\",\"isi-uzbek\":\"uz\",\"isi-vietnamese\":\"vi\",\"isi-welsh\":\"cy\",\"isizulu\":\"zu\",\"albania\":\"sq\",\"armenia\":\"hy\",\"azerbaijan\":\"az\",\"belanda\":\"nl\",\"belarus\":\"be\",\"bulgaria\":\"bg\",\"cina (mudah)\":\"zh-cn\",\"cina (tradisional)\":\"zh-tw\",\"croatia\":\"hr\",\"denmark\":\"da\",\"estonia\":\"et\",\"finland\":\"fi\",\"gaelic scotland\":\"gd\",\"galicia\":\"gl\",\"hungary\":\"hu\",\"ibrani\":\"he\",\"iceland\":\"is\",\"indonesia\":\"id\",\"inggeris\":\"en\",\"ireland\":\"ga\",\"itali\":\"it\",\"jepun\":\"ja\",\"jerman\":\"de\",\"korea\":\"ko\",\"kreol haiti\":\"ht\",\"kurdistan\":\"ku\",\"latvia\":\"lv\",\"lithuania\":\"lt\",\"macedonia\":\"mk\",\"malta\":\"mt\",\"melayu\":\"ms\",\"mongolia\":\"mn\",\"myanmar\":\"my\",\"norway\":\"nb\",\"parsi\":\"fa\",\"perancis\":\"fr\",\"poland\":\"pl\",\"portugis\":\"pt\",\"romania\":\"ro\",\"rusia\":\"ru\",\"sepanyol\":\"es\",\"serbia\":\"sr\",\"slovenia\":\"sl\",\"sweden\":\"sv\",\"turki\":\"tr\",\"ukraine\":\"uk\",\"vietnam\":\"vi\",\"wales\":\"cy\",\"азербайджанский\":\"az\",\"албанский\":\"sq\",\"амхарский\":\"am\",\"английский\":\"en\",\"арабский\":\"ar\",\"армянский\":\"hy\",\"баскский\":\"eu\",\"белорусский\":\"be\",\"бирманский\":\"my\",\"болгарский\":\"bg\",\"валлийский\":\"cy\",\"венгерский\":\"hu\",\"вьетнамский\":\"vi\",\"галисийский\":\"gl\",\"греческий\":\"el\",\"датский\":\"da\",\"иврит\":\"he\",\"индонезийский\":\"id\",\"ирландский\":\"ga\",\"исландский\":\"is\",\"испанский\":\"es\",\"итальянский\":\"it\",\"каталанский\":\"ca\",\"китайский (традиционный)\":\"zh-tw\",\"китайский (упрощенный)\":\"zh-cn\",\"корейский\":\"ko\",\"креольский (гаити)\":\"ht\",\"курманджи\":\"ku\",\"латинский\":\"la\",\"латышский\":\"lv\",\"литовский\":\"lt\",\"македонский\":\"mk\",\"малайский\":\"ms\",\"мальтийский\":\"mt\",\"маори\":\"mi\",\"монгольский\":\"mn\",\"немецкий\":\"de\",\"нидерландский\":\"nl\",\"норвежский\":\"nb\",\"персидский\":\"fa\",\"польский\":\"pl\",\"португальский\":\"pt\",\"румынский\":\"ro\",\"русский\":\"ru\",\"сербский\":\"sr\",\"словацкий\":\"sk\",\"словенский\":\"sl\",\"тайский\":\"th\",\"турецкий\":\"tr\",\"узбекский\":\"uz\",\"украинский\":\"uk\",\"финский\":\"fi\",\"французский\":\"fr\",\"хинди\":\"hi\",\"хорватский\":\"hr\",\"чешский\":\"cs\",\"шведский\":\"sv\",\"шотландский (гэльский)\":\"gd\",\"эсперанто\":\"eo\",\"эстонский\":\"et\",\"японский\":\"ja\",\"albański\":\"sq\",\"amharski\":\"am\",\"angielski\":\"en\",\"arabski\":\"ar\",\"azerski\":\"az\",\"baskijski\":\"eu\",\"białoruski\":\"be\",\"birmański\":\"my\",\"bułgarski\":\"bg\",\"chiński (tradycyjny)\":\"zh-tw\",\"chiński (uproszczony)\":\"zh-cn\",\"chorwacki\":\"hr\",\"czeski\":\"cs\",\"duński\":\"da\",\"estoński\":\"et\",\"fiński\":\"fi\",\"francuski\":\"fr\",\"galicyjski\":\"gl\",\"grecki\":\"el\",\"hebrajski\":\"he\",\"hiszpański\":\"es\",\"indonezyjski\":\"id\",\"irlandzki\":\"ga\",\"islandzki\":\"is\",\"japoński\":\"ja\",\"kataloński\":\"ca\",\"koreański\":\"ko\",\"kreolski (haiti)\":\"ht\",\"kurdyjski\":\"ku\",\"litewski\":\"lt\",\"łaciński\":\"la\",\"łotewski\":\"lv\",\"macedoński\":\"mk\",\"malajalam\":\"ml\",\"malajski\":\"ms\",\"maltański\":\"mt\",\"mongolski\":\"mn\",\"niderlandzki\":\"nl\",\"niemiecki\":\"de\",\"norweski\":\"nb\",\"ormiański\":\"hy\",\"perski\":\"fa\",\"polski\":\"pl\",\"portugalski\":\"pt\",\"rosyjski\":\"ru\",\"rumuński\":\"ro\",\"serbski\":\"sr\",\"słowacki\":\"sk\",\"słoweński\":\"sl\",\"szkocki gaelicki\":\"gd\",\"szwedzki\":\"sv\",\"tajski\":\"th\",\"turecki\":\"tr\",\"ukraiński\":\"uk\",\"uzbecki\":\"uz\",\"walijski\":\"cy\",\"węgierski\":\"hu\",\"wietnamski\":\"vi\",\"włoski\":\"it\",\"азербайджанская\":\"az\",\"албанская\":\"sq\",\"амхарская\":\"am\",\"англійская\":\"en\",\"арабская\":\"ar\",\"армянская\":\"hy\",\"балгарская\":\"bg\",\"баскская\":\"eu\",\"беларуская\":\"be\",\"в'етнамская\":\"vi\",\"валійская\":\"cy\",\"венгерская\":\"hu\",\"гаіцянская крэольская\":\"ht\",\"галандская\":\"nl\",\"галісійская\":\"gl\",\"грэчаская\":\"el\",\"дацкая\":\"da\",\"інданезійская\":\"id\",\"ірландская\":\"ga\",\"ісландская\":\"is\",\"іспанская\":\"es\",\"італьянская\":\"it\",\"іўрыт\":\"he\",\"карэйская\":\"ko\",\"каталонская\":\"ca\",\"кітайская (спрошчаная)\":\"zh-cn\",\"кітайская (традыцыйная)\":\"zh-tw\",\"курдская (курманджы)\":\"ku\",\"латышская\":\"lv\",\"лацінская\":\"la\",\"літоўская\":\"lt\",\"м'янманская (бірманская)\":\"my\",\"маары\":\"mi\",\"македонская\":\"mk\",\"малайская\":\"ms\",\"мальтыйская\":\"mt\",\"мангольская\":\"mn\",\"нарвежская\":\"nb\",\"нямецкая\":\"de\",\"партугальская\":\"pt\",\"персідская\":\"fa\",\"польская\":\"pl\",\"румынская\":\"ro\",\"руская\":\"ru\",\"сербская\":\"sr\",\"славацкая\":\"sk\",\"славенская\":\"sl\",\"тайская\":\"th\",\"турэцкая\":\"tr\",\"тэлугу\":\"te\",\"узбекская\":\"uz\",\"украінская\":\"uk\",\"фінская\":\"fi\",\"французская\":\"fr\",\"харвацкая\":\"hr\",\"хіндзі\":\"hi\",\"чэшская\":\"cs\",\"шатландская гэльская\":\"gd\",\"шведская\":\"sv\",\"эсперанта\":\"eo\",\"эстонская\":\"et\",\"японская\":\"ja\",\"amarikisht\":\"am\",\"anglisht\":\"en\",\"arabisht\":\"ar\",\"armenisht\":\"hy\",\"azerisht\":\"az\",\"baskisht\":\"eu\",\"birmanisht\":\"my\",\"bjellorusisht\":\"be\",\"bullgarisht\":\"bg\",\"çekisht\":\"cs\",\"danisht\":\"da\",\"estonisht\":\"et\",\"finlandisht\":\"fi\",\"frëngjisht\":\"fr\",\"galicianisht\":\"gl\",\"galishte skoceze\":\"gd\",\"greqisht\":\"el\",\"gjermanisht\":\"de\",\"hebraisht\":\"he\",\"hindisht\":\"hi\",\"holandisht\":\"nl\",\"hungarisht\":\"hu\",\"indonezisht\":\"id\",\"irlandisht\":\"ga\",\"islandisht\":\"is\",\"italisht\":\"it\",\"japonisht\":\"ja\",\"kanada\":\"kn\",\"katalonisht\":\"ca\",\"kinezisht (e thjeshtuar)\":\"zh-cn\",\"kinezisht (tradicionale)\":\"zh-tw\",\"koreanisht\":\"ko\",\"kreolishte haitiane\":\"ht\",\"kroatisht\":\"hr\",\"latinisht\":\"la\",\"letonisht\":\"lv\",\"lituanisht\":\"lt\",\"malajalamisht\":\"ml\",\"malajzisht\":\"ms\",\"malteze\":\"mt\",\"maorisht\":\"mi\",\"maqedonisht\":\"mk\",\"maratisht\":\"mr\",\"mongolisht\":\"mn\",\"norvegjisht\":\"nb\",\"persisht\":\"fa\",\"polonisht\":\"pl\",\"portugalisht\":\"pt\",\"rumanisht\":\"ro\",\"rusisht\":\"ru\",\"serbisht\":\"sr\",\"sllovakisht\":\"sk\",\"sllovenisht\":\"sl\",\"spanjisht\":\"es\",\"suedisht\":\"sv\",\"shqip\":\"sq\",\"tajlandisht\":\"th\",\"telugisht\":\"te\",\"turqisht\":\"tr\",\"uellsisht\":\"cy\",\"ukrainisht\":\"uk\",\"uzbekisht\":\"uz\",\"vietnamisht\":\"vi\",\"ሀንጋሪኛ\":\"hu\",\"ህንድኛ\":\"hi\",\"ሊትዌንኛ\":\"lt\",\"ላቲንኛ\":\"la\",\"ላትቪያኛ\":\"lv\",\"ማላያላምኛ\":\"ml\",\"ማላይኛ\":\"ms\",\"ማልቲስኛ\":\"mt\",\"ማራቲኛ\":\"mr\",\"ማዮሪኛ\":\"mi\",\"ሜቄዶኒያኛ\":\"mk\",\"ሞንጎሊያኛ\":\"mn\",\"ራሽያኛ\":\"ru\",\"ሮማኒያንኛ\":\"ro\",\"ሰርቢያኛ\":\"sr\",\"ስሎቫክኛ\":\"sk\",\"ስሎቬንያኛ\":\"sl\",\"ስዊድንኛ\":\"sv\",\"ስፓኒሽኛ\":\"es\",\"በርማኛ\":\"my\",\"ቡልጋሪያኛ\":\"bg\",\"ባስክኛ\":\"eu\",\"ቤላሩስኛ\":\"be\",\"ቪትናምኛ\":\"vi\",\"ቱርክኛ\":\"tr\",\"ታይኛ\":\"th\",\"ቴሉጉኛ\":\"te\",\"ቻይንኛ   (ቀላሉ)\":\"zh-cn\",\"ቻይንኛ  (ባሕላዊው)\":\"zh-tw\",\"ቼክኛ\":\"cs\",\"ኖርዌጅያንኛ\":\"nb\",\"አልባንያኛ\":\"sq\",\"አማርኛ\":\"am\",\"አርመኒያኛ\":\"hy\",\"አዜርባይጃንኛ\":\"az\",\"አይሪሽ\":\"ga\",\"አይስላንድኛ\":\"is\",\"ኡዝቤክኛ\":\"uz\",\"ኤስቶኒያኛ\":\"et\",\"ኤስፐራንቶ\":\"eo\",\"እንዶኔዢያኛ\":\"id\",\"እንግሊዝኛ\":\"en\",\"ኩርድሽኛ\":\"ku\",\"ካታላንኛ\":\"ca\",\"ካናዳኛ\":\"kn\",\"ክሮኤሽያኛ\":\"hr\",\"ኮሪያኛ\":\"ko\",\"ዌልሽ\":\"cy\",\"ዐረብኛ\":\"ar\",\"ዕብራይስጥ\":\"he\",\"ዙሉኛ\":\"zu\",\"የሃይቲ ክረኦሌኛ\":\"ht\",\"የስኮት ጌልክኛ\":\"gd\",\"ዩክሬንኛ\":\"uk\",\"ደችኛ\":\"nl\",\"ዴንሽኛ\":\"da\",\"ጀርመንኛ\":\"de\",\"ጃፓንኛ\":\"ja\",\"ጋሊሺያኛ\":\"gl\",\"ግሪክኛ\":\"el\",\"ጣሊያንኛ\":\"it\",\"ፈረንሳይኛ\":\"fr\",\"ፊኒሽኛ\":\"fi\",\"ፐርሺያኛ\":\"fa\",\"ፖሊሽኛ\":\"pl\",\"ፖርቱጋሊኛ\":\"pt\",\"alban\":\"sq\",\"alman\":\"de\",\"amarikcə\":\"am\",\"azərbaycan dili\":\"az\",\"bask\":\"eu\",\"belarusca\":\"be\",\"bolqar\":\"bg\",\"çex\":\"cs\",\"çin (ən'ənəvi)\":\"zh-tw\",\"çin (sadələşdirilmiş)\":\"zh-cn\",\"danimarka\":\"da\",\"erməni\":\"hy\",\"eston\":\"et\",\"ərəb\":\"ar\",\"fars dili\":\"fa\",\"fin\":\"fi\",\"fransız\":\"fr\",\"haiti kreol dili\":\"ht\",\"hind\":\"hi\",\"xorvat\":\"hr\",\"ispan\":\"es\",\"i̇ndoneziya\":\"id\",\"i̇ngilis\":\"en\",\"i̇rland\":\"ga\",\"i̇sland\":\"is\",\"i̇sveç\":\"sv\",\"i̇talyan\":\"it\",\"i̇vrit\":\"he\",\"katalan\":\"ca\",\"koreya\":\"ko\",\"kürd dili (kurmanci)\":\"ku\",\"qalisian\":\"gl\",\"latın\":\"la\",\"latış\":\"lv\",\"litva\":\"lt\",\"macar\":\"hu\",\"makedoniya\":\"mk\",\"maoricə\":\"mi\",\"monqolca\":\"mn\",\"myanma (birma) dili\":\"my\",\"norveç\":\"nb\",\"özbək\":\"uz\",\"polyak\":\"pl\",\"portuqal\":\"pt\",\"rumın\":\"ro\",\"rus\":\"ru\",\"serb\":\"sr\",\"sloven\":\"sl\",\"şotland (kelt)\":\"gd\",\"tayca\":\"th\",\"teluqu\":\"te\",\"türk\":\"tr\",\"uels\":\"cy\",\"ukrayna\":\"uk\",\"vyetnam\":\"vi\",\"yapon\":\"ja\",\"yunan\":\"el\",\"zulu dili\":\"zu\",\"albaniż\":\"sq\",\"amħari\":\"am\",\"armen\":\"hy\",\"ażerbajġani\":\"az\",\"belarussu\":\"be\",\"bulgaru\":\"bg\",\"ċek\":\"cs\",\"ċiniż (semplifikat)\":\"zh-cn\",\"ċiniż (tradizzjonali)\":\"zh-tw\",\"creole haiti\":\"ht\",\"daniż\":\"da\",\"ebrajk\":\"he\",\"estonjan\":\"et\",\"finlandiż\":\"fi\",\"franċiż\":\"fr\",\"ġappuniż\":\"ja\",\"ġermaniż\":\"de\",\"gaelic tal-iskoċċiżi\":\"gd\",\"galizjan\":\"gl\",\"grieg\":\"el\",\"għarbi\":\"ar\",\"ħindi\":\"hi\",\"indoneżjan\":\"id\",\"ingliż\":\"en\",\"irlandiż\":\"ga\",\"islandiż\":\"is\",\"kroat\":\"hr\",\"kurd (kurmanji)\":\"ku\",\"latvjan\":\"lv\",\"litwen\":\"lt\",\"maċedonjan\":\"mk\",\"malasjan\":\"ms\",\"malti\":\"mt\",\"marati\":\"mr\",\"mjanmar (burma)\":\"my\",\"mongoljan\":\"mn\",\"norveġiż\":\"nb\",\"olandiż\":\"nl\",\"persjan\":\"fa\",\"pollakk\":\"pl\",\"portugiż\":\"pt\",\"rumen\":\"ro\",\"russu\":\"ru\",\"slovakk\":\"sk\",\"spanjol\":\"es\",\"svediż\":\"sv\",\"tajlandiż\":\"th\",\"taljan\":\"it\",\"tork\":\"tr\",\"ukren\":\"uk\",\"ungeriż\":\"hu\",\"użbek\":\"uz\",\"vjetnamiż\":\"vi\",\"żulu\":\"zu\",\"albanski\":\"sq\",\"amharik\":\"am\",\"arapski\":\"ar\",\"armenijski\":\"hy\",\"azerbajdžanski\":\"az\",\"bjeloruski\":\"be\",\"bugarski\":\"bg\",\"burmanski\":\"my\",\"češki\":\"cs\",\"danski\":\"da\",\"engleski\":\"en\",\"estonski\":\"et\",\"finski\":\"fi\",\"galski\":\"gl\",\"grčki\":\"el\",\"haićansko-kreolski\":\"ht\",\"hebrejski\":\"he\",\"hindu\":\"hi\",\"hrvatski\":\"hr\",\"indonezijski\":\"id\",\"irski\":\"ga\",\"islandski\":\"is\",\"japanski\":\"ja\",\"katalonski\":\"ca\",\"kineski (pojednost.)\":\"zh-cn\",\"kineski (tradicionalni)\":\"zh-tw\",\"korejski\":\"ko\",\"kurdski\":\"ku\",\"latinski\":\"la\",\"latvijski/letonski\":\"lv\",\"litvanski\":\"lt\",\"mađarski\":\"hu\",\"makedonski\":\"mk\",\"malezijski\":\"ms\",\"malteški\":\"mt\",\"nizozemski\":\"nl\",\"norveški\":\"nb\",\"njemački\":\"de\",\"perzijski\":\"fa\",\"poljski\":\"pl\",\"rumunjski\":\"ro\",\"ruski\":\"ru\",\"slovački\":\"sk\",\"slovenski\":\"sl\",\"srpski\":\"sr\",\"škotski keltski\":\"gd\",\"španjolski\":\"es\",\"švedski\":\"sv\",\"tajlandski\":\"th\",\"talijanski\":\"it\",\"turski\":\"tr\",\"ukrajinski\":\"uk\",\"uzbekistanski\":\"uz\",\"velški\":\"cy\",\"vijetnamski\":\"vi\",\"آذرباﻳﺠﺎﻧﻰ\":\"az\",\"آلبانیایی\":\"sq\",\"آلمانی\":\"de\",\"ارمنی\":\"hy\",\"ازبکی\":\"uz\",\"اسپانیایی\":\"es\",\"اسپرانتو\":\"eo\",\"استونيايی\":\"et\",\"اسلواکی\":\"sk\",\"اسلونیایی\":\"sl\",\"اکراينی\":\"uk\",\"امهری\":\"am\",\"اندونزيايی\":\"id\",\"انگلیسی\":\"en\",\"ایتالیایی\":\"it\",\"ایرلندی\":\"ga\",\"ايسلندی\":\"is\",\"باسکی\":\"eu\",\"برمه‌ای\":\"my\",\"بلاروسی\":\"be\",\"بلغاری\":\"bg\",\"پرتغالی\":\"pt\",\"تايلندی\":\"th\",\"ترکی استانبولی\":\"tr\",\"تلوگو\":\"te\",\"چک\":\"cs\",\"چینی (ساده‌شده)\":\"zh-cn\",\"چینی (سنتی)\":\"zh-tw\",\"دانمارکی\":\"da\",\"روسی\":\"ru\",\"رومانيايی\":\"ro\",\"زولو\":\"zu\",\"ژاپنی\":\"ja\",\"سوئدی\":\"sv\",\"صربی\":\"sr\",\"عبری\":\"he\",\"عربی\":\"ar\",\"فارسی\":\"fa\",\"فرانسوی\":\"fr\",\"فنلاندی\":\"fi\",\"کاتالان\":\"ca\",\"کانارا\":\"kn\",\"کرئول هائیتی\":\"ht\",\"کردی\":\"ku\",\"کرواتی\":\"hr\",\"کره‌ای\":\"ko\",\"گالیسی\":\"gl\",\"گاليک اسکاتلندی\":\"gd\",\"لاتين\":\"la\",\"لتونيايی\":\"lv\",\"لهستانی\":\"pl\",\"ليتوانيايی\":\"lt\",\"مائوری\":\"mi\",\"مالایالمی\":\"ml\",\"مالايی\":\"ms\",\"مالتی\":\"mt\",\"مجاری\":\"hu\",\"مراتی\":\"mr\",\"مغولی\":\"mn\",\"مقدونيه‌ای\":\"mk\",\"نروژی\":\"nb\",\"ولزی\":\"cy\",\"ويتنامی\":\"vi\",\"هلندی\":\"nl\",\"هندی\":\"hi\",\"يونانی\":\"el\",\"ahepaitani\":\"az\",\"airihi\":\"ga\",\"amariki\":\"am\",\"amēniana\":\"hy\",\"arapeinia\":\"sq\",\"arapi\":\"ar\",\"eperānato\":\"eo\",\"etōnia\":\"et\",\"haina (onamata)\":\"zh-tw\",\"hainamana (kua whakamāmātia)\":\"zh-cn\",\"hanekeria\":\"hu\",\"hapanihi\":\"ja\",\"herepia\":\"sr\",\"hinerangi\":\"fi\",\"hīni\":\"hi\",\"hiperu\":\"he\",\"horowākia\":\"sk\",\"horowinia\":\"sl\",\"huitene\":\"sv\",\"huru\":\"zu\",\"ingarihi\":\"en\",\"initonīhia\":\"id\",\"itāriana\":\"it\",\"kanata\":\"kn\",\"karihia\":\"gl\",\"katarāna\":\"ca\",\"kereore haiti\":\"ht\",\"kiriki\":\"el\",\"kōreana\":\"ko\",\"koroātiana\":\"hr\",\"korukoru\":\"tr\",\"kūrihi\":\"ku\",\"makerōnia\":\"mk\",\"māratihi\":\"mt\",\"marei\":\"ms\",\"mareiarama\":\"ml\",\"mongōriana\":\"mn\",\"nōwei\":\"nb\",\"pākihi\":\"eu\",\"pāniora\":\"es\",\"pēma (purumīhi)\":\"my\",\"peraruhia\":\"be\",\"perēhia\":\"fa\",\"pōrana\":\"pl\",\"potukīhi\":\"pt\",\"purukāriana\":\"bg\",\"rātini\":\"la\",\"rāwhiana\":\"lv\",\"rituānia\":\"lt\",\"romānia\":\"ro\",\"rūhia\":\"ru\",\"tai\":\"th\",\"tati\":\"nl\",\"tenemāka\":\"da\",\"teruku\":\"te\",\"tiamana\":\"de\",\"tieke\":\"cs\",\"tiorangi\":\"is\",\"tuauri kotarangi\":\"gd\",\"uhipeke\":\"uz\",\"ūkareiana\":\"uk\",\"wēra\":\"cy\",\"whitināmu\":\"vi\",\"wīwī\":\"fr\",\"αγγλικά\":\"en\",\"αζερμπαϊτζανικά\":\"az\",\"αλβανικά\":\"sq\",\"αμχαρικά\":\"am\",\"αραβικά\":\"ar\",\"αρμενικά\":\"hy\",\"βασκικά\":\"eu\",\"βιετναμεζικά\":\"vi\",\"βιρμανικά\":\"my\",\"βουλγαρικά\":\"bg\",\"γαελικά σκοτίας\":\"gd\",\"γαλικιακά\":\"gl\",\"γαλλικά\":\"fr\",\"γερμανικά\":\"de\",\"δανικά\":\"da\",\"εβραϊκά\":\"he\",\"ελληνικά\":\"el\",\"εσθονικά\":\"et\",\"εσπεράντο\":\"eo\",\"ζουλού\":\"zu\",\"ιαπωνικά\":\"ja\",\"ινδονησιακά\":\"id\",\"ιρλανδικά\":\"ga\",\"ισλανδικά\":\"is\",\"ισπανικά\":\"es\",\"ιταλικά\":\"it\",\"κανάντα\":\"kn\",\"καταλανικά\":\"ca\",\"κινέζικα (απλοποιημένα)\":\"zh-cn\",\"κινέζικα (παραδοσιακά)\":\"zh-tw\",\"κορεατικά\":\"ko\",\"κουρδικά\":\"ku\",\"κρεόλ αϊτής\":\"ht\",\"κροατικά\":\"hr\",\"λατινικά\":\"la\",\"λετονικά\":\"lv\",\"λευκορωσικά\":\"be\",\"λιθουανικά\":\"lt\",\"μαλαγιάλαμ\":\"ml\",\"μαλέι\":\"ms\",\"μαλτεζικά\":\"mt\",\"μαορί\":\"mi\",\"μαραθικά\":\"mr\",\"μογγολικά\":\"mn\",\"νορβηγικά\":\"nb\",\"ολλανδικά\":\"nl\",\"ουαλικά\":\"cy\",\"ουγγρικά\":\"hu\",\"ουζμπεκικά\":\"uz\",\"ουκρανικά\":\"uk\",\"περσικά\":\"fa\",\"πολωνικά\":\"pl\",\"πορτογαλικά\":\"pt\",\"ρουμανικά\":\"ro\",\"ρωσικά\":\"ru\",\"σερβικά\":\"sr\",\"σλαβομακεδονικά\":\"mk\",\"σλοβακικά\":\"sk\",\"σλοβενικά\":\"sl\",\"σουηδικά\":\"sv\",\"ταϊλανδεζικά\":\"th\",\"τελούγκου\":\"te\",\"τούρκικα\":\"tr\",\"τσεχικά\":\"cs\",\"φινλανδικά\":\"fi\",\"χίντι\":\"hi\",\"amxar\":\"am\",\"arman\":\"hy\",\"bolgar\":\"bg\",\"dat\":\"da\",\"fors\":\"fa\",\"fransuz\":\"fr\",\"gaiti-kreol\":\"ht\",\"galisiy\":\"gl\",\"golland\":\"nl\",\"grek\":\"el\",\"ibroniy\":\"he\",\"indonez\":\"id\",\"ingliz\":\"en\",\"irland\":\"ga\",\"island\":\"is\",\"italyan\":\"it\",\"koreys\":\"ko\",\"kurd (kurmonji)\":\"ku\",\"latish\":\"lv\",\"lotin\":\"la\",\"makedon\":\"mk\",\"maltiy\":\"mt\",\"maratxi\":\"mr\",\"mo‘g‘ul\":\"mn\",\"nemis\":\"de\",\"norveg\":\"nb\",\"ozarbayjon\":\"az\",\"portugal\":\"pt\",\"rumin\":\"ro\",\"tay\":\"th\",\"turk\":\"tr\",\"ukrain\":\"uk\",\"valliy\":\"cy\",\"venger\":\"hu\",\"xitoy (an’anaviy)\":\"zh-tw\",\"xitoy (soddalashgan)\":\"zh-cn\",\"o‘zbek\":\"uz\",\"shotland-gel\":\"gd\",\"shved\":\"sv\",\"chex\":\"cs\",\"albanska\":\"sq\",\"amharísku\":\"am\",\"arabíska\":\"ar\",\"armenska\":\"hy\",\"aserska\":\"az\",\"baskneska\":\"eu\",\"búlgarska\":\"bg\",\"búrmíska\":\"my\",\"danska\":\"da\",\"eistneska\":\"et\",\"enska\":\"en\",\"esperantó\":\"eo\",\"finnska\":\"fi\",\"franska\":\"fr\",\"galisíska\":\"gl\",\"gríska\":\"el\",\"haítískt kreólamál\":\"ht\",\"hebreska\":\"he\",\"hindí\":\"hi\",\"hollenska\":\"nl\",\"hvítrússneska\":\"be\",\"indónesíska\":\"id\",\"írska\":\"ga\",\"íslenska\":\"is\",\"ítalska\":\"it\",\"japanska\":\"ja\",\"katalónska\":\"ca\",\"kínverska (einfölduð)\":\"zh-cn\",\"kínverska (hefðbundin)\":\"zh-tw\",\"kóreska\":\"ko\",\"króatíska\":\"hr\",\"kúrdíska\":\"ku\",\"latína\":\"la\",\"lettneska\":\"lv\",\"litháíska\":\"lt\",\"makedónska\":\"mk\",\"malajíska\":\"ms\",\"maltneska\":\"mt\",\"maoríska\":\"mi\",\"maratí\":\"mr\",\"mongólska\":\"mn\",\"norska\":\"nb\",\"persneska\":\"fa\",\"portúgalska\":\"pt\",\"pólska\":\"pl\",\"rúmenska\":\"ro\",\"rússneska\":\"ru\",\"serbneska\":\"sr\",\"skosk-gelíska\":\"gd\",\"slóvakíska\":\"sk\",\"slóvenska\":\"sl\",\"spænska\":\"es\",\"súlú\":\"zu\",\"sænska\":\"sv\",\"taílenska\":\"th\",\"tékkneska\":\"cs\",\"tyrkneska\":\"tr\",\"ungverska\":\"hu\",\"úkraínska\":\"uk\",\"úsbekíska\":\"uz\",\"velska\":\"cy\",\"víetnamska\":\"vi\",\"þýska\":\"de\",\"ադրբեջաներեն\":\"az\",\"ալբաներեն\":\"sq\",\"ամհարերեն\":\"am\",\"անգլերեն\":\"en\",\"արաբերեն\":\"ar\",\"բասկերեն\":\"eu\",\"բելառուսերեն\":\"be\",\"բիրմաներեն\":\"my\",\"բուլղարերեն\":\"bg\",\"գալիսերեն\":\"gl\",\"գերմաներեն\":\"de\",\"դանիերեն\":\"da\",\"եբրայերեն\":\"he\",\"զուլուսերեն\":\"zu\",\"էսպերանտո\":\"eo\",\"էստոներեն\":\"et\",\"թայերեն\":\"th\",\"թուրքերեն\":\"tr\",\"ինդոնեզերեն\":\"id\",\"իռլանդերեն\":\"ga\",\"իսլանդերեն\":\"is\",\"իսպաներեն\":\"es\",\"իտալերեն\":\"it\",\"լատիներեն\":\"la\",\"լատվիերեն\":\"lv\",\"լեհերեն\":\"pl\",\"լիտվերեն\":\"lt\",\"խորվաթերեն\":\"hr\",\"կաննադա\":\"kn\",\"կատալաներեն\":\"ca\",\"կելտական շոտլանդերեն\":\"gd\",\"կորեերեն\":\"ko\",\"կրեոլերեն (հայիթի)\":\"ht\",\"հայերեն\":\"hy\",\"հինդի\":\"hi\",\"հոլանդերեն\":\"nl\",\"հունարեն\":\"el\",\"հունգարերեն\":\"hu\",\"ճապոներեն\":\"ja\",\"մալայալամ\":\"ml\",\"մալայերեն\":\"ms\",\"մալթերեն\":\"mt\",\"մակեդոներեն\":\"mk\",\"մաորի\":\"mi\",\"մարաթի\":\"mr\",\"մոնղոլերեն\":\"mn\",\"նորվեգերեն\":\"nb\",\"շվեդերեն\":\"sv\",\"ուզբեկերեն\":\"uz\",\"ուկրաիներեն\":\"uk\",\"չեխերեն\":\"cs\",\"չինարեն (ավանդական)\":\"zh-tw\",\"չինարեն (պարզեցված)\":\"zh-cn\",\"պարսկերեն\":\"fa\",\"պորտուգալերեն\":\"pt\",\"ռումիներեն\":\"ro\",\"ռուսերեն\":\"ru\",\"սերբերեն\":\"sr\",\"սլովակերեն\":\"sk\",\"սլովեներեն\":\"sl\",\"վալերեն\":\"cy\",\"վիետնամերեն\":\"vi\",\"տելուգու\":\"te\",\"քրդերեն (քուրմանջի)\":\"ku\",\"ֆիններեն\":\"fi\",\"ֆրանսերեն\":\"fr\",\"arabia\":\"ar\",\"baski\":\"eu\",\"burma\":\"my\",\"englanti\":\"en\",\"espanja\":\"es\",\"haitinkreoli\":\"ht\",\"heprea\":\"he\",\"hollanti\":\"nl\",\"iiri\":\"ga\",\"islanti\":\"is\",\"italia\":\"it\",\"japani\":\"ja\",\"katalaani\":\"ca\",\"kiina (perinteinen)\":\"zh-tw\",\"kiina (yksinkert.)\":\"zh-cn\",\"kreikka\":\"el\",\"kroatia\":\"hr\",\"kurdi\":\"ku\",\"kymri\":\"cy\",\"liettua\":\"lt\",\"makedonia\":\"mk\",\"malaiji\":\"ms\",\"norja\":\"nb\",\"persia\":\"fa\",\"portugali\":\"pt\",\"puola\":\"pl\",\"ranska\":\"fr\",\"ruotsi\":\"sv\",\"saksa\":\"de\",\"skottigaeli\":\"gd\",\"slovakia\":\"sk\",\"suomi\":\"fi\",\"tanska\":\"da\",\"tsekki\":\"cs\",\"turkki\":\"tr\",\"ukraina\":\"uk\",\"unkari\":\"hu\",\"uzbekki\":\"uz\",\"valkovenäjä\":\"be\",\"venäjä\":\"ru\",\"viro\":\"et\",\"albaniera\":\"sq\",\"alemana\":\"de\",\"amharera\":\"am\",\"arabiera\":\"ar\",\"armeniera\":\"hy\",\"azerbaijanera\":\"az\",\"bielorrusiera\":\"be\",\"birmaniera\":\"my\",\"bulgariera\":\"bg\",\"daniera\":\"da\",\"errumaniera\":\"ro\",\"errusiera\":\"ru\",\"eskoziako gaelera\":\"gd\",\"eslovakiera\":\"sk\",\"esloveniera\":\"sl\",\"esperantoa\":\"eo\",\"estoniera\":\"et\",\"euskara\":\"eu\",\"frantsesa\":\"fr\",\"gaelera\":\"cy\",\"galiziera\":\"gl\",\"gaztelania\":\"es\",\"greziera\":\"el\",\"hebreera\":\"he\",\"hindia\":\"hi\",\"hungariera\":\"hu\",\"indonesiera\":\"id\",\"ingelesa\":\"en\",\"irlandera\":\"ga\",\"islandiera\":\"is\",\"italiera\":\"it\",\"japoniera\":\"ja\",\"katalana\":\"ca\",\"koreera\":\"ko\",\"kreolera (haiti)\":\"ht\",\"kroaziera\":\"hr\",\"kurduera\":\"ku\",\"letoniera\":\"lv\",\"lituaniera\":\"lt\",\"malabarera\":\"ml\",\"malaysiera\":\"ms\",\"maltera\":\"mt\",\"maoriera\":\"mi\",\"marathera\":\"mr\",\"mazedoniera\":\"mk\",\"mongoliera\":\"mn\",\"nederlandera\":\"nl\",\"norvegiera\":\"nb\",\"persiera\":\"fa\",\"poloniera\":\"pl\",\"portugesa\":\"pt\",\"serbiera\":\"sr\",\"suediera\":\"sv\",\"suomiera\":\"fi\",\"telugua\":\"te\",\"thaiera\":\"th\",\"turkiera\":\"tr\",\"txekiera\":\"cs\",\"txinera (soildua)\":\"zh-cn\",\"txinera (tradizionala)\":\"zh-tw\",\"ukrainera\":\"uk\",\"uzbekera\":\"uz\",\"vietnamera\":\"vi\",\"zuluera\":\"zu\",\"albanès\":\"sq\",\"alemany\":\"de\",\"amhàric\":\"am\",\"anglès\":\"en\",\"àrab\":\"ar\",\"armeni\":\"hy\",\"àzeri\":\"az\",\"basc\":\"eu\",\"bielorús\":\"be\",\"birmà\":\"my\",\"búlgar\":\"bg\",\"castellà\":\"es\",\"català\":\"ca\",\"coreà\":\"ko\",\"crioll d'haití\":\"ht\",\"croat\":\"hr\",\"danès\":\"da\",\"eslovac\":\"sk\",\"eslovè\":\"sl\",\"estonià\":\"et\",\"finès\":\"fi\",\"francès\":\"fr\",\"gaèlic escocès\":\"gd\",\"gallec\":\"gl\",\"gal·lès\":\"cy\",\"hebreu\":\"he\",\"hongarès\":\"hu\",\"indonesi\":\"id\",\"irlandès\":\"ga\",\"islandès\":\"is\",\"italià\":\"it\",\"japonès\":\"ja\",\"letó\":\"lv\",\"lituà\":\"lt\",\"llatí\":\"la\",\"macedònic\":\"mk\",\"malai\":\"ms\",\"malaiàlam\":\"ml\",\"maltès\":\"mt\",\"neerlandès\":\"nl\",\"noruec\":\"nb\",\"polonès\":\"pl\",\"portuguès\":\"pt\",\"romanès\":\"ro\",\"serbi\":\"sr\",\"suec\":\"sv\",\"txec\":\"cs\",\"ucraïnès\":\"uk\",\"xinès (simplificat)\":\"zh-cn\",\"xinès (tradicional)\":\"zh-tw\",\"albāņu\":\"sq\",\"amharu\":\"am\",\"angļu\":\"en\",\"arābu\":\"ar\",\"armēņu\":\"hy\",\"azerbaidžāņu\":\"az\",\"baltkrievu\":\"be\",\"basku\":\"eu\",\"birmiešu\":\"my\",\"bulgāru\":\"bg\",\"čehu\":\"cs\",\"dāņu\":\"da\",\"ebreju (ivrits)\":\"he\",\"franču\":\"fr\",\"galisiešu\":\"gl\",\"grieķu\":\"el\",\"holandiešu\":\"nl\",\"horvātu\":\"hr\",\"igauņu\":\"et\",\"indonēziešu\":\"id\",\"īru\":\"ga\",\"īslandiešu\":\"is\",\"itāļu\":\"it\",\"japāņu\":\"ja\",\"katalāņu\":\"ca\",\"korejiešu\":\"ko\",\"kreolu (haiti)\":\"ht\",\"krievu\":\"ru\",\"kurdu\":\"ku\",\"ķīniešu (tradicionālā)\":\"zh-tw\",\"ķīniešu (vienkāršotā)\":\"zh-cn\",\"latīņu\":\"la\",\"latviešu\":\"lv\",\"lietuviešu\":\"lt\",\"maķedoniešu\":\"mk\",\"malajalamiešu\":\"ml\",\"malajiešu\":\"ms\",\"maltiešu\":\"mt\",\"maratu\":\"mr\",\"mongoļu\":\"mn\",\"norvēģu\":\"nb\",\"persiešu\":\"fa\",\"poļu\":\"pl\",\"portugāļu\":\"pt\",\"rumāņu\":\"ro\",\"serbu\":\"sr\",\"skotu gēlu\":\"gd\",\"slovāku\":\"sk\",\"slovēņu\":\"sl\",\"somu\":\"fi\",\"spāņu\":\"es\",\"taju\":\"th\",\"turku\":\"tr\",\"ukraiņu\":\"uk\",\"ungāru\":\"hu\",\"uzbeku\":\"uz\",\"vācu\":\"de\",\"velsiešu\":\"cy\",\"vjetnamiešu\":\"vi\",\"zviedru\":\"sv\",\"belarussia\":\"be\",\"cek\":\"cs\",\"china (aks. sederhana)\":\"zh-cn\",\"china (aks. tradisional)\":\"zh-tw\",\"finlandia\":\"fi\",\"gaelig\":\"ga\",\"gaelik skotlandia\":\"gd\",\"galisia\":\"gl\",\"inggris\":\"en\",\"islan\":\"is\",\"jepang\":\"ja\",\"katala\":\"ca\",\"lituania\":\"lt\",\"polandia\":\"pl\",\"prancis\":\"fr\",\"rumania\":\"ro\",\"swensk\":\"sv\",\"yunani\":\"el\",\"అజర్‌బైజాని\":\"az\",\"అర్మేనియన్\":\"hy\",\"అల్బేనియన్\":\"sq\",\"ఆంగ్లము\":\"en\",\"ఆమ్హారిక్\":\"am\",\"ఆరబిక్\":\"ar\",\"ఇండొనేసియన్\":\"id\",\"ఇటాలియన్\":\"it\",\"ఉజ్బెక్\":\"uz\",\"ఎస్పెరాంటో\":\"eo\",\"ఏస్టోనియన్\":\"et\",\"ఐరిష్\":\"ga\",\"ఐస్ లాండిక్\":\"is\",\"కన్నడ\":\"kn\",\"కర్డిష్\":\"ku\",\"కొరియన్\":\"ko\",\"క్యాటలాన్\":\"ca\",\"క్రొయేషియన్\":\"hr\",\"గాలిసియన్\":\"gl\",\"గ్రీక్\":\"el\",\"చెక్\":\"cs\",\"చైనీస్ (సరళమైన)\":\"zh-cn\",\"చైనీస్ (సామ్ప్రదాయమైన)\":\"zh-tw\",\"జపనీస్\":\"ja\",\"జర్మన్\":\"de\",\"జులు\":\"zu\",\"టర్కిష్\":\"tr\",\"డచ్\":\"nl\",\"డానిష్\":\"da\",\"తెలుగు\":\"te\",\"థాయ్\":\"th\",\"నార్విజియన్\":\"nb\",\"పర్షియన్\":\"fa\",\"పోర్చుగీస్\":\"pt\",\"పోలిష్\":\"pl\",\"ఫిన్నిష్\":\"fi\",\"ఫ్రెంచ్\":\"fr\",\"బర్మీస్\":\"my\",\"బల్గేరియన్\":\"bg\",\"బాస్క్\":\"eu\",\"బెలారుషియన్\":\"be\",\"మంగోలియన్\":\"mn\",\"మయోరి\":\"mi\",\"మరాఠీ\":\"mr\",\"మలయాళం\":\"ml\",\"మాలై\":\"ms\",\"మాల్టీస్\":\"mt\",\"మాసిడోనియన్\":\"mk\",\"యుక్రేనియన్\":\"uk\",\"రష్యన్\":\"ru\",\"రొమేనియన్\":\"ro\",\"లాటిన్\":\"la\",\"లాట్వియన్\":\"lv\",\"లిథువేనియన్\":\"lt\",\"వియత్నామీస్\":\"vi\",\"వెల్ష్\":\"cy\",\"సెర్బియన్\":\"sr\",\"స్కాట్స్ గేలిక్\":\"gd\",\"స్పానిష్\":\"es\",\"స్లోవక్\":\"sk\",\"స్లోవేనియన్\":\"sl\",\"స్వీడిష్\":\"sv\",\"హంగేరియన్\":\"hu\",\"హిందీ\":\"hi\",\"హీబ్రూ\":\"he\",\"హైయేటియన్ క్రియోల్\":\"ht\",\"amhárico\":\"am\",\"azerí\":\"az\",\"chino (simplificado)\":\"zh-cn\",\"chino (tradicional)\":\"zh-tw\",\"criollo haitiano\":\"ht\",\"danés\":\"da\",\"estonio\":\"et\",\"euskera\":\"eu\",\"finlandés\":\"fi\",\"gallego\":\"gl\",\"griego\":\"el\",\"japonés\":\"ja\",\"kurdo\":\"ku\",\"malayo\":\"ms\",\"noruego\":\"nb\",\"rumano\":\"ro\",\"uzbeco\":\"uz\",\"albaania\":\"sq\",\"amhaari\":\"am\",\"araabia\":\"ar\",\"armeenia\":\"hy\",\"aserbaidžaani\":\"az\",\"birma\":\"my\",\"bulgaaria\":\"bg\",\"eesti\":\"et\",\"galeegi\":\"gl\",\"haitikreooli\":\"ht\",\"heebrea\":\"he\",\"hispaania\":\"es\",\"hollandi\":\"nl\",\"horvaadi\":\"hr\",\"indoneesia\":\"id\",\"inglise\":\"en\",\"islandi\":\"is\",\"itaalia\":\"it\",\"jaapani\":\"ja\",\"kreeka\":\"el\",\"ladina\":\"la\",\"leedu\":\"lt\",\"lihtsustatud hiina\":\"zh-cn\",\"läti\":\"lv\",\"makedoonia\":\"mk\",\"malajalaami\":\"ml\",\"maoori\":\"mi\",\"mongoli\":\"mn\",\"norra\":\"nb\",\"poola\":\"pl\",\"prantsuse\":\"fr\",\"pärsia\":\"fa\",\"rootsi\":\"sv\",\"rumeenia\":\"ro\",\"slovaki\":\"sk\",\"sloveeni\":\"sl\",\"soome\":\"fi\",\"suulu\":\"zu\",\"šoti\":\"gd\",\"taani\":\"da\",\"traditsiooniline hiina\":\"zh-tw\",\"tšehhi\":\"cs\",\"türgi\":\"tr\",\"uelsi\":\"cy\",\"ungari\":\"hu\",\"usbeki\":\"uz\",\"valgevene\":\"be\",\"vene\":\"ru\",\"albanyen\":\"sq\",\"amenyen\":\"hy\",\"anglè\":\"en\",\"azèbajani\":\"az\",\"belarisyen\":\"be\",\"bilgaryen\":\"bg\",\"chinwa (senp)\":\"zh-cn\",\"chinwa (tradisyonèl)\":\"zh-tw\",\"danwa\":\"da\",\"ebre\":\"he\",\"endonezyen\":\"id\",\"endou\":\"hi\",\"estonyen\":\"et\",\"fenlandè\":\"fi\",\"franse\":\"fr\",\"gaelik ekosè\":\"gd\",\"galisyen\":\"gl\",\"grèk\":\"el\",\"ikrenyen\":\"uk\",\"ilandè\":\"ga\",\"islandè\":\"is\",\"italyen\":\"it\",\"izbèk\":\"uz\",\"japonè\":\"ja\",\"koreyen\":\"ko\",\"kreyòl ayisyen\":\"ht\",\"kurde (kurmandji)\":\"ku\",\"kwoasyen\":\"hr\",\"laten\":\"la\",\"letonyen\":\"lv\",\"lityanyen\":\"lt\",\"malè\":\"ms\",\"malt\":\"mt\",\"masedonyen\":\"mk\",\"mongolyen\":\"mn\",\"myanma (burmese)\":\"my\",\"nòvejyen\":\"nb\",\"olandè, neyèlandè\":\"nl\",\"onngaryen\":\"hu\",\"panyòl\":\"es\",\"pèsyen\":\"fa\",\"polonè\":\"pl\",\"pòtigè\":\"pt\",\"ris\":\"ru\",\"romanyen\":\"ro\",\"sèb\":\"sr\",\"slovenyen\":\"sl\",\"syedwa\":\"sv\",\"tuk\":\"tr\",\"tyèk\":\"cs\",\"vyetnamyen\":\"vi\",\"albaneg\":\"sq\",\"almaeneg\":\"de\",\"arabeg\":\"ar\",\"armeneg\":\"hy\",\"aserbaijaneg\":\"az\",\"basgeg\":\"eu\",\"belarwseg\":\"be\",\"bwlgaraidd\":\"bg\",\"catalaneg\":\"ca\",\"creol haiti\":\"ht\",\"croateg\":\"hr\",\"cymraeg\":\"cy\",\"cyrdeg (kurmandji)\":\"ku\",\"daneg\":\"da\",\"eidaleg\":\"it\",\"estoneg\":\"et\",\"fietnameg\":\"vi\",\"ffineg\":\"fi\",\"fflemeg\":\"nl\",\"ffrangeg\":\"fr\",\"gaeleg yr alban\":\"gd\",\"galisaidd\":\"gl\",\"groeg\":\"el\",\"gwyddeleg\":\"ga\",\"hebraeg\":\"he\",\"hwngareg\":\"hu\",\"iaith corea\":\"ko\",\"indonesieg\":\"id\",\"islandeg\":\"is\",\"iwcraineg\":\"uk\",\"japaneg\":\"ja\",\"latfieg\":\"lv\",\"lithwaneg\":\"lt\",\"lladin\":\"la\",\"macedoneg\":\"mk\",\"malteseg\":\"mt\",\"mongoleg\":\"mn\",\"myanmar (byrma)\":\"my\",\"norwyeg\":\"nb\",\"perseg\":\"fa\",\"portiwgaleg\":\"pt\",\"pwyleg\":\"pl\",\"rwmaneg\":\"ro\",\"rwsieg\":\"ru\",\"saesneg\":\"en\",\"sbaeneg\":\"es\",\"serbeg\":\"sr\",\"slofac\":\"sk\",\"slofenia\":\"sl\",\"swedeg\":\"sv\",\"swlw\":\"zu\",\"tsieceg\":\"cs\",\"tsieineeg (traddodiadol)\":\"zh-tw\",\"tsieineeg (wedi symleiddio)\":\"zh-cn\",\"twrceg\":\"tr\",\"usbec\":\"uz\",\"अंग्रेज़ी\":\"en\",\"अज़रबैजानी\":\"az\",\"अल्बेनियन\":\"sq\",\"आइसलैंडिक\":\"is\",\"आर्मेनियन\":\"hy\",\"इटैलियन\":\"it\",\"उज़्बेक\":\"uz\",\"एस्तोनियन\":\"et\",\"एस्पेरांटो\":\"eo\",\"ऐम्हेरिक\":\"am\",\"कन्नड़\":\"kn\",\"कुर्दिश (करमंजी)\":\"ku\",\"कैटेलन\":\"ca\",\"गैलिशियन\":\"gl\",\"चीनी (परंपरागत)\":\"zh-tw\",\"चेक\":\"cs\",\"जापानी\":\"ja\",\"ज़ुलु\":\"zu\",\"डैनिश\":\"da\",\"तुर्क\":\"tr\",\"तेलुगु\":\"te\",\"पुर्तगाली\":\"pt\",\"फ़िनिश\":\"fi\",\"फ़्रेंच\":\"fr\",\"बर्मी\":\"my\",\"बुल्गारियन\":\"bg\",\"बेलारूसीयन\":\"be\",\"बैस्क\":\"eu\",\"मलयालम\":\"ml\",\"माऔरी\":\"mi\",\"माल्टी\":\"mt\",\"मेसीडोनियन\":\"mk\",\"यूक्रेनियन\":\"uk\",\"रूसी\":\"ru\",\"रोमेनियन\":\"ro\",\"लातवियन\":\"lv\",\"लैटिन\":\"la\",\"वियतनामी\":\"vi\",\"सर्बियाई\":\"sr\",\"स्पैनिश\":\"es\",\"स्लोवाक\":\"sk\",\"स्लोवेनियन\":\"sl\",\"हंगरियन\":\"hu\",\"हीब्रू\":\"he\",\"हैतियन क्रिओल\":\"ht\",\"阿尔巴尼亚语\":\"sq\",\"阿拉伯语\":\"ar\",\"阿姆哈拉语\":\"am\",\"阿塞拜疆语\":\"az\",\"爱尔兰语\":\"ga\",\"爱沙尼亚语\":\"et\",\"巴斯克语\":\"eu\",\"白俄罗斯语\":\"be\",\"保加利亚语\":\"bg\",\"冰岛语\":\"is\",\"波兰语\":\"pl\",\"波斯语\":\"fa\",\"丹麦语\":\"da\",\"德语\":\"de\",\"俄语\":\"ru\",\"法语\":\"fr\",\"芬兰语\":\"fi\",\"海地克里奥尔语\":\"ht\",\"韩语\":\"ko\",\"荷兰语\":\"nl\",\"加利西亚语\":\"gl\",\"加泰罗尼亚语\":\"ca\",\"捷克语\":\"cs\",\"卡纳达语\":\"kn\",\"克罗地亚语\":\"hr\",\"库尔德语\":\"ku\",\"拉丁语\":\"la\",\"拉脱维亚语\":\"lv\",\"立陶宛语\":\"lt\",\"罗马尼亚语\":\"ro\",\"马耳他语\":\"mt\",\"马拉地语\":\"mr\",\"马拉雅拉姆语\":\"ml\",\"马来语\":\"ms\",\"马其顿语\":\"mk\",\"毛利语\":\"mi\",\"蒙古语\":\"mn\",\"缅甸语\":\"my\",\"南非祖鲁语\":\"zu\",\"挪威语\":\"nb\",\"葡萄牙语\":\"pt\",\"日语\":\"ja\",\"瑞典语\":\"sv\",\"塞尔维亚语\":\"sr\",\"世界语\":\"eo\",\"斯洛伐克语\":\"sk\",\"斯洛文尼亚语\":\"sl\",\"苏格兰盖尔语\":\"gd\",\"泰卢固语\":\"te\",\"泰语\":\"th\",\"土耳其语\":\"tr\",\"威尔士语\":\"cy\",\"乌克兰语\":\"uk\",\"乌兹别克语\":\"uz\",\"西班牙语\":\"es\",\"希伯来语\":\"he\",\"希腊语\":\"el\",\"匈牙利语\":\"hu\",\"亚美尼亚语\":\"hy\",\"意大利语\":\"it\",\"印地语\":\"hi\",\"印尼语\":\"id\",\"英语\":\"en\",\"越南语\":\"vi\",\"中文(繁体)\":\"zh-tw\",\"中文(简体)\":\"zh-cn\",\"азербайджански\":\"az\",\"английски\":\"en\",\"арабски\":\"ar\",\"арменски\":\"hy\",\"баски\":\"eu\",\"беларуски\":\"be\",\"бирмански\":\"my\",\"български\":\"bg\",\"галисийски\":\"gl\",\"гръцки\":\"el\",\"датски\":\"da\",\"индонезийски\":\"id\",\"ирландски\":\"ga\",\"испански\":\"es\",\"италиански\":\"it\",\"китайски (опростен)\":\"zh-cn\",\"китайски (традиционен)\":\"zh-tw\",\"корейски\":\"ko\",\"кюрдски\":\"ku\",\"латвийски\":\"lv\",\"литовски\":\"lt\",\"малайски\":\"ms\",\"малтийски\":\"mt\",\"немски\":\"de\",\"нидерландски\":\"nl\",\"норвежки\":\"nb\",\"персийски\":\"fa\",\"румънски\":\"ro\",\"словашки\":\"sk\",\"словенски\":\"sl\",\"сръбски\":\"sr\",\"тайландски\":\"th\",\"уелски\":\"cy\",\"узбекски\":\"uz\",\"финландски\":\"fi\",\"френски\":\"fr\",\"хаитянски креолски\":\"ht\",\"хърватски\":\"hr\",\"шотландски келтски\":\"gd\",\"японски\":\"ja\",\"الآيسلندية\":\"is\",\"الأذرية\":\"az\",\"الارمنية\":\"hy\",\"الإسبانية\":\"es\",\"الاسبرانتو\":\"eo\",\"الإستونية\":\"et\",\"الاسكتلندية الغالية\":\"gd\",\"الألبانية\":\"sq\",\"الألمانية\":\"de\",\"الأمهرية\":\"am\",\"الإنجليزية\":\"en\",\"الإندونيسية\":\"id\",\"الأوزبكية\":\"uz\",\"الأوكرانية\":\"uk\",\"الأيرلندية\":\"ga\",\"الإيطالية\":\"it\",\"الباسكية\":\"eu\",\"البرتغالية\":\"pt\",\"البلغارية\":\"bg\",\"البورمية\":\"my\",\"البولندية\":\"pl\",\"البيلاروسية\":\"be\",\"التايلاندية\":\"th\",\"التركية\":\"tr\",\"التشيكية\":\"cs\",\"التيلوجو\":\"te\",\"الجاليكية\":\"gl\",\"الدانماركية\":\"da\",\"الروسية\":\"ru\",\"الرومانية\":\"ro\",\"الزولوية\":\"zu\",\"السلوفاكية\":\"sk\",\"السلوفينية\":\"sl\",\"السويدية\":\"sv\",\"الصربية\":\"sr\",\"الصينية (التقليدية)\":\"zh-tw\",\"الصينية (المبسطة)\":\"zh-cn\",\"العبرية\":\"he\",\"العربية\":\"ar\",\"الفارسية\":\"fa\",\"الفرنسية\":\"fr\",\"الفنلندية\":\"fi\",\"الفيتنامية\":\"vi\",\"القطلونية\":\"ca\",\"الكانادا\":\"kn\",\"الكردية\":\"ku\",\"الكرواتية\":\"hr\",\"الكورية\":\"ko\",\"اللاتفية\":\"lv\",\"اللاتينية\":\"la\",\"اللغة الكريولية الهايتية\":\"ht\",\"الليتوانية\":\"lt\",\"المالايالامية\":\"ml\",\"المالطيّة\":\"mt\",\"الماورية\":\"mi\",\"المقدونية\":\"mk\",\"الملايو\":\"ms\",\"المنغولية\":\"mn\",\"المهراتية\":\"mr\",\"النرويجية\":\"nb\",\"الهندية\":\"hi\",\"الهنغارية\":\"hu\",\"الهولندية\":\"nl\",\"الويلزية\":\"cy\",\"اليابانية\":\"ja\",\"اليونانية\":\"el\",\"баскијски\":\"eu\",\"вијетнамски\":\"vi\",\"галски\":\"gl\",\"енглески\":\"en\",\"индонежански\":\"id\",\"јапански\":\"ja\",\"јерменски\":\"hy\",\"кинески (поједностављени)\":\"zh-cn\",\"кинески (традиционални)\":\"zh-tw\",\"креолски (хаити)\":\"ht\",\"летонски\":\"lv\",\"мађарски\":\"hu\",\"марати\":\"mr\",\"немачки\":\"de\",\"персијски\":\"fa\",\"пољски\":\"pl\",\"румунски\":\"ro\",\"словеначки\":\"sl\",\"тајски\":\"th\",\"украјински\":\"uk\",\"азербайжан\":\"az\",\"албани\":\"sq\",\"амхарик\":\"am\",\"англи\":\"en\",\"араб\":\"ar\",\"армени\":\"hy\",\"баск\":\"eu\",\"беларусь\":\"be\",\"бирм\":\"my\",\"болгар\":\"bg\",\"вьетнам\":\"vi\",\"гаити креол\":\"ht\",\"галик\":\"gl\",\"гаэл\":\"gd\",\"герман\":\"de\",\"голланд\":\"nl\",\"грек\":\"el\",\"дани\":\"da\",\"индонези\":\"id\",\"ирланд\":\"ga\",\"исланд\":\"is\",\"испани\":\"es\",\"итали\":\"it\",\"каталан\":\"ca\",\"кипр\":\"he\",\"курд\":\"ku\",\"латви\":\"lv\",\"латин\":\"la\",\"литва\":\"lt\",\"македон\":\"mk\",\"малай\":\"ms\",\"малайлам\":\"ml\",\"малти\":\"mt\",\"монгол\":\"mn\",\"норвеги\":\"nb\",\"орос\":\"ru\",\"перс\":\"fa\",\"польш\":\"pl\",\"португаль\":\"pt\",\"румын\":\"ro\",\"серби\":\"sr\",\"словак\":\"sk\",\"словени\":\"sl\",\"солонгос\":\"ko\",\"тай\":\"th\",\"турк\":\"tr\",\"тэлүгү\":\"te\",\"узбек\":\"uz\",\"украин\":\"uk\",\"унгар\":\"hu\",\"уэльс\":\"cy\",\"финлянд\":\"fi\",\"франц\":\"fr\",\"хорват\":\"hr\",\"хятад (ердийн)\":\"zh-cn\",\"хятад (уламжлалт)\":\"zh-tw\",\"чех\":\"cs\",\"швед\":\"sv\",\"эстони\":\"et\",\"япон\":\"ja\",\"amhariska\":\"am\",\"arabiska\":\"ar\",\"armeniska\":\"hy\",\"azerbajdzjanska\":\"az\",\"baskiska\":\"eu\",\"bulgariska\":\"bg\",\"burmesiska\":\"my\",\"engelska\":\"en\",\"estniska\":\"et\",\"finska\":\"fi\",\"gaeliska\":\"gd\",\"galiciska\":\"gl\",\"grekiska\":\"el\",\"haitiska\":\"ht\",\"hebreiska\":\"he\",\"indonesiska\":\"id\",\"irländska\":\"ga\",\"isländska\":\"is\",\"italienska\":\"it\",\"kanaresiska\":\"kn\",\"katalanska\":\"ca\",\"kinesiska (förenklad)\":\"zh-cn\",\"kinesiska (traditionell)\":\"zh-tw\",\"koreanska\":\"ko\",\"kroatiska\":\"hr\",\"kurdiska\":\"ku\",\"lettiska\":\"lv\",\"litauiska\":\"lt\",\"makedonska\":\"mk\",\"malaysiska\":\"ms\",\"maltesiska\":\"mt\",\"mongoliska\":\"mn\",\"nederländska\":\"nl\",\"persiska\":\"fa\",\"polska\":\"pl\",\"portugisiska\":\"pt\",\"rumänska\":\"ro\",\"ryska\":\"ru\",\"serbiska\":\"sr\",\"slovakiska\":\"sk\",\"slovenska\":\"sl\",\"spanska\":\"es\",\"svenska\":\"sv\",\"thailändska\":\"th\",\"tjeckiska\":\"cs\",\"turkiska\":\"tr\",\"tyska\":\"de\",\"ukrainska\":\"uk\",\"ungerska\":\"hu\",\"uzbekiska\":\"uz\",\"vietnamesiska\":\"vi\",\"vitryska\":\"be\",\"walesiska\":\"cy\",\"albaneză\":\"sq\",\"amharică\":\"am\",\"arabă\":\"ar\",\"armeană\":\"hy\",\"azerbaidjană\":\"az\",\"bască\":\"eu\",\"bielorusă\":\"be\",\"birmană\":\"my\",\"bulgară\":\"bg\",\"catalană\":\"ca\",\"cehă\":\"cs\",\"chineză (simplificată)\":\"zh-cn\",\"chineză (tradițională)\":\"zh-tw\",\"coreeană\":\"ko\",\"creolă haitiană\":\"ht\",\"croată\":\"hr\",\"daneză\":\"da\",\"ebraică\":\"he\",\"engleză\":\"en\",\"estonă\":\"et\",\"finlandeză\":\"fi\",\"franceză\":\"fr\",\"galeză\":\"cy\",\"galica scoțiană\":\"gd\",\"galiciană\":\"gl\",\"germană\":\"de\",\"greacă\":\"el\",\"indoneziană\":\"id\",\"irlandeză\":\"ga\",\"islandeză\":\"is\",\"italiană\":\"it\",\"japoneză\":\"ja\",\"kurdă\":\"ku\",\"latină\":\"la\",\"letonă\":\"lv\",\"lituaniană\":\"lt\",\"macedoneană\":\"mk\",\"maghiară\":\"hu\",\"malaeză\":\"ms\",\"malteză\":\"mt\",\"mongolă\":\"mn\",\"neerlandeză\":\"nl\",\"norvegiană\":\"nb\",\"persană\":\"fa\",\"poloneză\":\"pl\",\"portugheză\":\"pt\",\"română\":\"ro\",\"rusă\":\"ru\",\"sârbă\":\"sr\",\"slovacă\":\"sk\",\"slovenă\":\"sl\",\"spaniolă\":\"es\",\"suedeză\":\"sv\",\"thailandeză\":\"th\",\"turcă\":\"tr\",\"ucraineană\":\"uk\",\"uzbecă\":\"uz\",\"vietnameză\":\"vi\",\"airių\":\"ga\",\"albanų\":\"sq\",\"amharų\":\"am\",\"anglų\":\"en\",\"arabų\":\"ar\",\"armėnų\":\"hy\",\"azerbaidžaniečių\":\"az\",\"baltarusių\":\"be\",\"baskų\":\"eu\",\"birmiečių\":\"my\",\"bulgarų\":\"bg\",\"čekų\":\"cs\",\"danų\":\"da\",\"estų\":\"et\",\"galisų\":\"gl\",\"graikų\":\"el\",\"haičio kreolų\":\"ht\",\"hebrajų\":\"he\",\"indoneziečių\":\"id\",\"islandų\":\"is\",\"ispanų\":\"es\",\"italų\":\"it\",\"japonų\":\"ja\",\"kanadų\":\"kn\",\"kataloniečių\":\"ca\",\"kinų (supaprastinta)\":\"zh-cn\",\"kinų (tradicinė)\":\"zh-tw\",\"korėjiečių\":\"ko\",\"kroatų\":\"hr\",\"kurdų\":\"ku\",\"latvių\":\"lv\",\"lenkų\":\"pl\",\"lietuvių\":\"lt\",\"lotynų\":\"la\",\"makedoniečių\":\"mk\",\"malajalių\":\"ml\",\"malajiečių\":\"ms\",\"maltiečių\":\"mt\",\"maorių\":\"mi\",\"maratų\":\"mr\",\"mongolų\":\"mn\",\"norvegų\":\"nb\",\"olandų\":\"nl\",\"persų\":\"fa\",\"portugalų\":\"pt\",\"prancūzų\":\"fr\",\"rumunų\":\"ro\",\"rusų\":\"ru\",\"serbų\":\"sr\",\"slovakų\":\"sk\",\"slovėnų\":\"sl\",\"suomių\":\"fi\",\"škotų (gėlų)\":\"gd\",\"švedų\":\"sv\",\"tajų\":\"th\",\"telugų\":\"te\",\"turkų\":\"tr\",\"ukrainiečių\":\"uk\",\"uzbekų\":\"uz\",\"valų\":\"cy\",\"vengrų\":\"hu\",\"vietnamiečių\":\"vi\",\"vokiečių\":\"de\",\"zulusų\":\"zu\",\"갈리시아어\":\"gl\",\"그리스어\":\"el\",\"네덜란드어\":\"nl\",\"노르웨이어\":\"nb\",\"덴마크어\":\"da\",\"독일어\":\"de\",\"라트비아어\":\"lv\",\"라틴어\":\"la\",\"러시아어\":\"ru\",\"루마니아어\":\"ro\",\"리투아니아어\":\"lt\",\"마라티어\":\"mr\",\"마오리어\":\"mi\",\"마케도니아어\":\"mk\",\"말라얄람어\":\"ml\",\"말레이어\":\"ms\",\"몰타어\":\"mt\",\"몽골어\":\"mn\",\"미얀마어 (버마어)\":\"my\",\"바스크어\":\"eu\",\"베트남어\":\"vi\",\"벨라루스어\":\"be\",\"불가리아어\":\"bg\",\"세르비아어\":\"sr\",\"스웨덴어\":\"sv\",\"스코틀랜드 게일어\":\"gd\",\"스페인어\":\"es\",\"슬로바키아어\":\"sk\",\"슬로베니아어\":\"sl\",\"아랍어\":\"ar\",\"아르메니아어\":\"hy\",\"아이슬란드어\":\"is\",\"아이티 크리올어\":\"ht\",\"아일랜드어\":\"ga\",\"아제르바이잔어\":\"az\",\"알바니아어\":\"sq\",\"암하라어\":\"am\",\"에스토니아어\":\"et\",\"에스페란토어\":\"eo\",\"영어\":\"en\",\"우즈베크어\":\"uz\",\"우크라이나어\":\"uk\",\"웨일즈어\":\"cy\",\"이탈리아어\":\"it\",\"인도네시아어\":\"id\",\"일본어\":\"ja\",\"줄루어\":\"zu\",\"중국어(간체)\":\"zh-cn\",\"중국어(번체)\":\"zh-tw\",\"체코어\":\"cs\",\"카탈로니아어\":\"ca\",\"칸나다어\":\"kn\",\"쿠르드어\":\"ku\",\"크로아티아어\":\"hr\",\"태국어\":\"th\",\"터키어\":\"tr\",\"텔루구어\":\"te\",\"페르시아어\":\"fa\",\"포르투갈어\":\"pt\",\"폴란드어\":\"pl\",\"프랑스어\":\"fr\",\"핀란드어\":\"fi\",\"한국어\":\"ko\",\"헝가리어\":\"hu\",\"히브리어\":\"he\",\"힌디어\":\"hi\",\"albanese\":\"sq\",\"amarico\":\"am\",\"arabo\":\"ar\",\"armeno\":\"hy\",\"azero\":\"az\",\"bielorusso\":\"be\",\"bulgaro\":\"bg\",\"catalano\":\"ca\",\"ceco\":\"cs\",\"cinese (semplificato)\":\"zh-cn\",\"cinese (tradizionale)\":\"zh-tw\",\"creolo haitiano\":\"ht\",\"croato\":\"hr\",\"curdo (kurmanji)\":\"ku\",\"danese\":\"da\",\"ebraico\":\"he\",\"estone\":\"et\",\"finlandese\":\"fi\",\"francese\":\"fr\",\"gaelico scozzese\":\"gd\",\"galiziano\":\"gl\",\"gallese\":\"cy\",\"giapponese\":\"ja\",\"greco\":\"el\",\"indonesiano\":\"id\",\"inglese\":\"en\",\"irlandese\":\"ga\",\"islandese\":\"is\",\"latino\":\"la\",\"lettone\":\"lv\",\"macedone\":\"mk\",\"malese\":\"ms\",\"mongolo\":\"mn\",\"norvegese\":\"nb\",\"olandese\":\"nl\",\"persiano\":\"fa\",\"polacco\":\"pl\",\"portoghese\":\"pt\",\"rumeno\":\"ro\",\"serbo\":\"sr\",\"slovacco\":\"sk\",\"sloveno\":\"sl\",\"spagnolo\":\"es\",\"svedese\":\"sv\",\"tailandese\":\"th\",\"tedesco\":\"de\",\"ucraino\":\"uk\",\"ungherese\":\"hu\",\"quốc tế ngữ\":\"eo\",\"tiếng ả rập\":\"ar\",\"tiếng albania\":\"sq\",\"tiếng amharic\":\"am\",\"tiếng anh\":\"en\",\"tiếng armenia\":\"hy\",\"tiếng azerbaijan\":\"az\",\"tiếng ba lan\":\"pl\",\"tiếng ba tư\":\"fa\",\"tiếng basque\":\"eu\",\"tiếng belarus\":\"be\",\"tiếng bồ đào nha\":\"pt\",\"tiếng bulgaria\":\"bg\",\"tiếng catalan\":\"ca\",\"tiếng creole ở haiti\":\"ht\",\"tiếng croatia\":\"hr\",\"tiếng do thái\":\"he\",\"tiếng đan mạch\":\"da\",\"tiếng đức\":\"de\",\"tiếng estonia\":\"et\",\"tiếng gael scotland\":\"gd\",\"tiếng galicia\":\"gl\",\"tiếng hà lan\":\"nl\",\"tiếng hàn\":\"ko\",\"tiếng hindi\":\"hi\",\"tiếng hungary\":\"hu\",\"tiếng hy lạp\":\"el\",\"tiếng iceland\":\"is\",\"tiếng indonesia\":\"id\",\"tiếng ireland\":\"ga\",\"tiếng kannada\":\"kn\",\"tiếng kurd\":\"ku\",\"tiếng latinh\":\"la\",\"tiếng latvia\":\"lv\",\"tiếng litva\":\"lt\",\"tiếng mã lai\":\"ms\",\"tiếng macedonia\":\"mk\",\"tiếng malayalam\":\"ml\",\"tiếng malta\":\"mt\",\"tiếng maori\":\"mi\",\"tiếng marathi\":\"mr\",\"tiếng mông cổ\":\"mn\",\"tiếng myanmar\":\"my\",\"tiếng na uy\":\"nb\",\"tiếng nga\":\"ru\",\"tiếng nhật\":\"ja\",\"tiếng pháp\":\"fr\",\"tiếng phần lan\":\"fi\",\"tiếng rumani\":\"ro\",\"tiếng séc\":\"cs\",\"tiếng serbia\":\"sr\",\"tiếng slovak\":\"sk\",\"tiếng slovenia\":\"sl\",\"tiếng tây ban nha\":\"es\",\"tiếng telugu\":\"te\",\"tiếng thái\":\"th\",\"tiếng thổ nhĩ kỳ\":\"tr\",\"tiếng thụy điển\":\"sv\",\"tiếng trung (giản thể)\":\"zh-cn\",\"tiếng trung (phồn thể)\":\"zh-tw\",\"tiếng ukraina\":\"uk\",\"tiếng uzbek\":\"uz\",\"tiếng việt\":\"vi\",\"tiếng xứ wales\":\"cy\",\"tiếng ý\":\"it\",\"tiếng zulu\":\"zu\",\"にほんご\":\"ja\"},\"scratchToGoogleMap\":{\"zh-cn\":\"zh\",\"nb\":\"no\",\"he\":\"iw\",\"es-419\":\"es\",\"pt-br\":\"pt\",\"ja-hira\":\"ja\"},\"previouslySupported\":[\"ab\",\"ms\",\"be\",\"eo\",\"hy\",\"hi\",\"kn\",\"ht\",\"ku\",\"la\",\"mk\",\"ml\",\"mt\",\"mr\",\"mn\",\"my\",\"nn\",\"sq\",\"te\",\"uz\"],\"spokenLanguages\":{\"en\":[{\"code\":\"zh-cn\",\"name\":\"Chinese (Mandarin)\"}],\"cy\":[{\"code\":\"zh-cn\",\"name\":\"Tsieineaidd (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portiwgaleg (Brasil)\"},{\"code\":\"es-419\",\"name\":\"Sbaeneg (America Ladin)\"}],\"zu\":[{\"code\":\"zh-cn\",\"name\":\"IsiShayina (isiMandarin)\"},{\"code\":\"hi\",\"name\":\"IsiHindi\"},{\"code\":\"pt-br\",\"name\":\"IsiPutukezi (saseBrazil)\"},{\"code\":\"es-419\",\"name\":\"ISpanishi (Latin American)\"}],\"ko\":[{\"code\":\"zh-cn\",\"name\":\"중국어 (북경어)\"},{\"code\":\"hi\",\"name\":\"힌디 어\"},{\"code\":\"pt-br\",\"name\":\"포르투갈어 (브라질)\"},{\"code\":\"es-419\",\"name\":\"스페인어 (라틴 아메리카)\"}],\"az\":[{\"code\":\"zh-cn\",\"name\":\"Çin (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portuqal (Braziliya)\"},{\"code\":\"es-419\",\"name\":\"İspan (Latın Amerikası)\"}],\"he\":[{\"code\":\"zh-cn\",\"name\":\"סינית (מנדרינית)\"},{\"code\":\"hi\",\"name\":\"הינדי\"},{\"code\":\"pt-br\",\"name\":\"פורטוגזית (ברזילאית)\"},{\"code\":\"es-419\",\"name\":\"ספרדית (אמריקה הלטינית)\"}],\"mk\":[{\"code\":\"zh-cn\",\"name\":\"Кинески (мандарински)\"},{\"code\":\"hi\",\"name\":\"Хинди\"},{\"code\":\"pt-br\",\"name\":\"Португалски (бразилски)\"},{\"code\":\"es-419\",\"name\":\"Шпански (Латинска Америка)\"}],\"am\":[{\"code\":\"zh-cn\",\"name\":\"ቻይንኛ (ማንዳሪን)\"},{\"code\":\"hi\",\"name\":\"ሂንዲ\"},{\"code\":\"pt-br\",\"name\":\"ፖርቱጋልኛ (ብራዚላዊ)\"},{\"code\":\"es-419\",\"name\":\"ስፓኒሽ (ላቲን አሜሪካ)\"}],\"mr\":[{\"code\":\"zh-cn\",\"name\":\"चीनी (मंदारिन)\"},{\"code\":\"hi\",\"name\":\"हिंदी\"},{\"code\":\"pt-br\",\"name\":\"पोर्तुगीज (ब्राझिलियन)\"},{\"code\":\"es-419\",\"name\":\"स्पॅनिश (लॅटिन अमेरिकन)\"}],\"cs\":[{\"code\":\"zh-cn\",\"name\":\"Čínština (mandarinka)\"},{\"code\":\"hi\",\"name\":\"hindština\"},{\"code\":\"pt-br\",\"name\":\"Portugalština (brazilská)\"},{\"code\":\"es-419\",\"name\":\"Španělština (latinskoamerická)\"}],\"zh-cn\":[{\"code\":\"zh-cn\",\"name\":\"中文\"},{\"code\":\"hi\",\"name\":\"印地语\"},{\"code\":\"pt-br\",\"name\":\"葡萄牙语（巴西）\"},{\"code\":\"es-419\",\"name\":\"西班牙语（拉丁美洲）\"}],\"la\":[{\"code\":\"zh-cn\",\"name\":\"Seres (Latin)\"},{\"code\":\"hi\",\"name\":\"Hibernica\"},{\"code\":\"pt-br\",\"name\":\"Portuguese (Spanish)\"},{\"code\":\"es-419\",\"name\":\"Hispanica (Latin American)\"}],\"nn\":[{\"code\":\"zh-cn\",\"name\":\"Kinesisk (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisisk (brasiliansk)\"},{\"code\":\"es-419\",\"name\":\"Spansk (latinamerikansk)\"}],\"my\":[{\"code\":\"zh-cn\",\"name\":\"တရုတ် (တရုတ်)\"},{\"code\":\"hi\",\"name\":\"ဟိန္ဒီ\"},{\"code\":\"pt-br\",\"name\":\"ပေါ်တူဂီ (ဘရာဇီး)\"},{\"code\":\"es-419\",\"name\":\"စပိန်ဘာသာစကား (လက်တင်အမေရိက)\"}],\"ga\":[{\"code\":\"zh-cn\",\"name\":\"Sínis (Mandairínis)\"},{\"code\":\"hi\",\"name\":\"Hiondúis\"},{\"code\":\"pt-br\",\"name\":\"Portaingéilis (Brasaíle)\"},{\"code\":\"es-419\",\"name\":\"Spáinnis (Meiriceá Laidineach)\"}],\"es\":[{\"code\":\"zh-cn\",\"name\":\"Chino (Mandarín)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugués (brasileño)\"},{\"code\":\"es-419\",\"name\":\"Español (latinoamericano)\"}],\"nl\":[{\"code\":\"zh-cn\",\"name\":\"Chinees (Mandarijn)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugees (Braziliaans)\"},{\"code\":\"es-419\",\"name\":\"Spaans (Latijns-Amerikaans)\"}],\"zh-tw\":[{\"code\":\"zh-cn\",\"name\":\"中文\"},{\"code\":\"hi\",\"name\":\"印地語\"},{\"code\":\"pt-br\",\"name\":\"葡萄牙語（巴西）\"},{\"code\":\"es-419\",\"name\":\"西班牙語（拉丁美洲）\"}],\"pt-br\":[{\"code\":\"zh-cn\",\"name\":\"Mandarim (chinês)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Português (brasileiro)\"},{\"code\":\"es-419\",\"name\":\"Espanhol (latino-americano)\"}],\"kn\":[{\"code\":\"zh-cn\",\"name\":\"ಚೈನೀಸ್ (ಮ್ಯಾಂಡರಿನ್)\"},{\"code\":\"hi\",\"name\":\"ಹಿಂದಿ\"},{\"code\":\"pt-br\",\"name\":\"ಪೋರ್ಚುಗೀಸ್ (ಬ್ರೆಜಿಲಿಯನ್)\"},{\"code\":\"es-419\",\"name\":\"ಸ್ಪ್ಯಾನಿಷ್ (ಲ್ಯಾಟಿನ್ ಅಮೇರಿಕನ್)\"}],\"uz\":[{\"code\":\"zh-cn\",\"name\":\"Xitoy (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindcha\"},{\"code\":\"pt-br\",\"name\":\"Portugal (Braziliya)\"},{\"code\":\"es-419\",\"name\":\"Ispan (Lotin Amerikasi)\"}],\"ja\":[{\"code\":\"zh-cn\",\"name\":\"中国語（標準語）\"},{\"code\":\"hi\",\"name\":\"ヒンディー語\"},{\"code\":\"pt-br\",\"name\":\"ポルトガル語（ブラジル）\"},{\"code\":\"es-419\",\"name\":\"スペイン語（ラテンアメリカ）\"}],\"is\":[{\"code\":\"zh-cn\",\"name\":\"Kínverska (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindí\"},{\"code\":\"pt-br\",\"name\":\"Portúgalska (brasilíska)\"},{\"code\":\"es-419\",\"name\":\"Spænska (rómönsku-ameríska)\"}],\"sk\":[{\"code\":\"zh-cn\",\"name\":\"Čínština (mandarínska)\"},{\"code\":\"hi\",\"name\":\"hindčina\"},{\"code\":\"pt-br\",\"name\":\"Portugalčina (brazílska)\"},{\"code\":\"es-419\",\"name\":\"Španielčina (latinskoamerická)\"}],\"ht\":[{\"code\":\"zh-cn\",\"name\":\"Chinwa (Mandaren)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Pòtigè (brezilyen)\"},{\"code\":\"es-419\",\"name\":\"Panyòl (Amerik Latin)\"}],\"bg\":[{\"code\":\"zh-cn\",\"name\":\"Китайски (мандарин)\"},{\"code\":\"hi\",\"name\":\"хинди\"},{\"code\":\"pt-br\",\"name\":\"Португалски (бразилски)\"},{\"code\":\"es-419\",\"name\":\"Испански (латиноамерикански)\"}],\"de\":[{\"code\":\"zh-cn\",\"name\":\"Chinesisch (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugiesisch (brasilianisch)\"},{\"code\":\"es-419\",\"name\":\"Spanisch (Lateinamerikanisch)\"}],\"gd\":[{\"code\":\"zh-cn\",\"name\":\"Sìneach (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Indeach\"},{\"code\":\"pt-br\",\"name\":\"Portuguese (Brazilian)\"},{\"code\":\"es-419\",\"name\":\"Spàinntis (Ameireagaidh Laidinn)\"}],\"et\":[{\"code\":\"zh-cn\",\"name\":\"Hiina (mandariini)\"},{\"code\":\"hi\",\"name\":\"Hindi keel\"},{\"code\":\"pt-br\",\"name\":\"Portugali (Brasiilia)\"},{\"code\":\"es-419\",\"name\":\"Hispaania keel (Ladina-Ameerika)\"}],\"fi\":[{\"code\":\"zh-cn\",\"name\":\"Kiina (mandariini)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugali (brasilia)\"},{\"code\":\"es-419\",\"name\":\"Espanja (Latinalainen Amerikka)\"}],\"ar\":[{\"code\":\"zh-cn\",\"name\":\"الصينية (الماندرين)\"},{\"code\":\"hi\",\"name\":\"الهندية\"},{\"code\":\"pt-br\",\"name\":\"البرتغالية (البرازيلية)\"},{\"code\":\"es-419\",\"name\":\"الإسبانية (أمريكا اللاتينية)\"}],\"hu\":[{\"code\":\"zh-cn\",\"name\":\"Kínai (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugál (brazil)\"},{\"code\":\"es-419\",\"name\":\"Spanyol (latin-amerikai)\"}],\"mt\":[{\"code\":\"zh-cn\",\"name\":\"Ċiniż (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Ħindi\"},{\"code\":\"pt-br\",\"name\":\"Portugiż (Brażiljan)\"},{\"code\":\"es-419\",\"name\":\"Spanjol (Latin-Amerikan)\"}],\"ro\":[{\"code\":\"zh-cn\",\"name\":\"Chineză (mandarină)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugheză (braziliană)\"},{\"code\":\"es-419\",\"name\":\"Spaniolă (latino-americană)\"}],\"fa\":[{\"code\":\"zh-cn\",\"name\":\"چینی (ماندارین)\"},{\"code\":\"hi\",\"name\":\"هندی\"},{\"code\":\"pt-br\",\"name\":\"پرتغالی (برزیلی)\"},{\"code\":\"es-419\",\"name\":\"اسپانیایی (آمریکای لاتین)\"}],\"hi\":[{\"code\":\"zh-cn\",\"name\":\"चीनी (मंदारिन)\"},{\"code\":\"hi\",\"name\":\"हिन्दी\"},{\"code\":\"pt-br\",\"name\":\"पुर्तगाली (ब्राजील)\"},{\"code\":\"es-419\",\"name\":\"स्पेनिश (लैटिन अमेरिकी)\"}],\"eo\":[{\"code\":\"zh-cn\",\"name\":\"Ĉina (mandarena)\"},{\"code\":\"hi\",\"name\":\"Hinda\"},{\"code\":\"pt-br\",\"name\":\"Portugala (brazila)\"},{\"code\":\"es-419\",\"name\":\"Hispana (latina)\"}],\"lt\":[{\"code\":\"zh-cn\",\"name\":\"Kinų (mandarinų)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugalų (Brazilijos)\"},{\"code\":\"es-419\",\"name\":\"Ispanų (Lotynų Amerikos)\"}],\"it\":[{\"code\":\"zh-cn\",\"name\":\"Cinese (mandarino)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portoghese (brasiliano)\"},{\"code\":\"es-419\",\"name\":\"Spagnolo (latino-americano)\"}],\"el\":[{\"code\":\"zh-cn\",\"name\":\"Κινέζικα (μανταρινικά)\"},{\"code\":\"hi\",\"name\":\"Χίντι\"},{\"code\":\"pt-br\",\"name\":\"Πορτογαλικά (Βραζιλίας)\"},{\"code\":\"es-419\",\"name\":\"Ισπανικά (Λατινικής Αμερικής)\"}],\"mi\":[{\"code\":\"zh-cn\",\"name\":\"Hainamana (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Potukua (Brazil)\"},{\"code\":\"es-419\",\"name\":\"Pāniora (Latin American)\"}],\"hr\":[{\"code\":\"zh-cn\",\"name\":\"Kineski (mandarinski)\"},{\"code\":\"hi\",\"name\":\"hindski\"},{\"code\":\"pt-br\",\"name\":\"Portugalski (brazilski)\"},{\"code\":\"es-419\",\"name\":\"Španjolski (latinoamerički)\"}],\"ca\":[{\"code\":\"zh-cn\",\"name\":\"Xinès (mandarí)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portuguès (brasiler)\"},{\"code\":\"es-419\",\"name\":\"Espanyol (llatinoamericà)\"}],\"th\":[{\"code\":\"zh-cn\",\"name\":\"จีน (แมนดาริน)\"},{\"code\":\"hi\",\"name\":\"ภาษาฮินดี\"},{\"code\":\"pt-br\",\"name\":\"โปรตุเกส (บราซิล)\"},{\"code\":\"es-419\",\"name\":\"สเปน (ละตินอเมริกา)\"}],\"hy\":[{\"code\":\"zh-cn\",\"name\":\"Չինարեն (մանդարին)\"},{\"code\":\"hi\",\"name\":\"Հինդի\"},{\"code\":\"pt-br\",\"name\":\"Պորտուգալերեն (բրազիլական)\"},{\"code\":\"es-419\",\"name\":\"Իսպաներեն (լատինաամերիկյան)\"}],\"id\":[{\"code\":\"zh-cn\",\"name\":\"Mandarin (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugis (Brasil)\"},{\"code\":\"es-419\",\"name\":\"Spanyol (Amerika Latin)\"}],\"eu\":[{\"code\":\"zh-cn\",\"name\":\"Txinera (mandarina)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugesa (brasildarra)\"},{\"code\":\"es-419\",\"name\":\"Espainiera (latinoamerikarra)\"}],\"da\":[{\"code\":\"zh-cn\",\"name\":\"Kinesisk (mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisisk (brasiliansk)\"},{\"code\":\"es-419\",\"name\":\"Spansk (latinamerikansk)\"}],\"ru\":[{\"code\":\"zh-cn\",\"name\":\"Китайский (мандарин)\"},{\"code\":\"hi\",\"name\":\"хинди\"},{\"code\":\"pt-br\",\"name\":\"Португальский (бразильский)\"},{\"code\":\"es-419\",\"name\":\"Испанский (латиноамериканский)\"}],\"sr\":[{\"code\":\"zh-cn\",\"name\":\"Кинески (мандарински)\"},{\"code\":\"hi\",\"name\":\"Хиндски\"},{\"code\":\"pt-br\",\"name\":\"Португалски (бразилски)\"},{\"code\":\"es-419\",\"name\":\"Шпански (латиноамерички)\"}],\"gl\":[{\"code\":\"zh-cn\",\"name\":\"Chinés (mandarín)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugués (brasileiro)\"},{\"code\":\"es-419\",\"name\":\"Español (latinoamericano)\"}],\"lv\":[{\"code\":\"zh-cn\",\"name\":\"Ķīniešu (mandarīnu)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugāļu (Brazīlijas)\"},{\"code\":\"es-419\",\"name\":\"Spāņu (latīņamerikāņu)\"}],\"nb\":[{\"code\":\"zh-cn\",\"name\":\"Kinesisk (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisisk (brasiliansk)\"},{\"code\":\"es-419\",\"name\":\"Spansk (latinamerikansk)\"}],\"tr\":[{\"code\":\"zh-cn\",\"name\":\"Çin (mandalinası)\"},{\"code\":\"hi\",\"name\":\"Hintçe\"},{\"code\":\"pt-br\",\"name\":\"Portekizce (Brezilya)\"},{\"code\":\"es-419\",\"name\":\"İspanyolca (Latin Amerika)\"}],\"fr\":[{\"code\":\"zh-cn\",\"name\":\"Mandarin (chinois)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugais (brésilien)\"},{\"code\":\"es-419\",\"name\":\"Espagnol (latino-américain)\"}],\"sv\":[{\"code\":\"zh-cn\",\"name\":\"Kinesiska (mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisiska (brasilianska)\"},{\"code\":\"es-419\",\"name\":\"Spanska (latinamerikanska)\"}],\"sl\":[{\"code\":\"zh-cn\",\"name\":\"Kitajščina (mandarina)\"},{\"code\":\"hi\",\"name\":\"Hindujščina\"},{\"code\":\"pt-br\",\"name\":\"Portugalščina (brazilska)\"},{\"code\":\"es-419\",\"name\":\"Španščina (latinskoameriška)\"}],\"ml\":[{\"code\":\"zh-cn\",\"name\":\"ചൈനീസ് (മന്ദാരിൻ)\"},{\"code\":\"hi\",\"name\":\"ഹിന്ദി\"},{\"code\":\"pt-br\",\"name\":\"പോർച്ചുഗീസ് (ബ്രസീൽ)\"},{\"code\":\"es-419\",\"name\":\"സ്പാനിഷ് (ലാറ്റിൻ അമേരിക്കൻ)\"}],\"be\":[{\"code\":\"zh-cn\",\"name\":\"Кітайская (мандарын)\"},{\"code\":\"hi\",\"name\":\"Хіндзі\"},{\"code\":\"pt-br\",\"name\":\"Партугальская (бразільскі)\"},{\"code\":\"es-419\",\"name\":\"Іспанская (лацінаамерыканская)\"}],\"pl\":[{\"code\":\"zh-cn\",\"name\":\"Chiński (mandaryński)\"},{\"code\":\"hi\",\"name\":\"hinduski\"},{\"code\":\"pt-br\",\"name\":\"Portugalski (brazylijski)\"},{\"code\":\"es-419\",\"name\":\"Hiszpański (latynoamerykański)\"}],\"pt\":[{\"code\":\"zh-cn\",\"name\":\"Mandarim (chinês)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Português (brasileiro)\"},{\"code\":\"es-419\",\"name\":\"Espanhol (latino-americano)\"}],\"ku\":[{\"code\":\"zh-cn\",\"name\":\"Chinese (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindî\"},{\"code\":\"pt-br\",\"name\":\"Portekîz (Brazilian)\"},{\"code\":\"es-419\",\"name\":\"Spanish (Amerîkaya Latîn)\"}],\"sq\":[{\"code\":\"zh-cn\",\"name\":\"Kinezisht (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugeze (Braziliane)\"},{\"code\":\"es-419\",\"name\":\"Spanjisht (Amerika Latine)\"}],\"ms\":[{\"code\":\"zh-cn\",\"name\":\"Cina (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugis (Brazil)\"},{\"code\":\"es-419\",\"name\":\"Sepanyol (Amerika Latin)\"}],\"vi\":[{\"code\":\"zh-cn\",\"name\":\"Tiếng trung quốc\"},{\"code\":\"hi\",\"name\":\"Tiếng Hindi\"},{\"code\":\"pt-br\",\"name\":\"Bồ Đào Nha (Brazil)\"},{\"code\":\"es-419\",\"name\":\"Tây Ban Nha (Mỹ Latinh)\"}],\"te\":[{\"code\":\"zh-cn\",\"name\":\"చైనీస్ (మాండరిన్)\"},{\"code\":\"hi\",\"name\":\"హిందీ\"},{\"code\":\"pt-br\",\"name\":\"పోర్చుగీస్ (బ్రెజిలియన్)\"},{\"code\":\"es-419\",\"name\":\"స్పానిష్ (లాటిన్ అమెరికన్)\"}],\"uk\":[{\"code\":\"zh-cn\",\"name\":\"Китайська (мандарин)\"},{\"code\":\"hi\",\"name\":\"Хінді\"},{\"code\":\"pt-br\",\"name\":\"Португальська (бразильська)\"},{\"code\":\"es-419\",\"name\":\"Іспанська (латиноамериканська)\"}],\"mn\":[{\"code\":\"zh-cn\",\"name\":\"Хятад хэл (Мандарин)\"},{\"code\":\"hi\",\"name\":\"Хинди хэл\"},{\"code\":\"pt-br\",\"name\":\"Португал хэл (Бразил)\"},{\"code\":\"es-419\",\"name\":\"Испани хэл (Латин Америк)\"}],\"es-419\":[{\"code\":\"zh-cn\",\"name\":\"Chino (Mandarín)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugués (brasileño)\"},{\"code\":\"es-419\",\"name\":\"Español (latinoamericano)\"}],\"ja-hira\":[{\"code\":\"zh-cn\",\"name\":\"中国語（標準語）\"},{\"code\":\"hi\",\"name\":\"ヒンディー語\"},{\"code\":\"pt-br\",\"name\":\"ポルトガル語（ブラジル）\"},{\"code\":\"es-419\",\"name\":\"スペイン語（ラテンアメリカ）\"}]}}");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js?name=extension-worker.js!./src/extension-support/extension-worker.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js?name=extension-worker.js!./src/extension-support/extension-worker.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return new Worker(__webpack_require__.p + "extension-worker.js");
};

/***/ }),

/***/ "./node_modules/xhr/index.js":
/*!***********************************!*\
  !*** ./node_modules/xhr/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var window = __webpack_require__(/*! global/window */ "./node_modules/global/window.js")
var isFunction = __webpack_require__(/*! is-function */ "./node_modules/is-function/index.js")
var parseHeaders = __webpack_require__(/*! parse-headers */ "./node_modules/parse-headers/parse-headers.js")
var xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js")

module.exports = createXHR
// Allow use of default import syntax in TypeScript
module.exports.default = createXHR;
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
    try {
        if (xhr.responseType === "document") {
            return xhr.responseXML
        }
        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
        if (xhr.responseType === "" && !firefoxBugTakenEffect) {
            return xhr.responseXML
        }
    } catch (e) {}

    return null
}

function noop() {}


/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ "./src/dispatch/central-dispatch.js":
/*!******************************************!*\
  !*** ./src/dispatch/central-dispatch.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const SharedDispatch = __webpack_require__(/*! ./shared-dispatch */ "./src/dispatch/shared-dispatch.js");
/**
 * 此类用作消息分发的中央代理. 它期望在主线程/窗口上运行，并且必须通知所有将参与消息传递系统的辅助线程. 从消息传递系统中的任何上下文中，调度程序的"call"方法可以在任何参与上下文中提供的任何"service"上调用任何方法. The dispatch system will forward function arguments and return values across worker boundaries as needed. 调度系统将根据需要跨工作者边界转发函数参数并返回值
 * @see {WorkerDispatch}
 */


class CentralDispatch extends SharedDispatch {
  constructor() {
    super();
    /**
     * Map of channel name to worker or local service provider.
     * If the entry is a Worker, the service is provided by an object on that worker.
     * Otherwise, the service is provided locally and methods on the service will be called directly.
     * @see {setService}
     * @type {object.<Worker|object>}
     */

    this.services = {};
    /**
     * The constructor we will use to recognize workers.
     * @type {Function}
     */

    this.workerClass = typeof Worker === "undefined" ? null : Worker;
    /**
     * List of workers attached to this dispatcher.
     * @type {Array}
     */

    this.workers = [];
  }
  /**
   * Synchronously call a particular method on a particular service provided locally.
   * Calling this function on a remote service will fail.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {*} - the return value of the service method.
   */


  callSync(service, method, ...args) {
    const {
      provider,
      isRemote
    } = this._getServiceProvider(service);

    if (provider) {
      if (isRemote) {
        throw new Error(`Cannot use 'callSync' on remote provider for service ${service}.`);
      }

      return provider[method].apply(provider, args);
    }

    throw new Error(`Provider not found for service: ${service}`);
  }
  /**
   * Synchronously set a local object as the global provider of the specified service.
   * WARNING: Any method on the provider can be called from any worker within the dispatch system.
   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.
   * @param {object} provider - a local object which provides this service.
   */


  setServiceSync(service, provider) {
    if (this.services.hasOwnProperty(service)) {
      console.warn(`Central dispatch replacing existing service provider for ${service}`);
    }

    this.services[service] = provider;
  }
  /**
   * Set a local object as the global provider of the specified service.
   * WARNING: Any method on the provider can be called from any worker within the dispatch system.
   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.
   * @param {object} provider - a local object which provides this service.
   * @returns {Promise} - a promise which will resolve once the service is registered.
   */


  setService(service, provider) {
    /** Return a promise for consistency with {@link WorkerDispatch#setService} */
    try {
      this.setServiceSync(service, provider);
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Add a worker to the message dispatch system. The worker must implement a compatible message dispatch framework.
   * The dispatcher will immediately attempt to "handshake" with the worker.
   * @param {Worker} worker - the worker to add into the dispatch system.
   */


  addWorker(worker) {
    if (this.workers.indexOf(worker) === -1) {
      this.workers.push(worker);
      worker.onmessage = this._onMessage.bind(this, worker);

      this._remoteCall(worker, "dispatch", "handshake").catch(e => {
        console.error(`Could not handshake with worker: ${JSON.stringify(e)}`);
      });
    } else {
      console.warn("Central dispatch ignoring attempt to add duplicate worker");
    }
  }
  /**
   * Fetch the service provider object for a particular service name.
   * @override
   * @param {string} service - the name of the service to look up
   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found
   * @protected
   */


  _getServiceProvider(service) {
    const provider = this.services[service];
    return provider && {
      provider,
      isRemote: Boolean(this.workerClass && provider instanceof this.workerClass)
    };
  }
  /**
   * Handle a call message sent to the dispatch service itself
   * @override
   * @param {Worker} worker - the worker which sent the message.
   * @param {DispatchCallMessage} message - the message to be handled.
   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate
   * @protected
   */


  _onDispatchMessage(worker, message) {
    let promise;

    switch (message.method) {
      case "setService":
        promise = this.setService(message.args[0], worker);
        break;

      default:
        console.error(`Central dispatch received message for unknown method: ${message.method}`);
    }

    return promise;
  }

}

module.exports = new CentralDispatch();

/***/ }),

/***/ "./src/dispatch/shared-dispatch.js":
/*!*****************************************!*\
  !*** ./src/dispatch/shared-dispatch.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call
 * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}
 * @property {string} service - the name of the service to be called
 * @property {string} method - the name of the method to be called
 * @property {Array|undefined} args - the arguments to be passed to the method
 */

/**
 * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call
 * @property {*} responseId - a copy of the response ID from the call which generated this response
 * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)
 * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)
 */

/**
 * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage
 * Any message to the dispatch system.
 */

/**
 * SharedDispatch类负责由以下人员共享的调度功能
 * {@link CentralDispatch} and {@link WorkerDispatch}.
 */
class SharedDispatch {
  constructor() {
    /**
     * List of callback registrations for promises waiting for a response from a call to a service on another
     * worker. A callback registration is an array of [resolve,reject] Promise functions.
     * Calls to local services don't enter this list.
     * @type {Array.<Function[]>}
     */
    this.callbacks = [];
    /**
     * The next response ID to be used.
     * @type {int}
     */

    this.nextResponseId = 0;
  }
  /**
   * Call a particular method on a particular service, regardless of whether that service is provided locally or on
   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone
   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be
   * transferred to the worker, and they should not be used after this call.
   * @example
   *      dispatcher.call('vm', 'setData', 'cat', 42);
   *      // this finds the worker for the 'vm' service, then on that worker calls:
   *      vm.setData('cat', 42);
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  call(service, method, ...args) {
    return this.transferCall(service, method, null, ...args);
  }
  /**
   * Call a particular method on a particular service, regardless of whether that service is provided locally or on
   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone
   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be
   * transferred to the worker, and they should not be used after this call.
   * @example
   *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);
   *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:
   *      vm.setData('cat', myArrayBuffer);
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  transferCall(service, method, transfer, ...args) {
    try {
      const {
        provider,
        isRemote
      } = this._getServiceProvider(service);

      if (provider) {
        if (isRemote) {
          return this._remoteTransferCall(provider, service, method, transfer, ...args);
        }

        const result = provider[method].apply(provider, args);
        return Promise.resolve(result);
      }

      return Promise.reject(new Error(`Service not found: ${service}`));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Check if a particular service lives on another worker.
   * @param {string} service - the service to check.
   * @returns {boolean} - true if the service is remote (calls must cross a Worker boundary), false otherwise.
   * @private
   */


  _isRemoteService(service) {
    return this._getServiceProvider(service).isRemote;
  }
  /**
   * Like {@link call}, but force the call to be posted through a particular communication channel.
   * @param {object} provider - send the call through this object's `postMessage` function.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  _remoteCall(provider, service, method, ...args) {
    return this._remoteTransferCall(provider, service, method, null, ...args);
  }
  /**
   * Like {@link transferCall}, but force the call to be posted through a particular communication channel.
   * @param {object} provider - send the call through this object's `postMessage` function.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  _remoteTransferCall(provider, service, method, transfer, ...args) {
    return new Promise((resolve, reject) => {
      const responseId = this._storeCallbacks(resolve, reject);
      /** @TODO: remove this hack! this is just here so we don't try to send `util` to a worker */


      if (args.length > 0 && typeof args[args.length - 1].yield === "function") {
        args.pop();
      }

      if (transfer) {
        provider.postMessage({
          service,
          method,
          responseId,
          args
        }, transfer);
      } else {
        provider.postMessage({
          service,
          method,
          responseId,
          args
        });
      }
    });
  }
  /**
   * Store callback functions pending a response message.
   * @param {Function} resolve - function to call if the service method returns.
   * @param {Function} reject - function to call if the service method throws.
   * @returns {*} - a unique response ID for this set of callbacks. See {@link _deliverResponse}.
   * @protected
   */


  _storeCallbacks(resolve, reject) {
    const responseId = this.nextResponseId++;
    this.callbacks[responseId] = [resolve, reject];
    return responseId;
  }
  /**
   * Deliver call response from a worker. This should only be called as the result of a message from a worker.
   * @param {int} responseId - the response ID of the callback set to call.
   * @param {DispatchResponseMessage} message - the message containing the response value(s).
   * @protected
   */


  _deliverResponse(responseId, message) {
    try {
      const [resolve, reject] = this.callbacks[responseId];
      delete this.callbacks[responseId];

      if (message.error) {
        reject(message.error);
      } else {
        resolve(message.result);
      }
    } catch (e) {
      console.error(`Dispatch callback failed: ${JSON.stringify(e)}`);
    }
  }
  /**
   * Handle a message event received from a connected worker.
   * @param {Worker} worker - the worker which sent the message, or the global object if running in a worker.
   * @param {MessageEvent} event - the message event to be handled.
   * @protected
   */


  _onMessage(worker, event) {
    /** @type {DispatchMessage} */
    const message = event.data;
    message.args = message.args || [];
    let promise;

    if (message.service) {
      if (message.service === "dispatch") {
        promise = this._onDispatchMessage(worker, message);
      } else {
        promise = this.call(message.service, message.method, ...message.args);
      }
    } else if (typeof message.responseId === "undefined") {
      console.error(`Dispatch caught malformed message from a worker: ${JSON.stringify(event)}`);
    } else {
      this._deliverResponse(message.responseId, message);
    }

    if (promise) {
      if (typeof message.responseId === "undefined") {
        console.error(`Dispatch message missing required response ID: ${JSON.stringify(event)}`);
      } else {
        promise.then(result => worker.postMessage({
          responseId: message.responseId,
          result
        }), error => worker.postMessage({
          responseId: message.responseId,
          error
        }));
      }
    }
  }
  /**
   * Fetch the service provider object for a particular service name.
   * @abstract
   * @param {string} service - the name of the service to look up
   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found
   * @protected
   */


  _getServiceProvider(service) {
    throw new Error(`Could not get provider for ${service}: _getServiceProvider not implemented`);
  }
  /**
   * Handle a call message sent to the dispatch service itself
   * @abstract
   * @param {Worker} worker - the worker which sent the message.
   * @param {DispatchCallMessage} message - the message to be handled.
   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate
   * @private
   */


  _onDispatchMessage(worker, message) {
    throw new Error(`Unimplemented dispatch message handler cannot handle ${message.method} method`);
  }

}

module.exports = SharedDispatch;

/***/ }),

/***/ "./src/engine/adapter.js":
/*!*******************************!*\
  !*** ./src/engine/adapter.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const mutationAdapter = __webpack_require__(/*! ./mutation-adapter */ "./src/engine/mutation-adapter.js");

const html = __webpack_require__(/*! htmlparser2 */ "./node_modules/htmlparser2/lib/index.js");
/**
 * Convert and an individual block DOM to the representation tree.
 * Based on Blockly's `domToBlockHeadless_`.
 * @param {Element} blockDOM DOM tree for an individual block.
 * @param {object} blocks Collection of blocks to add to.
 * @param {boolean} isTopBlock Whether blocks at this level are "top blocks."
 * @param {?string} parent Parent block ID.
 * @return {undefined}
 */


const domToBlock = function (blockDOM, blocks, isTopBlock, parent) {
  if (!blockDOM.attribs.id) {
    console.warn("adapter:", Utility.uid());
    blockDOM.attribs.id = Utility.uid();
  } // Block skeleton.


  const block = {
    id: blockDOM.attribs.id,
    // Block ID
    opcode: blockDOM.attribs.type,
    // For execution, "event_whengreenflag".
    inputs: {},
    // Inputs to this block and the blocks they point to.
    fields: {},
    // Fields on this block and their values.
    next: null,
    // Next block in the stack, if one exists.
    topLevel: isTopBlock,
    // If this block starts a stack.
    parent: parent,
    // Parent block ID, if available.
    shadow: blockDOM.name === "shadow",
    // If this represents a shadow/slot.
    x: blockDOM.attribs.x,
    // X position of script, if top-level.
    y: blockDOM.attribs.y // Y position of script, if top-level.

  }; // Add the block to the representation tree.

  blocks[block.id] = block; // Process XML children and find enclosed blocks, fields, etc.

  for (let i = 0; i < blockDOM.children.length; i++) {
    const xmlChild = blockDOM.children[i]; // Enclosed blocks and shadows

    let childBlockNode = null;
    let childShadowNode = null;

    for (let j = 0; j < xmlChild.children.length; j++) {
      const grandChildNode = xmlChild.children[j];

      if (!grandChildNode.name) {
        // Non-XML tag node.
        continue;
      }

      const grandChildNodeName = grandChildNode.name.toLowerCase();

      if (grandChildNodeName === "block") {
        childBlockNode = grandChildNode;
      } else if (grandChildNodeName === "shadow") {
        childShadowNode = grandChildNode;
      }
    } // Use shadow block only if there's no real block node.


    if (!childBlockNode && childShadowNode) {
      childBlockNode = childShadowNode;
    } // Not all Blockly-type blocks are handled here,
    // as we won't be using all of them for Scratch.


    switch (xmlChild.name.toLowerCase()) {
      case "field":
        {
          // Add the field to this block.
          const fieldName = xmlChild.attribs.name; // Add id in case it is a variable field

          const fieldId = xmlChild.attribs.id;
          let fieldData = "";

          if (xmlChild.children.length > 0 && xmlChild.children[0].data) {
            fieldData = xmlChild.children[0].data;
          } else {
            // If the child of the field with a data property
            // doesn't exist, set the data to an empty string.
            fieldData = "";
          }

          block.fields[fieldName] = {
            name: fieldName,
            id: fieldId,
            value: fieldData
          };
          const fieldVarType = xmlChild.attribs.variabletype;

          if (typeof fieldVarType === "string") {
            block.fields[fieldName].variableType = fieldVarType;
          }

          break;
        }

      case "comment":
        {
          block.comment = xmlChild.attribs.id;
          break;
        }

      case "value":
      case "statement":
        {
          // Recursively generate block structure for input block.
          domToBlock(childBlockNode, blocks, false, block.id);

          if (childShadowNode && childBlockNode !== childShadowNode) {
            // Also generate the shadow block.
            domToBlock(childShadowNode, blocks, false, block.id);
          } // Link this block's input to the child block.


          const inputName = xmlChild.attribs.name;
          block.inputs[inputName] = {
            name: inputName,
            block: childBlockNode.attribs.id,
            shadow: childShadowNode ? childShadowNode.attribs.id : null
          };
          break;
        }

      case "next":
        {
          if (!childBlockNode || !childBlockNode.attribs) {
            // Invalid child block.
            continue;
          } // Recursively generate block structure for next block.


          domToBlock(childBlockNode, blocks, false, block.id); // Link next block to this block.

          block.next = childBlockNode.attribs.id;
          break;
        }

      case "mutation":
        {
          block.mutation = mutationAdapter(xmlChild);
          break;
        }
    }
  }
};
/**
 * Convert outer blocks DOM from a Blockly CREATE event
 * to a usable form for the Scratch runtime.
 * This structure is based on Blockly xml.js:`domToWorkspace` and `domToBlock`.
 * @param {Element} blocksDOM DOM tree for this event.
 * @return {Array.<object>} Usable list of blocks from this CREATE event.
 */


const domToBlocks = function (blocksDOM) {
  // At this level, there could be multiple blocks adjacent in the DOM tree.
  const blocks = {};

  for (let i = 0; i < blocksDOM.length; i++) {
    const block = blocksDOM[i];

    if (!block.name || !block.attribs) {
      continue;
    }

    const tagName = block.name.toLowerCase();

    if (tagName === "block" || tagName === "shadow") {
      domToBlock(block, blocks, true, null);
    }
  } // Flatten blocks object into a list.


  const blocksList = [];

  for (const b in blocks) {
    if (!blocks.hasOwnProperty(b)) continue;
    blocksList.push(blocks[b]);
  }

  return blocksList;
};
/**
 * 运行时可以使用的块创建事件和块表示之间的适配器.
 * @param {object} e `Blockly.events.create` or `Blockly.events.endDrag`
 * @return {Array.<object>} List of blocks from this CREATE event.
 */


const adapter = function (e) {
  // Validate input
  if (typeof e !== "object") return;
  if (typeof e.xml !== "object") return; // console.log("解析HTML:", html);
  // console.log(
  //   "!!!!!!",
  //   html.parseDOM(e.xml.outerHTML, { decodeEntities: true })
  // );

  return domToBlocks(html.parseDOM(e.xml.outerHTML, {
    decodeEntities: true
  }));
};

module.exports = adapter;

/***/ }),

/***/ "./src/engine/block-utility.js":
/*!*************************************!*\
  !*** ./src/engine/block-utility.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");
/**
 * @fileoverview
 * Interface provided to block primitive functions for interacting with the
 * runtime, thread, target, and convenient methods.
 */


class BlockUtility {
  constructor(sequencer = null, thread = null) {
    /**
     * A sequencer block primitives use to branch or start procedures with
     * @type {?Sequencer}
     */
    this.sequencer = sequencer;
    /**
     * The block primitives thread with the block's target, stackFrame and
     * modifiable status.
     * @type {?Thread}
     */

    this.thread = thread;
    this._nowObj = {
      now: () => this.sequencer.runtime.currentMSecs
    };
  }
  /**
   * The target the primitive is working on.
   * @type {Target}
   */


  get target() {
    return this.thread.target;
  }
  /**
   * The runtime the block primitive is running in.
   * @type {Runtime}
   */


  get runtime() {
    return this.sequencer.runtime;
  }
  /**
   * Use the runtime's currentMSecs value as a timestamp value for now
   * This is useful in some cases where we need compatibility with Scratch 2
   * @type {function}
   */


  get nowObj() {
    if (this.runtime) {
      return this._nowObj;
    }

    return null;
  }
  /**
   * The stack frame used by loop and other blocks to track internal state.
   * @type {object}
   */


  get stackFrame() {
    const frame = this.thread.peekStackFrame();

    if (frame.executionContext === null) {
      frame.executionContext = {};
    }

    return frame.executionContext;
  }
  /**
   * Check the stack timer and return a boolean based on whether it has finished or not.
   * @return {boolean} - true if the stack timer has finished.
   */


  stackTimerFinished() {
    const timeElapsed = this.stackFrame.timer.timeElapsed();

    if (timeElapsed < this.stackFrame.duration) {
      return false;
    }

    return true;
  }
  /**
   * Check if the stack timer needs initialization.
   * @return {boolean} - true if the stack timer needs to be initialized.
   */


  stackTimerNeedsInit() {
    return !this.stackFrame.timer;
  }
  /**
   * Create and start a stack timer
   * @param {number} duration - a duration in milliseconds to set the timer for.
   */


  startStackTimer(duration) {
    if (this.nowObj) {
      this.stackFrame.timer = new Timer(this.nowObj);
    } else {
      this.stackFrame.timer = new Timer();
    }

    this.stackFrame.timer.start();
    this.stackFrame.duration = duration;
  }
  /**
   * Set the thread to yield.
   */


  yield() {
    this.thread.status = Thread.STATUS_YIELD;
  }
  /**
   * Set the thread to yield until the next tick of the runtime.
   */


  yieldTick() {
    this.thread.status = Thread.STATUS_YIELD_TICK;
  }
  /**
   * Start a branch in the current block.
   * @param {number} branchNum Which branch to step to (i.e., 1, 2).
   * @param {boolean} isLoop Whether this block is a loop.
   */


  startBranch(branchNum, isLoop) {
    this.sequencer.stepToBranch(this.thread, branchNum, isLoop);
  }
  /**
   * Stop all threads.
   */


  stopAll() {
    this.sequencer.runtime.stopAll();
  }
  /**
   * Stop threads other on this target other than the thread holding the
   * executed block.
   */


  stopOtherTargetThreads() {
    this.sequencer.runtime.stopForTarget(this.thread.target, this.thread);
  }
  /**
   * Stop this thread.
   */


  stopThisScript() {
    this.thread.stopThisScript();
  }
  /**
   * Start a specified procedure on this thread.
   * @param {string} procedureCode Procedure code for procedure to start.
   */


  startProcedure(procedureCode) {
    this.sequencer.stepToProcedure(this.thread, procedureCode);
  }
  /**
   * Get names and ids of parameters for the given procedure.
   * @param {string} procedureCode Procedure code for procedure to query.
   * @return {Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesAndIds(procedureCode) {
    return this.thread.target.blocks.getProcedureParamNamesAndIds(procedureCode);
  }
  /**
   * Get names, ids, and defaults of parameters for the given procedure.
   * @param {string} procedureCode Procedure code for procedure to query.
   * @return {Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesIdsAndDefaults(procedureCode) {
    return this.thread.target.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);
  }
  /**
   * Initialize procedure parameters in the thread before pushing parameters.
   */


  initParams() {
    this.thread.initParams();
  }
  /**
   * Store a procedure parameter value by its name.
   * @param {string} paramName The procedure's parameter name.
   * @param {*} paramValue The procedure's parameter value.
   */


  pushParam(paramName, paramValue) {
    this.thread.pushParam(paramName, paramValue);
  }
  /**
   * Retrieve the stored parameter value for a given parameter name.
   * @param {string} paramName The procedure's parameter name.
   * @return {*} The parameter's current stored value.
   */


  getParam(paramName) {
    return this.thread.getParam(paramName);
  }
  /**
   * Start all relevant hats.
   * @param {!string} requestedHat Opcode of hats to start.
   * @param {object=} optMatchFields Optionally, fields to match on the hat.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   * @return {Array.<Thread>} List of threads started by this function.
   */


  startHats(requestedHat, optMatchFields, optTarget) {
    // Store thread and sequencer to ensure we can return to the calling block's context.
    // startHats may execute further blocks and dirty the BlockUtility's execution context
    // and confuse the calling block when we return to it.
    const callerThread = this.thread;
    const callerSequencer = this.sequencer;
    const result = this.sequencer.runtime.startHats(requestedHat, optMatchFields, optTarget); // Restore thread and sequencer to prior values before we return to the calling block.

    this.thread = callerThread;
    this.sequencer = callerSequencer;
    return result;
  }
  /**
   * 查询命名的IO设备.
   * @param {string} device 像设备之类的名称，如键盘.
   * @param {string} func 要查询的设备功能的名称.
   * @param {Array.<*>} args 传递给设备功能的参数.
   * @return {*} 设备功能的预期输出.
   */


  ioQuery(device, func, args) {
    // 查找I / O设备并执行查询/功能调用.
    if (this.sequencer.runtime.ioDevices[device] && this.sequencer.runtime.ioDevices[device][func]) {
      const devObject = this.sequencer.runtime.ioDevices[device];
      return devObject[func].apply(devObject, args);
    }
  }

}

module.exports = BlockUtility;

/***/ }),

/***/ "./src/engine/blocks-execute-cache.js":
/*!********************************************!*\
  !*** ./src/engine/blocks-execute-cache.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * Access point for private method shared between blocks.js and execute.js for
 * caching execute information.
 */

/**
 * A private method shared with execute to build an object containing the block
 * information execute needs and that is reset when other cached Blocks info is
 * reset.
 * @param {Blocks} blocks Blocks containing the expected blockId
 * @param {string} blockId blockId for the desired execute cache
 */
exports.getCached = function () {
  throw new Error('blocks.js has not initialized BlocksExecuteCache');
}; // Call after the default throwing getCached is assigned for Blocks to replace.


__webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

/***/ }),

/***/ "./src/engine/blocks-runtime-cache.js":
/*!********************************************!*\
  !*** ./src/engine/blocks-runtime-cache.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * The BlocksRuntimeCache caches data about the top block of scripts so that
 * Runtime can iterate a targeted opcode and iterate the returned set faster.
 * Many top blocks need to match fields as well as opcode, since that matching
 * compares strings in uppercase we can go ahead and uppercase the cached value
 * so we don't need to in the future.
 */

/**
 * A set of cached data about the top block of a script.
 * @param {Blocks} container - Container holding the block and related data
 * @param {string} blockId - Id for whose block data is cached in this instance
 */
class RuntimeScriptCache {
  constructor(container, blockId) {
    /**
     * Container with block data for blockId.
     * @type {Blocks}
     */
    this.container = container;
    /**
     * ID for block this instance caches.
     * @type {string}
     */

    this.blockId = blockId;
    const block = container.getBlock(blockId);
    const fields = container.getFields(block);
    /**
     * Formatted fields or fields of input blocks ready for comparison in
     * runtime.
     *
     * This is a clone of parts of the targeted blocks. Changes to these
     * clones are limited to copies under RuntimeScriptCache and will not
     * appear in the original blocks in their container. This copy is
     * modified changing the case of strings to uppercase. These uppercase
     * values will be compared later by the VM.
     * @type {object}
     */

    this.fieldsOfInputs = Object.assign({}, fields);

    if (Object.keys(fields).length === 0) {
      const inputs = container.getInputs(block);

      for (const input in inputs) {
        if (!inputs.hasOwnProperty(input)) continue;
        const id = inputs[input].block;
        const inputBlock = container.getBlock(id);
        const inputFields = container.getFields(inputBlock);
        Object.assign(this.fieldsOfInputs, inputFields);
      }
    }

    for (const key in this.fieldsOfInputs) {
      const field = this.fieldsOfInputs[key] = Object.assign({}, this.fieldsOfInputs[key]);

      if (field.value.toUpperCase) {
        field.value = field.value.toUpperCase();
      }
    }
  }

}
/**
 * Get an array of scripts from a block container prefiltered to match opcode.
 * @param {Blocks} container - Container of blocks
 * @param {string} opcode - Opcode to filter top blocks by
 */


exports.getScripts = function () {
  throw new Error('blocks.js has not initialized BlocksRuntimeCache');
};
/**
 * Exposed RuntimeScriptCache class used by integration in blocks.js.
 * @private
 */


exports._RuntimeScriptCache = RuntimeScriptCache;

__webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

/***/ }),

/***/ "./src/engine/blocks.js":
/*!******************************!*\
  !*** ./src/engine/blocks.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const adapter = __webpack_require__(/*! ./adapter */ "./src/engine/adapter.js");

const mutationAdapter = __webpack_require__(/*! ./mutation-adapter */ "./src/engine/mutation-adapter.js");

const MonitorRecord = __webpack_require__(/*! ./monitor-record */ "./src/engine/monitor-record.js");

const {
  Map
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");

const BlocksExecuteCache = __webpack_require__(/*! ./blocks-execute-cache */ "./src/engine/blocks-execute-cache.js");

const BlocksRuntimeCache = __webpack_require__(/*! ./blocks-runtime-cache */ "./src/engine/blocks-runtime-cache.js");

const Variable = __webpack_require__(/*! ./variable */ "./src/engine/variable.js");
/**
 * @fileoverview
 * 存储和更改VM块表示形式，并处理 Blocks事件中的更新
 */

/**
 * 创建一个块容器.
 * @param {Runtime} runtime 此块容器在其中运行的运行时
 * @param {boolean} optNoGlow 指示该容器中的块不应请求发光的可选标志。 单击一个块以执行它时，这不会影响发光.
 */


class Blocks {
  constructor(runtime, optNoGlow) {
    this.runtime = runtime;
    /**
     * All blocks in the workspace.
     * Keys are block IDs, values are metadata about the block.
     * @type {Object.<string, Object>}
     */

    this._blocks = {};
    /**
     * All top-level scripts in the workspace.
     * A list of block IDs that represent scripts (i.e., first block in script).
     * @type {Array.<String>}
     */

    this._scripts = [];
    /**
     * Runtime Cache
     * @type {{inputs: {}, procedureParamNames: {}, procedureDefinitions: {}}}
     * @private
     */

    Object.defineProperty(this, "_cache", {
      writable: true,
      enumerable: false
    });
    this._cache = {
      /**
       * Cache block inputs by block id
       * @type {object.<string, !Array.<object>>}
       */
      inputs: {},

      /**
       * Cache procedure Param Names by block id
       * @type {object.<string, ?Array.<string>>}
       */
      procedureParamNames: {},

      /**
       * Cache procedure definitions by block id
       * @type {object.<string, ?string>}
       */
      procedureDefinitions: {},

      /**
       * A cache for execute to use and store on. Only available to
       * execute.
       * @type {object.<string, object>}
       */
      _executeCached: {},

      /**
       * A cache of block IDs and targets to start threads on as they are
       * actively monitored.
       * @type {Array<{blockId: string, target: Target}>}
       */
      _monitored: null,

      /**
       * A cache of hat opcodes to collection of theads to execute.
       * @type {object.<string, object>}
       */
      scripts: {}
    };
    /**
     * Flag which indicates that blocks in this container should not glow.
     * Blocks will still glow when clicked on, but this flag is used to control
     * whether the blocks in this container can request a glow as part of
     * a running stack. E.g. the flyout block container and the monitor block container
     * should not be able to request a glow, but blocks containers belonging to
     * sprites should.
     * @type {boolean}
     */

    this.forceNoGlow = optNoGlow || false;
  }
  /**
   * Blockly inputs that represent statements/branch.
   * are prefixed with this string.
   * @const{string}
   */


  static get BRANCH_INPUT_PREFIX() {
    return "SUBSTACK";
  }
  /**
   * Provide an object with metadata for the requested block ID.
   * @param {!string} blockId ID of block we have stored.
   * @return {?object} Metadata about the block, if it exists.
   */


  getBlock(blockId) {
    return this._blocks[blockId];
  }
  /**
   * Get all known top-level blocks that start scripts.
   * @return {Array.<string>} List of block IDs.
   */


  getScripts() {
    return this._scripts;
  }
  /**
   * Get the next block for a particular block
   * @param {?string} id ID of block to get the next block for
   * @return {?string} ID of next block in the sequence
   */


  getNextBlock(id) {
    const block = this._blocks[id];
    return typeof block === "undefined" ? null : block.next;
  }
  /**
   * Get the branch for a particular C-shaped block.
   * @param {?string} id ID for block to get the branch for.
   * @param {?number} branchNum Which branch to select (e.g. for if-else).
   * @return {?string} ID of block in the branch.
   */


  getBranch(id, branchNum) {
    const block = this._blocks[id];
    if (typeof block === "undefined") return null;
    if (!branchNum) branchNum = 1;
    let inputName = Blocks.BRANCH_INPUT_PREFIX;

    if (branchNum > 1) {
      inputName += branchNum;
    } // Empty C-block?


    const input = block.inputs[inputName];
    return typeof input === "undefined" ? null : input.block;
  }
  /**
   * Get the opcode for a particular block
   * @param {?object} block The block to query
   * @return {?string} the opcode corresponding to that block
   */


  getOpcode(block) {
    return typeof block === "undefined" ? null : block.opcode;
  }
  /**
   * Get all fields and their values for a block.
   * @param {?object} block The block to query.
   * @return {?object} All fields and their values.
   */


  getFields(block) {
    return typeof block === "undefined" ? null : block.fields;
  }
  /**
   * Get all non-branch inputs for a block.
   * @param {?object} block the block to query.
   * @return {?Array.<object>} All non-branch inputs and their associated blocks.
   */


  getInputs(block) {
    if (typeof block === "undefined") return null;
    let inputs = this._cache.inputs[block.id];

    if (typeof inputs !== "undefined") {
      return inputs;
    }

    inputs = {};

    for (const input in block.inputs) {
      // Ignore blocks prefixed with branch prefix.
      if (input.substring(0, Blocks.BRANCH_INPUT_PREFIX.length) !== Blocks.BRANCH_INPUT_PREFIX) {
        inputs[input] = block.inputs[input];
      }
    }

    this._cache.inputs[block.id] = inputs;
    return inputs;
  }
  /**
   * Get mutation data for a block.
   * @param {?object} block The block to query.
   * @return {?object} Mutation for the block.
   */


  getMutation(block) {
    return typeof block === "undefined" ? null : block.mutation;
  }
  /**
   * Get the top-level script for a given block.
   * @param {?string} id ID of block to query.
   * @return {?string} ID of top-level script block.
   */


  getTopLevelScript(id) {
    let block = this._blocks[id];
    if (typeof block === "undefined") return null;

    while (block.parent !== null) {
      block = this._blocks[block.parent];
    }

    return block.id;
  }
  /**
   * Get the procedure definition for a given name.
   * @param {?string} name Name of procedure to query.
   * @return {?string} ID of procedure definition.
   */


  getProcedureDefinition(name) {
    const blockID = this._cache.procedureDefinitions[name];

    if (typeof blockID !== "undefined") {
      return blockID;
    }

    for (const id in this._blocks) {
      if (!this._blocks.hasOwnProperty(id)) continue;
      const block = this._blocks[id];

      if (block.opcode === "procedures_definition") {
        const internal = this._getCustomBlockInternal(block);

        if (internal && internal.mutation.proccode === name) {
          this._cache.procedureDefinitions[name] = id; // The outer define block id

          return id;
        }
      }
    }

    this._cache.procedureDefinitions[name] = null;
    return null;
  }
  /**
   * Get names and ids of parameters for the given procedure.
   * @param {?string} name Name of procedure to query.
   * @return {?Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesAndIds(name) {
    return this.getProcedureParamNamesIdsAndDefaults(name).slice(0, 2);
  }
  /**
   * Get names, ids, and defaults of parameters for the given procedure.
   * @param {?string} name Name of procedure to query.
   * @return {?Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesIdsAndDefaults(name) {
    const cachedNames = this._cache.procedureParamNames[name];

    if (typeof cachedNames !== "undefined") {
      return cachedNames;
    }

    for (const id in this._blocks) {
      if (!this._blocks.hasOwnProperty(id)) continue;
      const block = this._blocks[id];

      if (block.opcode === "procedures_prototype" && block.mutation.proccode === name) {
        const names = JSON.parse(block.mutation.argumentnames);
        const ids = JSON.parse(block.mutation.argumentids);
        const defaults = JSON.parse(block.mutation.argumentdefaults);
        this._cache.procedureParamNames[name] = [names, ids, defaults];
        return this._cache.procedureParamNames[name];
      }
    }

    this._cache.procedureParamNames[name] = null;
    return null;
  }

  duplicate() {
    const newBlocks = new Blocks(this.runtime, this.forceNoGlow);
    newBlocks._blocks = Utility.cloneSimple(this._blocks);
    newBlocks._scripts = Utility.cloneSimple(this._scripts);
    return newBlocks;
  } // ---------------------------------------------------------------------

  /**
   * Create event listener for blocks, variables, and comments. Handles validation and
   * serves as a generic adapter between the blocks, variables, and the
   * runtime interface.
   * @param {object} e Blockly "block" or "variable" event
   */


  blocklyListen(e) {
    // Validate event
    if (typeof e !== "object") return;

    if (typeof e.blockId !== "string" && typeof e.varId !== "string" && typeof e.commentId !== "string") {
      return;
    }

    const stage = this.runtime.getTargetForStage();
    const editingTarget = this.runtime.getEditingTarget(); // UI event: clicked scripts toggle in the runtime.

    if (e.element === "stackclick") {
      this.runtime.toggleScript(e.blockId, {
        stackClick: true
      });
      return;
    } // Block create/update/destroy


    switch (e.type) {
      case "create":
        {
          const newBlocks = adapter(e); // A create event can create many blocks. Add them all.

          for (let i = 0; i < newBlocks.length; i++) {
            this.createBlock(newBlocks[i]);
          }

          break;
        }

      case "change":
        this.changeBlock({
          id: e.blockId,
          element: e.element,
          name: e.name,
          value: e.newValue
        });
        break;

      case "move":
        this.moveBlock({
          id: e.blockId,
          oldParent: e.oldParentId,
          oldInput: e.oldInputName,
          newParent: e.newParentId,
          newInput: e.newInputName,
          newCoordinate: e.newCoordinate
        });
        break;

      case "dragOutside":
        this.runtime.emitBlockDragUpdate(e.isOutside);
        break;

      case "endDrag":
        this.runtime.emitBlockDragUpdate(false
        /* areBlocksOverGui */
        ); // Drag blocks onto another sprite

        if (e.isOutside) {
          const newBlocks = adapter(e);
          this.runtime.emitBlockEndDrag(newBlocks, e.blockId);
        }

        break;

      case "delete":
        // Don't accept delete events for missing blocks,
        // or shadow blocks being obscured.
        if (!this._blocks.hasOwnProperty(e.blockId) || this._blocks[e.blockId].shadow) {
          return;
        } // Inform any runtime to forget about glows on this script.


        if (this._blocks[e.blockId].topLevel) {
          this.runtime.quietGlow(e.blockId);
        }

        this.deleteBlock(e.blockId);
        break;

      case "var_create":
        // Check if the variable being created is global or local
        // If local, create a local var on the current editing target, as long
        // as there are no conflicts, and the current target is actually a sprite
        // If global or if the editing target is not present or we somehow got
        // into a state where a local var was requested for the stage,
        // create a stage (global) var after checking for name conflicts
        // on all the sprites.
        if (e.isLocal && editingTarget && !editingTarget.isStage && !e.isCloud) {
          if (!editingTarget.lookupVariableById(e.varId)) {
            editingTarget.createVariable(e.varId, e.varName, e.varType);
            this.emitProjectChanged();
          }
        } else {
          if (stage.lookupVariableById(e.varId)) {
            // Do not re-create a variable if it already exists
            return;
          } // Check for name conflicts in all of the targets


          const allTargets = this.runtime.targets.filter(t => t.isOriginal);

          for (const target of allTargets) {
            if (target.lookupVariableByNameAndType(e.varName, e.varType, true)) {
              return;
            }
          }

          stage.createVariable(e.varId, e.varName, e.varType, e.isCloud);
          this.emitProjectChanged();
        }

        break;

      case "var_rename":
        if (editingTarget && editingTarget.variables.hasOwnProperty(e.varId)) {
          // This is a local variable, rename on the current target
          editingTarget.renameVariable(e.varId, e.newName); // Update all the blocks on the current target that use
          // this variable

          editingTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);
        } else {
          // This is a global variable
          stage.renameVariable(e.varId, e.newName); // Update all blocks on all targets that use the renamed variable

          const targets = this.runtime.targets;

          for (let i = 0; i < targets.length; i++) {
            const currTarget = targets[i];
            currTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);
          }
        }

        this.emitProjectChanged();
        break;

      case "var_delete":
        {
          const target = editingTarget && editingTarget.variables.hasOwnProperty(e.varId) ? editingTarget : stage;
          target.deleteVariable(e.varId);
          this.emitProjectChanged();
          break;
        }

      case "comment_create":
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();
          currTarget.createComment(e.commentId, e.blockId, e.text, e.xy.x, e.xy.y, e.width, e.height, e.minimized);

          if (currTarget.comments[e.commentId].x === null && currTarget.comments[e.commentId].y === null) {
            // Block comments imported from 2.0 projects are imported with their
            // x and y coordinates set to null so that scratch-blocks can
            // auto-position them. If we are receiving a create event for these
            // comments, then the auto positioning should have taken place.
            // Update the x and y position of these comments to match the
            // one from the event.
            currTarget.comments[e.commentId].x = e.xy.x;
            currTarget.comments[e.commentId].y = e.xy.y;
          }
        }

        this.emitProjectChanged();
        break;

      case "comment_change":
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();

          if (!currTarget.comments.hasOwnProperty(e.commentId)) {
            console.warn(`Cannot change comment with id ${e.commentId} because it does not exist.`);
            return;
          }

          const comment = currTarget.comments[e.commentId];
          const change = e.newContents_;

          if (change.hasOwnProperty("minimized")) {
            comment.minimized = change.minimized;
          }

          if (change.hasOwnProperty("width") && change.hasOwnProperty("height")) {
            comment.width = change.width;
            comment.height = change.height;
          }

          if (change.hasOwnProperty("text")) {
            comment.text = change.text;
          }

          this.emitProjectChanged();
        }

        break;

      case "comment_move":
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();

          if (currTarget && !currTarget.comments.hasOwnProperty(e.commentId)) {
            console.warn(`Cannot change comment with id ${e.commentId} because it does not exist.`);
            return;
          }

          const comment = currTarget.comments[e.commentId];
          const newCoord = e.newCoordinate_;
          comment.x = newCoord.x;
          comment.y = newCoord.y;
          this.emitProjectChanged();
        }

        break;

      case "comment_delete":
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();

          if (!currTarget.comments.hasOwnProperty(e.commentId)) {
            // If we're in this state, we have probably received
            // a delete event from a workspace that we switched from
            // (e.g. a delete event for a comment on sprite a's workspace
            // when switching from sprite a to sprite b)
            return;
          }

          delete currTarget.comments[e.commentId];

          if (e.blockId) {
            const block = currTarget.blocks.getBlock(e.blockId);

            if (!block) {
              console.warn(`Could not find block referenced by comment with id: ${e.commentId}`);
              return;
            }

            delete block.comment;
          }

          this.emitProjectChanged();
        }

        break;
    }
  } // ---------------------------------------------------------------------

  /**
   * Reset all runtime caches.
   */


  resetCache() {
    this._cache.inputs = {};
    this._cache.procedureParamNames = {};
    this._cache.procedureDefinitions = {};
    this._cache._executeCached = {};
    this._cache._monitored = null;
    this._cache.scripts = {};
  }
  /**
   * Emit a project changed event if this is a block container
   * that can affect the project state.
   */


  emitProjectChanged() {
    if (!this.forceNoGlow) {
      this.runtime.emitProjectChanged();
    }
  }
  /**
   * Block management: create blocks and scripts from a `create` event
   * @param {!object} block Blockly create event to be processed
   */


  createBlock(block) {
    // Does the block already exist?
    // Could happen, e.g., for an unobscured shadow.
    if (this._blocks.hasOwnProperty(block.id)) {
      return;
    } // Create new block.


    this._blocks[block.id] = block; // Push block id to scripts array.
    // Blocks are added as a top-level stack if they are marked as a top-block
    // (if they were top-level XML in the event).

    if (block.topLevel) {
      this._addScript(block.id);
    }

    this.resetCache(); // A new block was actually added to the block container,
    // emit a project changed event

    this.emitProjectChanged();
  }
  /**
   * Block management: change block field values
   * @param {!object} args Blockly change event to be processed
   */


  changeBlock(args) {
    // Validate
    if (["field", "mutation", "checkbox"].indexOf(args.element) === -1) return;
    let block = this._blocks[args.id];
    if (typeof block === "undefined") return;

    switch (args.element) {
      case "field":
        // TODO when the field of a monitored block changes,
        // update the checkbox in the flyout based on whether
        // a monitor for that current combination of selected parameters exists
        // e.g.
        // 1. check (current [v year])
        // 2. switch dropdown in flyout block to (current [v minute])
        // 3. the checkbox should become unchecked if we're not already
        //    monitoring current minute
        // Update block value
        if (!block.fields[args.name]) return;

        if (args.name === "VARIABLE" || args.name === "LIST" || args.name === "BROADCAST_OPTION") {
          // Get variable name using the id in args.value.
          const variable = this.runtime.getEditingTarget().lookupVariableById(args.value);

          if (variable) {
            block.fields[args.name].value = variable.name;
            block.fields[args.name].id = args.value;
          }
        } else {
          // Changing the value in a dropdown
          block.fields[args.name].value = args.value; // The selected item in the sensing of block menu needs to change based on the
          // selected target.  Set it to the first item in the menu list.
          // TODO: (#1787)

          if (block.opcode === "sensing_of_object_menu") {
            if (block.fields.OBJECT.value === "_stage_") {
              this._blocks[block.parent].fields.PROPERTY.value = "backdrop #";
            } else {
              this._blocks[block.parent].fields.PROPERTY.value = "x position";
            }

            this.runtime.requestBlocksUpdate();
          }

          const flyoutBlock = block.shadow && block.parent ? this._blocks[block.parent] : block;

          if (flyoutBlock.isMonitored) {
            this.runtime.requestUpdateMonitor(Map({
              id: flyoutBlock.id,
              params: this._getBlockParams(flyoutBlock)
            }));
          }
        }

        break;

      case "mutation":
        block.mutation = mutationAdapter(args.value);
        break;

      case "checkbox":
        {
          // A checkbox usually has a one to one correspondence with the monitor
          // block but in the case of monitored reporters that have arguments,
          // map the old id to a new id, creating a new monitor block if necessary
          if (block.fields && Object.keys(block.fields).length > 0 && block.opcode !== "data_variable" && block.opcode !== "data_listcontents") {
            // This block has an argument which needs to get separated out into
            // multiple monitor blocks with ids based on the selected argument
            const newId = Utility.getMonitorIdForBlockWithArgs(block.id, block.fields); // Note: we're not just constantly creating a longer and longer id everytime we check
            // the checkbox because we're using the id of the block in the flyout as the base
            // check if a block with the new id already exists, otherwise create

            let newBlock = this.runtime.monitorBlocks.getBlock(newId);

            if (!newBlock) {
              newBlock = JSON.parse(JSON.stringify(block));
              newBlock.id = newId;
              this.runtime.monitorBlocks.createBlock(newBlock);
            }

            block = newBlock; // Carry on through the rest of this code with newBlock
          }

          const wasMonitored = block.isMonitored;
          block.isMonitored = args.value; // Variable blocks may be sprite specific depending on the owner of the variable

          let isSpriteLocalVariable = false;

          if (block.opcode === "data_variable") {
            isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.VARIABLE.id];
          } else if (block.opcode === "data_listcontents") {
            isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.LIST.id];
          }

          const isSpriteSpecific = isSpriteLocalVariable || this.runtime.monitorBlockInfo.hasOwnProperty(block.opcode) && this.runtime.monitorBlockInfo[block.opcode].isSpriteSpecific;

          if (isSpriteSpecific) {
            // If creating a new sprite specific monitor, the only possible target is
            // the current editing one b/c you cannot dynamically create monitors.
            // Also, do not change the targetId if it has already been assigned
            block.targetId = block.targetId || this.runtime.getEditingTarget().id;
          } else {
            block.targetId = null;
          }

          if (wasMonitored && !block.isMonitored) {
            this.runtime.requestHideMonitor(block.id);
          } else if (!wasMonitored && block.isMonitored) {
            // Tries to show the monitor for specified block. If it doesn't exist, add the monitor.
            if (!this.runtime.requestShowMonitor(block.id)) {
              this.runtime.requestAddMonitor(MonitorRecord({
                id: block.id,
                targetId: block.targetId,
                spriteName: block.targetId ? this.runtime.getTargetById(block.targetId).getName() : null,
                opcode: block.opcode,
                params: this._getBlockParams(block),
                // @todo(vm#565) for numerical values with decimals, some countries use comma
                value: "",
                mode: block.opcode === "data_listcontents" ? "list" : "default"
              }));
            }
          }

          break;
        }
    }

    this.emitProjectChanged();
    this.resetCache();
  }
  /**
   * Block management: move blocks from parent to parent
   * @param {!object} e Blockly move event to be processed
   */


  moveBlock(e) {
    if (!this._blocks.hasOwnProperty(e.id)) {
      return;
    }

    const block = this._blocks[e.id]; // Track whether a change actually occurred
    // ignoring changes like routine re-positioning
    // of a block when loading a workspace

    let didChange = false; // Move coordinate changes.

    if (e.newCoordinate) {
      didChange = block.x !== e.newCoordinate.x || block.y !== e.newCoordinate.y;
      block.x = e.newCoordinate.x;
      block.y = e.newCoordinate.y;
    } // Remove from any old parent.


    if (typeof e.oldParent !== "undefined") {
      const oldParent = this._blocks[e.oldParent];

      if (typeof e.oldInput !== "undefined" && oldParent.inputs[e.oldInput].block === e.id) {
        // This block was connected to the old parent's input.
        oldParent.inputs[e.oldInput].block = null;
      } else if (oldParent.next === e.id) {
        // This block was connected to the old parent's next connection.
        oldParent.next = null;
      }

      this._blocks[e.id].parent = null;
      didChange = true;
    } // Is this block a top-level block?


    if (typeof e.newParent === "undefined") {
      this._addScript(e.id);
    } else {
      // Remove script, if one exists.
      this._deleteScript(e.id); // Otherwise, try to connect it in its new place.


      if (typeof e.newInput === "undefined") {
        // Moved to the new parent's next connection.
        this._blocks[e.newParent].next = e.id;
      } else {
        // Moved to the new parent's input.
        // Don't obscure the shadow block.
        let oldShadow = null;

        if (this._blocks[e.newParent].inputs.hasOwnProperty(e.newInput)) {
          oldShadow = this._blocks[e.newParent].inputs[e.newInput].shadow;
        } // If the block being attached is itself a shadow, make sure to set
        // both block and shadow to that blocks ID. This happens when adding
        // inputs to a custom procedure.


        if (this._blocks[e.id].shadow) oldShadow = e.id;
        this._blocks[e.newParent].inputs[e.newInput] = {
          name: e.newInput,
          block: e.id,
          shadow: oldShadow
        };
      }

      this._blocks[e.id].parent = e.newParent;
      didChange = true;
    }

    this.resetCache();
    if (didChange) this.emitProjectChanged();
  }
  /**
   * Block management: run all blocks.
   * @param {!object} runtime Runtime to run all blocks in.
   */


  runAllMonitored(runtime) {
    if (this._cache._monitored === null) {
      this._cache._monitored = Object.keys(this._blocks).filter(blockId => this.getBlock(blockId).isMonitored).map(blockId => {
        const targetId = this.getBlock(blockId).targetId;
        return {
          blockId,
          target: targetId ? runtime.getTargetById(targetId) : null
        };
      });
    }

    const monitored = this._cache._monitored;

    for (let i = 0; i < monitored.length; i++) {
      const {
        blockId,
        target
      } = monitored[i];
      runtime.addMonitorScript(blockId, target);
    }
  }
  /**
   * Block management: delete blocks and their associated scripts. Does nothing if a block
   * with the given ID does not exist.
   * @param {!string} blockId Id of block to delete
   */


  deleteBlock(blockId) {
    // @todo In runtime, stop threads running on this script.
    // Get block
    const block = this._blocks[blockId];

    if (!block) {
      // No block with the given ID exists
      return;
    } // Delete children


    if (block.next !== null) {
      this.deleteBlock(block.next);
    } // Delete inputs (including branches)


    for (const input in block.inputs) {
      // If it's null, the block in this input moved away.
      if (block.inputs[input].block !== null) {
        this.deleteBlock(block.inputs[input].block);
      } // Delete obscured shadow blocks.


      if (block.inputs[input].shadow !== null && block.inputs[input].shadow !== block.inputs[input].block) {
        this.deleteBlock(block.inputs[input].shadow);
      }
    } // Delete any script starting with this block.


    this._deleteScript(blockId); // Delete block itself.


    delete this._blocks[blockId];
    this.resetCache();
    this.emitProjectChanged();
  }
  /**
   * Returns a map of all references to variables or lists from blocks
   * in this block container.
   * @param {Array<object>} optBlocks Optional list of blocks to constrain the search to.
   * This is useful for getting variable/list references for a stack of blocks instead
   * of all blocks on the workspace
   * @param {?boolean} optIncludeBroadcast Optional whether to include broadcast fields.
   * @return {object} A map of variable ID to a list of all variable references
   * for that ID. A variable reference contains the field referencing that variable
   * and also the type of the variable being referenced.
   */


  getAllVariableAndListReferences(optBlocks, optIncludeBroadcast) {
    const blocks = optBlocks ? optBlocks : this._blocks;
    const allReferences = Object.create(null);

    for (const blockId in blocks) {
      let varOrListField = null;
      let varType = null;

      if (blocks[blockId].fields.VARIABLE) {
        varOrListField = blocks[blockId].fields.VARIABLE;
        varType = Variable.SCALAR_TYPE;
      } else if (blocks[blockId].fields.LIST) {
        varOrListField = blocks[blockId].fields.LIST;
        varType = Variable.LIST_TYPE;
      } else if (optIncludeBroadcast && blocks[blockId].fields.BROADCAST_OPTION) {
        varOrListField = blocks[blockId].fields.BROADCAST_OPTION;
        varType = Variable.BROADCAST_MESSAGE_TYPE;
      }

      if (varOrListField) {
        const currVarId = varOrListField.id;

        if (allReferences[currVarId]) {
          allReferences[currVarId].push({
            referencingField: varOrListField,
            type: varType
          });
        } else {
          allReferences[currVarId] = [{
            referencingField: varOrListField,
            type: varType
          }];
        }
      }
    }

    return allReferences;
  }
  /**
   * Keep blocks up to date after a variable gets renamed.
   * @param {string} varId The id of the variable that was renamed
   * @param {string} newName The new name of the variable that was renamed
   */


  updateBlocksAfterVarRename(varId, newName) {
    const blocks = this._blocks;

    for (const blockId in blocks) {
      let varOrListField = null;

      if (blocks[blockId].fields.VARIABLE) {
        varOrListField = blocks[blockId].fields.VARIABLE;
      } else if (blocks[blockId].fields.LIST) {
        varOrListField = blocks[blockId].fields.LIST;
      }

      if (varOrListField) {
        const currFieldId = varOrListField.id;

        if (varId === currFieldId) {
          varOrListField.value = newName;
        }
      }
    }
  }
  /**
   * Keep blocks up to date after they are shared between targets.
   * @param {boolean} isStage If the new target is a stage.
   */


  updateTargetSpecificBlocks(isStage) {
    const blocks = this._blocks;

    for (const blockId in blocks) {
      if (isStage && blocks[blockId].opcode === "event_whenthisspriteclicked") {
        blocks[blockId].opcode = "event_whenstageclicked";
      } else if (!isStage && blocks[blockId].opcode === "event_whenstageclicked") {
        blocks[blockId].opcode = "event_whenthisspriteclicked";
      }
    }
  }
  /**
   * Update blocks after a sound, costume, or backdrop gets renamed.
   * Any block referring to the old name of the asset should get updated
   * to refer to the new name.
   * @param {string} oldName The old name of the asset that was renamed.
   * @param {string} newName The new name of the asset that was renamed.
   * @param {string} assetType String representation of the kind of asset
   * that was renamed. This can be one of 'sprite','costume', 'sound', or
   * 'backdrop'.
   */


  updateAssetName(oldName, newName, assetType) {
    let getAssetField;

    if (assetType === "costume") {
      getAssetField = this._getCostumeField.bind(this);
    } else if (assetType === "sound") {
      getAssetField = this._getSoundField.bind(this);
    } else if (assetType === "backdrop") {
      getAssetField = this._getBackdropField.bind(this);
    } else if (assetType === "sprite") {
      getAssetField = this._getSpriteField.bind(this);
    } else {
      return;
    }

    const blocks = this._blocks;

    for (const blockId in blocks) {
      const assetField = getAssetField(blockId);

      if (assetField && assetField.value === oldName) {
        assetField.value = newName;
      }
    }
  }
  /**
   * Update sensing_of blocks after a variable gets renamed.
   * @param {string} oldName The old name of the variable that was renamed.
   * @param {string} newName The new name of the variable that was renamed.
   * @param {string} targetName The name of the target the variable belongs to.
   * @return {boolean} Returns true if any of the blocks were updated.
   */


  updateSensingOfReference(oldName, newName, targetName) {
    const blocks = this._blocks;
    let blockUpdated = false;

    for (const blockId in blocks) {
      const block = blocks[blockId];

      if (block.opcode === "sensing_of" && block.fields.PROPERTY.value === oldName && // If block and shadow are different, it means a block is inserted to OBJECT, and should be ignored.
      block.inputs.OBJECT.block === block.inputs.OBJECT.shadow) {
        const inputBlock = this.getBlock(block.inputs.OBJECT.block);

        if (inputBlock.fields.OBJECT.value === targetName) {
          block.fields.PROPERTY.value = newName;
          blockUpdated = true;
        }
      }
    }

    if (blockUpdated) this.resetCache();
    return blockUpdated;
  }
  /**
   * Helper function to retrieve a costume menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The costume menu field of the block with the given block id.
   * Null if either a block with the given id doesn't exist or if a costume menu field
   * does not exist on the block with the given id.
   */


  _getCostumeField(blockId) {
    const block = this.getBlock(blockId);

    if (block && block.fields.hasOwnProperty("COSTUME")) {
      return block.fields.COSTUME;
    }

    return null;
  }
  /**
   * Helper function to retrieve a sound menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The sound menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a sound menu field
   * does not exist on the block with the given id.
   */


  _getSoundField(blockId) {
    const block = this.getBlock(blockId);

    if (block && block.fields.hasOwnProperty("SOUND_MENU")) {
      return block.fields.SOUND_MENU;
    }

    return null;
  }
  /**
   * Helper function to retrieve a backdrop menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The backdrop menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a backdrop menu field
   * does not exist on the block with the given id.
   */


  _getBackdropField(blockId) {
    const block = this.getBlock(blockId);

    if (block && block.fields.hasOwnProperty("BACKDROP")) {
      return block.fields.BACKDROP;
    }

    return null;
  }
  /**
   * Helper function to retrieve a sprite menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The sprite menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a sprite menu field
   * does not exist on the block with the given id.
   */


  _getSpriteField(blockId) {
    const block = this.getBlock(blockId);

    if (!block) {
      return null;
    }

    const spriteMenuNames = ["TOWARDS", "TO", "OBJECT", "VIDEOONMENU2", "DISTANCETOMENU", "TOUCHINGOBJECTMENU", "CLONE_OPTION"];

    for (let i = 0; i < spriteMenuNames.length; i++) {
      const menuName = spriteMenuNames[i];

      if (block.fields.hasOwnProperty(menuName)) {
        return block.fields[menuName];
      }
    }

    return null;
  } // ---------------------------------------------------------------------

  /**
   * Encode all of `this._blocks` as an XML string usable
   * by a Blockly/scratch-blocks workspace.
   * @param {object<string, Comment>} comments Map of comments referenced by id
   * @return {string} String of XML representing this object's blocks.
   */


  toXML(comments) {
    return this._scripts.map(script => this.blockToXML(script, comments)).join();
  }
  /**
   * Recursively encode an individual block and its children
   * into a Blockly/scratch-blocks XML string.
   * @param {!string} blockId ID of block to encode.
   * @param {object<string, Comment>} comments Map of comments referenced by id
   * @return {string} String of XML representing this block and any children.
   */


  blockToXML(blockId, comments) {
    const block = this._blocks[blockId]; // block should exist, but currently some blocks' next property point
    // to a blockId for non-existent blocks. Until we track down that behavior,
    // this early exit allows the project to load.

    if (!block) return; // Encode properties of this block.

    const tagName = block.shadow ? "shadow" : "block";
    let xmlString = `<${tagName}
                id="${block.id}"
                type="${block.opcode}"
                ${block.topLevel ? `x="${block.x}" y="${block.y}"` : ""}
            >`;
    const commentId = block.comment;

    if (commentId) {
      if (comments) {
        if (comments.hasOwnProperty(commentId)) {
          xmlString += comments[commentId].toXML();
        } else {
          console.warn(`Could not find comment with id: ${commentId} in provided comment descriptions.`);
        }
      } else {
        console.warn(`Cannot serialize comment with id: ${commentId}; no comment descriptions provided.`);
      }
    } // Add any mutation. Must come before inputs.


    if (block.mutation) {
      xmlString += this.mutationToXML(block.mutation);
    } // Add any inputs on this block.


    for (const input in block.inputs) {
      if (!block.inputs.hasOwnProperty(input)) continue;
      const blockInput = block.inputs[input]; // Only encode a value tag if the value input is occupied.

      if (blockInput.block || blockInput.shadow) {
        xmlString += `<value name="${blockInput.name}">`;

        if (blockInput.block) {
          xmlString += this.blockToXML(blockInput.block, comments);
        }

        if (blockInput.shadow && blockInput.shadow !== blockInput.block) {
          // Obscured shadow.
          xmlString += this.blockToXML(blockInput.shadow, comments);
        }

        xmlString += "</value>";
      }
    } // Add any fields on this block.


    for (const field in block.fields) {
      if (!block.fields.hasOwnProperty(field)) continue;
      const blockField = block.fields[field];
      xmlString += `<field name="${blockField.name}"`;
      const fieldId = blockField.id;

      if (fieldId) {
        xmlString += ` id="${fieldId}"`;
      }

      const varType = blockField.variableType;

      if (typeof varType === "string") {
        xmlString += ` variabletype="${varType}"`;
      }

      let value = blockField.value;

      if (typeof value === "string") {
        value = Utility.xmlEscape(blockField.value);
      }

      xmlString += `>${value}</field>`;
    } // Add blocks connected to the next connection.


    if (block.next) {
      xmlString += `<next>${this.blockToXML(block.next, comments)}</next>`;
    }

    xmlString += `</${tagName}>`;
    return xmlString;
  }
  /**
   * Recursively encode a mutation object to XML.
   * @param {!object} mutation Object representing a mutation.
   * @return {string} XML string representing a mutation.
   */


  mutationToXML(mutation) {
    let mutationString = `<${mutation.tagName}`;

    for (const prop in mutation) {
      if (prop === "children" || prop === "tagName") continue;
      let mutationValue = typeof mutation[prop] === "string" ? Utility.xmlEscape(mutation[prop]) : mutation[prop]; // Handle dynamic extension blocks

      if (prop === "blockInfo") {
        mutationValue = Utility.xmlEscape(JSON.stringify(mutation[prop]));
      }

      mutationString += ` ${prop}="${mutationValue}"`;
    }

    mutationString += ">";

    for (let i = 0; i < mutation.children.length; i++) {
      mutationString += this.mutationToXML(mutation.children[i]);
    }

    mutationString += `</${mutation.tagName}>`;
    return mutationString;
  } // ---------------------------------------------------------------------

  /**
   * Helper to serialize block fields and input fields for reporting new monitors
   * @param {!object} block Block to be paramified.
   * @return {!object} object of param key/values.
   */


  _getBlockParams(block) {
    const params = {};

    for (const key in block.fields) {
      params[key] = block.fields[key].value;
    }

    for (const inputKey in block.inputs) {
      const inputBlock = this._blocks[block.inputs[inputKey].block];

      for (const key in inputBlock.fields) {
        params[key] = inputBlock.fields[key].value;
      }
    }

    return params;
  }
  /**
   * Helper to get the corresponding internal procedure definition block
   * @param {!object} defineBlock Outer define block.
   * @return {!object} internal definition block which has the mutation.
   */


  _getCustomBlockInternal(defineBlock) {
    if (defineBlock.inputs && defineBlock.inputs.custom_block) {
      return this._blocks[defineBlock.inputs.custom_block.block];
    }
  }
  /**
   * Helper to add a stack to `this._scripts`.
   * @param {?string} topBlockId ID of block that starts the script.
   */


  _addScript(topBlockId) {
    const i = this._scripts.indexOf(topBlockId);

    if (i > -1) return; // Already in scripts.

    this._scripts.push(topBlockId); // Update `topLevel` property on the top block.


    this._blocks[topBlockId].topLevel = true;
  }
  /**
   * Helper to remove a script from `this._scripts`.
   * @param {?string} topBlockId ID of block that starts the script.
   */


  _deleteScript(topBlockId) {
    const i = this._scripts.indexOf(topBlockId);

    if (i > -1) this._scripts.splice(i, 1); // Update `topLevel` property on the top block.

    if (this._blocks[topBlockId]) this._blocks[topBlockId].topLevel = false;
  }

}
/**
 * A private method shared with execute to build an object containing the block
 * information execute needs and that is reset when other cached Blocks info is
 * reset.
 * @param {Blocks} blocks Blocks containing the expected blockId
 * @param {string} blockId blockId for the desired execute cache
 * @param {function} CacheType constructor for cached block information
 * @return {object} execute cache object
 */


BlocksExecuteCache.getCached = function (blocks, blockId, CacheType) {
  let cached = blocks._cache._executeCached[blockId];

  if (typeof cached !== "undefined") {
    return cached;
  }

  const block = blocks.getBlock(blockId);
  if (typeof block === "undefined") return null;

  if (typeof CacheType === "undefined") {
    cached = {
      id: blockId,
      opcode: blocks.getOpcode(block),
      fields: blocks.getFields(block),
      inputs: blocks.getInputs(block),
      mutation: blocks.getMutation(block)
    };
  } else {
    cached = new CacheType(blocks, {
      id: blockId,
      opcode: blocks.getOpcode(block),
      fields: blocks.getFields(block),
      inputs: blocks.getInputs(block),
      mutation: blocks.getMutation(block)
    });
  }

  blocks._cache._executeCached[blockId] = cached;
  return cached;
};
/**
 * Cache class constructor for runtime. Used to consider what threads should
 * start based on hat data.
 * @type {function}
 */


const RuntimeScriptCache = BlocksRuntimeCache._RuntimeScriptCache;
/**
 * Get an array of scripts from a block container prefiltered to match opcode.
 * @param {Blocks} blocks - Container of blocks
 * @param {string} opcode - Opcode to filter top blocks by
 * @returns {Array.<RuntimeScriptCache>} - Array of RuntimeScriptCache cache
 *   objects
 */

BlocksRuntimeCache.getScripts = function (blocks, opcode) {
  let scripts = blocks._cache.scripts[opcode];

  if (!scripts) {
    scripts = blocks._cache.scripts[opcode] = [];
    const allScripts = blocks._scripts;

    for (let i = 0; i < allScripts.length; i++) {
      const topBlockId = allScripts[i];
      const block = blocks.getBlock(topBlockId);

      if (block.opcode === opcode) {
        scripts.push(new RuntimeScriptCache(blocks, topBlockId));
      }
    }
  }

  return scripts;
};

module.exports = Blocks;

/***/ }),

/***/ "./src/engine/comment.js":
/*!*******************************!*\
  !*** ./src/engine/comment.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview
 * Object representing a Scratch Comment (block or workspace).
 */
class Comment {
  /**
   * @param {string} id Id of the comment.
   * @param {string} text Text content of the comment.
   * @param {number} x X position of the comment on the workspace.
   * @param {number} y Y position of the comment on the workspace.
   * @param {number} width The width of the comment when it is full size.
   * @param {number} height The height of the comment when it is full size.
   * @param {boolean} minimized Whether the comment is minimized.
   * @constructor
   */
  constructor(id, text, x, y, width, height, minimized) {
    console.warn("comment:", Utility.uid());
    this.id = id || Utility.uid();
    this.text = text;
    this.x = x;
    this.y = y;
    this.width = Math.max(Number(width), Comment.MIN_WIDTH);
    this.height = Math.max(Number(height), Comment.MIN_HEIGHT);
    this.minimized = minimized || false;
    this.blockId = null;
  }

  toXML() {
    return `<comment id="${this.id}" x="${this.x}" y="${this.y}" w="${this.width}" h="${this.height}" pinned="${this.blockId !== null}" minimized="${this.minimized}">${Utility.xmlEscape(this.text)}</comment>`;
  } // TODO choose min and defaults for width and height


  static get MIN_WIDTH() {
    return 20;
  }

  static get MIN_HEIGHT() {
    return 20;
  }

  static get DEFAULT_WIDTH() {
    return 100;
  }

  static get DEFAULT_HEIGHT() {
    return 100;
  }

}

module.exports = Comment;

/***/ }),

/***/ "./src/engine/execute.js":
/*!*******************************!*\
  !*** ./src/engine/execute.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const BlockUtility = __webpack_require__(/*! ./block-utility */ "./src/engine/block-utility.js");

const BlocksExecuteCache = __webpack_require__(/*! ./blocks-execute-cache */ "./src/engine/blocks-execute-cache.js");

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const {
  Map
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
/**
 * Single BlockUtility instance reused by execute for every pritimive ran.
 * @const
 */


const blockUtility = new BlockUtility();
/**
 * Profiler frame name for block functions.
 * @const {string}
 */

const blockFunctionProfilerFrame = "blockFunction";
/**
 * Profiler frame ID for 'blockFunction'.
 * @type {number}
 */

let blockFunctionProfilerId = -1;
/**
 * Utility function to determine if a value is a Promise.
 * @param {*} value Value to check for a Promise.
 * @return {boolean} True if the value appears to be a Promise.
 */

const isPromise = function (value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
};
/**
 * Handle any reported value from the primitive, either directly returned
 * or after a promise resolves.
 * @param {*} resolvedValue Value eventually returned from the primitive.
 * @param {!Sequencer} sequencer Sequencer stepping the thread for the ran
 * primitive.
 * @param {!Thread} thread Thread containing the primitive.
 * @param {!string} currentBlockId Id of the block in its thread for value from
 * the primitive.
 * @param {!string} opcode opcode used to identify a block function primitive.
 * @param {!boolean} isHat Is the current block a hat?
 */
// @todo move this to callback attached to the thread when we have performance
// metrics (dd)


const handleReport = function (resolvedValue, sequencer, thread, blockCached, lastOperation) {
  const currentBlockId = blockCached.id;
  const opcode = blockCached.opcode;
  const isHat = blockCached._isHat;
  thread.pushReportedValue(resolvedValue);

  if (isHat) {
    // Hat predicate was evaluated.
    if (sequencer.runtime.getIsEdgeActivatedHat(opcode)) {
      // If this is an edge-activated hat, only proceed if the value is
      // true and used to be false, or the stack was activated explicitly
      // via stack click
      if (!thread.stackClick) {
        const hasOldEdgeValue = thread.target.hasEdgeActivatedValue(currentBlockId);
        const oldEdgeValue = thread.target.updateEdgeActivatedValue(currentBlockId, resolvedValue);
        const edgeWasActivated = hasOldEdgeValue ? !oldEdgeValue && resolvedValue : resolvedValue;

        if (!edgeWasActivated) {
          sequencer.retireThread(thread);
        }
      }
    } else if (!resolvedValue) {
      // Not an edge-activated hat: retire the thread
      // if predicate was false.
      sequencer.retireThread(thread);
    }
  } else {
    // In a non-hat, report the value visually if necessary if
    // at the top of the thread stack.
    if (lastOperation && typeof resolvedValue !== "undefined" && thread.atStackTop()) {
      if (thread.stackClick) {
        sequencer.runtime.visualReport(currentBlockId, resolvedValue);
      }

      if (thread.updateMonitor) {
        const targetId = sequencer.runtime.monitorBlocks.getBlock(currentBlockId).targetId;

        if (targetId && !sequencer.runtime.getTargetById(targetId)) {
          // Target no longer exists
          return;
        }

        sequencer.runtime.requestUpdateMonitor(Map({
          id: currentBlockId,
          spriteName: targetId ? sequencer.runtime.getTargetById(targetId).getName() : null,
          value: resolvedValue
        }));
      }
    } // Finished any yields.


    thread.status = Thread.STATUS_RUNNING;
  }
};

const handlePromise = (primitiveReportedValue, sequencer, thread, blockCached, lastOperation) => {
  if (thread.status === Thread.STATUS_RUNNING) {
    // Primitive returned a promise; automatically yield thread.
    thread.status = Thread.STATUS_PROMISE_WAIT;
  } // Promise handlers


  primitiveReportedValue.then(resolvedValue => {
    handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation); // If it's a command block or a top level reporter in a stackClick.

    if (lastOperation) {
      let stackFrame;
      let nextBlockId;

      do {
        // In the case that the promise is the last block in the current thread stack
        // We need to pop out repeatedly until we find the next block.
        const popped = thread.popStack();

        if (popped === null) {
          return;
        }

        nextBlockId = thread.target.blocks.getNextBlock(popped);

        if (nextBlockId !== null) {
          // A next block exists so break out this loop
          break;
        } // Investigate the next block and if not in a loop,
        // then repeat and pop the next item off the stack frame


        stackFrame = thread.peekStackFrame();
      } while (stackFrame !== null && !stackFrame.isLoop);

      thread.pushStack(nextBlockId);
    }
  }, rejectionReason => {
    // Promise rejected: the primitive had some error.
    // Log it and proceed.
    console.warn("Primitive rejected promise: ", rejectionReason);
    thread.status = Thread.STATUS_RUNNING;
    thread.popStack();
  });
};
/**
 * A execute.js internal representation of a block to reduce the time spent in
 * execute as the same blocks are called the most.
 *
 * With the help of the Blocks class create a mutable copy of block
 * information. The members of BlockCached derived values of block information
 * that does not need to be reevaluated until a change in Blocks. Since Blocks
 * handles where the cache instance is stored, it drops all cache versions of a
 * block when any change happens to it. This way we can quickly execute blocks
 * and keep perform the right action according to the current block information
 * in the editor.
 *
 * @param {Blocks} blockContainer the related Blocks instance
 * @param {object} cached default set of cached values
 */


class BlockCached {
  constructor(blockContainer, cached) {
    /**
     * Block id in its parent set of blocks.
     * @type {string}
     */
    this.id = cached.id;
    /**
     * Block operation code for this block.
     * @type {string}
     */

    this.opcode = cached.opcode;
    /**
     * Original block object containing argument values for static fields.
     * @type {object}
     */

    this.fields = cached.fields;
    /**
     * Original block object containing argument values for executable inputs.
     * @type {object}
     */

    this.inputs = cached.inputs;
    /**
     * Procedure mutation.
     * @type {?object}
     */

    this.mutation = cached.mutation;
    /**
     * The profiler the block is configured with.
     * @type {?Profiler}
     */

    this._profiler = null;
    /**
     * Profiler information frame.
     * @type {?ProfilerFrame}
     */

    this._profilerFrame = null;
    /**
     * Is the opcode a hat (event responder) block.
     * @type {boolean}
     */

    this._isHat = false;
    /**
     * The block opcode's implementation function.
     * @type {?function}
     */

    this._blockFunction = null;
    /**
     * Is the block function defined for this opcode?
     * @type {boolean}
     */

    this._definedBlockFunction = false;
    /**
     * Is this block a block with no function but a static value to return.
     * @type {boolean}
     */

    this._isShadowBlock = false;
    /**
     * The static value of this block if it is a shadow block.
     * @type {?any}
     */

    this._shadowValue = null;
    /**
     * A copy of the block's fields that may be modified.
     * @type {object}
     */

    this._fields = Object.assign({}, this.fields);
    /**
     * A copy of the block's inputs that may be modified.
     * @type {object}
     */

    this._inputs = Object.assign({}, this.inputs);
    /**
     * An arguments object for block implementations. All executions of this
     * specific block will use this objecct.
     * @type {object}
     */

    this._argValues = {
      mutation: this.mutation
    };
    /**
     * The inputs key the parent refers to this BlockCached by.
     * @type {string}
     */

    this._parentKey = null;
    /**
     * The target object where the parent wants the resulting value stored
     * with _parentKey as the key.
     * @type {object}
     */

    this._parentValues = null;
    /**
     * A sequence of non-shadow operations that can must be performed. This
     * list recreates the order this block and its children are executed.
     * Since the order is always the same we can safely store that order
     * and iterate over the operations instead of dynamically walking the
     * tree every time.
     * @type {Array<BlockCached>}
     */

    this._ops = [];
    const {
      runtime
    } = blockUtility.sequencer;
    const {
      opcode,
      fields,
      inputs
    } = this; // Assign opcode isHat and blockFunction data to avoid dynamic lookups.

    this._isHat = runtime.getIsHat(opcode);
    this._blockFunction = runtime.getOpcodeFunction(opcode);
    this._definedBlockFunction = typeof this._blockFunction !== "undefined"; // Store the current shadow value if there is a shadow value.

    const fieldKeys = Object.keys(fields);
    this._isShadowBlock = !this._definedBlockFunction && fieldKeys.length === 1 && Object.keys(inputs).length === 0;
    this._shadowValue = this._isShadowBlock && fields[fieldKeys[0]].value; // Store the static fields onto _argValues.

    for (const fieldName in fields) {
      if (fieldName === "VARIABLE" || fieldName === "LIST" || fieldName === "BROADCAST_OPTION") {
        this._argValues[fieldName] = {
          id: fields[fieldName].id,
          name: fields[fieldName].value
        };
      } else {
        this._argValues[fieldName] = fields[fieldName].value;
      }
    } // Remove custom_block. It is not part of block execution.


    delete this._inputs.custom_block;

    if ("BROADCAST_INPUT" in this._inputs) {
      // BROADCAST_INPUT is called BROADCAST_OPTION in the args and is an
      // object with an unchanging shape.
      this._argValues.BROADCAST_OPTION = {
        id: null,
        name: null
      }; // We can go ahead and compute BROADCAST_INPUT if it is a shadow
      // value.

      const broadcastInput = this._inputs.BROADCAST_INPUT;

      if (broadcastInput.block === broadcastInput.shadow) {
        // Shadow dropdown menu is being used.
        // Get the appropriate information out of it.
        const shadow = blockContainer.getBlock(broadcastInput.shadow);
        const broadcastField = shadow.fields.BROADCAST_OPTION;
        this._argValues.BROADCAST_OPTION.id = broadcastField.id;
        this._argValues.BROADCAST_OPTION.name = broadcastField.value; // Evaluating BROADCAST_INPUT here we do not need to do so
        // later.

        delete this._inputs.BROADCAST_INPUT;
      }
    } // Cache all input children blocks in the operation lists. The
    // operations can later be run in the order they appear in correctly
    // executing the operations quickly in a flat loop instead of needing to
    // recursivly iterate them.


    for (const inputName in this._inputs) {
      const input = this._inputs[inputName];

      if (input.block) {
        const inputCached = BlocksExecuteCache.getCached(blockContainer, input.block, BlockCached);

        if (inputCached._isHat) {
          continue;
        }

        this._ops.push(...inputCached._ops);

        inputCached._parentKey = inputName;
        inputCached._parentValues = this._argValues; // Shadow values are static and do not change, go ahead and
        // store their value on args.

        if (inputCached._isShadowBlock) {
          this._argValues[inputName] = inputCached._shadowValue;
        }
      }
    } // The final operation is this block itself. At the top most block is a
    // command block or a block that is being run as a monitor.


    if (this._definedBlockFunction) {
      this._ops.push(this);
    }
  }

}
/**
 * Initialize a BlockCached instance so its command/hat
 * block and reporters can be profiled during execution.
 * @param {Profiler} profiler - The profiler that is currently enabled.
 * @param {BlockCached} blockCached - The blockCached instance to profile.
 */


const _prepareBlockProfiling = function (profiler, blockCached) {
  blockCached._profiler = profiler;

  if (blockFunctionProfilerId === -1) {
    blockFunctionProfilerId = profiler.idByName(blockFunctionProfilerFrame);
  }

  const ops = blockCached._ops;

  for (let i = 0; i < ops.length; i++) {
    ops[i]._profilerFrame = profiler.frame(blockFunctionProfilerId, ops[i].opcode);
  }
};
/**
 * Execute a block.
 * @param {!Sequencer} sequencer Which sequencer is executing.
 * @param {!Thread} thread Thread which to read and execute.
 */


const execute = function (sequencer, thread) {
  const runtime = sequencer.runtime; // store sequencer and thread so block functions can access them through
  // convenience methods.

  blockUtility.sequencer = sequencer;
  blockUtility.thread = thread; // Current block to execute is the one on the top of the stack.

  const currentBlockId = thread.peekStack();
  const currentStackFrame = thread.peekStackFrame();
  let blockContainer = thread.blockContainer;
  let blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached);

  if (blockCached === null) {
    blockContainer = runtime.flyoutBlocks;
    blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached); // Stop if block or target no longer exists.

    if (blockCached === null) {
      // No block found: stop the thread; script no longer exists.
      sequencer.retireThread(thread);
      return;
    }
  }

  const ops = blockCached._ops;
  const length = ops.length;
  let i = 0;

  if (currentStackFrame.reported !== null) {
    const reported = currentStackFrame.reported; // Reinstate all the previous values.

    for (; i < reported.length; i++) {
      const {
        opCached: oldOpCached,
        inputValue
      } = reported[i];
      const opCached = ops.find(op => op.id === oldOpCached);

      if (opCached) {
        const inputName = opCached._parentKey;
        const argValues = opCached._parentValues;

        if (inputName === "BROADCAST_INPUT") {
          // Something is plugged into the broadcast input.
          // Cast it to a string. We don't need an id here.
          argValues.BROADCAST_OPTION.id = null;
          argValues.BROADCAST_OPTION.name = String(inputValue);
        } else {
          argValues[inputName] = inputValue;
        }
      }
    } // Find the last reported block that is still in the set of operations.
    // This way if the last operation was removed, we'll find the next
    // candidate. If an earlier block that was performed was removed then
    // we'll find the index where the last operation is now.


    if (reported.length > 0) {
      const lastExisting = reported.reverse().find(report => ops.find(op => op.id === report.opCached));

      if (lastExisting) {
        i = ops.findIndex(opCached => opCached.id === lastExisting.opCached) + 1;
      } else {
        i = 0;
      }
    } // The reporting block must exist and must be the next one in the sequence of operations.


    if (thread.justReported !== null && ops[i] && ops[i].id === currentStackFrame.reporting) {
      const opCached = ops[i];
      const inputValue = thread.justReported;
      thread.justReported = null;
      const inputName = opCached._parentKey;
      const argValues = opCached._parentValues;

      if (inputName === "BROADCAST_INPUT") {
        // Something is plugged into the broadcast input.
        // Cast it to a string. We don't need an id here.
        argValues.BROADCAST_OPTION.id = null;
        argValues.BROADCAST_OPTION.name = String(inputValue);
      } else {
        argValues[inputName] = inputValue;
      }

      i += 1;
    }

    currentStackFrame.reporting = null;
    currentStackFrame.reported = null;
  }

  const start = i;

  for (; i < length; i++) {
    const lastOperation = i === length - 1;
    const opCached = ops[i];
    const blockFunction = opCached._blockFunction; // Update values for arguments (inputs).

    const argValues = opCached._argValues; // Fields are set during opCached initialization.
    // Blocks should glow when a script is starting,
    // not after it has finished (see #1404).
    // Only blocks in blockContainers that don't forceNoGlow
    // should request a glow.

    if (!blockContainer.forceNoGlow) {
      thread.requestScriptGlowInFrame = true;
    } // Inputs are set during previous steps in the loop.


    const primitiveReportedValue = blockFunction(argValues, blockUtility); // If it's a promise, wait until promise resolves.

    if (isPromise(primitiveReportedValue)) {
      handlePromise(primitiveReportedValue, sequencer, thread, opCached, lastOperation); // Store the already reported values. They will be thawed into the
      // future versions of the same operations by block id. The reporting
      // operation if it is promise waiting will set its parent value at
      // that time.

      thread.justReported = null;
      currentStackFrame.reporting = ops[i].id;
      currentStackFrame.reported = ops.slice(0, i).map(reportedCached => {
        const inputName = reportedCached._parentKey;
        const reportedValues = reportedCached._parentValues;

        if (inputName === "BROADCAST_INPUT") {
          return {
            opCached: reportedCached.id,
            inputValue: reportedValues[inputName].BROADCAST_OPTION.name
          };
        }

        return {
          opCached: reportedCached.id,
          inputValue: reportedValues[inputName]
        };
      }); // We are waiting for a promise. Stop running this set of operations
      // and continue them later after thawing the reported values.

      break;
    } else if (thread.status === Thread.STATUS_RUNNING) {
      if (lastOperation) {
        handleReport(primitiveReportedValue, sequencer, thread, opCached, lastOperation);
      } else {
        // By definition a block that is not last in the list has a
        // parent.
        const inputName = opCached._parentKey;
        const parentValues = opCached._parentValues;

        if (inputName === "BROADCAST_INPUT") {
          // Something is plugged into the broadcast input.
          // Cast it to a string. We don't need an id here.
          parentValues.BROADCAST_OPTION.id = null;
          parentValues.BROADCAST_OPTION.name = String(primitiveReportedValue);
        } else {
          parentValues[inputName] = primitiveReportedValue;
        }
      }
    }
  }

  if (runtime.profiler !== null) {
    if (blockCached._profiler !== runtime.profiler) {
      _prepareBlockProfiling(runtime.profiler, blockCached);
    } // Determine the index that is after the last executed block. `i` is
    // currently the block that was just executed. `i + 1` will be the block
    // after that. `length` with the min call makes sure we don't try to
    // reference an operation outside of the set of operations.


    const end = Math.min(i + 1, length);

    for (let p = start; p < end; p++) {
      ops[p]._profilerFrame.count += 1;
    }
  }
};

module.exports = execute;

/***/ }),

/***/ "./src/engine/monitor-record.js":
/*!**************************************!*\
  !*** ./src/engine/monitor-record.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
  Record
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");

const MonitorRecord = Record({
  id: null,
  // Block Id

  /** Present only if the monitor is sprite-specific, such as x position */
  spriteName: null,

  /** Present only if the monitor is sprite-specific, such as x position */
  targetId: null,
  opcode: null,
  value: null,
  params: null,
  mode: 'default',
  sliderMin: 0,
  sliderMax: 100,
  isDiscrete: true,
  x: null,
  // (x: null, y: null) Indicates that the monitor should be auto-positioned
  y: null,
  width: 0,
  height: 0,
  visible: true
});
module.exports = MonitorRecord;

/***/ }),

/***/ "./src/engine/mutation-adapter.js":
/*!****************************************!*\
  !*** ./src/engine/mutation-adapter.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const html = __webpack_require__(/*! htmlparser2 */ "./node_modules/htmlparser2/lib/index.js");

const decodeHtml = __webpack_require__(/*! decode-html */ "./node_modules/decode-html/index.js");
/**
 * Convert a part of a mutation DOM to a mutation VM object, recursively.
 * @param {object} dom DOM object for mutation tag.
 * @return {object} Object representing useful parts of this mutation.
 */


const mutatorTagToObject = function (dom) {
  const obj = Object.create(null);
  obj.tagName = dom.name;
  obj.children = [];

  for (const prop in dom.attribs) {
    if (prop === 'xmlns') continue;
    obj[prop] = decodeHtml(dom.attribs[prop]); // Note: the capitalization of block info in the following lines is important.
    // The lowercase is read in from xml which normalizes case. The VM uses camel case everywhere else.

    if (prop === 'blockinfo') {
      obj.blockInfo = JSON.parse(obj.blockinfo);
      delete obj.blockinfo;
    }
  }

  for (let i = 0; i < dom.children.length; i++) {
    obj.children.push(mutatorTagToObject(dom.children[i]));
  }

  return obj;
};
/**
 * Adapter between mutator XML or DOM and block representation which can be
 * used by the Scratch runtime.
 * @param {(object|string)} mutation Mutation XML string or DOM.
 * @return {object} Object representing the mutation.
 */


const mutationAdpater = function (mutation) {
  let mutationParsed; // Check if the mutation is already parsed; if not, parse it.

  if (typeof mutation === 'object') {
    mutationParsed = mutation;
  } else {
    mutationParsed = html.parseDOM(mutation)[0];
  }

  return mutatorTagToObject(mutationParsed);
};

module.exports = mutationAdpater;

/***/ }),

/***/ "./src/engine/profiler.js":
/*!********************************!*\
  !*** ./src/engine/profiler.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview
 * A way to profile Scratch internal performance. Like what blocks run during a
 * step? How much time do they take? How much time is spent inbetween blocks?
 *
 * Profiler aims for to spend as little time inside its functions while
 * recording. For this it has a simple internal record structure that records a
 * series of values for each START and STOP event in a single array. This lets
 * all the values be pushed in one call for the array. This simplicity allows
 * the contents of the start() and stop() calls to be inlined in areas that are
 * called frequently enough to want even greater performance from Profiler so
 * what is recorded better reflects on the profiled code and not Profiler
 * itself.
 */

/**
 * The next id returned for a new profile'd function.
 * @type {number}
 */
let nextId = 0;
/**
 * The mapping of names to ids.
 * @const {Object.<string, number>}
 */

const profilerNames = {};
/**
 * The START event identifier in Profiler records.
 * @const {number}
 */

const START = 0;
/**
 * The STOP event identifier in Profiler records.
 * @const {number}
 */

const STOP = 1;
/**
 * The number of cells used in the records array by a START event.
 * @const {number}
 */

const START_SIZE = 4;
/**
 * The number of cells used in the records array by a STOP event.
 * @const {number}
 */

const STOP_SIZE = 2;
/**
 * Stored reference to Performance instance provided by the Browser.
 * @const {Performance}
 */

const performance = typeof window === 'object' && window.performance;
/**
 * Callback handle called by Profiler for each frame it decodes from its
 * records.
 * @callback FrameCallback
 * @param {ProfilerFrame} frame
 */

/**
 * A set of information about a frame of execution that was recorded.
 */

class ProfilerFrame {
  /**
   * @param {number} depth Depth of the frame in the recorded stack.
   */
  constructor(depth) {
    /**
     * The numeric id of a record symbol like Runtime._step or
     * blockFunction.
     * @type {number}
     */
    this.id = -1;
    /**
     * The amount of time spent inside the recorded frame and any deeper
     * frames.
     * @type {number}
     */

    this.totalTime = 0;
    /**
     * The amount of time spent only inside this record frame. Not
     * including time in any deeper frames.
     * @type {number}
     */

    this.selfTime = 0;
    /**
     * An arbitrary argument for the recorded frame. For example a block
     * function might record its opcode as an argument.
     * @type {*}
     */

    this.arg = null;
    /**
     * The depth of the recorded frame. This can help compare recursive
     * funtions that are recorded. Each level of recursion with have a
     * different depth value.
     * @type {number}
     */

    this.depth = depth;
    /**
     * A summarized count of the number of calls to this frame.
     * @type {number}
     */

    this.count = 0;
  }

}

class Profiler {
  /**
   * @param {FrameCallback} onFrame a handle called for each recorded frame.
   * The passed frame value may not be stored as it'll be updated with later
   * frame information. Any information that is further stored by the handler
   * should make copies or reduce the information.
   */
  constructor(onFrame = function () {}) {
    /**
     * A series of START and STOP values followed by arguments. After
     * recording is complete the full set of records is reported back by
     * stepping through the series to connect the relative START and STOP
     * information.
     * @type {Array.<*>}
     */
    this.records = [];
    /**
     * An array of frames incremented on demand instead as part of start
     * and stop.
     * @type {Array.<ProfilerFrame>}
     */

    this.increments = [];
    /**
     * An array of profiler frames separated by counter argument. Generally
     * for Scratch these frames are separated by block function opcode.
     * This tracks each time an opcode is called.
     * @type {Array.<ProfilerFrame>}
     */

    this.counters = [];
    /**
     * A frame with no id or argument.
     * @type {ProfilerFrame}
     */

    this.nullFrame = new ProfilerFrame(-1);
    /**
     * A cache of ProfilerFrames to reuse when reporting the recorded
     * frames in records.
     * @type {Array.<ProfilerFrame>}
     */

    this._stack = [new ProfilerFrame(0)];
    /**
     * A callback handle called with each decoded frame when reporting back
     * all the recorded times.
     * @type {FrameCallback}
     */

    this.onFrame = onFrame;
    /**
     * A reference to the START record id constant.
     * @const {number}
     */

    this.START = START;
    /**
     * A reference to the STOP record id constant.
     * @const {number}
     */

    this.STOP = STOP;
  }
  /**
   * Start recording a frame of time for an id and optional argument.
   * @param {number} id The id returned by idByName for a name symbol like
   * Runtime._step.
   * @param {?*} arg An arbitrary argument value to store with the frame.
   */


  start(id, arg) {
    this.records.push(START, id, arg, performance.now());
  }
  /**
   * Stop the current frame.
   */


  stop() {
    this.records.push(STOP, performance.now());
  }
  /**
   * Increment the number of times this symbol is called.
   * @param {number} id The id returned by idByName for a name symbol.
   */


  increment(id) {
    if (!this.increments[id]) {
      this.increments[id] = new ProfilerFrame(-1);
      this.increments[id].id = id;
    }

    this.increments[id].count += 1;
  }
  /**
   * Find or create a ProfilerFrame-like object whose counter can be
   * incremented outside of the Profiler.
   * @param {number} id The id returned by idByName for a name symbol.
   * @param {*} arg The argument for a frame that identifies it in addition
   *   to the id.
   * @return {{count: number}} A ProfilerFrame-like whose count should be
   *   incremented for each call.
   */


  frame(id, arg) {
    for (let i = 0; i < this.counters.length; i++) {
      if (this.counters[i].id === id && this.counters[i].arg === arg) {
        return this.counters[i];
      }
    }

    const newCounter = new ProfilerFrame(-1);
    newCounter.id = id;
    newCounter.arg = arg;
    this.counters.push(newCounter);
    return newCounter;
  }
  /**
   * Decode records and report all frames to `this.onFrame`.
   */


  reportFrames() {
    const stack = this._stack;
    let depth = 1; // Step through the records and initialize Frame instances from the
    // START and STOP events. START and STOP events are separated by events
    // for deeper frames run by higher frames. Frames are stored on a stack
    // and reinitialized for each START event. When a stop event is reach
    // the Frame for the current depth has its final values stored and its
    // passed to the current onFrame callback. This way Frames are "pushed"
    // for each START event and "popped" for each STOP and handed to an
    // outside handle to any desired reduction of the collected data.

    for (let i = 0; i < this.records.length;) {
      if (this.records[i] === START) {
        if (depth >= stack.length) {
          stack.push(new ProfilerFrame(depth));
        } // Store id, arg, totalTime, and initialize selfTime.


        const frame = stack[depth++];
        frame.id = this.records[i + 1];
        frame.arg = this.records[i + 2]; // totalTime is first set as the time recorded by this START
        // event. Once the STOP event is reached the stored start time
        // is subtracted from the recorded stop time. The resulting
        // difference is the actual totalTime, and replaces the start
        // time in frame.totalTime.
        //
        // totalTime is used this way as a convenient member to store a
        // value between the two events without needing additional
        // members on the Frame or in a shadow map.

        frame.totalTime = this.records[i + 3]; // selfTime is decremented until we reach the STOP event for
        // this frame. totalTime will be added to it then to get the
        // time difference.

        frame.selfTime = 0;
        i += START_SIZE;
      } else if (this.records[i] === STOP) {
        const now = this.records[i + 1];
        const frame = stack[--depth]; // totalTime is the difference between the start event time
        // stored in totalTime and the stop event time pulled from this
        // record.

        frame.totalTime = now - frame.totalTime; // selfTime is the difference of this frame's totalTime and the
        // sum of totalTime of deeper frames.

        frame.selfTime += frame.totalTime; // Remove this frames totalTime from the parent's selfTime.

        stack[depth - 1].selfTime -= frame.totalTime; // This frame occured once.

        frame.count = 1;
        this.onFrame(frame);
        i += STOP_SIZE;
      } else {
        this.records.length = 0;
        throw new Error('Unable to decode Profiler records.');
      }
    }

    for (let j = 0; j < this.increments.length; j++) {
      if (this.increments[j] && this.increments[j].count > 0) {
        this.onFrame(this.increments[j]);
        this.increments[j].count = 0;
      }
    }

    for (let k = 0; k < this.counters.length; k++) {
      if (this.counters[k].count > 0) {
        this.onFrame(this.counters[k]);
        this.counters[k].count = 0;
      }
    }

    this.records.length = 0;
  }
  /**
   * Lookup or create an id for a frame name.
   * @param {string} name The name to return an id for.
   * @return {number} The id for the passed name.
   */


  idByName(name) {
    return Profiler.idByName(name);
  }
  /**
   * Reverse lookup the name from a given frame id.
   * @param {number} id The id to search for.
   * @return {string} The name for the given id.
   */


  nameById(id) {
    return Profiler.nameById(id);
  }
  /**
   * Lookup or create an id for a frame name.
   * @static
   * @param {string} name The name to return an id for.
   * @return {number} The id for the passed name.
   */


  static idByName(name) {
    if (typeof profilerNames[name] !== 'number') {
      profilerNames[name] = nextId++;
    }

    return profilerNames[name];
  }
  /**
   * Reverse lookup the name from a given frame id.
   * @static
   * @param {number} id The id to search for.
   * @return {string} The name for the given id.
   */


  static nameById(id) {
    for (const name in profilerNames) {
      if (profilerNames[name] === id) {
        return name;
      }
    }

    return null;
  }
  /**
   * Profiler is only available on platforms with the Performance API.
   * @return {boolean} Can the Profiler run in this browser?
   */


  static available() {
    return typeof window === 'object' && typeof window.performance !== 'undefined';
  }

}
/**
 * A reference to the START record id constant.
 * @const {number}
 */


Profiler.START = START;
/**
 * A reference to the STOP record id constant.
 * @const {number}
 */

Profiler.STOP = STOP;
module.exports = Profiler;

/***/ }),

/***/ "./src/engine/runtime.js":
/*!*******************************!*\
  !*** ./src/engine/runtime.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const {
  OrderedMap
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");

const ArgumentType = __webpack_require__(/*! ../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const Blocks = __webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

const BlocksRuntimeCache = __webpack_require__(/*! ./blocks-runtime-cache */ "./src/engine/blocks-runtime-cache.js");

const BlockType = __webpack_require__(/*! ../extension-support/block-type */ "./src/extension-support/block-type.js");

const Profiler = __webpack_require__(/*! ./profiler */ "./src/engine/profiler.js");

const Sequencer = __webpack_require__(/*! ./sequencer */ "./src/engine/sequencer.js");

const execute = __webpack_require__(/*! ./execute.js */ "./src/engine/execute.js");

const TargetType = __webpack_require__(/*! ../extension-support/target-type */ "./src/extension-support/target-type.js");

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const maybeFormatMessage = __webpack_require__(/*! ../util/maybe-format-message */ "./src/util/maybe-format-message.js");

const StageLayering = __webpack_require__(/*! ./stage-layering */ "./src/engine/stage-layering.js");

const Variable = __webpack_require__(/*! ./variable */ "./src/engine/variable.js");

const ScratchLinkWebSocket = __webpack_require__(/*! ../util/scratch-link-websocket */ "./src/util/scratch-link-websocket.js"); // Virtual I/O devices.


const Clock = __webpack_require__(/*! ../io/clock */ "./src/io/clock.js");

const Cloud = __webpack_require__(/*! ../io/cloud */ "./src/io/cloud.js");

const Keyboard = __webpack_require__(/*! ../io/keyboard */ "./src/io/keyboard.js");

const Mouse = __webpack_require__(/*! ../io/mouse */ "./src/io/mouse.js");

const MouseWheel = __webpack_require__(/*! ../io/mouseWheel */ "./src/io/mouseWheel.js");

const UserData = __webpack_require__(/*! ../io/userData */ "./src/io/userData.js");

const Video = __webpack_require__(/*! ../io/video */ "./src/io/video.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const defaultBlockPackages = __webpack_require__(/*! ../vm-blocks.js */ "./src/vm-blocks.js");

console.warn("测试新方式:", defaultBlockPackages);
/**
 * These constants are copied from scratch-blocks/core/constants.js
 * @TODO find a way to require() these straight from scratch-blocks... maybe make a scratch-blocks/dist/constants.js?
 * @readonly
 * @enum {int}
 */

const KidBlocksConstants = {
  /**
   * ENUM for output shape: hexagonal (booleans/predicates).
   * @const
   */
  OUTPUT_SHAPE_HEXAGONAL: 1,

  /**
   * ENUM for output shape: rounded (numbers).
   * @const
   */
  OUTPUT_SHAPE_ROUND: 2,

  /**
   * ENUM for output shape: squared (any/all values; strings).
   * @const
   */
  OUTPUT_SHAPE_SQUARE: 3
};
const defaultExtensionColors = ["#0FBD8C", "#0DA57A", "#0B8E69"];
/**
 * Information used for converting Scratch argument types into scratch-blocks data.
 * @type {object.<ArgumentType, {shadowType: string, fieldType: string}>}
 */

const ArgumentTypeMap = (() => {
  const map = {};
  map[ArgumentType.ANGLE] = {
    shadow: {
      type: "math_angle",
      // We specify fieldNames here so that we can pick
      // create and populate a field with the defaultValue
      // specified in the extension.
      // When the `fieldName` property is not specified,
      // the <field></field> will be left out of the XML and
      // the scratch-blocks defaults for that field will be
      // used instead (e.g. default of 0 for number fields)
      fieldName: "NUM"
    }
  };
  map[ArgumentType.COLOR] = {
    shadow: {
      type: "colour_picker",
      fieldName: "COLOUR"
    }
  };
  map[ArgumentType.NUMBER] = {
    shadow: {
      type: "math_number",
      fieldName: "NUM"
    }
  };
  map[ArgumentType.STRING] = {
    shadow: {
      type: "text",
      fieldName: "TEXT"
    }
  };
  map[ArgumentType.BOOLEAN] = {
    check: "Boolean"
  };
  map[ArgumentType.MATRIX] = {
    shadow: {
      type: "matrix",
      fieldName: "MATRIX"
    }
  };
  map[ArgumentType.NOTE] = {
    shadow: {
      type: "note",
      fieldName: "NOTE"
    }
  };
  map[ArgumentType.IMAGE] = {
    // Inline images are weird because they're not actually "arguments".
    // They are more analagous to the label on a block.
    fieldType: "field_image"
  };
  return map;
})();
/**
 * A pair of functions used to manage the cloud variable limit,
 * to be used when adding (or attempting to add) or removing a cloud variable.
 * @typedef {object} CloudDataManager
 * @property {function} canAddCloudVariable A function to call to check that
 * a cloud variable can be added.
 * @property {function} addCloudVariable A function to call to track a new
 * cloud variable on the runtime.
 * @property {function} removeCloudVariable A function to call when
 * removing an existing cloud variable.
 * @property {function} hasCloudVariables A function to call to check that
 * the runtime has any cloud variables.
 */

/**
 * Creates and manages cloud variable limit in a project,
 * and returns two functions to be used to add a new
 * cloud variable (while checking that it can be added)
 * and remove an existing cloud variable.
 * These are to be called whenever attempting to create or delete
 * a cloud variable.
 * @return {CloudDataManager} The functions to be used when adding or removing a
 * cloud variable.
 */


const cloudDataManager = () => {
  const limit = 10;
  let count = 0;

  const canAddCloudVariable = () => count < limit;

  const addCloudVariable = () => {
    count++;
  };

  const removeCloudVariable = () => {
    count--;
  };

  const hasCloudVariables = () => count > 0;

  return {
    canAddCloudVariable,
    addCloudVariable,
    removeCloudVariable,
    hasCloudVariables
  };
};
/**
 * Numeric ID for Runtime._step in Profiler instances.
 * @type {number}
 */


let stepProfilerId = -1;
/**
 * Numeric ID for Sequencer.stepThreads in Profiler instances.
 * @type {number}
 */

let stepThreadsProfilerId = -1;
/**
 * Numeric ID for RenderWebGL.draw in Profiler instances.
 * @type {number}
 */

let rendererDrawProfilerId = -1;
/**
 * Manages targets, scripts, and the sequencer.
 * @constructor
 */

class Runtime extends EventEmitter {
  constructor() {
    super();
    console.log("class Runtime");
    /**
     * Target management and storage.
     * @type {Array.<!Target>}
     */

    this.targets = [];
    /**
     * Targets in reverse order of execution. Shares its order with drawables.
     * @type {Array.<!Target>}
     */

    this.executableTargets = [];
    /**
     * A list of threads that are currently running in the VM.
     * Threads are added when execution starts and pruned when execution ends.
     * @type {Array.<Thread>}
     */

    this.threads = [];
    /** @type {!Sequencer} */

    this.sequencer = new Sequencer(this);
    /**
     * Storage container for flyout blocks.
     * These will execute on `_editingTarget.`
     * @type {!Blocks}
     */

    this.flyoutBlocks = new Blocks(this, true
    /* force no glow */
    );
    /**
     * Storage container for monitor blocks.
     * These will execute on a target maybe
     * @type {!Blocks}
     */

    this.monitorBlocks = new Blocks(this, true
    /* force no glow */
    );
    /**
     * Currently known editing target for the VM.
     * @type {?Target}
     */

    this._editingTarget = null;
    /**
     * Map to look up a block primitive's implementation function by its opcode.
     * This is a two-step lookup: package name first, then primitive name.
     * @type {Object.<string, Function>}
     */

    this._primitives = {};
    /**
     * Map to look up all block information by extended opcode.
     * @type {Array.<CategoryInfo>}
     * @private
     */

    this._blockInfo = [];
    /**
     * Map to look up hat blocks' metadata.
     * Keys are opcode for hat, values are metadata objects.
     * @type {Object.<string, Object>}
     */

    this._hats = {};
    /**
     * A list of script block IDs that were glowing during the previous frame.
     * @type {!Array.<!string>}
     */

    this._scriptGlowsPreviousFrame = [];
    /**
     * Number of non-monitor threads running during the previous frame.
     * @type {number}
     */

    this._nonMonitorThreadCount = 0;
    /**
     * All threads that finished running and were removed from this.threads
     * by behaviour in Sequencer.stepThreads.
     * @type {Array<Thread>}
     */

    this._lastStepDoneThreads = null;
    /**
     * Currently known number of clones, used to enforce clone limit.
     * @type {number}
     */

    this._cloneCounter = 0;
    /**
     * Flag to emit a targets update at the end of a step. When target data
     * changes, this flag is set to true.
     * @type {boolean}
     */

    this._refreshTargets = false;
    /**
     * Map to look up all monitor block information by opcode.
     * @type {object}
     * @private
     */

    this.monitorBlockInfo = {};
    /**
     * Ordered map of all monitors, which are MonitorReporter objects.
     */

    this._monitorState = OrderedMap({});
    /**
     * Monitor state from last tick
     */

    this._prevMonitorState = OrderedMap({});
    /**
     * Whether the project is in "turbo mode."
     * @type {Boolean}
     */

    this.turboMode = false;
    /**
     * Whether the project is in "compatibility mode" (30 TPS).
     * @type {Boolean}
     */

    this.compatibilityMode = false;
    /**
     * A reference to the current runtime stepping interval, set
     * by a `setInterval`.
     * @type {!number}
     */

    this._steppingInterval = null;
    /**
     * Current length of a step.
     * Changes as mode switches, and used by the sequencer to calculate
     * WORK_TIME.
     * @type {!number}
     */

    this.currentStepTime = null; // Set an intial value for this.currentMSecs

    this.updateCurrentMSecs();
    /**
     * Whether any primitive has requested a redraw.
     * Affects whether `Sequencer.stepThreads` will yield
     * after stepping each thread.
     * Reset on every frame.
     * @type {boolean}
     */

    this.redrawRequested = false; // 注册所有给定的块包.

    this._registerBlockPackages(); // 注册并初始化"IO devices"，用于处理 I/O 相关数据的容器.

    /** @type {Object.<string, Object>} */


    this.ioDevices = {
      clock: new Clock(this),
      cloud: new Cloud(this),
      keyboard: new Keyboard(this),
      mouse: new Mouse(this),
      mouseWheel: new MouseWheel(this),
      userData: new UserData(),
      video: new Video(this)
    };
    /**
     * A list of extensions, used to manage hardware connection.
     */

    this.peripheralExtensions = {};
    /**
     * A runtime profiler that records timed events for later playback to
     * diagnose Scratch performance.
     * @type {Profiler}
     */

    this.profiler = null;
    const newCloudDataManager = cloudDataManager();
    /**
     * Check wether the runtime has any cloud data.
     * @type {function}
     * @return {boolean} Whether or not the runtime currently has any
     * cloud variables.
     */

    this.hasCloudData = newCloudDataManager.hasCloudVariables;
    /**
     * A function which checks whether a new cloud variable can be added
     * to the runtime.
     * @type {function}
     * @return {boolean} Whether or not a new cloud variable can be added
     * to the runtime.
     */

    this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;
    /**
     * A function that tracks a new cloud variable in the runtime,
     * updating the cloud variable limit. Calling this function will
     * emit a cloud data update event if this is the first cloud variable
     * being added.
     * @type {function}
     */

    this.addCloudVariable = this._initializeAddCloudVariable(newCloudDataManager);
    /**
     * A function which updates the runtime's cloud variable limit
     * when removing a cloud variable and emits a cloud update event
     * if the last of the cloud variables is being removed.
     * @type {function}
     */

    this.removeCloudVariable = this._initializeRemoveCloudVariable(newCloudDataManager);
  }
  /**
   * Width of the stage, in pixels.
   * @const {number}
   */


  static get STAGE_WIDTH() {
    return 480;
  }
  /**
   * Height of the stage, in pixels.
   * @const {number}
   */


  static get STAGE_HEIGHT() {
    return 360;
  }
  /**
   * Event name for glowing a script.
   * @const {string}
   */


  static get SCRIPT_GLOW_ON() {
    return "SCRIPT_GLOW_ON";
  }
  /**
   * Event name for unglowing a script.
   * @const {string}
   */


  static get SCRIPT_GLOW_OFF() {
    return "SCRIPT_GLOW_OFF";
  }
  /**
   * Event name for glowing a block.
   * @const {string}
   */


  static get BLOCK_GLOW_ON() {
    return "BLOCK_GLOW_ON";
  }
  /**
   * Event name for unglowing a block.
   * @const {string}
   */


  static get BLOCK_GLOW_OFF() {
    return "BLOCK_GLOW_OFF";
  }
  /**
   * Event name for a cloud data update
   * to this project.
   * @const {string}
   */


  static get HAS_CLOUD_DATA_UPDATE() {
    return "HAS_CLOUD_DATA_UPDATE";
  }
  /**
   * Event name for turning on turbo mode.
   * @const {string}
   */


  static get TURBO_MODE_ON() {
    return "TURBO_MODE_ON";
  }
  /**
   * Event name for turning off turbo mode.
   * @const {string}
   */


  static get TURBO_MODE_OFF() {
    return "TURBO_MODE_OFF";
  }
  /**
   * Event name when the project is started (threads may not necessarily be
   * running).
   * @const {string}
   */


  static get PROJECT_START() {
    return "PROJECT_START";
  }
  /**
   * Event name when threads start running.
   * Used by the UI to indicate running status.
   * @const {string}
   */


  static get PROJECT_RUN_START() {
    return "PROJECT_RUN_START";
  }
  /**
   * Event name when threads stop running
   * Used by the UI to indicate not-running status.
   * @const {string}
   */


  static get PROJECT_RUN_STOP() {
    return "PROJECT_RUN_STOP";
  }
  /**
   * Event name for project being stopped or restarted by the user.
   * Used by blocks that need to reset state.
   * @const {string}
   */


  static get PROJECT_STOP_ALL() {
    return "PROJECT_STOP_ALL";
  }
  /**
   * Event name for target being stopped by a stop for target call.
   * Used by blocks that need to stop individual targets.
   * @const {string}
   */


  static get STOP_FOR_TARGET() {
    return "STOP_FOR_TARGET";
  }
  /**
   * Event name for visual value report.
   * @const {string}
   */


  static get VISUAL_REPORT() {
    return "VISUAL_REPORT";
  }
  /**
   * 项目加载报告的事件名称.
   * @const {string}
   */


  static get PROJECT_LOADED() {
    return "PROJECT_LOADED";
  }
  /**
   * Event name for report that a change was made that can be saved
   * @const {string}
   */


  static get PROJECT_CHANGED() {
    return "PROJECT_CHANGED";
  }
  /**
   * Event name for report that a change was made to an extension in the toolbox.
   * @const {string}
   */


  static get TOOLBOX_EXTENSIONS_NEED_UPDATE() {
    return "TOOLBOX_EXTENSIONS_NEED_UPDATE";
  }
  /**
   * Event name for targets update report.
   * @const {string}
   */


  static get TARGETS_UPDATE() {
    return "TARGETS_UPDATE";
  }
  /**
   * Event name for monitors update.
   * @const {string}
   */


  static get MONITORS_UPDATE() {
    return "MONITORS_UPDATE";
  }
  /**
   * Event name for block drag update.
   * @const {string}
   */


  static get BLOCK_DRAG_UPDATE() {
    return "BLOCK_DRAG_UPDATE";
  }
  /**
   * Event name for block drag end.
   * @const {string}
   */


  static get BLOCK_DRAG_END() {
    return "BLOCK_DRAG_END";
  }
  /**
   * Event name for reporting that an extension was added.
   * @const {string}
   */


  static get EXTENSION_ADDED() {
    return "EXTENSION_ADDED";
  }
  /**
   * Event name for reporting that an extension as asked for a custom field to be added
   * @const {string}
   */


  static get EXTENSION_FIELD_ADDED() {
    return "EXTENSION_FIELD_ADDED";
  }
  /**
   * Event name for updating the available set of peripheral devices.
   * This causes the peripheral connection modal to update a list of
   * available peripherals.
   * @const {string}
   */


  static get PERIPHERAL_LIST_UPDATE() {
    return "PERIPHERAL_LIST_UPDATE";
  }
  /**
   * Event name for reporting that a peripheral has connected.
   * This causes the status button in the blocks menu to indicate 'connected'.
   * @const {string}
   */


  static get PERIPHERAL_CONNECTED() {
    return "PERIPHERAL_CONNECTED";
  }
  /**
   * Event name for reporting that a peripheral has been intentionally disconnected.
   * This causes the status button in the blocks menu to indicate 'disconnected'.
   * @const {string}
   */


  static get PERIPHERAL_DISCONNECTED() {
    return "PERIPHERAL_DISCONNECTED";
  }
  /**
   * Event name for reporting that a peripheral has encountered a request error.
   * This causes the peripheral connection modal to switch to an error state.
   * @const {string}
   */


  static get PERIPHERAL_REQUEST_ERROR() {
    return "PERIPHERAL_REQUEST_ERROR";
  }
  /**
   * Event name for reporting that a peripheral connection has been lost.
   * This causes a 'peripheral connection lost' error alert to display.
   * @const {string}
   */


  static get PERIPHERAL_CONNECTION_LOST_ERROR() {
    return "PERIPHERAL_CONNECTION_LOST_ERROR";
  }
  /**
   * Event name for reporting that a peripheral has not been discovered.
   * This causes the peripheral connection modal to show a timeout state.
   * @const {string}
   */


  static get PERIPHERAL_SCAN_TIMEOUT() {
    return "PERIPHERAL_SCAN_TIMEOUT";
  }
  /**
   * Event name to indicate that the microphone is being used to stream audio.
   * @const {string}
   */


  static get MIC_LISTENING() {
    return "MIC_LISTENING";
  }
  /**
   * Event name for reporting that blocksInfo was updated.
   * @const {string}
   */


  static get BLOCKSINFO_UPDATE() {
    return "BLOCKSINFO_UPDATE";
  }
  /**
   * Event name when the runtime tick loop has been started.
   * @const {string}
   */


  static get RUNTIME_STARTED() {
    return "RUNTIME_STARTED";
  }
  /**
   * Event name when the runtime dispose has been called.
   * @const {string}
   */


  static get RUNTIME_DISPOSED() {
    return "RUNTIME_DISPOSED";
  }
  /**
   * Event name for reporting that a block was updated and needs to be rerendered.
   * @const {string}
   */


  static get BLOCKS_NEED_UPDATE() {
    return "BLOCKS_NEED_UPDATE";
  }
  /**
   * How rapidly we try to step threads by default, in ms.
   */


  static get THREAD_STEP_INTERVAL() {
    return 1000 / 60;
  }
  /**
   * In compatibility mode, how rapidly we try to step threads, in ms.
   */


  static get THREAD_STEP_INTERVAL_COMPATIBILITY() {
    return 1000 / 30;
  }
  /**
   * How many clones can be created at a time.
   * @const {number}
   */


  static get MAX_CLONES() {
    return 300;
  } // -----------------------------------------------------------------------------
  // -----------------------------------------------------------------------------
  // Helper function for initializing the addCloudVariable function


  _initializeAddCloudVariable(newCloudDataManager) {
    // The addCloudVariable function
    return () => {
      const hadCloudVarsBefore = this.hasCloudData();
      newCloudDataManager.addCloudVariable();

      if (!hadCloudVarsBefore && this.hasCloudData()) {
        this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, true);
      }
    };
  } // Helper function for initializing the removeCloudVariable function


  _initializeRemoveCloudVariable(newCloudDataManager) {
    return () => {
      const hadCloudVarsBefore = this.hasCloudData();
      newCloudDataManager.removeCloudVariable();

      if (hadCloudVarsBefore && !this.hasCloudData()) {
        this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);
      }
    };
  }
  /**
   * 在此运行时注册默认块包.
   * @todo Prefix opcodes with package name.
   * @private
   */


  _registerBlockPackages() {
    for (const packageName in defaultBlockPackages) {
      if (defaultBlockPackages.hasOwnProperty(packageName)) {
        // @待办事项根据程序包特权传递不同的运行时?
        const packageObject = new defaultBlockPackages[packageName](this); // 从包装收集元.

        if (packageObject.getPrimitives) {
          const packagePrimitives = packageObject.getPrimitives();

          for (const op in packagePrimitives) {
            if (packagePrimitives.hasOwnProperty(op)) {
              this._primitives[op] = packagePrimitives[op].bind(packageObject);
            }
          }
        } // Collect hat metadata from package.


        if (packageObject.getHats) {
          const packageHats = packageObject.getHats();

          for (const hatName in packageHats) {
            if (packageHats.hasOwnProperty(hatName)) {
              this._hats[hatName] = packageHats[hatName];
            }
          }
        } // Collect monitored from package.


        if (packageObject.getMonitored) {
          this.monitorBlockInfo = Object.assign({}, this.monitorBlockInfo, packageObject.getMonitored());
        }
      }
    }
  }

  getMonitorState() {
    return this._monitorState;
  }
  /**
   * Generate an extension-specific menu ID.
   * @param {string} menuName - the name of the menu.
   * @param {string} extensionId - the ID of the extension hosting the menu.
   * @returns {string} - the constructed ID.
   * @private
   */


  _makeExtensionMenuId(menuName, extensionId) {
    return `${extensionId}_menu_${Utility.xmlEscape(menuName)}`;
  }
  /**
   * Create a context ("args") object for use with `formatMessage` on messages which might be target-specific.
   * @param {Target} [target] - the target to use as context. If a target is not provided, default to the current
   * editing target or the stage.
   */


  makeMessageContextForTarget(target) {
    const context = {};
    target = target || this.getEditingTarget() || this.getTargetForStage();

    if (target) {
      context.targetType = target.isStage ? TargetType.STAGE : TargetType.SPRITE;
    }
  }
  /**
   * Register the primitives provided by an extension.
   * @param {ExtensionMetadata} extensionInfo - information about the extension (id, blocks, etc.)
   * @private
   */


  _registerExtensionPrimitives(extensionInfo) {
    const categoryInfo = {
      id: extensionInfo.id,
      name: maybeFormatMessage(extensionInfo.name),
      showStatusButton: extensionInfo.showStatusButton,
      blockIconURI: extensionInfo.blockIconURI,
      menuIconURI: extensionInfo.menuIconURI
    };

    if (extensionInfo.color1) {
      categoryInfo.color1 = extensionInfo.color1;
      categoryInfo.color2 = extensionInfo.color2;
      categoryInfo.color3 = extensionInfo.color3;
    } else {
      categoryInfo.color1 = defaultExtensionColors[0];
      categoryInfo.color2 = defaultExtensionColors[1];
      categoryInfo.color3 = defaultExtensionColors[2];
    }

    this._blockInfo.push(categoryInfo);

    this._fillExtensionCategory(categoryInfo, extensionInfo);

    for (const fieldTypeName in categoryInfo.customFieldTypes) {
      if (extensionInfo.customFieldTypes.hasOwnProperty(fieldTypeName)) {
        const fieldTypeInfo = categoryInfo.customFieldTypes[fieldTypeName]; // Emit events for custom field types from extension

        this.emit(Runtime.EXTENSION_FIELD_ADDED, {
          name: `field_${fieldTypeInfo.extendedName}`,
          implementation: fieldTypeInfo.fieldImplementation
        });
      }
    }

    this.emit(Runtime.EXTENSION_ADDED, categoryInfo);
  }
  /**
   * Reregister the primitives for an extension
   * @param  {ExtensionMetadata} extensionInfo - new info (results of running getInfo) for an extension
   * @private
   */


  _refreshExtensionPrimitives(extensionInfo) {
    const categoryInfo = this._blockInfo.find(info => info.id === extensionInfo.id);

    if (categoryInfo) {
      categoryInfo.name = maybeFormatMessage(extensionInfo.name);

      this._fillExtensionCategory(categoryInfo, extensionInfo);

      this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);
    }
  }
  /**
   * Read extension information, convert menus, blocks and custom field types
   * and store the results in the provided category object.
   * @param {CategoryInfo} categoryInfo - the category to be filled
   * @param {ExtensionMetadata} extensionInfo - the extension metadata to read
   * @private
   */


  _fillExtensionCategory(categoryInfo, extensionInfo) {
    categoryInfo.blocks = [];
    categoryInfo.customFieldTypes = {};
    categoryInfo.menus = [];
    categoryInfo.menuInfo = {};

    for (const menuName in extensionInfo.menus) {
      if (extensionInfo.menus.hasOwnProperty(menuName)) {
        const menuInfo = extensionInfo.menus[menuName];

        const convertedMenu = this._buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo);

        categoryInfo.menus.push(convertedMenu);
        categoryInfo.menuInfo[menuName] = menuInfo;
      }
    }

    for (const fieldTypeName in extensionInfo.customFieldTypes) {
      if (extensionInfo.customFieldTypes.hasOwnProperty(fieldTypeName)) {
        const fieldType = extensionInfo.customFieldTypes[fieldTypeName];

        const fieldTypeInfo = this._buildCustomFieldInfo(fieldTypeName, fieldType, extensionInfo.id, categoryInfo);

        categoryInfo.customFieldTypes[fieldTypeName] = fieldTypeInfo;
      }
    }

    for (const blockInfo of extensionInfo.blocks) {
      try {
        const convertedBlock = this._convertForScratchBlocks(blockInfo, categoryInfo);

        categoryInfo.blocks.push(convertedBlock);

        if (convertedBlock.json) {
          const opcode = convertedBlock.json.type;

          if (blockInfo.blockType !== BlockType.EVENT) {
            this._primitives[opcode] = convertedBlock.info.func;
          }

          if (blockInfo.blockType === BlockType.EVENT || blockInfo.blockType === BlockType.HAT) {
            this._hats[opcode] = {
              edgeActivated: blockInfo.isEdgeActivated,
              restartExistingThreads: blockInfo.shouldRestartExistingThreads
            };
          }
        }
      } catch (e) {
        console.error("Error parsing block: ", {
          block: blockInfo,
          error: e
        });
      }
    }
  }
  /**
   * Convert the given extension menu items into the scratch-blocks style of list of pairs.
   * If the menu is dynamic (e.g. the passed in argument is a function), return the input unmodified.
   * @param {object} menuItems - an array of menu items or a function to retrieve such an array
   * @returns {object} - an array of 2 element arrays or the original input function
   * @private
   */


  _convertMenuItems(menuItems) {
    if (typeof menuItems !== "function") {
      const extensionMessageContext = this.makeMessageContextForTarget();
      return menuItems.map(item => {
        const formattedItem = maybeFormatMessage(item, extensionMessageContext);

        switch (typeof formattedItem) {
          case "string":
            return [formattedItem, formattedItem];

          case "object":
            return [maybeFormatMessage(item.text, extensionMessageContext), item.value];

          default:
            throw new Error(`Can't interpret menu item: ${JSON.stringify(item)}`);
        }
      });
    }

    return menuItems;
  }
  /**
   * Build the scratch-blocks JSON for a menu. Note that scratch-blocks treats menus as a special kind of block.
   * @param {string} menuName - the name of the menu
   * @param {object} menuInfo - a description of this menu and its items
   * @property {*} items - an array of menu items or a function to retrieve such an array
   * @property {boolean} [acceptReporters] - if true, allow dropping reporters onto this menu
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {object} - a JSON-esque object ready for scratch-blocks' consumption
   * @private
   */


  _buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo) {
    const menuId = this._makeExtensionMenuId(menuName, categoryInfo.id);

    const menuItems = this._convertMenuItems(menuInfo.items);

    return {
      json: {
        message0: "%1",
        type: menuId,
        inputsInline: true,
        output: "String",
        colour: categoryInfo.color1,
        colourSecondary: categoryInfo.color2,
        colourTertiary: categoryInfo.color3,
        outputShape: menuInfo.acceptReporters ? KidBlocksConstants.OUTPUT_SHAPE_ROUND : KidBlocksConstants.OUTPUT_SHAPE_SQUARE,
        args0: [{
          type: "field_dropdown",
          name: menuName,
          options: menuItems
        }]
      }
    };
  }

  _buildCustomFieldInfo(fieldName, fieldInfo, extensionId, categoryInfo) {
    const extendedName = `${extensionId}_${fieldName}`;
    return {
      fieldName: fieldName,
      extendedName: extendedName,
      argumentTypeInfo: {
        shadow: {
          type: extendedName,
          fieldName: `field_${extendedName}`
        }
      },
      scratchBlocksDefinition: this._buildCustomFieldTypeForScratchBlocks(extendedName, fieldInfo.output, fieldInfo.outputShape, categoryInfo),
      fieldImplementation: fieldInfo.implementation
    };
  }
  /**
   * Build the scratch-blocks JSON needed for a fieldType.
   * Custom field types need to be namespaced to the extension so that extensions can't interfere with each other
   * @param  {string} fieldName - The name of the field
   * @param {string} output - The output of the field
   * @param {number} outputShape - Shape of the field (from KidBlocksConstants)
   * @param {object} categoryInfo - The category the field belongs to (Used to set its colors)
   * @returns {object} - Object to be inserted into scratch-blocks
   */


  _buildCustomFieldTypeForScratchBlocks(fieldName, output, outputShape, categoryInfo) {
    return {
      json: {
        type: fieldName,
        message0: "%1",
        inputsInline: true,
        output: output,
        colour: categoryInfo.color1,
        colourSecondary: categoryInfo.color2,
        colourTertiary: categoryInfo.color3,
        outputShape: outputShape,
        args0: [{
          name: `field_${fieldName}`,
          type: `field_${fieldName}`
        }]
      }
    };
  }
  /**
   * Convert ExtensionBlockMetadata into data ready for scratch-blocks.
   * @param {ExtensionBlockMetadata} blockInfo - the block info to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */


  _convertForScratchBlocks(blockInfo, categoryInfo) {
    if (blockInfo === "---") {
      return this._convertSeparatorForScratchBlocks(blockInfo);
    }

    if (blockInfo.blockType === BlockType.BUTTON) {
      return this._convertButtonForScratchBlocks(blockInfo);
    }

    return this._convertBlockForScratchBlocks(blockInfo, categoryInfo);
  }
  /**
   * Convert ExtensionBlockMetadata into scratch-blocks JSON & XML, and generate a proxy function.
   * @param {ExtensionBlockMetadata} blockInfo - the block to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */


  _convertBlockForScratchBlocks(blockInfo, categoryInfo) {
    const extendedOpcode = `${categoryInfo.id}_${blockInfo.opcode}`;
    const blockJSON = {
      type: extendedOpcode,
      inputsInline: true,
      category: categoryInfo.name,
      colour: categoryInfo.color1,
      colourSecondary: categoryInfo.color2,
      colourTertiary: categoryInfo.color3
    };
    const context = {
      // TODO: store this somewhere so that we can map args appropriately after translation.
      // This maps an arg name to its relative position in the original (usually English) block text.
      // When displaying a block in another language we'll need to run a `replace` action similar to the one
      // below, but each `[ARG]` will need to be replaced with the number in this map.
      argsMap: {},
      blockJSON,
      categoryInfo,
      blockInfo,
      inputList: []
    }; // If an icon for the extension exists, prepend it to each block, with a vertical separator.
    // We can overspecify an icon for each block, but if no icon exists on a block, fall back to
    // the category block icon.

    const iconURI = blockInfo.blockIconURI || categoryInfo.blockIconURI;

    if (iconURI) {
      blockJSON.extensions = ["scratch_extension"];
      blockJSON.message0 = "%1 %2";
      const iconJSON = {
        type: "field_image",
        src: iconURI,
        width: 40,
        height: 40
      };
      const separatorJSON = {
        type: "field_vertical_separator"
      };
      blockJSON.args0 = [iconJSON, separatorJSON];
    }

    switch (blockInfo.blockType) {
      case BlockType.COMMAND:
        blockJSON.outputShape = KidBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.previousStatement = null; // null = available connection; undefined = hat

        if (!blockInfo.isTerminal) {
          blockJSON.nextStatement = null; // null = available connection; undefined = terminal
        }

        break;

      case BlockType.REPORTER:
        blockJSON.output = "String"; // TODO: distinguish number & string here?

        blockJSON.outputShape = KidBlocksConstants.OUTPUT_SHAPE_ROUND;
        break;

      case BlockType.BOOLEAN:
        blockJSON.output = "Boolean";
        blockJSON.outputShape = KidBlocksConstants.OUTPUT_SHAPE_HEXAGONAL;
        break;

      case BlockType.HAT:
      case BlockType.EVENT:
        if (!blockInfo.hasOwnProperty("isEdgeActivated")) {
          // if absent, this property defaults to true
          blockInfo.isEdgeActivated = true;
        }

        blockJSON.outputShape = KidBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.nextStatement = null; // null = available connection; undefined = terminal

        break;

      case BlockType.CONDITIONAL:
      case BlockType.LOOP:
        blockInfo.branchCount = blockInfo.branchCount || 1;
        blockJSON.outputShape = KidBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.previousStatement = null; // null = available connection; undefined = hat

        if (!blockInfo.isTerminal) {
          blockJSON.nextStatement = null; // null = available connection; undefined = terminal
        }

        break;
    }

    const blockText = Array.isArray(blockInfo.text) ? blockInfo.text : [blockInfo.text];
    let inTextNum = 0; // text for the next block "arm" is blockText[inTextNum]

    let inBranchNum = 0; // how many branches have we placed into the JSON so far?

    let outLineNum = 0; // used for scratch-blocks `message${outLineNum}` and `args${outLineNum}`

    const convertPlaceholders = this._convertPlaceholders.bind(this, context);

    const extensionMessageContext = this.makeMessageContextForTarget(); // alternate between a block "arm" with text on it and an open slot for a substack

    while (inTextNum < blockText.length || inBranchNum < blockInfo.branchCount) {
      if (inTextNum < blockText.length) {
        context.outLineNum = outLineNum;
        const lineText = maybeFormatMessage(blockText[inTextNum], extensionMessageContext);
        const convertedText = lineText.replace(/\[(.+?)]/g, convertPlaceholders);

        if (blockJSON[`message${outLineNum}`]) {
          blockJSON[`message${outLineNum}`] += convertedText;
        } else {
          blockJSON[`message${outLineNum}`] = convertedText;
        }

        ++inTextNum;
        ++outLineNum;
      }

      if (inBranchNum < blockInfo.branchCount) {
        blockJSON[`message${outLineNum}`] = "%1";
        blockJSON[`args${outLineNum}`] = [{
          type: "input_statement",
          name: `SUBSTACK${inBranchNum > 0 ? inBranchNum + 1 : ""}`
        }];
        ++inBranchNum;
        ++outLineNum;
      }
    }

    if (blockInfo.blockType === BlockType.REPORTER) {
      if (!blockInfo.disableMonitor && context.inputList.length === 0) {
        blockJSON.checkboxInFlyout = true;
      }
    } else if (blockInfo.blockType === BlockType.LOOP) {
      // Add icon to the bottom right of a loop block
      blockJSON[`lastDummyAlign${outLineNum}`] = "RIGHT";
      blockJSON[`message${outLineNum}`] = "%1";
      blockJSON[`args${outLineNum}`] = [{
        type: "field_image",
        src: "./static/blocks-media/repeat.svg",
        // TODO: use a constant or make this configurable?
        width: 24,
        height: 24,
        alt: "*",
        // TODO remove this since we don't use collapsed blocks in scratch
        flip_rtl: true
      }];
      ++outLineNum;
    }

    const mutation = blockInfo.isDynamic ? `<mutation blockInfo="${Utility.xmlEscape(JSON.stringify(blockInfo))}"/>` : "";
    const inputs = context.inputList.join("");
    const blockXML = `<block type="${extendedOpcode}">${mutation}${inputs}</block>`;
    return {
      info: context.blockInfo,
      json: context.blockJSON,
      xml: blockXML
    };
  }
  /**
   * Generate a separator between blocks categories or sub-categories.
   * @param {ExtensionBlockMetadata} blockInfo - the block to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */


  _convertSeparatorForScratchBlocks(blockInfo) {
    return {
      info: blockInfo,
      xml: '<sep gap="36"/>'
    };
  }
  /**
   * Convert a button for scratch-blocks. A button has no opcode but specifies a callback name in the `func` field.
   * @param {ExtensionBlockMetadata} buttonInfo - the button to convert
   * @property {string} func - the callback name
   * @param {CategoryInfo} categoryInfo - the category for this button
   * @returns {ConvertedBlockInfo} - the converted & original button information
   * @private
   */


  _convertButtonForScratchBlocks(buttonInfo) {
    // for now we only support these pre-defined callbacks handled in scratch-blocks
    const supportedCallbackKeys = ["MAKE_A_LIST", "MAKE_A_PROCEDURE", "MAKE_A_VARIABLE"];

    if (supportedCallbackKeys.indexOf(buttonInfo.func) < 0) {
      console.error(`Custom button callbacks not supported yet: ${buttonInfo.func}`);
    }

    const extensionMessageContext = this.makeMessageContextForTarget();
    const buttonText = maybeFormatMessage(buttonInfo.text, extensionMessageContext);
    return {
      info: buttonInfo,
      xml: `<button text="${buttonText}" callbackKey="${buttonInfo.func}"></button>`
    };
  }
  /**
   * Helper for _convertPlaceholdes which handles inline images which are a specialized case of block "arguments".
   * @param {object} argInfo Metadata about the inline image as specified by the extension
   * @return {object} JSON blob for a scratch-blocks image field.
   * @private
   */


  _constructInlineImageJson(argInfo) {
    if (!argInfo.dataURI) {
      console.warn("Missing data URI in extension block with argument type IMAGE");
    }

    return {
      type: "field_image",
      src: argInfo.dataURI || "",
      // TODO these probably shouldn't be hardcoded...?
      width: 24,
      height: 24,
      // Whether or not the inline image should be flipped horizontally
      // in RTL languages. Defaults to false, indicating that the
      // image will not be flipped.
      flip_rtl: argInfo.flipRTL || false
    };
  }
  /**
   * Helper for _convertForScratchBlocks which handles linearization of argument placeholders. Called as a callback
   * from string#replace. In addition to the return value the JSON and XML items in the context will be filled.
   * @param {object} context - information shared with _convertForScratchBlocks about the block, etc.
   * @param {string} match - the overall string matched by the placeholder regex, including brackets: '[FOO]'.
   * @param {string} placeholder - the name of the placeholder being matched: 'FOO'.
   * @return {string} scratch-blocks placeholder for the argument: '%1'.
   * @private
   */


  _convertPlaceholders(context, match, placeholder) {
    // Sanitize the placeholder to ensure valid XML
    placeholder = placeholder.replace(/[<"&]/, "_"); // Determine whether the argument type is one of the known standard field types

    const argInfo = context.blockInfo.arguments[placeholder] || {};
    let argTypeInfo = ArgumentTypeMap[argInfo.type] || {}; // Field type not a standard field type, see if extension has registered custom field type

    if (!ArgumentTypeMap[argInfo.type] && context.categoryInfo.customFieldTypes[argInfo.type]) {
      argTypeInfo = context.categoryInfo.customFieldTypes[argInfo.type].argumentTypeInfo;
    } // Start to construct the scratch-blocks style JSON defining how the block should be
    // laid out


    let argJSON; // Most field types are inputs (slots on the block that can have other blocks plugged into them)
    // check if this is not one of those cases. E.g. an inline image on a block.

    if (argTypeInfo.fieldType === "field_image") {
      argJSON = this._constructInlineImageJson(argInfo);
    } else {
      // Construct input value
      // Layout a block argument (e.g. an input slot on the block)
      argJSON = {
        type: "input_value",
        name: placeholder
      };
      const defaultValue = typeof argInfo.defaultValue === "undefined" ? "" : Utility.xmlEscape(maybeFormatMessage(argInfo.defaultValue, this.makeMessageContextForTarget()).toString());

      if (argTypeInfo.check) {
        // Right now the only type of 'check' we have specifies that the
        // input slot on the block accepts Boolean reporters, so it should be
        // shaped like a hexagon
        argJSON.check = argTypeInfo.check;
      }

      let valueName;
      let shadowType;
      let fieldName;

      if (argInfo.menu) {
        const menuInfo = context.categoryInfo.menuInfo[argInfo.menu];

        if (menuInfo.acceptReporters) {
          valueName = placeholder;
          shadowType = this._makeExtensionMenuId(argInfo.menu, context.categoryInfo.id);
          fieldName = argInfo.menu;
        } else {
          argJSON.type = "field_dropdown";
          argJSON.options = this._convertMenuItems(menuInfo.items);
          valueName = null;
          shadowType = null;
          fieldName = placeholder;
        }
      } else {
        valueName = placeholder;
        shadowType = argTypeInfo.shadow && argTypeInfo.shadow.type || null;
        fieldName = argTypeInfo.shadow && argTypeInfo.shadow.fieldName || null;
      } // <value> is the ScratchBlocks name for a block input.


      if (valueName) {
        context.inputList.push(`<value name="${placeholder}">`);
      } // The <shadow> is a placeholder for a reporter and is visible when there's no reporter in this input.
      // Boolean inputs don't need to specify a shadow in the XML.


      if (shadowType) {
        context.inputList.push(`<shadow type="${shadowType}">`);
      } // A <field> displays a dynamic value: a user-editable text field, a drop-down menu, etc.
      // Leave out the field if defaultValue or fieldName are not specified


      if (defaultValue && fieldName) {
        context.inputList.push(`<field name="${fieldName}">${defaultValue}</field>`);
      }

      if (shadowType) {
        context.inputList.push("</shadow>");
      }

      if (valueName) {
        context.inputList.push("</value>");
      }
    }

    const argsName = `args${context.outLineNum}`;
    const blockArgs = context.blockJSON[argsName] = context.blockJSON[argsName] || [];
    if (argJSON) blockArgs.push(argJSON);
    const argNum = blockArgs.length;
    context.argsMap[placeholder] = argNum;
    return `%${argNum}`;
  }
  /**
   * @returns {Array.<object>} scratch-blocks XML for each category of extension blocks, in category order.
   * @param {?Target} [target] - the active editing target (optional)
   * @property {string} id - the category / extension ID
   * @property {string} xml - the XML text for this category, starting with `<category>` and ending with `</category>`
   */


  getBlocksXML(target) {
    return this._blockInfo.map(categoryInfo => {
      const {
        name,
        color1,
        color2
      } = categoryInfo; // Filter out blocks that aren't supposed to be shown on this target, as determined by the block info's
      // `hideFromPalette` and `filter` properties.

      const paletteBlocks = categoryInfo.blocks.filter(block => {
        let blockFilterIncludesTarget = true; // If an editing target is not passed, include all blocks
        // If the block info doesn't include a `filter` property, always include it

        if (target && block.info.filter) {
          blockFilterIncludesTarget = block.info.filter.includes(target.isStage ? TargetType.STAGE : TargetType.SPRITE);
        } // If the block info's `hideFromPalette` is true, then filter out this block


        return blockFilterIncludesTarget && !block.info.hideFromPalette;
      });
      const colorXML = `colour="${color1}" secondaryColour="${color2}"`; // Use a menu icon if there is one. Otherwise, use the block icon. If there's no icon,
      // the category menu will show its default colored circle.

      let menuIconURI = "";

      if (categoryInfo.menuIconURI) {
        menuIconURI = categoryInfo.menuIconURI;
      } else if (categoryInfo.blockIconURI) {
        menuIconURI = categoryInfo.blockIconURI;
      }

      const menuIconXML = menuIconURI ? `iconURI="${menuIconURI}"` : "";
      let statusButtonXML = "";

      if (categoryInfo.showStatusButton) {
        statusButtonXML = 'showStatusButton="true"';
      }

      return {
        id: categoryInfo.id,
        xml: `<category name="${name}" id="${categoryInfo.id}" ${statusButtonXML} ${colorXML} ${menuIconXML}>${paletteBlocks.map(block => block.xml).join("")}</category>`
      };
    });
  }
  /**
   * @returns {Array.<string>} - an array containing the scratch-blocks JSON information for each dynamic block.
   */


  getBlocksJSON() {
    return this._blockInfo.reduce((result, categoryInfo) => result.concat(categoryInfo.blocks.map(blockInfo => blockInfo.json)), []);
  }
  /**
   * Get a scratch link socket.
   * @param {string} type Either BLE or BT
   * @returns {ScratchLinkSocket} The scratch link socket.
   */


  getScratchLinkSocket(type) {
    const factory = this._linkSocketFactory || this._defaultScratchLinkSocketFactory;
    return factory(type);
  }
  /**
   * Configure how ScratchLink sockets are created. Factory must consume a "type" parameter
   * either BT or BLE.
   * @param {Function} factory The new factory for creating ScratchLink sockets.
   */


  configureScratchLinkSocketFactory(factory) {
    this._linkSocketFactory = factory;
  }
  /**
   * The default scratch link socket creator, using websockets to the installed device manager.
   * @param {string} type Either BLE or BT
   * @returns {ScratchLinkSocket} The new scratch link socket (a WebSocket object)
   */


  _defaultScratchLinkSocketFactory(type) {
    return new ScratchLinkWebSocket(type);
  }
  /**
   * Register an extension that communications with a hardware peripheral by id,
   * to have access to it and its peripheral functions in the future.
   * @param {string} extensionId - the id of the extension.
   * @param {object} extension - the extension to register.
   */


  registerPeripheralExtension(extensionId, extension) {
    this.peripheralExtensions[extensionId] = extension;
  }
  /**
   * Tell the specified extension to scan for a peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  scanForPeripheral(extensionId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].scan();
    }
  }
  /**
   * Connect to the extension's specified peripheral.
   * @param {string} extensionId - the id of the extension.
   * @param {number} peripheralId - the id of the peripheral.
   */


  connectPeripheral(extensionId, peripheralId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].connect(peripheralId);
    }
  }
  /**
   * Disconnect from the extension's connected peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  disconnectPeripheral(extensionId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].disconnect();
    }
  }
  /**
   * Returns whether the extension has a currently connected peripheral.
   * @param {string} extensionId - the id of the extension.
   * @return {boolean} - whether the extension has a connected peripheral.
   */


  getPeripheralIsConnected(extensionId) {
    let isConnected = false;

    if (this.peripheralExtensions[extensionId]) {
      isConnected = this.peripheralExtensions[extensionId].isConnected();
    }

    return isConnected;
  }
  /**
   * Emit an event to indicate that the microphone is being used to stream audio.
   * @param {boolean} listening - true if the microphone is currently listening.
   */


  emitMicListening(listening) {
    this.emit(Runtime.MIC_LISTENING, listening);
  }
  /**
   * Retrieve the function associated with the given opcode.
   * @param {!string} opcode The opcode to look up.
   * @return {Function} The function which implements the opcode.
   */


  getOpcodeFunction(opcode) {
    return this._primitives[opcode];
  }
  /**
   * Return whether an opcode represents a hat block.
   * @param {!string} opcode The opcode to look up.
   * @return {boolean} True if the op is known to be a hat.
   */


  getIsHat(opcode) {
    return this._hats.hasOwnProperty(opcode);
  }
  /**
   * Return whether an opcode represents an edge-activated hat block.
   * @param {!string} opcode The opcode to look up.
   * @return {boolean} True if the op is known to be a edge-activated hat.
   */


  getIsEdgeActivatedHat(opcode) {
    return this._hats.hasOwnProperty(opcode) && this._hats[opcode].edgeActivated;
  }
  /**
   * Attach the audio engine
   * @param {!AudioEngine} audioEngine The audio engine to attach
   */


  attachAudioEngine(audioEngine) {
    this.audioEngine = audioEngine;
  }
  /**
   * Attach the renderer
   * @param {!RenderWebGL} renderer The renderer to attach
   */


  attachRenderer(renderer) {
    console.warn("runtime.js 关联 renderer", renderer);
    this.renderer = renderer;
    this.renderer.setLayerGroupOrdering(StageLayering.LAYER_GROUPS);
  }
  /**
   * 设置svg适配器，将scratch 2 svgs转换为scratch 3 svgs
   * @param {!SvgRenderer} svgAdapter The adapter to attach
   */


  attachV2SVGAdapter(svgAdapter) {
    console.log("设置svg适配器，将scratch 2 svgs转换为scratch 3 svgs:", svgAdapter);
    this.v2SvgAdapter = svgAdapter;
  }
  /**
   * 设置VM /运行时的位图适配器，该适配器将草稿2位图转换为草稿3位图。 （从头开始的3个位图都是位图分辨率2）
   * @param {!function} bitmapAdapter The adapter to attach
   */


  attachV2BitmapAdapter(bitmapAdapter) {
    this.v2BitmapAdapter = bitmapAdapter;
  }
  /**
   * 连接存储模块
   * @param {!Storage} storage 要附加的存储模块
   */


  attachStorage(storage) {
    console.log("连接存储模块", storage);
    this.storage = storage;
  } // -----------------------------------------------------------------------------
  // -----------------------------------------------------------------------------

  /**
   * 创建一个线程并将其推送到线程列表.
   * @param {!string} id 启动堆栈的块的ID.
   * @param {!Target} target 目标在其上运行线程.
   * @param {?object} opts 可选参数
   * @param {?boolean} opts.stackClick 如果脚本是通过单击堆栈激活的，则返回true
   * @param {?boolean} opts.updateMonitor 如果脚本应更新监视器值，则为true
   * @return {!Thread} 新创建的线程.
   */


  _pushThread(id, target, opts) {
    const thread = new Thread(id);
    thread.target = target;
    thread.stackClick = Boolean(opts && opts.stackClick);
    thread.updateMonitor = Boolean(opts && opts.updateMonitor);
    thread.blockContainer = thread.updateMonitor ? this.monitorBlocks : target.blocks;
    thread.pushStack(id);
    this.threads.push(thread);
    return thread;
  }
  /**
   * Stop a thread: stop running it immediately, and remove it from the thread list later.
   * @param {!Thread} thread Thread object to remove from actives
   */


  _stopThread(thread) {
    // Mark the thread for later removal
    thread.isKilled = true; // Inform sequencer to stop executing that thread.

    this.sequencer.retireThread(thread);
  }
  /**
   * Restart a thread in place, maintaining its position in the list of threads.
   * This is used by `startHats` to and is necessary to ensure 2.0-like execution order.
   * Test project: https://scratch.mit.edu/projects/130183108/
   * @param {!Thread} thread Thread object to restart.
   * @return {Thread} The restarted thread.
   */


  _restartThread(thread) {
    const newThread = new Thread(thread.topBlock);
    newThread.target = thread.target;
    newThread.stackClick = thread.stackClick;
    newThread.updateMonitor = thread.updateMonitor;
    newThread.blockContainer = thread.blockContainer;
    newThread.pushStack(thread.topBlock);
    const i = this.threads.indexOf(thread);

    if (i > -1) {
      this.threads[i] = newThread;
      return newThread;
    }

    this.threads.push(thread);
    return thread;
  }
  /**
   * Return whether a thread is currently active/running.
   * @param {?Thread} thread Thread object to check.
   * @return {boolean} True if the thread is active/running.
   */


  isActiveThread(thread) {
    return thread.stack.length > 0 && thread.status !== Thread.STATUS_DONE && this.threads.indexOf(thread) > -1;
  }
  /**
   * Return whether a thread is waiting for more information or done.
   * @param {?Thread} thread Thread object to check.
   * @return {boolean} True if the thread is waiting
   */


  isWaitingThread(thread) {
    return thread.status === Thread.STATUS_PROMISE_WAIT || thread.status === Thread.STATUS_YIELD_TICK || !this.isActiveThread(thread);
  }
  /**
   * Toggle a script.
   * @param {!string} topBlockId ID of block that starts the script.
   * @param {?object} opts optional arguments to toggle script
   * @param {?string} opts.target target ID for target to run script on. If not supplied, uses editing target.
   * @param {?boolean} opts.stackClick true if the user activated the stack by clicking, false if not. This
   *     determines whether we show a visual report when turning on the script.
   */


  toggleScript(topBlockId, opts) {
    opts = Object.assign({
      target: this._editingTarget,
      stackClick: false
    }, opts); // Remove any existing thread.

    for (let i = 0; i < this.threads.length; i++) {
      // Toggling a script that's already running turns it off
      if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE) {
        const blockContainer = opts.target.blocks;
        const opcode = blockContainer.getOpcode(blockContainer.getBlock(topBlockId));

        if (this.getIsEdgeActivatedHat(opcode) && this.threads[i].stackClick !== opts.stackClick) {
          // Allow edge activated hat thread stack click to coexist with
          // edge activated hat thread that runs every frame
          continue;
        }

        this._stopThread(this.threads[i]);

        return;
      }
    } // Otherwise add it.


    this._pushThread(topBlockId, opts.target, opts);
  }
  /**
   * Enqueue a script that when finished will update the monitor for the block.
   * @param {!string} topBlockId ID of block that starts the script.
   * @param {?Target} optTarget target Target to run script on. If not supplied, uses editing target.
   */


  addMonitorScript(topBlockId, optTarget) {
    if (!optTarget) optTarget = this._editingTarget;

    for (let i = 0; i < this.threads.length; i++) {
      // Don't re-add the script if it's already running
      if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE && this.threads[i].updateMonitor) {
        return;
      }
    } // Otherwise add it.


    this._pushThread(topBlockId, optTarget, {
      updateMonitor: true
    });
  }
  /**
   * Run a function `f` for all scripts in a workspace.
   * `f` will be called with two parameters:
   *  - the top block ID of the script.
   *  - the target that owns the script.
   * @param {!Function} f Function to call for each script.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   */


  allScriptsDo(f, optTarget) {
    let targets = this.executableTargets;

    if (optTarget) {
      targets = [optTarget];
    }

    for (let t = targets.length - 1; t >= 0; t--) {
      const target = targets[t];
      const scripts = target.blocks.getScripts();

      for (let j = 0; j < scripts.length; j++) {
        const topBlockId = scripts[j];
        f(topBlockId, target);
      }
    }
  }

  allScriptsByOpcodeDo(opcode, f, optTarget) {
    let targets = this.executableTargets;

    if (optTarget) {
      targets = [optTarget];
    }

    for (let t = targets.length - 1; t >= 0; t--) {
      const target = targets[t];
      const scripts = BlocksRuntimeCache.getScripts(target.blocks, opcode);

      for (let j = 0; j < scripts.length; j++) {
        f(scripts[j], target);
      }
    }
  }
  /**
   * Start all relevant hats.
   * @param {!string} requestedHatOpcode Opcode of hats to start.
   * @param {object=} optMatchFields Optionally, fields to match on the hat.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   * @return {Array.<Thread>} List of threads started by this function.
   */


  startHats(requestedHatOpcode, optMatchFields, optTarget) {
    if (!this._hats.hasOwnProperty(requestedHatOpcode)) {
      // No known hat with this opcode.
      return;
    }

    const instance = this;
    const newThreads = []; // Look up metadata for the relevant hat.

    const hatMeta = instance._hats[requestedHatOpcode];

    for (const opts in optMatchFields) {
      if (!optMatchFields.hasOwnProperty(opts)) continue;
      optMatchFields[opts] = optMatchFields[opts].toUpperCase();
    } // Consider all scripts, looking for hats with opcode `requestedHatOpcode`.


    this.allScriptsByOpcodeDo(requestedHatOpcode, (script, target) => {
      const {
        blockId: topBlockId,
        fieldsOfInputs: hatFields
      } = script; // Match any requested fields.
      // For example: ensures that broadcasts match.
      // This needs to happen before the block is evaluated
      // (i.e., before the predicate can be run) because "broadcast and wait"
      // needs to have a precise collection of started threads.

      for (const matchField in optMatchFields) {
        if (hatFields[matchField].value !== optMatchFields[matchField]) {
          // Field mismatch.
          return;
        }
      }

      if (hatMeta.restartExistingThreads) {
        // If `restartExistingThreads` is true, we should stop
        // any existing threads starting with the top block.
        for (let i = 0; i < this.threads.length; i++) {
          if (this.threads[i].target === target && this.threads[i].topBlock === topBlockId && // stack click threads and hat threads can coexist
          !this.threads[i].stackClick) {
            newThreads.push(this._restartThread(this.threads[i]));
            return;
          }
        }
      } else {
        // If `restartExistingThreads` is false, we should
        // give up if any threads with the top block are running.
        for (let j = 0; j < this.threads.length; j++) {
          if (this.threads[j].target === target && this.threads[j].topBlock === topBlockId && // stack click threads and hat threads can coexist
          !this.threads[j].stackClick && this.threads[j].status !== Thread.STATUS_DONE) {
            // Some thread is already running.
            return;
          }
        }
      } // Start the thread with this top block.


      newThreads.push(this._pushThread(topBlockId, target));
    }, optTarget); // For compatibility with Scratch 2, edge triggered hats need to be processed before
    // threads are stepped. See ScratchRuntime.as for original implementation

    newThreads.forEach(thread => {
      execute(this.sequencer, thread);
      thread.goToNextBlock();
    });
    return newThreads;
  }
  /**
   * Dispose all targets. Return to clean state.
   */


  dispose() {
    this.stopAll(); // Deleting each target's variable's monitors.

    this.targets.forEach(target => {
      if (target.isOriginal) target.deleteMonitors();
    });
    this.targets.map(this.disposeTarget, this);
    this._monitorState = OrderedMap({});
    this.emit(Runtime.RUNTIME_DISPOSED);
    this.ioDevices.clock.resetProjectTimer(); // @todo clear out extensions? turboMode? etc.
    // *********** Cloud *******************
    // If the runtime currently has cloud data,
    // emit a has cloud data update event resetting
    // it to false

    if (this.hasCloudData()) {
      this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);
    }

    this.ioDevices.cloud.clear(); // Reset runtime cloud data info

    const newCloudDataManager = cloudDataManager();
    this.hasCloudData = newCloudDataManager.hasCloudVariables;
    this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;
    this.addCloudVariable = this._initializeAddCloudVariable(newCloudDataManager);
    this.removeCloudVariable = this._initializeRemoveCloudVariable(newCloudDataManager);
  }
  /**
   *将目标添加到运行时。 这将跟踪目标的子画面窗格排序。 调用此函数后，仍然需要将目标置于正确的执行顺序中.
   * @param {Target} target target to add
   */


  addTarget(target) {
    console.log("runtime.js addTarget()", target);
    this.targets.push(target);
    this.executableTargets.push(target);
  }
  /**
   * Move a target in the execution order by a relative amount.
   *
   * A positve number will make the target execute earlier. A negative number
   * will make the target execute later in the order.
   *
   * @param {Target} executableTarget target to move
   * @param {number} delta number of positions to move target by
   * @returns {number} new position in execution order
   */


  moveExecutable(executableTarget, delta) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);
    this.executableTargets.splice(oldIndex, 1);
    let newIndex = oldIndex + delta;

    if (newIndex > this.executableTargets.length) {
      newIndex = this.executableTargets.length;
    }

    if (newIndex <= 0) {
      if (this.executableTargets.length > 0 && this.executableTargets[0].isStage) {
        newIndex = 1;
      } else {
        newIndex = 0;
      }
    }

    this.executableTargets.splice(newIndex, 0, executableTarget);
    return newIndex;
  }
  /**
   * Set a target to execute at a specific position in the execution order.
   *
   * Infinity will set the target to execute first. 0 will set the target to
   * execute last (before the stage).
   *
   * @param {Target} executableTarget target to move
   * @param {number} newIndex position in execution order to place the target
   * @returns {number} new position in the execution order
   */


  setExecutablePosition(executableTarget, newIndex) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);
    return this.moveExecutable(executableTarget, newIndex - oldIndex);
  }
  /**
   * Remove a target from the execution set.
   * @param {Target} executableTarget target to remove
   */


  removeExecutable(executableTarget) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);

    if (oldIndex > -1) {
      this.executableTargets.splice(oldIndex, 1);
    }
  }
  /**
   * Dispose of a target.
   * @param {!Target} disposingTarget Target to dispose of.
   */


  disposeTarget(disposingTarget) {
    this.targets = this.targets.filter(target => {
      if (disposingTarget !== target) return true; // Allow target to do dispose actions.

      target.dispose(); // Remove from list of targets.

      return false;
    });
  }
  /**
   * Stop any threads acting on the target.
   * @param {!Target} target Target to stop threads for.
   * @param {Thread=} optThreadException Optional thread to skip.
   */


  stopForTarget(target, optThreadException) {
    // Emit stop event to allow blocks to clean up any state.
    this.emit(Runtime.STOP_FOR_TARGET, target, optThreadException); // Stop any threads on the target.

    for (let i = 0; i < this.threads.length; i++) {
      if (this.threads[i] === optThreadException) {
        continue;
      }

      if (this.threads[i].target === target) {
        this._stopThread(this.threads[i]);
      }
    }
  }
  /**
   * Start all threads that start with the green flag.
   */


  greenFlag() {
    this.stopAll();
    this.emit(Runtime.PROJECT_START);
    this.ioDevices.clock.resetProjectTimer();
    this.targets.forEach(target => target.clearEdgeActivatedValues()); // Inform all targets of the green flag.

    for (let i = 0; i < this.targets.length; i++) {
      this.targets[i].onGreenFlag();
    }

    this.startHats("event_whenflagclicked");
  }
  /**
   * Stop "everything."
   */


  stopAll() {
    // Emit stop event to allow blocks to clean up any state.
    this.emit(Runtime.PROJECT_STOP_ALL); // Dispose all clones.

    const newTargets = [];

    for (let i = 0; i < this.targets.length; i++) {
      this.targets[i].onStopAll();

      if (this.targets[i].hasOwnProperty("isOriginal") && !this.targets[i].isOriginal) {
        this.targets[i].dispose();
      } else {
        newTargets.push(this.targets[i]);
      }
    }

    this.targets = newTargets; // Dispose of the active thread.

    if (this.sequencer.activeThread !== null) {
      this._stopThread(this.sequencer.activeThread);
    } // Remove all remaining threads from executing in the next tick.


    this.threads = [];
  }
  /**
   * Repeatedly run `sequencer.stepThreads` and filter out
   * inactive threads after each iteration.
   */


  _step() {
    if (this.profiler !== null) {
      if (stepProfilerId === -1) {
        stepProfilerId = this.profiler.idByName("Runtime._step");
      }

      this.profiler.start(stepProfilerId);
    } // Clean up threads that were told to stop during or since the last step


    this.threads = this.threads.filter(thread => !thread.isKilled); // Find all edge-activated hats, and add them to threads to be evaluated.

    for (const hatType in this._hats) {
      if (!this._hats.hasOwnProperty(hatType)) continue;
      const hat = this._hats[hatType];

      if (hat.edgeActivated) {
        this.startHats(hatType);
      }
    }

    this.redrawRequested = false;

    this._pushMonitors();

    if (this.profiler !== null) {
      if (stepThreadsProfilerId === -1) {
        stepThreadsProfilerId = this.profiler.idByName("Sequencer.stepThreads");
      }

      this.profiler.start(stepThreadsProfilerId);
    }

    const doneThreads = this.sequencer.stepThreads();

    if (this.profiler !== null) {
      this.profiler.stop();
    }

    this._updateGlows(doneThreads); // Add done threads so that even if a thread finishes within 1 frame, the green
    // flag will still indicate that a script ran.


    this._emitProjectRunStatus(this.threads.length + doneThreads.length - this._getMonitorThreadCount([...this.threads, ...doneThreads])); // Store threads that completed this iteration for testing and other
    // internal purposes.


    this._lastStepDoneThreads = doneThreads;

    if (this.renderer) {
      // @todo: Only render when this.redrawRequested or clones rendered.
      if (this.profiler !== null) {
        if (rendererDrawProfilerId === -1) {
          rendererDrawProfilerId = this.profiler.idByName("RenderWebGL.draw");
        }

        this.profiler.start(rendererDrawProfilerId);
      }

      this.renderer.draw();

      if (this.profiler !== null) {
        this.profiler.stop();
      }
    }

    if (this._refreshTargets) {
      this.emit(Runtime.TARGETS_UPDATE, false
      /* Don't emit project changed */
      );
      this._refreshTargets = false;
    }

    if (!this._prevMonitorState.equals(this._monitorState)) {
      this.emit(Runtime.MONITORS_UPDATE, this._monitorState);
      this._prevMonitorState = this._monitorState;
    }

    if (this.profiler !== null) {
      this.profiler.stop();
      this.profiler.reportFrames();
    }
  }
  /**
   * Get the number of threads in the given array that are monitor threads (threads
   * that update monitor values, and don't count as running a script).
   * @param {!Array.<Thread>} threads The set of threads to look through.
   * @return {number} The number of monitor threads in threads.
   */


  _getMonitorThreadCount(threads) {
    let count = 0;
    threads.forEach(thread => {
      if (thread.updateMonitor) count++;
    });
    return count;
  }
  /**
   * Queue monitor blocks to sequencer to be run.
   */


  _pushMonitors() {
    this.monitorBlocks.runAllMonitored(this);
  }
  /**
   * 设置运行时已知的当前编辑目标.
   * @param {!Target} editingTarget New editing target.
   */


  setEditingTarget(editingTarget) {
    const oldEditingTarget = this._editingTarget;
    this._editingTarget = editingTarget; // 必须清除脚本发光.

    this._scriptGlowsPreviousFrame = [];

    this._updateGlows();

    if (oldEditingTarget !== this._editingTarget) {
      this.requestToolboxExtensionsUpdate();
    }
  }
  /**
   * Set whether we are in 30 TPS compatibility mode.
   * @param {boolean} compatibilityModeOn True iff in compatibility mode.
   */


  setCompatibilityMode(compatibilityModeOn) {
    this.compatibilityMode = compatibilityModeOn;

    if (this._steppingInterval) {
      clearInterval(this._steppingInterval);
      this._steppingInterval = null;
      this.start();
    }
  }
  /**
   * Emit glows/glow clears for scripts after a single tick.
   * Looks at `this.threads` and notices which have turned on/off new glows.
   * @param {Array.<Thread>=} optExtraThreads Optional list of inactive threads.
   */


  _updateGlows(optExtraThreads) {
    const searchThreads = [];
    searchThreads.push.apply(searchThreads, this.threads);

    if (optExtraThreads) {
      searchThreads.push.apply(searchThreads, optExtraThreads);
    } // Set of scripts that request a glow this frame.


    const requestedGlowsThisFrame = []; // Final set of scripts glowing during this frame.

    const finalScriptGlows = []; // Find all scripts that should be glowing.

    for (let i = 0; i < searchThreads.length; i++) {
      const thread = searchThreads[i];
      const target = thread.target;

      if (target === this._editingTarget) {
        const blockForThread = thread.blockGlowInFrame;

        if (thread.requestScriptGlowInFrame || thread.stackClick) {
          let script = target.blocks.getTopLevelScript(blockForThread);

          if (!script) {
            // Attempt to find in flyout blocks.
            script = this.flyoutBlocks.getTopLevelScript(blockForThread);
          }

          if (script) {
            requestedGlowsThisFrame.push(script);
          }
        }
      }
    } // Compare to previous frame.


    for (let j = 0; j < this._scriptGlowsPreviousFrame.length; j++) {
      const previousFrameGlow = this._scriptGlowsPreviousFrame[j];

      if (requestedGlowsThisFrame.indexOf(previousFrameGlow) < 0) {
        // Glow turned off.
        this.glowScript(previousFrameGlow, false);
      } else {
        // Still glowing.
        finalScriptGlows.push(previousFrameGlow);
      }
    }

    for (let k = 0; k < requestedGlowsThisFrame.length; k++) {
      const currentFrameGlow = requestedGlowsThisFrame[k];

      if (this._scriptGlowsPreviousFrame.indexOf(currentFrameGlow) < 0) {
        // Glow turned on.
        this.glowScript(currentFrameGlow, true);
        finalScriptGlows.push(currentFrameGlow);
      }
    }

    this._scriptGlowsPreviousFrame = finalScriptGlows;
  }
  /**
   * Emit run start/stop after each tick. Emits when `this.threads.length` goes
   * between non-zero and zero
   *
   * @param {number} nonMonitorThreadCount The new nonMonitorThreadCount
   */


  _emitProjectRunStatus(nonMonitorThreadCount) {
    if (this._nonMonitorThreadCount === 0 && nonMonitorThreadCount > 0) {
      this.emit(Runtime.PROJECT_RUN_START);
    }

    if (this._nonMonitorThreadCount > 0 && nonMonitorThreadCount === 0) {
      this.emit(Runtime.PROJECT_RUN_STOP);
    }

    this._nonMonitorThreadCount = nonMonitorThreadCount;
  }
  /**
   * "Quiet" a script's glow: stop the VM from generating glow/unglow events
   * about that script. Use when a script has just been deleted, but we may
   * still be tracking glow data about it.
   * @param {!string} scriptBlockId Id of top-level block in script to quiet.
   */


  quietGlow(scriptBlockId) {
    const index = this._scriptGlowsPreviousFrame.indexOf(scriptBlockId);

    if (index > -1) {
      this._scriptGlowsPreviousFrame.splice(index, 1);
    }
  }
  /**
   * Emit feedback for block glowing (used in the sequencer).
   * @param {?string} blockId ID for the block to update glow
   * @param {boolean} isGlowing True to turn on glow; false to turn off.
   */


  glowBlock(blockId, isGlowing) {
    if (isGlowing) {
      this.emit(Runtime.BLOCK_GLOW_ON, {
        id: blockId
      });
    } else {
      this.emit(Runtime.BLOCK_GLOW_OFF, {
        id: blockId
      });
    }
  }
  /**
   * Emit feedback for script glowing.
   * @param {?string} topBlockId ID for the top block to update glow
   * @param {boolean} isGlowing True to turn on glow; false to turn off.
   */


  glowScript(topBlockId, isGlowing) {
    if (isGlowing) {
      this.emit(Runtime.SCRIPT_GLOW_ON, {
        id: topBlockId
      });
    } else {
      this.emit(Runtime.SCRIPT_GLOW_OFF, {
        id: topBlockId
      });
    }
  }
  /**
   * Emit whether blocks are being dragged over gui
   * @param {boolean} areBlocksOverGui True if blocks are dragged out of blocks workspace, false otherwise
   */


  emitBlockDragUpdate(areBlocksOverGui) {
    this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);
  }
  /**
   * Emit event to indicate that the block drag has ended with the blocks outside the blocks workspace
   * @param {Array.<object>} blocks The set of blocks dragged to the GUI
   * @param {string} topBlockId The original id of the top block being dragged
   */


  emitBlockEndDrag(blocks, topBlockId) {
    this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);
  }
  /**
   * Emit value for reporter to show in the blocks.
   * @param {string} blockId ID for the block.
   * @param {string} value Value to show associated with the block.
   */


  visualReport(blockId, value) {
    this.emit(Runtime.VISUAL_REPORT, {
      id: blockId,
      value: String(value)
    });
  }
  /**
   * Add a monitor to the state. If the monitor already exists in the state,
   * updates those properties that are defined in the given monitor record.
   * @param {!MonitorRecord} monitor Monitor to add.
   */


  requestAddMonitor(monitor) {
    const id = monitor.get("id");

    if (!this.requestUpdateMonitor(monitor)) {
      // update monitor if it exists in the state
      // if the monitor did not exist in the state, add it
      this._monitorState = this._monitorState.set(id, monitor);
    }
  }
  /**
   * 更新状态中的监视器并报告更新成功/失败.
   * @param {!Map} monitor 监视值以更新。 监视器上的值被具有相同ID的旧监视器上的值覆盖。 如果在新监视器上未定义值，则旧监视器将保留其旧值.
   * @return {boolean} 如果状态中存在监视器并且已更新监视器，则为true；否则，则为false.
   */


  requestUpdateMonitor(monitor) {
    const id = monitor.get("id");

    if (this._monitorState.has(id)) {
      this._monitorState = // 在此处使用mergeWith防止未定义的值覆盖现有的值
      this._monitorState.set(id, this._monitorState.get(id).mergeWith((prev, next) => {
        if (typeof next === "undefined" || next === null) {
          return prev;
        }

        return next;
      }, monitor));
      return true;
    }

    return false;
  }
  /**
   * Removes a monitor from the state. Does nothing if the monitor already does
   * not exist in the state.
   * @param {!string} monitorId ID of the monitor to remove.
   */


  requestRemoveMonitor(monitorId) {
    this._monitorState = this._monitorState.delete(monitorId);
  }
  /**
   * Hides a monitor and returns success/failure of action.
   * @param {!string} monitorId ID of the monitor to hide.
   * @return {boolean} true if monitor exists and was updated, false otherwise
   */


  requestHideMonitor(monitorId) {
    return this.requestUpdateMonitor(new Map([["id", monitorId], ["visible", false]]));
  }
  /**
   * Shows a monitor and returns success/failure of action.
   * not exist in the state.
   * @param {!string} monitorId ID of the monitor to show.
   * @return {boolean} true if monitor exists and was updated, false otherwise
   */


  requestShowMonitor(monitorId) {
    return this.requestUpdateMonitor(new Map([["id", monitorId], ["visible", true]]));
  }
  /**
   * Removes all monitors with the given target ID from the state. Does nothing if
   * the monitor already does not exist in the state.
   * @param {!string} targetId Remove all monitors with given target ID.
   */


  requestRemoveMonitorByTargetId(targetId) {
    this._monitorState = this._monitorState.filterNot(value => value.targetId === targetId);
  }
  /**
   * Get a target by its id.
   * @param {string} targetId Id of target to find.
   * @return {?Target} The target, if found.
   */


  getTargetById(targetId) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];

      if (target.id === targetId) {
        return target;
      }
    }
  }
  /**
   * Get the first original (non-clone-block-created) sprite given a name.
   * @param {string} spriteName Name of sprite to look for.
   * @return {?Target} Target representing a sprite of the given name.
   */


  getSpriteTargetByName(spriteName) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];

      if (target.isStage) {
        continue;
      }

      if (target.sprite && target.sprite.name === spriteName) {
        return target;
      }
    }
  }
  /**
   * Get a target by its drawable id.
   * @param {number} drawableID drawable id of target to find
   * @return {?Target} The target, if found
   */


  getTargetByDrawableId(drawableID) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];
      if (target.drawableID === drawableID) return target;
    }
  }
  /**
   * Update the clone counter to track how many clones are created.
   * @param {number} changeAmount How many clones have been created/destroyed.
   */


  changeCloneCounter(changeAmount) {
    this._cloneCounter += changeAmount;
  }
  /**
   * 返回是否有可用克隆.
   * @return {boolean} True until the number of clones hits Runtime.MAX_CLONES.
   */


  clonesAvailable() {
    return this._cloneCounter < Runtime.MAX_CLONES;
  }
  /**
   * 报告项目已在虚拟机中加载.
   */


  emitProjectLoaded() {
    console.log("runtime.js 项目已在虚拟机中加载", Runtime.PROJECT_LOADED);
    this.emit(Runtime.PROJECT_LOADED);
  }
  /**
   * Report that the project has changed in a way that would affect serialization
   */


  emitProjectChanged() {
    this.emit(Runtime.PROJECT_CHANGED);
  }
  /**
   * Report that a new target has been created, possibly by cloning an existing target.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @fires Runtime#targetWasCreated
   */


  fireTargetWasCreated(newTarget, sourceTarget) {
    this.emit("targetWasCreated", newTarget, sourceTarget);
  }
  /**
   * Report that a clone target is being removed.
   * @param {Target} target - the target being removed
   * @fires Runtime#targetWasRemoved
   */


  fireTargetWasRemoved(target) {
    this.emit("targetWasRemoved", target);
  }
  /**
   * Get a target representing the Scratch stage, if one exists.
   * @return {?Target} The target, if found.
   */


  getTargetForStage() {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];

      if (target.isStage) {
        return target;
      }
    }
  }
  /**
   * Get the editing target.
   * @return {?Target} The editing target.
   */


  getEditingTarget() {
    return this._editingTarget;
  }

  getAllVarNamesOfType(varType) {
    let varNames = [];

    for (const target of this.targets) {
      const targetVarNames = target.getAllVariableNamesInScopeByType(varType, true);
      varNames = varNames.concat(targetVarNames);
    }

    return varNames;
  }
  /**
   * Get the label or label function for an opcode
   * @param {string} extendedOpcode - the opcode you want a label for
   * @return {object} - object with label and category
   * @property {string} category - the category for this opcode
   * @property {Function} [labelFn] - function to generate the label for this opcode
   * @property {string} [label] - the label for this opcode if `labelFn` is absent
   */


  getLabelForOpcode(extendedOpcode) {
    const [category, opcode] = StringUtil.splitFirst(extendedOpcode, "_");
    if (!(category && opcode)) return;

    const categoryInfo = this._blockInfo.find(ci => ci.id === category);

    if (!categoryInfo) return;
    const block = categoryInfo.blocks.find(b => b.info.opcode === opcode);
    if (!block) return; // TODO: we may want to format the label in a locale-specific way.

    return {
      category: "extension",
      // This assumes that all extensions have the same monitor color.
      label: `${categoryInfo.name}: ${block.info.text}`
    };
  }
  /**
   * Create a new global variable avoiding conflicts with other variable names.
   * @param {string} variableName The desired variable name for the new global variable.
   * This can be turned into a fresh name as necessary.
   * @param {string} optVarId An optional ID to use for the variable. A new one will be generated
   * if a falsey value for this parameter is provided.
   * @param {string} optVarType The type of the variable to create. Defaults to Variable.SCALAR_TYPE.
   * @return {Variable} The new variable that was created.
   */


  createNewGlobalVariable(variableName, optVarId, optVarType) {
    const varType = typeof optVarType === "string" ? optVarType : Variable.SCALAR_TYPE;
    const allVariableNames = this.getAllVarNamesOfType(varType);
    const newName = StringUtil.unusedName(variableName, allVariableNames);
    console.warn("runtime:", Utility.uid());
    const variable = new Variable(optVarId || Utility.uid(), newName, varType);
    const stage = this.getTargetForStage();
    stage.variables[variable.id] = variable;
    return variable;
  }
  /**
   * Tell the runtime to request a redraw.
   * Use after a clone/sprite has completed some visible operation on the stage.
   */


  requestRedraw() {
    this.redrawRequested = true;
  }
  /**
   * Emit a targets update at the end of the step if the provided target is
   * the original sprite
   * @param {!Target} target Target requesting the targets update
   */


  requestTargetsUpdate(target) {
    if (!target.isOriginal) return;
    this._refreshTargets = true;
  }
  /**
   * Emit an event that indicates that the blocks on the workspace need updating.
   */


  requestBlocksUpdate() {
    this.emit(Runtime.BLOCKS_NEED_UPDATE);
  }
  /**
   * Emit an event that indicates that the toolbox extension blocks need updating.
   */


  requestToolboxExtensionsUpdate() {
    this.emit(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE);
  }
  /**
   * Set up timers to repeatedly step in a browser.
   */


  start() {
    // Do not start if we are already running
    if (this._steppingInterval) return;
    let interval = Runtime.THREAD_STEP_INTERVAL;

    if (this.compatibilityMode) {
      interval = Runtime.THREAD_STEP_INTERVAL_COMPATIBILITY;
    }

    this.currentStepTime = interval;
    this._steppingInterval = setInterval(() => {
      this._step();
    }, interval);
    this.emit(Runtime.RUNTIME_STARTED);
  }
  /**
   * Turn on profiling.
   * @param {Profiler/FrameCallback} onFrame A callback handle passed a
   * profiling frame when the profiler reports its collected data.
   */


  enableProfiling(onFrame) {
    if (Profiler.available()) {
      this.profiler = new Profiler(onFrame);
    }
  }
  /**
   * Turn off profiling.
   */


  disableProfiling() {
    this.profiler = null;
  }
  /**
   * Update a millisecond timestamp value that is saved on the Runtime.
   * This value is helpful in certain instances for compatibility with Scratch 2,
   * which sometimes uses a `currentMSecs` timestamp value in Interpreter.as
   */


  updateCurrentMSecs() {
    this.currentMSecs = Date.now();
  }

}
/**
 * Event fired after a new target has been created, possibly by cloning an existing target.
 *
 * @event Runtime#targetWasCreated
 * @param {Target} newTarget - the newly created target.
 * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
 */


module.exports = Runtime;

/***/ }),

/***/ "./src/engine/sequencer.js":
/*!*********************************!*\
  !*** ./src/engine/sequencer.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const execute = __webpack_require__(/*! ./execute.js */ "./src/engine/execute.js");
/**
 * Profiler frame name for stepping a single thread.
 * @const {string}
 */


const stepThreadProfilerFrame = 'Sequencer.stepThread';
/**
 * Profiler frame name for the inner loop of stepThreads.
 * @const {string}
 */

const stepThreadsInnerProfilerFrame = 'Sequencer.stepThreads#inner';
/**
 * Profiler frame name for execute.
 * @const {string}
 */

const executeProfilerFrame = 'execute';
/**
 * Profiler frame ID for stepThreadProfilerFrame.
 * @type {number}
 */

let stepThreadProfilerId = -1;
/**
 * Profiler frame ID for stepThreadsInnerProfilerFrame.
 * @type {number}
 */

let stepThreadsInnerProfilerId = -1;
/**
 * Profiler frame ID for executeProfilerFrame.
 * @type {number}
 */

let executeProfilerId = -1;

class Sequencer {
  constructor(runtime) {
    /**
     * A utility timer for timing thread sequencing.
     * @type {!Timer}
     */
    this.timer = new Timer();
    /**
     * Reference to the runtime owning this sequencer.
     * @type {!Runtime}
     */

    this.runtime = runtime;
    this.activeThread = null;
  }
  /**
   * Time to run a warp-mode thread, in ms.
   * @type {number}
   */


  static get WARP_TIME() {
    return 500;
  }
  /**
   * Step through all threads in `this.runtime.threads`, running them in order.
   * @return {Array.<!Thread>} List of inactive threads after stepping.
   */


  stepThreads() {
    // Work time is 75% of the thread stepping interval.
    const WORK_TIME = 0.75 * this.runtime.currentStepTime; // For compatibility with Scatch 2, update the millisecond clock
    // on the Runtime once per step (see Interpreter.as in Scratch 2
    // for original use of `currentMSecs`)

    this.runtime.updateCurrentMSecs(); // Start counting toward WORK_TIME.

    this.timer.start(); // Count of active threads.

    let numActiveThreads = Infinity; // Whether `stepThreads` has run through a full single tick.

    let ranFirstTick = false;
    const doneThreads = []; // Conditions for continuing to stepping threads:
    // 1. We must have threads in the list, and some must be active.
    // 2. Time elapsed must be less than WORK_TIME.
    // 3. Either turbo mode, or no redraw has been requested by a primitive.

    while (this.runtime.threads.length > 0 && numActiveThreads > 0 && this.timer.timeElapsed() < WORK_TIME && (this.runtime.turboMode || !this.runtime.redrawRequested)) {
      if (this.runtime.profiler !== null) {
        if (stepThreadsInnerProfilerId === -1) {
          stepThreadsInnerProfilerId = this.runtime.profiler.idByName(stepThreadsInnerProfilerFrame);
        }

        this.runtime.profiler.start(stepThreadsInnerProfilerId);
      }

      numActiveThreads = 0;
      let stoppedThread = false; // Attempt to run each thread one time.

      const threads = this.runtime.threads;

      for (let i = 0; i < threads.length; i++) {
        const activeThread = this.activeThread = threads[i]; // Check if the thread is done so it is not executed.

        if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {
          // Finished with this thread.
          stoppedThread = true;
          continue;
        }

        if (activeThread.status === Thread.STATUS_YIELD_TICK && !ranFirstTick) {
          // Clear single-tick yield from the last call of `stepThreads`.
          activeThread.status = Thread.STATUS_RUNNING;
        }

        if (activeThread.status === Thread.STATUS_RUNNING || activeThread.status === Thread.STATUS_YIELD) {
          // Normal-mode thread: step.
          if (this.runtime.profiler !== null) {
            if (stepThreadProfilerId === -1) {
              stepThreadProfilerId = this.runtime.profiler.idByName(stepThreadProfilerFrame);
            } // Increment the number of times stepThread is called.


            this.runtime.profiler.increment(stepThreadProfilerId);
          }

          this.stepThread(activeThread);
          activeThread.warpTimer = null;

          if (activeThread.isKilled) {
            i--; // if the thread is removed from the list (killed), do not increase index
          }
        }

        if (activeThread.status === Thread.STATUS_RUNNING) {
          numActiveThreads++;
        } // Check if the thread completed while it just stepped to make
        // sure we remove it before the next iteration of all threads.


        if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {
          // Finished with this thread.
          stoppedThread = true;
        }
      } // We successfully ticked once. Prevents running STATUS_YIELD_TICK
      // threads on the next tick.


      ranFirstTick = true;

      if (this.runtime.profiler !== null) {
        this.runtime.profiler.stop();
      } // Filter inactive threads from `this.runtime.threads`.


      if (stoppedThread) {
        let nextActiveThread = 0;

        for (let i = 0; i < this.runtime.threads.length; i++) {
          const thread = this.runtime.threads[i];

          if (thread.stack.length !== 0 && thread.status !== Thread.STATUS_DONE) {
            this.runtime.threads[nextActiveThread] = thread;
            nextActiveThread++;
          } else {
            doneThreads.push(thread);
          }
        }

        this.runtime.threads.length = nextActiveThread;
      }
    }

    this.activeThread = null;
    return doneThreads;
  }
  /**
   * Step the requested thread for as long as necessary.
   * @param {!Thread} thread Thread object to step.
   */


  stepThread(thread) {
    let currentBlockId = thread.peekStack();

    if (!currentBlockId) {
      // A "null block" - empty branch.
      thread.popStack(); // Did the null follow a hat block?

      if (thread.stack.length === 0) {
        thread.status = Thread.STATUS_DONE;
        return;
      }
    } // Save the current block ID to notice if we did control flow.


    while (currentBlockId = thread.peekStack()) {
      let isWarpMode = thread.peekStackFrame().warpMode;

      if (isWarpMode && !thread.warpTimer) {
        // Initialize warp-mode timer if it hasn't been already.
        // This will start counting the thread toward `Sequencer.WARP_TIME`.
        thread.warpTimer = new Timer();
        thread.warpTimer.start();
      } // Execute the current block.


      if (this.runtime.profiler !== null) {
        if (executeProfilerId === -1) {
          executeProfilerId = this.runtime.profiler.idByName(executeProfilerFrame);
        } // Increment the number of times execute is called.


        this.runtime.profiler.increment(executeProfilerId);
      }

      if (thread.target === null) {
        this.retireThread(thread);
      } else {
        execute(this, thread);
      }

      thread.blockGlowInFrame = currentBlockId; // If the thread has yielded or is waiting, yield to other threads.

      if (thread.status === Thread.STATUS_YIELD) {
        // Mark as running for next iteration.
        thread.status = Thread.STATUS_RUNNING; // In warp mode, yielded blocks are re-executed immediately.

        if (isWarpMode && thread.warpTimer.timeElapsed() <= Sequencer.WARP_TIME) {
          continue;
        }

        return;
      } else if (thread.status === Thread.STATUS_PROMISE_WAIT) {
        // A promise was returned by the primitive. Yield the thread
        // until the promise resolves. Promise resolution should reset
        // thread.status to Thread.STATUS_RUNNING.
        return;
      } else if (thread.status === Thread.STATUS_YIELD_TICK) {
        // stepThreads will reset the thread to Thread.STATUS_RUNNING
        return;
      } // If no control flow has happened, switch to next block.


      if (thread.peekStack() === currentBlockId) {
        thread.goToNextBlock();
      } // If no next block has been found at this point, look on the stack.


      while (!thread.peekStack()) {
        thread.popStack();

        if (thread.stack.length === 0) {
          // No more stack to run!
          thread.status = Thread.STATUS_DONE;
          return;
        }

        const stackFrame = thread.peekStackFrame();
        isWarpMode = stackFrame.warpMode;

        if (stackFrame.isLoop) {
          // The current level of the stack is marked as a loop.
          // Return to yield for the frame/tick in general.
          // Unless we're in warp mode - then only return if the
          // warp timer is up.
          if (!isWarpMode || thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {
            // Don't do anything to the stack, since loops need
            // to be re-executed.
            return;
          } // Don't go to the next block for this level of the stack,
          // since loops need to be re-executed.


          continue;
        } else if (stackFrame.waitingReporter) {
          // This level of the stack was waiting for a value.
          // This means a reporter has just returned - so don't go
          // to the next block for this level of the stack.
          return;
        } // Get next block of existing block on the stack.


        thread.goToNextBlock();
      }
    }
  }
  /**
   * Step a thread into a block's branch.
   * @param {!Thread} thread Thread object to step to branch.
   * @param {number} branchNum Which branch to step to (i.e., 1, 2).
   * @param {boolean} isLoop Whether this block is a loop.
   */


  stepToBranch(thread, branchNum, isLoop) {
    if (!branchNum) {
      branchNum = 1;
    }

    const currentBlockId = thread.peekStack();
    const branchId = thread.target.blocks.getBranch(currentBlockId, branchNum);
    thread.peekStackFrame().isLoop = isLoop;

    if (branchId) {
      // Push branch ID to the thread's stack.
      thread.pushStack(branchId);
    } else {
      thread.pushStack(null);
    }
  }
  /**
   * Step a procedure.
   * @param {!Thread} thread Thread object to step to procedure.
   * @param {!string} procedureCode Procedure code of procedure to step to.
   */


  stepToProcedure(thread, procedureCode) {
    const definition = thread.target.blocks.getProcedureDefinition(procedureCode);

    if (!definition) {
      return;
    } // Check if the call is recursive.
    // If so, set the thread to yield after pushing.


    const isRecursive = thread.isRecursiveCall(procedureCode); // To step to a procedure, we put its definition on the stack.
    // Execution for the thread will proceed through the definition hat
    // and on to the main definition of the procedure.
    // When that set of blocks finishes executing, it will be popped
    // from the stack by the sequencer, returning control to the caller.

    thread.pushStack(definition); // In known warp-mode threads, only yield when time is up.

    if (thread.peekStackFrame().warpMode && thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {
      thread.status = Thread.STATUS_YIELD;
    } else {
      // Look for warp-mode flag on definition, and set the thread
      // to warp-mode if needed.
      const definitionBlock = thread.target.blocks.getBlock(definition);
      const innerBlock = thread.target.blocks.getBlock(definitionBlock.inputs.custom_block.block);
      let doWarp = false;

      if (innerBlock && innerBlock.mutation) {
        const warp = innerBlock.mutation.warp;

        if (typeof warp === 'boolean') {
          doWarp = warp;
        } else if (typeof warp === 'string') {
          doWarp = JSON.parse(warp);
        }
      }

      if (doWarp) {
        thread.peekStackFrame().warpMode = true;
      } else if (isRecursive) {
        // In normal-mode threads, yield any time we have a recursive call.
        thread.status = Thread.STATUS_YIELD;
      }
    }
  }
  /**
   * Retire a thread in the middle, without considering further blocks.
   * @param {!Thread} thread Thread object to retire.
   */


  retireThread(thread) {
    thread.stack = [];
    thread.stackFrame = [];
    thread.requestScriptGlowInFrame = false;
    thread.status = Thread.STATUS_DONE;
  }

}

module.exports = Sequencer;

/***/ }),

/***/ "./src/engine/stage-layering.js":
/*!**************************************!*\
  !*** ./src/engine/stage-layering.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

class StageLayering {
  static get BACKGROUND_LAYER() {
    return 'background';
  }

  static get VIDEO_LAYER() {
    return 'video';
  }

  static get PEN_LAYER() {
    return 'pen';
  }

  static get SPRITE_LAYER() {
    return 'sprite';
  } // Order of layer groups relative to each other,


  static get LAYER_GROUPS() {
    return [StageLayering.BACKGROUND_LAYER, StageLayering.VIDEO_LAYER, StageLayering.PEN_LAYER, StageLayering.SPRITE_LAYER];
  }

}

module.exports = StageLayering;

/***/ }),

/***/ "./src/engine/target.js":
/*!******************************!*\
  !*** ./src/engine/target.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const Blocks = __webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");

const {
  Map
} = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const VariableUtil = __webpack_require__(/*! ../util/variable-util */ "./src/util/variable-util.js");
/**
 * @fileoverview
 * A Target is an abstract "code-running" object for the VM.
 * Examples include sprites/clones or potentially physical-world devices.
 *
 * 似乎是每个target的数据结构
 */


class Target extends EventEmitter {
  /**
   * @param {Runtime} runtime 引用运行时.
   * @param {?Blocks} blocks 该目标拥有的块的块实例.
   * @constructor
   */
  constructor(runtime, blocks) {
    super();
    console.log("class Target ,id在此生成", blocks, runtime);

    if (!blocks) {
      blocks = new Blocks(runtime);
    }
    /**
     * Reference to the runtime.
     * @type {Runtime}
     */


    this.runtime = runtime;
    /**
     * 唯一ID.
     * @type {string}
     */

    this.id = Utility.uid();
    /**
     * Blocks run as code for this target.
     * @type {!Blocks}
     */

    this.blocks = blocks;
    /**
     * Dictionary of variables and their values for this target.
     * Key is the variable id.
     * @type {Object.<string,*>}
     */

    this.variables = {};
    /**
     * Dictionary of comments for this target.
     * Key is the comment id.
     * @type {Object.<string,*>}
     */

    this.comments = {};
    /**
     * Dictionary of custom state for this target.
     * This can be used to store target-specific custom state for blocks which need it.
     * TODO: do we want to persist this in SB3 files?
     * @type {Object.<string,*>}
     */

    this._customState = {};
    /**
     * Currently known values for edge-activated hats.
     * Keys are block ID for the hat; values are the currently known values.
     * @type {Object.<string, *>}
     */

    this._edgeActivatedHatValues = {};
  }
  /**
   * 当项目收到“绿色标志”时调用。
   * @abstract
   */


  onGreenFlag() {}
  /**
   * 返回此目标的可读名称.目标实现应优先于此.
   * @abstract
   * @returns {string} Human-readable name for the target.
   */


  getName() {
    return this.id;
  }
  /**
   * 更新边缘激活的帽子块值.
   * @param {!string} blockId ID of hat to store value for.
   * @param {*} newValue Value to store for edge-activated hat.
   * @return {*} The old value for the edge-activated hat.
   */


  updateEdgeActivatedValue(blockId, newValue) {
    const oldValue = this._edgeActivatedHatValues[blockId];
    this._edgeActivatedHatValues[blockId] = newValue;
    return oldValue;
  }

  hasEdgeActivatedValue(blockId) {
    return this._edgeActivatedHatValues.hasOwnProperty(blockId);
  }
  /**
   * Clear all edge-activaed hat values.
   */


  clearEdgeActivatedValues() {
    this._edgeActivatedHatValues = {};
  }
  /**
   * 查找变量对象，首先通过id查找，如果没有找到id，则通过名称查找.
   * 如果两次查找均失败，则创建一个新变量.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {!Variable} Variable object.
   */


  lookupOrCreateVariable(id, name) {
    let variable = this.lookupVariableById(id);
    if (variable) return variable;
    variable = this.lookupVariableByNameAndType(name, Variable.SCALAR_TYPE);
    if (variable) return variable; // 不存在具有该名称的变量-在本地创建.

    const newVariable = new Variable(id, name, Variable.SCALAR_TYPE, false);
    this.variables[id] = newVariable;
    return newVariable;
  }
  /**
   * Look up a broadcast message object with the given id and return it
   * if it exists.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {?Variable} Variable object.
   */


  lookupBroadcastMsg(id, name) {
    let broadcastMsg;

    if (id) {
      broadcastMsg = this.lookupVariableById(id);
    } else if (name) {
      broadcastMsg = this.lookupBroadcastByInputValue(name);
    } else {
      console.error("Cannot find broadcast message if neither id nor name are provided.");
    }

    if (broadcastMsg) {
      if (name && broadcastMsg.name.toLowerCase() !== name.toLowerCase()) {
        console.error(`Found broadcast message with id: ${id}, but` + `its name, ${broadcastMsg.name} did not match expected name ${name}.`);
      }

      if (broadcastMsg.type !== Variable.BROADCAST_MESSAGE_TYPE) {
        console.error(`Found variable with id: ${id}, but its type ${broadcastMsg.type}` + `did not match expected type ${Variable.BROADCAST_MESSAGE_TYPE}`);
      }

      return broadcastMsg;
    }
  }
  /**
   * Look up a broadcast message with the given name and return the variable
   * if it exists. Does not create a new broadcast message variable if
   * it doesn't exist.
   * @param {string} name Name of the variable.
   * @return {?Variable} Variable object.
   */


  lookupBroadcastByInputValue(name) {
    const vars = this.variables;

    for (const propName in vars) {
      if (vars[propName].type === Variable.BROADCAST_MESSAGE_TYPE && vars[propName].name.toLowerCase() === name.toLowerCase()) {
        return vars[propName];
      }
    }
  }
  /**
   * Look up a variable object.
   * Search begins for local variables; then look for globals.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {!Variable} Variable object.
   */


  lookupVariableById(id) {
    // If we have a local copy, return it.
    if (this.variables.hasOwnProperty(id)) {
      return this.variables[id];
    } // If the stage has a global copy, return it.


    if (this.runtime && !this.isStage) {
      const stage = this.runtime.getTargetForStage();

      if (stage && stage.variables.hasOwnProperty(id)) {
        return stage.variables[id];
      }
    }
  }
  /**
   * Look up a variable object by its name and variable type.
   * Search begins with local variables; then global variables if a local one
   * was not found.
   * @param {string} name Name of the variable.
   * @param {string} type Type of the variable. Defaults to Variable.SCALAR_TYPE.
   * @param {?bool} skipStage Optional flag to skip checking the stage
   * @return {?Variable} Variable object if found, or null if not.
   */


  lookupVariableByNameAndType(name, type, skipStage) {
    if (typeof name !== "string") return;
    if (typeof type !== "string") type = Variable.SCALAR_TYPE;
    skipStage = skipStage || false;

    for (const varId in this.variables) {
      const currVar = this.variables[varId];

      if (currVar.name === name && currVar.type === type) {
        return currVar;
      }
    }

    if (!skipStage && this.runtime && !this.isStage) {
      const stage = this.runtime.getTargetForStage();

      if (stage) {
        for (const varId in stage.variables) {
          const currVar = stage.variables[varId];

          if (currVar.name === name && currVar.type === type) {
            return currVar;
          }
        }
      }
    }

    return null;
  }
  /**
   * Look up a list object for this target, and create it if one doesn't exist.
   * Search begins for local lists; then look for globals.
   * @param {!string} id Id of the list.
   * @param {!string} name Name of the list.
   * @return {!Varible} Variable object representing the found/created list.
   */


  lookupOrCreateList(id, name) {
    let list = this.lookupVariableById(id);
    if (list) return list;
    list = this.lookupVariableByNameAndType(name, Variable.LIST_TYPE);
    if (list) return list; // No variable with this name exists - create it locally.

    const newList = new Variable(id, name, Variable.LIST_TYPE, false);
    this.variables[id] = newList;
    return newList;
  }
  /**
   * Creates a variable with the given id and name and adds it to the
   * dictionary of variables.
   * @param {string} id Id of variable
   * @param {string} name Name of variable.
   * @param {string} type Type of variable, '', 'broadcast_msg', or 'list'
   * @param {boolean} isCloud Whether the variable to create has the isCloud flag set.
   * Additional checks are made that the variable can be created as a cloud variable.
   */


  createVariable(id, name, type, isCloud) {
    if (!this.variables.hasOwnProperty(id)) {
      const newVariable = new Variable(id, name, type, false);

      if (isCloud && this.isStage && this.runtime.canAddCloudVariable()) {
        newVariable.isCloud = true;
        this.runtime.addCloudVariable();
        this.runtime.ioDevices.cloud.requestCreateVariable(newVariable);
      }

      this.variables[id] = newVariable;
    }
  }
  /**
   * Creates a comment with the given properties.
   * @param {string} id Id of the comment.
   * @param {string} blockId Optional id of the block the comment is attached
   * to if it is a block comment.
   * @param {string} text The text the comment contains.
   * @param {number} x The x coordinate of the comment on the workspace.
   * @param {number} y The y coordinate of the comment on the workspace.
   * @param {number} width The width of the comment when it is full size
   * @param {number} height The height of the comment when it is full size
   * @param {boolean} minimized Whether the comment is minimized.
   */


  createComment(id, blockId, text, x, y, width, height, minimized) {
    if (!this.comments.hasOwnProperty(id)) {
      const newComment = new Comment(id, text, x, y, width, height, minimized);

      if (blockId) {
        newComment.blockId = blockId;
        const blockWithComment = this.blocks.getBlock(blockId);

        if (blockWithComment) {
          blockWithComment.comment = id;
        } else {
          console.warn(`Could not find block with id ${blockId} associated with commentId: ${id}`);
        }
      }

      this.comments[id] = newComment;
    }
  }
  /**
   * Renames the variable with the given id to newName.
   * @param {string} id Id of variable to rename.
   * @param {string} newName New name for the variable.
   */


  renameVariable(id, newName) {
    if (this.variables.hasOwnProperty(id)) {
      const variable = this.variables[id];

      if (variable.id === id) {
        const oldName = variable.name;
        variable.name = newName;

        if (this.runtime) {
          if (variable.isCloud && this.isStage) {
            this.runtime.ioDevices.cloud.requestRenameVariable(oldName, newName);
          }

          if (variable.type === Variable.SCALAR_TYPE) {
            // sensing__of may be referencing to this variable.
            // Change the reference.
            let blockUpdated = false;
            this.runtime.targets.forEach(t => {
              blockUpdated = t.blocks.updateSensingOfReference(oldName, newName, this.isStage ? "_stage_" : this.getName()) || blockUpdated;
            }); // Request workspace change only if sensing_of blocks were actually updated.

            if (blockUpdated) this.runtime.requestBlocksUpdate();
          }

          const blocks = this.runtime.monitorBlocks;
          blocks.changeBlock({
            id: id,
            element: "field",
            name: variable.type === Variable.LIST_TYPE ? "LIST" : "VARIABLE",
            value: id
          }, this.runtime);
          const monitorBlock = blocks.getBlock(variable.id);

          if (monitorBlock) {
            this.runtime.requestUpdateMonitor(Map({
              id: id,
              params: blocks._getBlockParams(monitorBlock)
            }));
          }
        }
      }
    }
  }
  /**
   * Removes the variable with the given id from the dictionary of variables.
   * @param {string} id Id of variable to delete.
   */


  deleteVariable(id) {
    if (this.variables.hasOwnProperty(id)) {
      // Get info about the variable before deleting it
      const deletedVariableName = this.variables[id].name;
      const deletedVariableWasCloud = this.variables[id].isCloud;
      delete this.variables[id];

      if (this.runtime) {
        if (deletedVariableWasCloud && this.isStage) {
          this.runtime.ioDevices.cloud.requestDeleteVariable(deletedVariableName);
          this.runtime.removeCloudVariable();
        }

        this.runtime.monitorBlocks.deleteBlock(id);
        this.runtime.requestRemoveMonitor(id);
      }
    }
  }
  /**
   * Remove this target's monitors from the runtime state and remove the
   * target-specific monitored blocks (e.g. local variables, global variables for the stage, x-position).
   * NOTE: This does not delete any of the stage monitors like backdrop name.
   */


  deleteMonitors() {
    this.runtime.requestRemoveMonitorByTargetId(this.id);
    let targetSpecificMonitorBlockIds;

    if (this.isStage) {
      // This only deletes global variables and not other stage monitors like backdrop number.
      targetSpecificMonitorBlockIds = Object.keys(this.variables);
    } else {
      targetSpecificMonitorBlockIds = Object.keys(this.runtime.monitorBlocks._blocks).filter(key => this.runtime.monitorBlocks._blocks[key].targetId === this.id);
    }

    for (const blockId of targetSpecificMonitorBlockIds) {
      this.runtime.monitorBlocks.deleteBlock(blockId);
    }
  }
  /**
   * Create a clone of the variable with the given id from the dictionary of
   * this target's variables.
   * @param {string} id Id of variable to duplicate.
   * @param {boolean=} optKeepOriginalId Optional flag to keep the original variable ID
   * for the duplicate variable. This is necessary when cloning a sprite, for example.
   * @return {?Variable} The duplicated variable, or null if
   * the original variable was not found.
   */


  duplicateVariable(id, optKeepOriginalId) {
    if (this.variables.hasOwnProperty(id)) {
      const originalVariable = this.variables[id];
      const newVariable = new Variable(optKeepOriginalId ? id : null, // conditionally keep original id or generate a new one
      originalVariable.name, originalVariable.type, originalVariable.isCloud);

      if (newVariable.type === Variable.LIST_TYPE) {
        newVariable.value = originalVariable.value.slice(0);
      } else {
        newVariable.value = originalVariable.value;
      }

      return newVariable;
    }

    return null;
  }
  /**
   * Duplicate the dictionary of this target's variables as part of duplicating.
   * this target or making a clone.
   * @param {object=} optBlocks Optional block container for the target being duplicated.
   * If provided, new variables will be generated with new UIDs and any variable references
   * in this blocks container will be updated to refer to the corresponding new IDs.
   * @return {object} The duplicated dictionary of variables
   */


  duplicateVariables(optBlocks) {
    let allVarRefs;

    if (optBlocks) {
      allVarRefs = optBlocks.getAllVariableAndListReferences();
    }

    return Object.keys(this.variables).reduce((accum, varId) => {
      const newVariable = this.duplicateVariable(varId, !optBlocks);
      accum[newVariable.id] = newVariable;

      if (optBlocks && allVarRefs) {
        const currVarRefs = allVarRefs[varId];

        if (currVarRefs) {
          this.mergeVariables(varId, newVariable.id, currVarRefs);
        }
      }

      return accum;
    }, {});
  }
  /**
   * Post/edit sprite info.
   * @param {object} data An object with sprite info data to set.
   * @abstract
   */


  postSpriteInfo() {}
  /**
   * Retrieve custom state associated with this target and the provided state ID.
   * @param {string} stateId - specify which piece of state to retrieve.
   * @returns {*} the associated state, if any was found.
   */


  getCustomState(stateId) {
    return this._customState[stateId];
  }
  /**
   * Store custom state associated with this target and the provided state ID.
   * @param {string} stateId - specify which piece of state to store on this target.
   * @param {*} newValue - the state value to store.
   */


  setCustomState(stateId, newValue) {
    this._customState[stateId] = newValue;
  }
  /**
   * Call to destroy a target.
   * @abstract
   */


  dispose() {
    this._customState = {};

    if (this.runtime) {
      this.runtime.removeExecutable(this);
    }
  } // Variable Conflict Resolution Helpers

  /**
   * Get the names of all the variables of the given type that are in scope for this target.
   * For targets that are not the stage, this includes any target-specific
   * variables as well as any stage variables unless the skipStage flag is true.
   * For the stage, this is all stage variables.
   * @param {string} type The variable type to search for; defaults to Variable.SCALAR_TYPE
   * @param {?bool} skipStage Optional flag to skip the stage.
   * @return {Array<string>} A list of variable names
   */


  getAllVariableNamesInScopeByType(type, skipStage) {
    if (typeof type !== "string") type = Variable.SCALAR_TYPE;
    skipStage = skipStage || false;
    const targetVariables = Object.values(this.variables).filter(v => v.type === type).map(variable => variable.name);

    if (skipStage || this.isStage || !this.runtime) {
      return targetVariables;
    }

    const stage = this.runtime.getTargetForStage();
    const stageVariables = stage.getAllVariableNamesInScopeByType(type);
    return targetVariables.concat(stageVariables);
  }
  /**
   * Merge variable references with another variable.
   * @param {string} idToBeMerged ID of the variable whose references need to be updated
   * @param {string} idToMergeWith ID of the variable that the old references should be replaced with
   * @param {?Array<Object>} optReferencesToUpdate Optional context of the change.
   * Defaults to all the blocks in this target.
   * @param {?string} optNewName New variable name to merge with. The old
   * variable name in the references being updated should be replaced with this new name.
   * If this parameter is not provided or is '', no name change occurs.
   */


  mergeVariables(idToBeMerged, idToMergeWith, optReferencesToUpdate, optNewName) {
    const referencesToChange = optReferencesToUpdate || // TODO should there be a separate helper function that traverses the blocks
    // for all references for a given ID instead of doing the below..?
    this.blocks.getAllVariableAndListReferences()[idToBeMerged];
    VariableUtil.updateVariableIdentifiers(referencesToChange, idToMergeWith, optNewName);
  }
  /**
   * Share a local variable (and given references for that variable) to the stage.
   * @param {string} varId The ID of the variable to share.
   * @param {Array<object>} varRefs The list of variable references being shared,
   * that reference the given variable ID. The names and IDs of these variable
   * references will be updated to refer to the new (or pre-existing) global variable.
   */


  shareLocalVariableToStage(varId, varRefs) {
    if (!this.runtime) return;
    const variable = this.variables[varId];

    if (!variable) {
      console.warn(`Cannot share a local variable to the stage if it's not local.`);
      return;
    }

    const stage = this.runtime.getTargetForStage(); // If a local var is being shared with the stage,
    // sharing will make the variable global, resulting in a conflict
    // with the existing local variable. Preemptively Resolve this conflict
    // by renaming the new global variable.
    // First check if we've already done the local to global transition for this
    // variable. If we have, merge it with the global variable we've already created.

    const varIdForStage = `StageVarFromLocal_${varId}`;
    let stageVar = stage.lookupVariableById(varIdForStage); // If a global var doesn't already exist, create a new one with a fresh name.
    // Use the ID we created above so that we can lookup this new variable in the
    // future if we decide to share this same variable again.

    if (!stageVar) {
      const varName = variable.name;
      const varType = variable.type;
      const newStageName = `Stage: ${varName}`;
      stageVar = this.runtime.createNewGlobalVariable(newStageName, varIdForStage, varType);
    } // Update all variable references to use the new name and ID


    this.mergeVariables(varId, stageVar.id, varRefs, stageVar.name);
  }
  /**
   * Share a local variable with a sprite, merging with one of the same name and
   * type if it already exists on the sprite, or create a new one.
   * @param {string} varId Id of the variable to share
   * @param {Target} sprite The sprite to share the variable with
   * @param {Array<object>} varRefs A list of all the variable references currently being shared.
   */


  shareLocalVariableToSprite(varId, sprite, varRefs) {
    if (!this.runtime) return;
    if (this.isStage) return;
    const variable = this.variables[varId];

    if (!variable) {
      console.warn(`Tried to call 'shareLocalVariableToSprite' with a non-local variable.`);
      return;
    }

    const varName = variable.name;
    const varType = variable.type; // Check if the receiving sprite already has a variable of the same name and type
    // and use the existing variable, otherwise create a new one.

    const existingLocalVar = sprite.lookupVariableByNameAndType(varName, varType);
    let newVarId;

    if (existingLocalVar) {
      newVarId = existingLocalVar.id;
    } else {
      const newVar = new Variable(null, varName, varType);
      newVarId = newVar.id;
      sprite.variables[newVarId] = newVar;
    } // Merge with the local variable on the new sprite.


    this.mergeVariables(varId, newVarId, varRefs);
  }
  /**
   * Given a list of variable referencing fields, shares those variables with
   * the target with the provided id, resolving any variable conflicts that arise
   * using the following rules:
   *
   * If this target is the stage, exit. There are no conflicts that arise
   * from sharing variables from the stage to another sprite. The variables
   * already exist globally, so no further action is needed.
   *
   * If a variable being referenced is a global variable, do nothing. The
   * global variable already exists so no further action is needed.
   *
   * If a variable being referenced is local, and
   * 1) The receiving target is a sprite:
   * create a new local variable or merge with an existing local variable
   * of the same name and type. Update all the referencing fields
   * for the original variable to reference the new variable.
   * 2) The receiving target is the stage:
   * Create a new global variable with a fresh name and update all the referencing
   * fields to reference the new variable.
   *
   * @param {Array<object>} blocks The blocks containing
   * potential conflicting references to variables.
   * @param {Target} receivingTarget The target receiving the variables
   */


  resolveVariableSharingConflictsWithTarget(blocks, receivingTarget) {
    if (this.isStage) return; // Get all the variable references in the given list of blocks

    const allVarListRefs = this.blocks.getAllVariableAndListReferences(blocks); // For all the variables being referenced, check for which ones are local
    // to this target, and resolve conflicts based on whether the receiving target
    // is a sprite (with a conflicting local variable) or whether it is
    // the stage (which cannot have local variables)

    for (const varId in allVarListRefs) {
      const currVar = this.variables[varId];
      if (!currVar) continue; // The current variable is global, there shouldn't be any conflicts here, skip it.
      // Get the list of references for the current variable id

      const currVarListRefs = allVarListRefs[varId];

      if (receivingTarget.isStage) {
        this.shareLocalVariableToStage(varId, currVarListRefs);
      } else {
        this.shareLocalVariableToSprite(varId, receivingTarget, currVarListRefs);
      }
    }
  }
  /**
   * 修复此目标中的变量引用，避免与同一范围中的现有变量发生冲突.
   * 在将目标作为新的精灵上传到现有项目中时使用此方法，其中新的精灵可能包含对已在项目中作为全局变量存在的变量名称的引用（因此属于给定Sprite中变量引用的范围）.
   *
   * If this target has a block that references an existing global variable and that
   * variable *does not* exist in this target (e.g. it was a global variable in the
   * project the sprite was originally exported from), merge the variables. This entails
   * fixing the variable references in this sprite to reference the id of the pre-existing global variable.
   *
   * If this target has a block that references an existing global variable and that
   * variable does exist in the target itself (e.g. it's a local variable in the sprite being uploaded),
   * then the local variable is renamed to distinguish itself from the pre-existing variable.
   * All blocks that reference the local variable will be updated to use the new name.
   */
  // TODO (#1360) This function is too long, add some helpers for the different chunks and cases...


  fixUpVariableReferences() {
    if (!this.runtime) return; // There's no runtime context to conflict with

    if (this.isStage) return; // Stage can't have variable conflicts with itself (and also can't be uploaded)

    const stage = this.runtime.getTargetForStage();
    if (!stage || !stage.variables) return;

    const renameConflictingLocalVar = (id, name, type) => {
      const conflict = stage.lookupVariableByNameAndType(name, type);

      if (conflict) {
        const newName = StringUtil.unusedName(`${this.getName()}: ${name}`, this.getAllVariableNamesInScopeByType(type));
        this.renameVariable(id, newName);
        return newName;
      }

      return null;
    };

    const allReferences = this.blocks.getAllVariableAndListReferences();
    const unreferencedLocalVarIds = [];

    if (Object.keys(this.variables).length > 0) {
      for (const localVarId in this.variables) {
        if (!this.variables.hasOwnProperty(localVarId)) continue;
        if (!allReferences[localVarId]) unreferencedLocalVarIds.push(localVarId);
      }
    }

    const conflictIdsToReplace = Object.create(null);
    const conflictNamesToReplace = Object.create(null); // Cache the list of all variable names by type so that we don't need to
    // re-calculate this in every iteration of the following loop.

    const varNamesByType = {};

    const allVarNames = type => {
      const namesOfType = varNamesByType[type];
      if (namesOfType) return namesOfType;
      varNamesByType[type] = this.runtime.getAllVarNamesOfType(type);
      return varNamesByType[type];
    };

    for (const varId in allReferences) {
      // We don't care about which var ref we get, they should all have the same var info
      const varRef = allReferences[varId][0];
      const varName = varRef.referencingField.value;
      const varType = varRef.type;

      if (this.lookupVariableById(varId)) {
        // Found a variable with the id in either the target or the stage,
        // figure out which one.
        if (this.variables.hasOwnProperty(varId)) {
          // If the target has the variable, then check whether the stage
          // has one with the same name and type. If it does, then rename
          // this target specific variable so that there is a distinction.
          const newVarName = renameConflictingLocalVar(varId, varName, varType);

          if (newVarName) {
            // We are not calling this.blocks.updateBlocksAfterVarRename
            // here because it will search through all the blocks. We already
            // have access to all the references for this var id.
            allReferences[varId].map(ref => {
              ref.referencingField.value = newVarName;
              return ref;
            });
          }
        }
      } else {
        // We didn't find the referenced variable id anywhere,
        // Treat it as a reference to a global variable (from the original
        // project this sprite was exported from).
        // Check for whether a global variable of the same name and type exists,
        // and if so, track it to merge with the existing global in a second pass of the blocks.
        const existingVar = stage.lookupVariableByNameAndType(varName, varType);

        if (existingVar) {
          if (!conflictIdsToReplace[varId]) {
            conflictIdsToReplace[varId] = existingVar.id;
          }
        } else {
          // A global variable with the same name did not already exist,
          // create a new one such that it does not conflict with any
          // names of local variables of the same type.
          const allNames = allVarNames(varType);
          const freshName = StringUtil.unusedName(varName, allNames);
          stage.createVariable(varId, freshName, varType);

          if (!conflictNamesToReplace[varId]) {
            conflictNamesToReplace[varId] = freshName;
          }
        }
      }
    } // Rename any local variables that were missed above because they aren't
    // referenced by any blocks


    for (const id in unreferencedLocalVarIds) {
      const varId = unreferencedLocalVarIds[id];
      const name = this.variables[varId].name;
      const type = this.variables[varId].type;
      renameConflictingLocalVar(varId, name, type);
    } // Handle global var conflicts with existing global vars (e.g. a sprite is uploaded, and has
    // blocks referencing some variable that the sprite does not own, and this
    // variable conflicts with a global var)
    // In this case, we want to merge the new variable referenes with the
    // existing global variable


    for (const conflictId in conflictIdsToReplace) {
      const existingId = conflictIdsToReplace[conflictId];
      const referencesToUpdate = allReferences[conflictId];
      this.mergeVariables(conflictId, existingId, referencesToUpdate);
    } // Handle global var conflicts existing local vars (e.g a sprite is uploaded,
    // and has blocks referencing some variable that the sprite does not own, and this
    // variable conflcits with another sprite's local var).
    // In this case, we want to go through the variable references and update
    // the name of the variable in that reference.


    for (const conflictId in conflictNamesToReplace) {
      const newName = conflictNamesToReplace[conflictId];
      const referencesToUpdate = allReferences[conflictId];
      referencesToUpdate.map(ref => {
        ref.referencingField.value = newName;
        return ref;
      });
    }
  }

}

module.exports = Target;

/***/ }),

/***/ "./src/engine/thread.js":
/*!******************************!*\
  !*** ./src/engine/thread.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Recycle bin for empty stackFrame objects
 * @type Array<_StackFrame>
 */
const _stackFrameFreeList = [];
/**
 * A frame used for each level of the stack. A general purpose
 * place to store a bunch of execution context and parameters
 * @param {boolean} warpMode Whether this level of the stack is warping
 * @constructor
 * @private
 */

class _StackFrame {
  constructor(warpMode) {
    /**
     * Whether this level of the stack is a loop.
     * @type {boolean}
     */
    this.isLoop = false;
    /**
     * Whether this level is in warp mode.  Is set by some legacy blocks and
     * "turbo mode"
     * @type {boolean}
     */

    this.warpMode = warpMode;
    /**
     * Reported value from just executed block.
     * @type {Any}
     */

    this.justReported = null;
    /**
     * The active block that is waiting on a promise.
     * @type {string}
     */

    this.reporting = '';
    /**
     * Persists reported inputs during async block.
     * @type {Object}
     */

    this.reported = null;
    /**
     * Name of waiting reporter.
     * @type {string}
     */

    this.waitingReporter = null;
    /**
     * Procedure parameters.
     * @type {Object}
     */

    this.params = null;
    /**
     * A context passed to block implementations.
     * @type {Object}
     */

    this.executionContext = null;
  }
  /**
   * Reset all properties of the frame to pristine null and false states.
   * Used to recycle.
   * @return {_StackFrame} this
   */


  reset() {
    this.isLoop = false;
    this.warpMode = false;
    this.justReported = null;
    this.reported = null;
    this.waitingReporter = null;
    this.params = null;
    this.executionContext = null;
    return this;
  }
  /**
   * Reuse an active stack frame in the stack.
   * @param {?boolean} warpMode defaults to current warpMode
   * @returns {_StackFrame} this
   */


  reuse(warpMode = this.warpMode) {
    this.reset();
    this.warpMode = Boolean(warpMode);
    return this;
  }
  /**
   * Create or recycle a stack frame object.
   * @param {boolean} warpMode Enable warpMode on this frame.
   * @returns {_StackFrame} The clean stack frame with correct warpMode setting.
   */


  static create(warpMode) {
    const stackFrame = _stackFrameFreeList.pop();

    if (typeof stackFrame !== 'undefined') {
      stackFrame.warpMode = Boolean(warpMode);
      return stackFrame;
    }

    return new _StackFrame(warpMode);
  }
  /**
   * Put a stack frame object into the recycle bin for reuse.
   * @param {_StackFrame} stackFrame The frame to reset and recycle.
   */


  static release(stackFrame) {
    if (typeof stackFrame !== 'undefined') {
      _stackFrameFreeList.push(stackFrame.reset());
    }
  }

}
/**
 * A thread is a running stack context and all the metadata needed.
 * @param {?string} firstBlock First block to execute in the thread.
 * @constructor
 */


class Thread {
  constructor(firstBlock) {
    /**
     * ID of top block of the thread
     * @type {!string}
     */
    this.topBlock = firstBlock;
    /**
     * Stack for the thread. When the sequencer enters a control structure,
     * the block is pushed onto the stack so we know where to exit.
     * @type {Array.<string>}
     */

    this.stack = [];
    /**
     * Stack frames for the thread. Store metadata for the executing blocks.
     * @type {Array.<_StackFrame>}
     */

    this.stackFrames = [];
    /**
     * Status of the thread, one of three states (below)
     * @type {number}
     */

    this.status = 0;
    /* Thread.STATUS_RUNNING */

    /**
     * Whether the thread is killed in the middle of execution.
     * @type {boolean}
     */

    this.isKilled = false;
    /**
     * Target of this thread.
     * @type {?Target}
     */

    this.target = null;
    /**
     * The Blocks this thread will execute.
     * @type {Blocks}
     */

    this.blockContainer = null;
    /**
     * Whether the thread requests its script to glow during this frame.
     * @type {boolean}
     */

    this.requestScriptGlowInFrame = false;
    /**
     * Which block ID should glow during this frame, if any.
     * @type {?string}
     */

    this.blockGlowInFrame = null;
    /**
     * A timer for when the thread enters warp mode.
     * Substitutes the sequencer's count toward WORK_TIME on a per-thread basis.
     * @type {?Timer}
     */

    this.warpTimer = null;
    this.justReported = null;
  }
  /**
   * Thread status for initialized or running thread.
   * This is the default state for a thread - execution should run normally,
   * stepping from block to block.
   * @const
   */


  static get STATUS_RUNNING() {
    return 0;
  }
  /**
   * Threads are in this state when a primitive is waiting on a promise;
   * execution is paused until the promise changes thread status.
   * @const
   */


  static get STATUS_PROMISE_WAIT() {
    return 1;
  }
  /**
   * Thread status for yield.
   * @const
   */


  static get STATUS_YIELD() {
    return 2;
  }
  /**
   * Thread status for a single-tick yield. This will be cleared when the
   * thread is resumed.
   * @const
   */


  static get STATUS_YIELD_TICK() {
    return 3;
  }
  /**
   * Thread status for a finished/done thread.
   * Thread is in this state when there are no more blocks to execute.
   * @const
   */


  static get STATUS_DONE() {
    return 4;
  }
  /**
   * Push stack and update stack frames appropriately.
   * @param {string} blockId Block ID to push to stack.
   */


  pushStack(blockId) {
    this.stack.push(blockId); // Push an empty stack frame, if we need one.
    // Might not, if we just popped the stack.

    if (this.stack.length > this.stackFrames.length) {
      const parent = this.stackFrames[this.stackFrames.length - 1];
      this.stackFrames.push(_StackFrame.create(typeof parent !== 'undefined' && parent.warpMode));
    }
  }
  /**
   * Reset the stack frame for use by the next block.
   * (avoids popping and re-pushing a new stack frame - keeps the warpmode the same
   * @param {string} blockId Block ID to push to stack.
   */


  reuseStackForNextBlock(blockId) {
    this.stack[this.stack.length - 1] = blockId;
    this.stackFrames[this.stackFrames.length - 1].reuse();
  }
  /**
   * Pop last block on the stack and its stack frame.
   * @return {string} Block ID popped from the stack.
   */


  popStack() {
    _StackFrame.release(this.stackFrames.pop());

    return this.stack.pop();
  }
  /**
   * Pop back down the stack frame until we hit a procedure call or the stack frame is emptied
   */


  stopThisScript() {
    let blockID = this.peekStack();

    while (blockID !== null) {
      const block = this.target.blocks.getBlock(blockID);

      if (typeof block !== 'undefined' && block.opcode === 'procedures_call') {
        break;
      }

      this.popStack();
      blockID = this.peekStack();
    }

    if (this.stack.length === 0) {
      // Clean up!
      this.requestScriptGlowInFrame = false;
      this.status = Thread.STATUS_DONE;
    }
  }
  /**
   * Get top stack item.
   * @return {?string} Block ID on top of stack.
   */


  peekStack() {
    return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
  }
  /**
   * Get top stack frame.
   * @return {?object} Last stack frame stored on this thread.
   */


  peekStackFrame() {
    return this.stackFrames.length > 0 ? this.stackFrames[this.stackFrames.length - 1] : null;
  }
  /**
   * Get stack frame above the current top.
   * @return {?object} Second to last stack frame stored on this thread.
   */


  peekParentStackFrame() {
    return this.stackFrames.length > 1 ? this.stackFrames[this.stackFrames.length - 2] : null;
  }
  /**
   * Push a reported value to the parent of the current stack frame.
   * @param {*} value Reported value to push.
   */


  pushReportedValue(value) {
    this.justReported = typeof value === 'undefined' ? null : value;
  }
  /**
   * Initialize procedure parameters on this stack frame.
   */


  initParams() {
    const stackFrame = this.peekStackFrame();

    if (stackFrame.params === null) {
      stackFrame.params = {};
    }
  }
  /**
   * Add a parameter to the stack frame.
   * Use when calling a procedure with parameter values.
   * @param {!string} paramName Name of parameter.
   * @param {*} value Value to set for parameter.
   */


  pushParam(paramName, value) {
    const stackFrame = this.peekStackFrame();
    stackFrame.params[paramName] = value;
  }
  /**
   * Get a parameter at the lowest possible level of the stack.
   * @param {!string} paramName Name of parameter.
   * @return {*} value Value for parameter.
   */


  getParam(paramName) {
    for (let i = this.stackFrames.length - 1; i >= 0; i--) {
      const frame = this.stackFrames[i];

      if (frame.params === null) {
        continue;
      }

      if (frame.params.hasOwnProperty(paramName)) {
        return frame.params[paramName];
      }

      return null;
    }

    return null;
  }
  /**
   * Whether the current execution of a thread is at the top of the stack.
   * @return {boolean} True if execution is at top of the stack.
   */


  atStackTop() {
    return this.peekStack() === this.topBlock;
  }
  /**
   * Switch the thread to the next block at the current level of the stack.
   * For example, this is used in a standard sequence of blocks,
   * where execution proceeds from one block to the next.
   */


  goToNextBlock() {
    const nextBlockId = this.target.blocks.getNextBlock(this.peekStack());
    this.reuseStackForNextBlock(nextBlockId);
  }
  /**
   * Attempt to determine whether a procedure call is recursive,
   * by examining the stack.
   * @param {!string} procedureCode Procedure code of procedure being called.
   * @return {boolean} True if the call appears recursive.
   */


  isRecursiveCall(procedureCode) {
    let callCount = 5; // Max number of enclosing procedure calls to examine.

    const sp = this.stack.length - 1;

    for (let i = sp - 1; i >= 0; i--) {
      const block = this.target.blocks.getBlock(this.stack[i]);

      if (block.opcode === 'procedures_call' && block.mutation.proccode === procedureCode) {
        return true;
      }

      if (--callCount < 0) return false;
    }

    return false;
  }

}

module.exports = Thread;

/***/ }),

/***/ "./src/engine/variable.js":
/*!********************************!*\
  !*** ./src/engine/variable.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview
 * 代表Scratch变量的对象
 */
class Variable {
  /**
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @param {string} type Type of the variable, one of '' or 'list'
   * @param {boolean} isCloud Whether the variable is stored in the cloud.
   * @constructor
   */
  constructor(id, name, type, isCloud) {
    console.log("class Variable:", id, name, type, isCloud);
    this.id = id || Utility.uid();
    this.name = name;
    this.type = type;
    this.isCloud = isCloud;

    switch (this.type) {
      case Variable.SCALAR_TYPE:
        this.value = 0;
        break;

      case Variable.LIST_TYPE:
        this.value = [];
        break;

      case Variable.BROADCAST_MESSAGE_TYPE:
        this.value = this.name;
        break;

      default:
        throw new Error(`Invalid variable type: ${this.type}`);
    }
  }

  toXML(isLocal) {
    isLocal = isLocal === true;
    return `<variable type="${this.type}" id="${this.id}" islocal="${isLocal}" iscloud="${this.isCloud}">${Utility.xmlEscape(this.name)}</variable>`;
  }
  /**
   * Type representation for scalar variables.
   * This is currently represented as ''
   * for compatibility with blockly.
   * @const {string}
   */


  static get SCALAR_TYPE() {
    return "";
  }
  /**
   * Type representation for list variables.
   * @const {string}
   */


  static get LIST_TYPE() {
    return "list";
  }
  /**
   * Type representation for list variables.
   * @const {string}
   */


  static get BROADCAST_MESSAGE_TYPE() {
    return "broadcast_msg";
  }

}

module.exports = Variable;

/***/ }),

/***/ "./src/extension-support/argument-type.js":
/*!************************************************!*\
  !*** ./src/extension-support/argument-type.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Block argument types
 * @enum {string}
 */
const ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',

  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',

  /**
   * Numeric value with color picker
   */
  COLOR: 'color',

  /**
   * Numeric value with text field
   */
  NUMBER: 'number',

  /**
   * String value with text field
   */
  STRING: 'string',

  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',

  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',

  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
module.exports = ArgumentType;

/***/ }),

/***/ "./src/extension-support/block-type.js":
/*!*********************************************!*\
  !*** ./src/extension-support/block-type.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Types of block
 * @enum {string}
 */
const BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',

  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',

  /**
   * Command block
   */
  COMMAND: 'command',

  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',

  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',

  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',

  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',

  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
module.exports = BlockType;

/***/ }),

/***/ "./src/extension-support/extension-manager.js":
/*!****************************************************!*\
  !*** ./src/extension-support/extension-manager.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const dispatch = __webpack_require__(/*! ../dispatch/central-dispatch */ "./src/dispatch/central-dispatch.js");

const maybeFormatMessage = __webpack_require__(/*! ../util/maybe-format-message */ "./src/util/maybe-format-message.js");

const BlockType = __webpack_require__(/*! ./block-type */ "./src/extension-support/block-type.js");

const ArgumentType = __webpack_require__(/*! ./argument-type */ "./src/extension-support/argument-type.js");

const TargetType = __webpack_require__(/*! ../extension-support/target-type */ "./src/extension-support/target-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const RenderedTarget = __webpack_require__(/*! ../sprites/rendered-target */ "./src/sprites/rendered-target.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");
/** 把 core_example合并过来 */

/* eslint-disable-next-line max-len */


const blockIconURICoreExample = 'data:image/svg+xml,%3Csvg id="rotate-counter-clockwise" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%233d79cc;%7D.cls-2%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3Erotate-counter-clockwise%3C/title%3E%3Cpath class="cls-1" d="M22.68,12.2a1.6,1.6,0,0,1-1.27.63H13.72a1.59,1.59,0,0,1-1.16-2.58l1.12-1.41a4.82,4.82,0,0,0-3.14-.77,4.31,4.31,0,0,0-2,.8,4.25,4.25,0,0,0-1.34,1.73,5.06,5.06,0,0,0,.54,4.62A5.58,5.58,0,0,0,12,17.74h0a2.26,2.26,0,0,1-.16,4.52A10.25,10.25,0,0,1,3.74,18,10.14,10.14,0,0,1,2.25,8.78,9.7,9.7,0,0,1,5.08,4.64,9.92,9.92,0,0,1,9.66,2.5a10.66,10.66,0,0,1,7.72,1.68l1.08-1.35a1.57,1.57,0,0,1,1.24-.6,1.6,1.6,0,0,1,1.54,1.21l1.7,7.37A1.57,1.57,0,0,1,22.68,12.2Z"/%3E%3Cpath class="cls-2" d="M21.38,11.83H13.77a.59.59,0,0,1-.43-1l1.75-2.19a5.9,5.9,0,0,0-4.7-1.58,5.07,5.07,0,0,0-4.11,3.17A6,6,0,0,0,7,15.77a6.51,6.51,0,0,0,5,2.92,1.31,1.31,0,0,1-.08,2.62,9.3,9.3,0,0,1-7.35-3.82A9.16,9.16,0,0,1,3.17,9.12,8.51,8.51,0,0,1,5.71,5.4,8.76,8.76,0,0,1,9.82,3.48a9.71,9.71,0,0,1,7.75,2.07l1.67-2.1a.59.59,0,0,1,1,.21L22,11.08A.59.59,0,0,1,21.38,11.83Z"/%3E%3C/svg%3E';
/**
 * An example core block implemented using the extension spec.
 * This is not loaded as part of the core blocks in the VM but it is provided
 * and used as part of tests.
 */

class KidCoreExample {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: "coreExample",
      name: "CoreEx",
      // This string does not need to be translated as this extension is only used as an example.
      blocks: [{
        func: "MAKE_A_VARIABLE",
        blockType: BlockType.BUTTON,
        text: "make a variable (CoreEx)"
      }, {
        opcode: "exampleOpcode",
        blockType: BlockType.REPORTER,
        text: "example block"
      }, {
        opcode: "exampleWithInlineImage",
        blockType: BlockType.COMMAND,
        text: "block with image [CLOCKWISE] inline",
        arguments: {
          CLOCKWISE: {
            type: ArgumentType.IMAGE,
            dataURI: blockIconURICoreExample
          }
        }
      }]
    };
  }
  /**
   * Example opcode just returns the name of the stage target.
   * @returns {string} The name of the first target in the project.
   */


  exampleOpcode() {
    const stage = this.runtime.getTargetForStage();
    return stage ? stage.getName() : "no stage yet";
  }

  exampleWithInlineImage() {
    return;
  }

}
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURIPenBlocks = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+cGVuLWljb248L3RpdGxlPjxnIHN0cm9rZT0iIzU3NUU3NSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik04Ljc1MyAzNC42MDJsLTQuMjUgMS43OCAxLjc4My00LjIzN2MxLjIxOC0yLjg5MiAyLjkwNy01LjQyMyA1LjAzLTcuNTM4TDMxLjA2NiA0LjkzYy44NDYtLjg0MiAyLjY1LS40MSA0LjAzMi45NjcgMS4zOCAxLjM3NSAxLjgxNiAzLjE3My45NyA0LjAxNUwxNi4zMTggMjkuNTljLTIuMTIzIDIuMTE2LTQuNjY0IDMuOC03LjU2NSA1LjAxMiIgZmlsbD0iI0ZGRiIvPjxwYXRoIGQ9Ik0yOS40MSA2LjExcy00LjQ1LTIuMzc4LTguMjAyIDUuNzcyYy0xLjczNCAzLjc2Ni00LjM1IDEuNTQ2LTQuMzUgMS41NDYiLz48cGF0aCBkPSJNMzYuNDIgOC44MjVjMCAuNDYzLS4xNC44NzMtLjQzMiAxLjE2NGwtOS4zMzUgOS4zYy4yODItLjI5LjQxLS42NjguNDEtMS4xMiAwLS44NzQtLjUwNy0xLjk2My0xLjQwNi0yLjg2OC0xLjM2Mi0xLjM1OC0zLjE0Ny0xLjgtNC4wMDItLjk5TDMwLjk5IDUuMDFjLjg0NC0uODQgMi42NS0uNDEgNC4wMzUuOTYuODk4LjkwNCAxLjM5NiAxLjk4MiAxLjM5NiAyLjg1NU0xMC41MTUgMzMuNzc0Yy0uNTczLjMwMi0xLjE1Ny41Ny0xLjc2NC44M0w0LjUgMzYuMzgybDEuNzg2LTQuMjM1Yy4yNTgtLjYwNC41My0xLjE4Ni44MzMtMS43NTcuNjkuMTgzIDEuNDQ4LjYyNSAyLjEwOCAxLjI4Mi42Ni42NTggMS4xMDIgMS40MTIgMS4yODcgMi4xMDIiIGZpbGw9IiM0Qzk3RkYiLz48cGF0aCBkPSJNMzYuNDk4IDguNzQ4YzAgLjQ2NC0uMTQuODc0LS40MzMgMS4xNjVsLTE5Ljc0MiAxOS42OGMtMi4xMyAyLjExLTQuNjczIDMuNzkzLTcuNTcyIDUuMDFMNC41IDM2LjM4bC45NzQtMi4zMTYgMS45MjUtLjgwOGMyLjg5OC0xLjIxOCA1LjQ0LTIuOSA3LjU3LTUuMDFsMTkuNzQzLTE5LjY4Yy4yOTItLjI5Mi40MzItLjcwMi40MzItMS4xNjUgMC0uNjQ2LS4yNy0xLjQtLjc4LTIuMTIyLjI1LjE3Mi41LjM3Ny43MzcuNjE0Ljg5OC45MDUgMS4zOTYgMS45ODMgMS4zOTYgMi44NTYiIGZpbGw9IiM1NzVFNzUiIG9wYWNpdHk9Ii4xNSIvPjxwYXRoIGQ9Ik0xOC40NSAxMi44M2MwIC41LS40MDQuOTA1LS45MDQuOTA1cy0uOTA1LS40MDUtLjkwNS0uOTA0YzAtLjUuNDA3LS45MDMuOTA2LS45MDMuNSAwIC45MDQuNDA0LjkwNC45MDR6IiBmaWxsPSIjNTc1RTc1Ii8+PC9nPjwvc3ZnPg==";
/**
 * Enum for pen color parameter values.
 * @readonly
 * @enum {string}
 */

const ColorParam = {
  COLOR: "color",
  SATURATION: "saturation",
  BRIGHTNESS: "brightness",
  TRANSPARENCY: "transparency"
};
/**
 * @typedef {object} PenState - the pen state associated with a particular target.
 * @property {Boolean} penDown - tracks whether the pen should draw for this target.
 * @property {number} color - the current color (hue) of the pen.
 * @property {PenAttributes} penAttributes - cached pen attributes for the renderer. This is the authoritative value for
 *   diameter but not for pen color.
 */

/**
 * Host for the Pen-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */

class kidPenBlocksExtensions {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The ID of the renderer Drawable corresponding to the pen layer.
     * @type {int}
     * @private
     */

    this._penDrawableId = -1;
    /**
     * The ID of the renderer Skin corresponding to the pen layer.
     * @type {int}
     * @private
     */

    this._penSkinId = -1;
    this._onTargetCreated = this._onTargetCreated.bind(this);
    this._onTargetMoved = this._onTargetMoved.bind(this);
    runtime.on("targetWasCreated", this._onTargetCreated);
    runtime.on("RUNTIME_DISPOSED", this.clear.bind(this));
  }
  /**
   * The default pen state, to be used when a target has no existing pen state.
   * @type {PenState}
   */


  static get DEFAULT_PEN_STATE() {
    return {
      penDown: false,
      color: 66.66,
      saturation: 100,
      brightness: 100,
      transparency: 0,
      _shade: 50,
      // Used only for legacy `change shade by` blocks
      penAttributes: {
        color4f: [0, 0, 1, 1],
        diameter: 1
      }
    };
  }
  /**
   * The minimum and maximum allowed pen size.
   * The maximum is twice the diagonal of the stage, so that even an
   * off-stage sprite can fill it.
   * @type {{min: number, max: number}}
   */


  static get PEN_SIZE_RANGE() {
    return {
      min: 1,
      max: 1200
    };
  }
  /**
   * The key to load & store a target's pen-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.pen";
  }
  /**
   * Clamp a pen size value to the range allowed by the pen.
   * @param {number} requestedSize - the requested pen size.
   * @returns {number} the clamped size.
   * @private
   */


  _clampPenSize(requestedSize) {
    return Utility.clamp(requestedSize, kidPenBlocksExtensions.PEN_SIZE_RANGE.min, kidPenBlocksExtensions.PEN_SIZE_RANGE.max);
  }
  /**
   * Retrieve the ID of the renderer "Skin" corresponding to the pen layer. If
   * the pen Skin doesn't yet exist, create it.
   * @returns {int} the Skin ID of the pen layer, or -1 on failure.
   * @private
   */


  _getPenLayerID() {
    if (this._penSkinId < 0 && this.runtime.renderer) {
      this._penSkinId = this.runtime.renderer.createPenSkin();
      this._penDrawableId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);
      this.runtime.renderer.updateDrawableProperties(this._penDrawableId, {
        skinId: this._penSkinId
      });
    }

    return this._penSkinId;
  }
  /**
   * @param {Target} target - collect pen state for this target. Probably, but not necessarily, a RenderedTarget.
   * @returns {PenState} the mutable pen state associated with that target. This will be created if necessary.
   * @private
   */


  _getPenState(target) {
    let penState = target.getCustomState(kidPenBlocksExtensions.STATE_KEY);

    if (!penState) {
      penState = Utility.cloneSimple(kidPenBlocksExtensions.DEFAULT_PEN_STATE);
      target.setCustomState(kidPenBlocksExtensions.STATE_KEY, penState);
    }

    return penState;
  }
  /**
   * When a pen-using Target is cloned, clone the pen state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const penState = sourceTarget.getCustomState(kidPenBlocksExtensions.STATE_KEY);

      if (penState) {
        newTarget.setCustomState(kidPenBlocksExtensions.STATE_KEY, Utility.cloneSimple(penState));

        if (penState.penDown) {
          newTarget.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
        }
      }
    }
  }
  /**
   * Handle a target which has moved. This only fires when the pen is down.
   * @param {RenderedTarget} target - the target which has moved.
   * @param {number} oldX - the previous X position.
   * @param {number} oldY - the previous Y position.
   * @param {boolean} isForce - whether the movement was forced.
   * @private
   */


  _onTargetMoved(target, oldX, oldY, isForce) {
    // Only move the pen if the movement isn't forced (ie. dragged).
    if (!isForce) {
      const penSkinId = this._getPenLayerID();

      if (penSkinId >= 0) {
        const penState = this._getPenState(target);

        this.runtime.renderer.penLine(penSkinId, penState.penAttributes, oldX, oldY, target.x, target.y);
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * Wrap a color input into the range (0,100).
   * @param {number} value - the value to be wrapped.
   * @returns {number} the wrapped value.
   * @private
   */


  _wrapColor(value) {
    return Utility.wrapClamp(value, 0, 100);
  }
  /**
   * Initialize color parameters menu with localized strings
   * @returns {array} of the localized text and values for each menu element
   * @private
   */


  _initColorParam() {
    return [{
      text: formatMessage({
        id: "pen.colorMenu.color",
        default: "color",
        description: "label for color element in color picker for pen extension"
      }),
      value: ColorParam.COLOR
    }, {
      text: formatMessage({
        id: "pen.colorMenu.saturation",
        default: "saturation",
        description: "label for saturation element in color picker for pen extension"
      }),
      value: ColorParam.SATURATION
    }, {
      text: formatMessage({
        id: "pen.colorMenu.brightness",
        default: "brightness",
        description: "label for brightness element in color picker for pen extension"
      }),
      value: ColorParam.BRIGHTNESS
    }, {
      text: formatMessage({
        id: "pen.colorMenu.transparency",
        default: "transparency",
        description: "label for transparency element in color picker for pen extension"
      }),
      value: ColorParam.TRANSPARENCY
    }];
  }
  /**
   * Clamp a pen color parameter to the range (0,100).
   * @param {number} value - the value to be clamped.
   * @returns {number} the clamped value.
   * @private
   */


  _clampColorParam(value) {
    return Utility.clamp(value, 0, 100);
  }
  /**
   * Convert an alpha value to a pen transparency value.
   * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
   * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
   * @param {number} alpha - the input alpha value.
   * @returns {number} the transparency value.
   * @private
   */


  _alphaToTransparency(alpha) {
    return (1.0 - alpha) * 100.0;
  }
  /**
   * Convert a pen transparency value to an alpha value.
   * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
   * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
   * @param {number} transparency - the input transparency value.
   * @returns {number} the alpha value.
   * @private
   */


  _transparencyToAlpha(transparency) {
    return 1.0 - transparency / 100.0;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: "pen",
      name: formatMessage({
        id: "pen.categoryName",
        default: "Pen",
        description: "Label for the pen extension category"
      }),
      blockIconURI: blockIconURIPenBlocks,
      blocks: [{
        opcode: "clear",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.clear",
          default: "erase all",
          description: "erase all pen trails and stamps"
        })
      }, {
        opcode: "stamp",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.stamp",
          default: "stamp",
          description: "render current costume on the background"
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: "penDown",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.penDown",
          default: "pen down",
          description: "start leaving a trail when the sprite moves"
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: "penUp",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.penUp",
          default: "pen up",
          description: "stop leaving a trail behind the sprite"
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: "setPenColorToColor",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.setColor",
          default: "set pen color to [COLOR]",
          description: "set the pen color to a particular (RGB) value"
        }),
        arguments: {
          COLOR: {
            type: ArgumentType.COLOR
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: "changePenColorParamBy",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.changeColorParam",
          default: "change pen [COLOR_PARAM] by [VALUE]",
          description: "change the state of a pen color parameter"
        }),
        arguments: {
          COLOR_PARAM: {
            type: ArgumentType.STRING,
            menu: "colorParam",
            defaultValue: ColorParam.COLOR
          },
          VALUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 10
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: "setPenColorParamTo",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.setColorParam",
          default: "set pen [COLOR_PARAM] to [VALUE]",
          description: "set the state for a pen color parameter e.g. saturation"
        }),
        arguments: {
          COLOR_PARAM: {
            type: ArgumentType.STRING,
            menu: "colorParam",
            defaultValue: ColorParam.COLOR
          },
          VALUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: "changePenSizeBy",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.changeSize",
          default: "change pen size by [SIZE]",
          description: "change the diameter of the trail left by a sprite"
        }),
        arguments: {
          SIZE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: "setPenSizeTo",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.setSize",
          default: "set pen size to [SIZE]",
          description: "set the diameter of a trail left by a sprite"
        }),
        arguments: {
          SIZE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        filter: [TargetType.SPRITE]
      },
      /* Legacy blocks, should not be shown in flyout */
      {
        opcode: "setPenShadeToNumber",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.setShade",
          default: "set pen shade to [SHADE]",
          description: "legacy pen blocks - set pen shade"
        }),
        arguments: {
          SHADE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: "changePenShadeBy",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.changeShade",
          default: "change pen shade by [SHADE]",
          description: "legacy pen blocks - change pen shade"
        }),
        arguments: {
          SHADE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: "setPenHueToNumber",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.setHue",
          default: "set pen color to [HUE]",
          description: "legacy pen blocks - set pen color to number"
        }),
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: "changePenHueBy",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "pen.changeHue",
          default: "change pen color by [HUE]",
          description: "legacy pen blocks - change pen color"
        }),
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }],
      menus: {
        colorParam: {
          acceptReporters: true,
          items: this._initColorParam()
        }
      }
    };
  }
  /**
   * The pen "clear" block clears the pen layer's contents.
   */


  clear() {
    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penClear(penSkinId);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "stamp" block stamps the current drawable's image onto the pen layer.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  stamp(args, util) {
    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      const target = util.target;
      this.runtime.renderer.penStamp(penSkinId, target.drawableID);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "pen down" block causes the target to leave pen trails on future motion.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  penDown(args, util) {
    const target = util.target;

    const penState = this._getPenState(target);

    if (!penState.penDown) {
      penState.penDown = true;
      target.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
    }

    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penPoint(penSkinId, penState.penAttributes, target.x, target.y);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "pen up" block stops the target from leaving pen trails.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  penUp(args, util) {
    const target = util.target;

    const penState = this._getPenState(target);

    if (penState.penDown) {
      penState.penDown = false;
      target.removeListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
    }
  }
  /**
   * The pen "set pen color to {color}" block sets the pen to a particular RGB color.
   * The transparency is reset to 0.
   * @param {object} args - the block arguments.
   *  @property {int} COLOR - the color to set, expressed as a 24-bit RGB value (0xRRGGBB).
   * @param {object} util - utility object provided by the runtime.
   */


  setPenColorToColor(args, util) {
    const penState = this._getPenState(util.target);

    const rgb = Utility.toRgbColorObject(args.COLOR);
    const hsv = Utility.rgbToHsv(rgb);
    penState.color = hsv.h / 360 * 100;
    penState.saturation = hsv.s * 100;
    penState.brightness = hsv.v * 100;

    if (rgb.hasOwnProperty("a")) {
      penState.transparency = 100 * (1 - rgb.a / 255.0);
    } else {
      penState.transparency = 0;
    } // Set the legacy "shade" value the same way scratch 2 did.


    penState._shade = penState.brightness / 2;

    this._updatePenColor(penState);
  }
  /**
   * Update the cached color from the color, saturation, brightness and transparency values
   * in the provided PenState object.
   * @param {PenState} penState - the pen state to update.
   * @private
   */


  _updatePenColor(penState) {
    const rgb = Utility.hsvToRgb({
      h: penState.color * 360 / 100,
      s: penState.saturation / 100,
      v: penState.brightness / 100
    });
    penState.penAttributes.color4f[0] = rgb.r / 255.0;
    penState.penAttributes.color4f[1] = rgb.g / 255.0;
    penState.penAttributes.color4f[2] = rgb.b / 255.0;
    penState.penAttributes.color4f[3] = this._transparencyToAlpha(penState.transparency);
  }
  /**
   * Set or change a single color parameter on the pen state, and update the pen color.
   * @param {ColorParam} param - the name of the color parameter to set or change.
   * @param {number} value - the value to set or change the param by.
   * @param {PenState} penState - the pen state to update.
   * @param {boolean} change - if true change param by value, if false set param to value.
   * @private
   */


  _setOrChangeColorParam(param, value, penState, change) {
    switch (param) {
      case ColorParam.COLOR:
        penState.color = this._wrapColor(value + (change ? penState.color : 0));
        break;

      case ColorParam.SATURATION:
        penState.saturation = this._clampColorParam(value + (change ? penState.saturation : 0));
        break;

      case ColorParam.BRIGHTNESS:
        penState.brightness = this._clampColorParam(value + (change ? penState.brightness : 0));
        break;

      case ColorParam.TRANSPARENCY:
        penState.transparency = this._clampColorParam(value + (change ? penState.transparency : 0));
        break;

      default:
        console.warn(`Tried to set or change unknown color parameter: ${param}`);
    }

    this._updatePenColor(penState);
  }
  /**
   * The "change pen {ColorParam} by {number}" block changes one of the pen's color parameters
   * by a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to change the selected parameter by.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenColorParamBy(args, util) {
    const penState = this._getPenState(util.target);

    this._setOrChangeColorParam(args.COLOR_PARAM, Utility.toNumber(args.VALUE), penState, true);
  }
  /**
   * The "set pen {ColorParam} to {number}" block sets one of the pen's color parameters
   * to a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to set the selected parameter to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenColorParamTo(args, util) {
    const penState = this._getPenState(util.target);

    this._setOrChangeColorParam(args.COLOR_PARAM, Utility.toNumber(args.VALUE), penState, false);
  }
  /**
   * The pen "change pen size by {number}" block changes the pen size by the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenSizeBy(args, util) {
    const penAttributes = this._getPenState(util.target).penAttributes;

    penAttributes.diameter = this._clampPenSize(penAttributes.diameter + Utility.toNumber(args.SIZE));
  }
  /**
   * The pen "set pen size to {number}" block sets the pen size to the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenSizeTo(args, util) {
    const penAttributes = this._getPenState(util.target).penAttributes;

    penAttributes.diameter = this._clampPenSize(Utility.toNumber(args.SIZE));
  }
  /* LEGACY OPCODES */

  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount to set the hue to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenHueToNumber(args, util) {
    const penState = this._getPenState(util.target);

    const hueValue = Utility.toNumber(args.HUE);
    const colorValue = hueValue / 2;

    this._setOrChangeColorParam(ColorParam.COLOR, colorValue, penState, false);

    this._setOrChangeColorParam(ColorParam.TRANSPARENCY, 0, penState, false);

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount of desired hue change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenHueBy(args, util) {
    const penState = this._getPenState(util.target);

    const hueChange = Utility.toNumber(args.HUE);
    const colorChange = hueChange / 2;

    this._setOrChangeColorParam(ColorParam.COLOR, colorChange, penState, true);

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Use legacy "set shade" code to calculate RGB value for shade,
   * then convert back to HSV and store those components.
   * It is important to also track the given shade in penState._shade
   * because it cannot be accurately backed out of the new HSV later.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount to set the shade to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenShadeToNumber(args, util) {
    const penState = this._getPenState(util.target);

    let newShade = Utility.toNumber(args.SHADE); // Wrap clamp the new shade value the way scratch 2 did.

    newShade = newShade % 200;
    if (newShade < 0) newShade += 200; // And store the shade that was used to compute this new color for later use.

    penState._shade = newShade;

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Because "shade" cannot be backed out of hsv consistently, use the previously
   * stored penState._shade to make the shade change.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount of desired shade change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenShadeBy(args, util) {
    const penState = this._getPenState(util.target);

    const shadeChange = Utility.toNumber(args.SHADE);
    this.setPenShadeToNumber({
      SHADE: penState._shade + shadeChange
    }, util);
  }
  /**
   * Update the pen state's color from its hue & shade values, Scratch 2.0 style.
   * @param {object} penState - update the HSV & RGB values in this pen state from its hue & shade values.
   * @private
   */


  _legacyUpdatePenColor(penState) {
    // Create the new color in RGB using the scratch 2 "shade" model
    let rgb = Utility.hsvToRgb({
      h: penState.color * 360 / 100,
      s: 1,
      v: 1
    });
    const shade = penState._shade > 100 ? 200 - penState._shade : penState._shade;

    if (shade < 50) {
      rgb = Utility.mixRgb(Utility.RGB_BLACK, rgb, (10 + shade) / 60);
    } else {
      rgb = Utility.mixRgb(rgb, Utility.RGB_WHITE, (shade - 50) / 60);
    } // Update the pen state according to new color


    const hsv = Utility.rgbToHsv(rgb);
    penState.color = 100 * hsv.h / 360;
    penState.saturation = 100 * hsv.s;
    penState.brightness = 100 * hsv.v;

    this._updatePenColor(penState);
  }

}
/** @description MIDI音乐资源域名 */


const ASSET_MIDI_HOST = window.location.protocol.indexOf("https") != -1 ? `https://kid.leadersir.net/` : `http://kid.leadersir.net/`;
/** @description midi资源url统一部分 */

const ASSET_MIDI_URL = `${ASSET_MIDI_HOST}kid/material/midi/`;
/** @description 用于存储所有midi资源的key及buffer */

let MIDI_BUFFER = {
  "drums/1-snare.mp3": null,
  "drums/2-bass-drum.mp3": null,
  "drums/3-side-stick.mp3": null,
  "drums/4-crash-cymbal.mp3": null,
  "drums/5-open-hi-hat.mp3": null,
  "drums/6-closed-hi-hat.mp3": null,
  "drums/7-tambourine.mp3": null,
  "drums/8-hand-clap.mp3": null,
  "drums/9-claves.mp3": null,
  "drums/10-wood-block.mp3": null,
  "drums/11-cowbell.mp3": null,
  "drums/12-triangle.mp3": null,
  "drums/13-bongo.mp3": null,
  "drums/14-conga.mp3": null,
  "drums/15-cabasa.mp3": null,
  "drums/16-guiro.mp3": null,
  "drums/17-vibraslap.mp3": null,
  "drums/18-cuica.mp3": null,
  "instruments/1-piano/24.mp3": null,
  "instruments/1-piano/36.mp3": null,
  "instruments/1-piano/48.mp3": null,
  "instruments/1-piano/60.mp3": null,
  "instruments/1-piano/72.mp3": null,
  "instruments/1-piano/84.mp3": null,
  "instruments/1-piano/96.mp3": null,
  "instruments/1-piano/108.mp3": null,
  "instruments/2-electric-piano/60.mp3": null,
  "instruments/3-organ/60.mp3": null,
  "instruments/4-guitar/60.mp3": null,
  "instruments/5-electric-guitar/60.mp3": null,
  "instruments/6-bass/36.mp3": null,
  "instruments/6-bass/48.mp3": null,
  "instruments/7-pizzicato/60.mp3": null,
  "instruments/8-cello/36.mp3": null,
  "instruments/8-cello/48.mp3": null,
  "instruments/8-cello/60.mp3": null,
  "instruments/9-trombone/36.mp3": null,
  "instruments/9-trombone/48.mp3": null,
  "instruments/9-trombone/60.mp3": null,
  "instruments/10-clarinet/48.mp3": null,
  "instruments/10-clarinet/60.mp3": null,
  "instruments/11-saxophone/36.mp3": null,
  "instruments/11-saxophone/60.mp3": null,
  "instruments/11-saxophone/84.mp3": null,
  "instruments/12-flute/60.mp3": null,
  "instruments/12-flute/72.mp3": null,
  "instruments/13-wooden-flute/60.mp3": null,
  "instruments/13-wooden-flute/72.mp3": null,
  "instruments/14-bassoon/36.mp3": null,
  "instruments/14-bassoon/48.mp3": null,
  "instruments/14-bassoon/60.mp3": null,
  "instruments/15-choir/48.mp3": null,
  "instruments/15-choir/60.mp3": null,
  "instruments/15-choir/72.mp3": null,
  "instruments/16-vibraphone/60.mp3": null,
  "instruments/16-vibraphone/72.mp3": null,
  "instruments/17-music-box/60.mp3": null,
  "instruments/18-steel-drum/60.mp3": null,
  "instruments/19-marimba/60.mp3": null,
  "instruments/20-synth-lead/60.mp3": null,
  "instruments/21-synth-pad/60.mp3": null
};
/**
 * @type {string} 显示在每个扩展块左边缘的图标svg，编码为数据URI.
 */

const blockIconURIMusicBlocks = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlPm11c2ljLWJsb2NrLWljb248L3RpdGxlPjxkZWZzPjxwYXRoIGQ9Ik0zMi4xOCAyNS44NzRDMzIuNjM2IDI4LjE1NyAzMC41MTIgMzAgMjcuNDMzIDMwYy0zLjA3IDAtNS45MjMtMS44NDMtNi4zNzItNC4xMjYtLjQ1OC0yLjI4NSAxLjY2NS00LjEzNiA0Ljc0My00LjEzNi42NDcgMCAxLjI4My4wODQgMS44OS4yMzQuMzM4LjA4Ni42MzcuMTguOTM4LjMwMi44Ny0uMDItLjEwNC0yLjI5NC0xLjgzNS0xMi4yMy0yLjEzNC0xMi4zMDIgMy4wNi0xLjg3IDguNzY4LTIuNzUyIDUuNzA4LS44ODUuMDc2IDQuODItMy42NSAzLjg0NC0zLjcyNC0uOTg3LTQuNjUtNy4xNTMuMjYzIDE0LjczOHptLTE2Ljk5OCA1Ljk5QzE1LjYzIDM0LjE0OCAxMy41MDcgMzYgMTAuNDQgMzZjLTMuMDcgMC01LjkyMi0xLjg1Mi02LjM4LTQuMTM2LS40NDgtMi4yODQgMS42NzQtNC4xMzUgNC43NS00LjEzNSAxLjAwMyAwIDEuOTc1LjE5NiAyLjg1NS41NDMuODIyLS4wNTUtLjE1LTIuMzc3LTEuODYyLTEyLjIyOC0yLjEzMy0xMi4zMDMgMy4wNi0xLjg3IDguNzY0LTIuNzUzIDUuNzA2LS44OTQuMDc2IDQuODItMy42NDggMy44MzQtMy43MjQtLjk4Ny00LjY1LTcuMTUyLjI2MiAxNC43Mzh6IiBpZD0iYSIvPjwvZGVmcz48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjx1c2UgZmlsbD0iI0ZGRiIgeGxpbms6aHJlZj0iI2EiLz48cGF0aCBzdHJva2Utb3BhY2l0eT0iLjEiIHN0cm9rZT0iIzAwMCIgZD0iTTI4LjQ1NiAyMS42NzVjLS4wMS0uMzEyLS4wODctLjgyNS0uMjU2LTEuNzAyLS4wOTYtLjQ5NS0uNjEyLTMuMDIyLS43NTMtMy43My0uMzk1LTEuOTgtLjc2LTMuOTItMS4xNDItNi4xMTMtLjczMi00LjIyMy0uNjkzLTYuMDUuMzQ0LTYuNTI3LjUtLjIzIDEuMDYtLjA4IDEuODQuMzUuNDE0LjIyNyAyLjE4MiAxLjM2NSAyLjA3IDEuMjk2IDEuOTk0IDEuMjQyIDMuNDY0IDEuNzc0IDQuOTMgMS41NDggMS41MjYtLjIzNyAyLjUwNC0uMDYgMi44NzYuNjE4LjM0OC42MzUuMDE1IDEuNDE2LS43MyAyLjE4LTEuNDcyIDEuNTE2LTMuOTc1IDIuNTE0LTUuODQ4IDIuMDIzLS44MjItLjIyLTEuMjM4LS40NjUtMi4zOC0xLjI2N2wtLjA5NS0uMDY2Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMy4yOTQgMS4zMzYgMi4wOCA5LjE4NyAyLjYzNyAxMS42NzRsLjAwMi4wMTJjLjUyOCAyLjYzNy0xLjg3MyA0LjcyNC01LjIzNiA0LjcyNC0zLjI5IDAtNi4zNjMtMS45ODgtNi44NjItNC41MjgtLjUzLTIuNjQgMS44NzMtNC43MzQgNS4yMzMtNC43MzQuNjcyIDAgMS4zNDcuMDg1IDIuMDE0LjI1LjIyNy4wNTcuNDM2LjExOC42MzYuMTg3em0tMTYuOTk2IDUuOTljLS4wMS0uMzE4LS4wOS0uODM4LS4yNjYtMS43MzctLjA5LS40Ni0uNTk1LTIuOTM3LS43NTMtMy43MjctLjM5LTEuOTYtLjc1LTMuODktMS4xMy02LjA3LS43MzItNC4yMjMtLjY5Mi02LjA1LjM0NC02LjUyNi41MDItLjIzIDEuMDYtLjA4MiAxLjg0LjM1LjQxNS4yMjcgMi4xODIgMS4zNjQgMi4wNyAxLjI5NSAxLjk5MyAxLjI0MiAzLjQ2MiAxLjc3NCA0LjkyNiAxLjU0OCAxLjUyNS0uMjQgMi41MDQtLjA2NCAyLjg3Ni42MTQuMzQ4LjYzNS4wMTUgMS40MTUtLjcyOCAyLjE4LTEuNDc0IDEuNTE3LTMuOTc3IDIuNTEzLTUuODQ3IDIuMDE3LS44Mi0uMjItMS4yMzYtLjQ2NC0yLjM3OC0xLjI2N2wtLjA5NS0uMDY1Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMi4yOTQgMS4zMzcgMi4wNzggOS4xOSAyLjYzNiAxMS42NzVsLjAwMy4wMTNjLjUxNyAyLjYzOC0xLjg4NCA0LjczMi01LjIzNCA0LjczMi0zLjI4NyAwLTYuMzYtMS45OTMtNi44Ny00LjU0LS41Mi0yLjY0IDEuODg0LTQuNzMgNS4yNC00LjczLjkwNSAwIDEuODAzLjE1IDIuNjUuNDM2eiIvPjwvZz48L3N2Zz4=";
/**
 * @type {string} 将在类别菜单中显示的图标svg，编码为数据URI.
 */

const menuIconURIMusicBlocks = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE2LjA5IDEyLjkzN2MuMjI4IDEuMTQxLS44MzMgMi4wNjMtMi4zNzMgMi4wNjMtMS41MzUgMC0yLjk2Mi0uOTIyLTMuMTg2LTIuMDYzLS4yMy0xLjE0Mi44MzMtMi4wNjggMi4zNzItMi4wNjguMzIzIDAgLjY0MS4wNDIuOTQ1LjExN2EzLjUgMy41IDAgMCAxIC40NjguMTUxYy40MzUtLjAxLS4wNTItMS4xNDctLjkxNy02LjExNC0xLjA2Ny02LjE1MiAxLjUzLS45MzUgNC4zODQtMS4zNzcgMi44NTQtLjQ0Mi4wMzggMi40MS0xLjgyNSAxLjkyMi0xLjg2Mi0uNDkzLTIuMzI1LTMuNTc3LjEzMiA3LjM3ek03LjQ2IDguNTYzYy0xLjg2Mi0uNDkzLTIuMzI1LTMuNTc2LjEzIDcuMzdDNy44MTYgMTcuMDczIDYuNzU0IDE4IDUuMjIgMThjLTEuNTM1IDAtMi45NjEtLjkyNi0zLjE5LTIuMDY4LS4yMjQtMS4xNDIuODM3LTIuMDY3IDIuMzc1LTIuMDY3LjUwMSAwIC45ODcuMDk4IDEuNDI3LjI3Mi40MTItLjAyOC0uMDc0LTEuMTg5LS45My02LjExNEMzLjgzNCAxLjg3IDYuNDMgNy4wODcgOS4yODIgNi42NDZjMi44NTQtLjQ0Ny4wMzggMi40MS0xLjgyMyAxLjkxN3oiIGZpbGw9IiM1NzVFNzUiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==";
/**
 * @function 拉取远端资源
 */

async function pullRemoteAssetAsync() {
  console.warn("待拉取的资源名:");
  const temp = Object.keys(MIDI_BUFFER);

  for (let i = 0; i < temp.length; i++) {
    console.warn("遍历拉取", temp[i]);
    const response = await fetch(ASSET_MIDI_URL + temp[i]);
    const blob = await response.blob();
    console.warn("blob:", blob);
    let reader = new FileReader(); // 开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象.

    reader.readAsArrayBuffer(blob); // 处理load事件。该事件在读取操作完成时触发。

    reader.onload = function (event) {
      MIDI_BUFFER[temp[i]] = event.target.result;
    };
  }
}
/**
 * 与音乐相关的块的类
 * @param {Runtime} runtime - 运行时实例化此块包.
 * @constructor
 */


class kidMusicBlocks {
  constructor(runtime) {
    this.runtime = runtime;
    /** @type {number} 当前正在同时播放的鼓声和乐器声音的数量. */

    this._concurrencyCounter = 0;
    /** @type {Array} 一组声音播放器，每个鼓声音一个. */

    this._drumPlayers = [];
    /** @type {Array[]} 声音播放器的数组。 每个乐器都有一个或多个音频播放器. */

    this._instrumentPlayerArrays = [];
    /** @type {Array[]} 声音播放器的数组。 每个乐器mya的每个可弹奏音符都有一个音频播放器. */

    this._instrumentPlayerNoteArrays = [];
    /** @type {Array} 音频bufferSourceNodes的数组。 每次您演奏乐器或鼓声时，都会创建一个bufferSourceNode。 我们会保留对它们的引用，以确保可以触发他们的事件. */

    this._bufferSources = [];
    this._onTargetCreated = this._onTargetCreated.bind(this);
    this.runtime.on("targetWasCreated", this._onTargetCreated);
    this._playNoteForPicker = this._playNoteForPicker.bind(this);
    this.runtime.on("PLAY_NOTE", this._playNoteForPicker);

    this._loadAllSounds();
  }
  /**
   * 解码全套鼓声和乐器声音，并将音频缓冲区存储在数组中.
   */


  async _loadAllSounds() {
    console.log("音乐扩展index.js _loadAllSounds"); // 等待拉取完成。

    await pullRemoteAssetAsync();
    const loadingPromises = [];
    this.DRUM_INFO.forEach((drumInfo, index) => {
      const filePath = `drums/${drumInfo.fileName}`;
      console.log("音乐扩展index.js _loadAllSounds drum", drumInfo);

      const promise = this._storeSound(filePath, index, this._drumPlayers);

      loadingPromises.push(promise);
    });
    this.INSTRUMENT_INFO.forEach((instrumentInfo, instrumentIndex) => {
      this._instrumentPlayerArrays[instrumentIndex] = [];
      this._instrumentPlayerNoteArrays[instrumentIndex] = [];
      instrumentInfo.samples.forEach((sample, noteIndex) => {
        const filePath = `instruments/${instrumentInfo.dirName}/${sample}`;
        console.log("音乐扩展index.js _loadAllSounds instrument", instrumentInfo);

        const promise = this._storeSound(filePath, noteIndex, this._instrumentPlayerArrays[instrumentIndex]);

        loadingPromises.push(promise);
      });
    });
    Promise.all(loadingPromises).then(() => {
      // @TODO: 更新扩展状态指示器.
      console.warn("更新扩展状态指示器");
    });
  }
  /**
   * 解码声音并将播放器存储在阵列中.
   * @param {string} filePath - 音频文件名.
   * @param {number} index - 存储音频播放器的索引.
   * @param {array} playerArray - 存储它的玩家数组.
   * @return {Promise} - 一旦存储声音，诺言就会解决.
   */


  _storeSound(filePath, index, playerArray) {
    console.log("音乐扩展index.js _storeSound", filePath, index, playerArray);
    const fullPath = `${filePath}.mp3`;
    if (!MIDI_BUFFER[fullPath]) return; // 声音播放器已通过上面所需的清单文件下载。.

    const soundBuffer = MIDI_BUFFER[fullPath];
    return this._decodeSound(soundBuffer).then(player => {
      playerArray[index] = player;
    });
  }
  /**
   * 解码声音并使用音频缓冲区返回承诺.
   * @param  {ArrayBuffer} soundBuffer - 包含编码音频的缓冲区.
   * @return {Promise} - 声音解码后将解决的诺言.
   */


  _decodeSound(soundBuffer) {
    console.log("音乐扩展index.js _decodeSound", soundBuffer);
    const engine = this.runtime.audioEngine;
    if (!engine) return Promise.reject(new Error("No Audio Context Detected")); // 检查较新的基于承诺的API

    return engine.decodeSoundPlayer({
      data: {
        buffer: soundBuffer
      }
    });
  }
  /**
   * 以暂存块格式为菜单创建数据，该数据由具有文本和值属性的对象数组组成。 文本是翻译后的字符串，值是一个索引.
   * @param  {object[]} info - An array of info objects each having a name property.
   * @return {array} - An array of objects with text and value properties.
   * @private
   */


  _buildMenu(info) {
    return info.map((entry, index) => {
      const obj = {};
      obj.text = entry.name;
      obj.value = String(index + 1);
      return obj;
    });
  }
  /**
   * 有关每个鼓的一系列信息.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the drums menu.
   * @param {string} fileName - the name of the audio file containing the drum sound.
   */


  get DRUM_INFO() {
    return [{
      name: formatMessage({
        id: "music.drumSnare",
        default: "(1) Snare Drum",
        description: "Sound of snare drum as used in a standard drum kit"
      }),
      fileName: "1-snare"
    }, {
      name: formatMessage({
        id: "music.drumBass",
        default: "(2) Bass Drum",
        description: "Sound of bass drum as used in a standard drum kit"
      }),
      fileName: "2-bass-drum"
    }, {
      name: formatMessage({
        id: "music.drumSideStick",
        default: "(3) Side Stick",
        description: "Sound of a drum stick hitting the side of a drum (usually the snare)"
      }),
      fileName: "3-side-stick"
    }, {
      name: formatMessage({
        id: "music.drumCrashCymbal",
        default: "(4) Crash Cymbal",
        description: "Sound of a drum stick hitting a crash cymbal"
      }),
      fileName: "4-crash-cymbal"
    }, {
      name: formatMessage({
        id: "music.drumOpenHiHat",
        default: "(5) Open Hi-Hat",
        description: "Sound of a drum stick hitting a hi-hat while open"
      }),
      fileName: "5-open-hi-hat"
    }, {
      name: formatMessage({
        id: "music.drumClosedHiHat",
        default: "(6) Closed Hi-Hat",
        description: "Sound of a drum stick hitting a hi-hat while closed"
      }),
      fileName: "6-closed-hi-hat"
    }, {
      name: formatMessage({
        id: "music.drumTambourine",
        default: "(7) Tambourine",
        description: "Sound of a tambourine being struck"
      }),
      fileName: "7-tambourine"
    }, {
      name: formatMessage({
        id: "music.drumHandClap",
        default: "(8) Hand Clap",
        description: "Sound of two hands clapping together"
      }),
      fileName: "8-hand-clap"
    }, {
      name: formatMessage({
        id: "music.drumClaves",
        default: "(9) Claves",
        description: "Sound of claves being struck together"
      }),
      fileName: "9-claves"
    }, {
      name: formatMessage({
        id: "music.drumWoodBlock",
        default: "(10) Wood Block",
        description: "Sound of a wood block being struck"
      }),
      fileName: "10-wood-block"
    }, {
      name: formatMessage({
        id: "music.drumCowbell",
        default: "(11) Cowbell",
        description: "Sound of a cowbell being struck"
      }),
      fileName: "11-cowbell"
    }, {
      name: formatMessage({
        id: "music.drumTriangle",
        default: "(12) Triangle",
        description: "Sound of a triangle (instrument) being struck"
      }),
      fileName: "12-triangle"
    }, {
      name: formatMessage({
        id: "music.drumBongo",
        default: "(13) Bongo",
        description: "Sound of a bongo being struck"
      }),
      fileName: "13-bongo"
    }, {
      name: formatMessage({
        id: "music.drumConga",
        default: "(14) Conga",
        description: "Sound of a conga being struck"
      }),
      fileName: "14-conga"
    }, {
      name: formatMessage({
        id: "music.drumCabasa",
        default: "(15) Cabasa",
        description: "Sound of a cabasa being shaken"
      }),
      fileName: "15-cabasa"
    }, {
      name: formatMessage({
        id: "music.drumGuiro",
        default: "(16) Guiro",
        description: "Sound of a guiro being played"
      }),
      fileName: "16-guiro"
    }, {
      name: formatMessage({
        id: "music.drumVibraslap",
        default: "(17) Vibraslap",
        description: "Sound of a Vibraslap being played"
      }),
      fileName: "17-vibraslap"
    }, {
      name: formatMessage({
        id: "music.drumCuica",
        default: "(18) Cuica",
        description: "Sound of a cuica being played"
      }),
      fileName: "18-cuica"
    }];
  }
  /**
   * An array of info about each instrument.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the instruments menu.
   * @param {string} dirName - the name of the directory containing audio samples for this instrument.
   * @param {number} [releaseTime] - an optional duration for the release portion of each note.
   * @param {number[]} samples - an array of numbers representing the MIDI note number for each
   *                           sampled sound used to play this instrument.
   */


  get INSTRUMENT_INFO() {
    return [{
      name: formatMessage({
        id: "music.instrumentPiano",
        default: "(1) Piano",
        description: "Sound of a piano"
      }),
      dirName: "1-piano",
      releaseTime: 0.5,
      samples: [24, 36, 48, 60, 72, 84, 96, 108]
    }, {
      name: formatMessage({
        id: "music.instrumentElectricPiano",
        default: "(2) Electric Piano",
        description: "Sound of an electric piano"
      }),
      dirName: "2-electric-piano",
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentOrgan",
        default: "(3) Organ",
        description: "Sound of an organ"
      }),
      dirName: "3-organ",
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentGuitar",
        default: "(4) Guitar",
        description: "Sound of an accoustic guitar"
      }),
      dirName: "4-guitar",
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentElectricGuitar",
        default: "(5) Electric Guitar",
        description: "Sound of an electric guitar"
      }),
      dirName: "5-electric-guitar",
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentBass",
        default: "(6) Bass",
        description: "Sound of an accoustic upright bass"
      }),
      dirName: "6-bass",
      releaseTime: 0.25,
      samples: [36, 48]
    }, {
      name: formatMessage({
        id: "music.instrumentPizzicato",
        default: "(7) Pizzicato",
        description: "Sound of a string instrument (e.g. violin) being plucked"
      }),
      dirName: "7-pizzicato",
      releaseTime: 0.25,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentCello",
        default: "(8) Cello",
        description: "Sound of a cello being played with a bow"
      }),
      dirName: "8-cello",
      releaseTime: 0.1,
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: "music.instrumentTrombone",
        default: "(9) Trombone",
        description: "Sound of a trombone being played"
      }),
      dirName: "9-trombone",
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: "music.instrumentClarinet",
        default: "(10) Clarinet",
        description: "Sound of a clarinet being played"
      }),
      dirName: "10-clarinet",
      samples: [48, 60]
    }, {
      name: formatMessage({
        id: "music.instrumentSaxophone",
        default: "(11) Saxophone",
        description: "Sound of a saxophone being played"
      }),
      dirName: "11-saxophone",
      samples: [36, 60, 84]
    }, {
      name: formatMessage({
        id: "music.instrumentFlute",
        default: "(12) Flute",
        description: "Sound of a flute being played"
      }),
      dirName: "12-flute",
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: "music.instrumentWoodenFlute",
        default: "(13) Wooden Flute",
        description: "Sound of a wooden flute being played"
      }),
      dirName: "13-wooden-flute",
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: "music.instrumentBassoon",
        default: "(14) Bassoon",
        description: "Sound of a bassoon being played"
      }),
      dirName: "14-bassoon",
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: "music.instrumentChoir",
        default: "(15) Choir",
        description: "Sound of a choir singing"
      }),
      dirName: "15-choir",
      releaseTime: 0.25,
      samples: [48, 60, 72]
    }, {
      name: formatMessage({
        id: "music.instrumentVibraphone",
        default: "(16) Vibraphone",
        description: "Sound of a vibraphone being struck"
      }),
      dirName: "16-vibraphone",
      releaseTime: 0.5,
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: "music.instrumentMusicBox",
        default: "(17) Music Box",
        description: "Sound of a music box playing"
      }),
      dirName: "17-music-box",
      releaseTime: 0.25,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentSteelDrum",
        default: "(18) Steel Drum",
        description: "Sound of a steel drum being struck"
      }),
      dirName: "18-steel-drum",
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentMarimba",
        default: "(19) Marimba",
        description: "Sound of a marimba being struck"
      }),
      dirName: "19-marimba",
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentSynthLead",
        default: "(20) Synth Lead",
        description: 'Sound of a "lead" synthesizer being played'
      }),
      dirName: "20-synth-lead",
      releaseTime: 0.1,
      samples: [60]
    }, {
      name: formatMessage({
        id: "music.instrumentSynthPad",
        default: "(21) Synth Pad",
        description: 'Sound of a "pad" synthesizer being played'
      }),
      dirName: "21-synth-pad",
      releaseTime: 0.25,
      samples: [60]
    }];
  }
  /**
   * 从MIDI乐器编号到Scratch乐器编号的映射的数组.
   * @type {number[]}
   */


  get MIDI_INSTRUMENTS() {
    return [// Acoustic Grand, Bright Acoustic, Electric Grand, Honky-Tonk
    1, 1, 1, 1, // Electric Piano 1, Electric Piano 2, Harpsichord, Clavinet
    2, 2, 4, 4, // Celesta, Glockenspiel, Music Box, Vibraphone
    17, 17, 17, 16, // Marimba, Xylophone, Tubular Bells, Dulcimer
    19, 16, 17, 17, // Drawbar Organ, Percussive Organ, Rock Organ, Church Organ
    3, 3, 3, 3, // Reed Organ, Accordion, Harmonica, Tango Accordion
    3, 3, 3, 3, // Nylon String Guitar, Steel String Guitar, Electric Jazz Guitar, Electric Clean Guitar
    4, 4, 5, 5, // Electric Muted Guitar, Overdriven Guitar,Distortion Guitar, Guitar Harmonics
    5, 5, 5, 5, // Acoustic Bass, Electric Bass (finger), Electric Bass (pick), Fretless Bass
    6, 6, 6, 6, // Slap Bass 1, Slap Bass 2, Synth Bass 1, Synth Bass 2
    6, 6, 6, 6, // Violin, Viola, Cello, Contrabass
    8, 8, 8, 8, // Tremolo Strings, Pizzicato Strings, Orchestral Strings, Timpani
    8, 7, 8, 19, // String Ensemble 1, String Ensemble 2, SynthStrings 1, SynthStrings 2
    8, 8, 8, 8, // Choir Aahs, Voice Oohs, Synth Voice, Orchestra Hit
    15, 15, 15, 19, // Trumpet, Trombone, Tuba, Muted Trumpet
    9, 9, 9, 9, // French Horn, Brass Section, SynthBrass 1, SynthBrass 2
    9, 9, 9, 9, // Soprano Sax, Alto Sax, Tenor Sax, Baritone Sax
    11, 11, 11, 11, // Oboe, English Horn, Bassoon, Clarinet
    14, 14, 14, 10, // Piccolo, Flute, Recorder, Pan Flute
    12, 12, 13, 13, // Blown Bottle, Shakuhachi, Whistle, Ocarina
    13, 13, 12, 12, // Lead 1 (square), Lead 2 (sawtooth), Lead 3 (calliope), Lead 4 (chiff)
    20, 20, 20, 20, // Lead 5 (charang), Lead 6 (voice), Lead 7 (fifths), Lead 8 (bass+lead)
    20, 20, 20, 20, // Pad 1 (new age), Pad 2 (warm), Pad 3 (polysynth), Pad 4 (choir)
    21, 21, 21, 21, // Pad 5 (bowed), Pad 6 (metallic), Pad 7 (halo), Pad 8 (sweep)
    21, 21, 21, 21, // FX 1 (rain), FX 2 (soundtrack), FX 3 (crystal), FX 4 (atmosphere)
    21, 21, 21, 21, // FX 5 (brightness), FX 6 (goblins), FX 7 (echoes), FX 8 (sci-fi)
    21, 21, 21, 21, // Sitar, Banjo, Shamisen, Koto
    4, 4, 4, 4, // Kalimba, Bagpipe, Fiddle, Shanai
    17, 14, 8, 10, // Tinkle Bell, Agogo, Steel Drums, Woodblock
    17, 17, 18, 19, // Taiko Drum, Melodic Tom, Synth Drum, Reverse Cymbal
    1, 1, 1, 1, // Guitar Fret Noise, Breath Noise, Seashore, Bird Tweet
    21, 21, 21, 21, // Telephone Ring, Helicopter, Applause, Gunshot
    21, 21, 21, 21];
  }
  /**
   * 一个数组，它是从范围（35..81）的MIDI鼓号到Scratch鼓号的映射.
   * It's in the format [drumNum, pitch, decay].
   * 目前未使用音调和衰减属性.
   * @type {Array[]}
   */


  get MIDI_DRUMS() {
    return [[1, -4], // "BassDrum" in 2.0, "Bass Drum" in 3.0 (which was "Tom" in 2.0)
    [1, 0], // Same as just above
    [2, 0], [0, 0], [7, 0], [0, 2], [1, -6, 4], [5, 0], [1, -3, 3.2], [5, 0], // "HiHatPedal" in 2.0, "Closed Hi-Hat" in 3.0
    [1, 0, 3], [4, -8], [1, 4, 3], [1, 7, 2.7], [3, -8], [1, 10, 2.7], [4, -2], [3, -11], [4, 2], [6, 0], [3, 0, 3.5], [10, 0], [3, -8, 3.5], [16, -6], [4, 2], [12, 2], [12, 0], [13, 0, 0.2], [13, 0, 2], [13, -5, 2], [12, 12], [12, 5], [10, 19], [10, 12], [14, 0], [14, 0], // "Maracas" in 2.0, "Cabasa" in 3.0 (TODO: pitch up?)
    [17, 12], [17, 5], [15, 0], // "GuiroShort" in 2.0, "Guiro" in 3.0 (which was "GuiroLong" in 2.0) (TODO: decay?)
    [15, 0], [8, 0], [9, 0], [9, -4], [17, -5], [17, 0], [11, -6, 1], [11, -6, 3]];
  }
  /**
   * The key to load & store a target's music-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.music";
  }
  /**
   * The default music-related state, to be used when a target has no existing music state.
   * @type {MusicState}
   */


  static get DEFAULT_MUSIC_STATE() {
    return {
      currentInstrument: 0
    };
  }
  /**
   * The minimum and maximum MIDI note numbers, for clamping the input to play note.
   * @type {{min: number, max: number}}
   */


  static get MIDI_NOTE_RANGE() {
    return {
      min: 0,
      max: 130
    };
  }
  /**
   * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
   * 100 beats at the default tempo of 60bpm is 100 seconds.
   * @type {{min: number, max: number}}
   */


  static get BEAT_RANGE() {
    return {
      min: 0,
      max: 100
    };
  }
  /** The minimum and maximum tempo values, in bpm.
   * @type {{min: number, max: number}}
   */


  static get TEMPO_RANGE() {
    return {
      min: 20,
      max: 500
    };
  }
  /**
   * The maximum number of sounds to allow to play simultaneously.
   * @type {number}
   */


  static get CONCURRENCY_LIMIT() {
    return 30;
  }
  /**
   * @param {Target} target - collect music state for this target.
   * @returns {MusicState} the mutable music state associated with that target. This will be created if necessary.
   * @private
   */


  _getMusicState(target) {
    let musicState = target.getCustomState(kidMusicBlocks.STATE_KEY);

    if (!musicState) {
      musicState = Utility.cloneSimple(kidMusicBlocks.DEFAULT_MUSIC_STATE);
      target.setCustomState(kidMusicBlocks.STATE_KEY, musicState);
    }

    return musicState;
  }
  /**
   * When a music-playing Target is cloned, clone the music state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const musicState = sourceTarget.getCustomState(kidMusicBlocks.STATE_KEY);

      if (musicState) {
        newTarget.setCustomState(kidMusicBlocks.STATE_KEY, Utility.cloneSimple(musicState));
      }
    }
  }
  /**
   * @returns {object} 此扩展及其块的元数据.
   */


  getInfo() {
    return {
      id: "music",
      name: formatMessage({
        id: "music.categoryName",
        default: "Music",
        description: "Label for the Music extension category"
      }),
      menuIconURI: menuIconURIMusicBlocks,
      blockIconURI: blockIconURIMusicBlocks,
      blocks: [{
        opcode: "playDrumForBeats",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.playDrumForBeats",
          default: "play drum [DRUM] for [BEATS] beats",
          description: "play drum sample for a number of beats"
        }),
        arguments: {
          DRUM: {
            type: ArgumentType.NUMBER,
            menu: "DRUM",
            defaultValue: 1
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: "midiPlayDrumForBeats",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.midiPlayDrumForBeats",
          default: "play drum [DRUM] for [BEATS] beats",
          description: "play drum sample for a number of beats according to a mapping of MIDI codes"
        }),
        arguments: {
          DRUM: {
            type: ArgumentType.NUMBER,
            menu: "DRUM",
            defaultValue: 1
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        },
        hideFromPalette: true
      }, {
        opcode: "restForBeats",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.restForBeats",
          default: "rest for [BEATS] beats",
          description: "rest (play no sound) for a number of beats"
        }),
        arguments: {
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: "playNoteForBeats",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.playNoteForBeats",
          default: "play note [NOTE] for [BEATS] beats",
          description: "play a note for a number of beats"
        }),
        arguments: {
          NOTE: {
            type: ArgumentType.NOTE,
            defaultValue: 60
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: "setInstrument",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.setInstrument",
          default: "set instrument to [INSTRUMENT]",
          description: "set the instrument (e.g. piano, guitar, trombone) for notes played"
        }),
        arguments: {
          INSTRUMENT: {
            type: ArgumentType.NUMBER,
            menu: "INSTRUMENT",
            defaultValue: 1
          }
        }
      }, {
        opcode: "midiSetInstrument",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.midiSetInstrument",
          default: "set instrument to [INSTRUMENT]",
          description: "set the instrument for notes played according to a mapping of MIDI codes"
        }),
        arguments: {
          INSTRUMENT: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: "setTempo",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.setTempo",
          default: "set tempo to [TEMPO]",
          description: "set tempo (speed) for notes, drums, and rests played"
        }),
        arguments: {
          TEMPO: {
            type: ArgumentType.NUMBER,
            defaultValue: 60
          }
        }
      }, {
        opcode: "changeTempo",
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: "music.changeTempo",
          default: "change tempo by [TEMPO]",
          description: "change tempo (speed) for notes, drums, and rests played"
        }),
        arguments: {
          TEMPO: {
            type: ArgumentType.NUMBER,
            defaultValue: 20
          }
        }
      }, {
        opcode: "getTempo",
        text: formatMessage({
          id: "music.getTempo",
          default: "tempo",
          description: "get the current tempo (speed) for notes, drums, and rests played"
        }),
        blockType: BlockType.REPORTER
      }],
      menus: {
        DRUM: {
          acceptReporters: true,
          items: this._buildMenu(this.DRUM_INFO)
        },
        INSTRUMENT: {
          acceptReporters: true,
          items: this._buildMenu(this.INSTRUMENT_INFO)
        }
      }
    };
  }
  /**
   * Play a drum sound for some number of beats.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} DRUM - the number of the drum to play.
   * @property {number} BEATS - the duration in beats of the drum sound.
   */


  playDrumForBeats(args, util) {
    this._playDrumForBeats(args.DRUM, args.BEATS, util);
  }
  /**
   * Play a drum sound for some number of beats according to the range of "MIDI" drum codes supported.
   * This block is implemented for compatibility with old Scratch projects that use the
   * 'drum:duration:elapsed:from:' block.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  midiPlayDrumForBeats(args, util) {
    let drumNum = Utility.toNumber(args.DRUM);
    drumNum = Math.round(drumNum);
    const midiDescription = this.MIDI_DRUMS[drumNum - 35];

    if (midiDescription) {
      drumNum = midiDescription[0];
    } else {
      drumNum = 2; // Default instrument used in Scratch 2.0
    }

    drumNum += 1; // drumNum input to _playDrumForBeats is one-indexed

    this._playDrumForBeats(drumNum, args.BEATS, util);
  }
  /**
   * Internal code to play a drum sound for some number of beats.
   * @param {number} drumNum - the drum number.
   * @param {beats} beats - the duration in beats to pause after playing the sound.
   * @param {object} util - utility object provided by the runtime.
   */


  _playDrumForBeats(drumNum, beats, util) {
    if (this._stackTimerNeedsInit(util)) {
      drumNum = Utility.toNumber(drumNum);
      drumNum = Math.round(drumNum);
      drumNum -= 1; // drums are one-indexed

      drumNum = Utility.wrapClamp(drumNum, 0, this.DRUM_INFO.length - 1);
      beats = Utility.toNumber(beats);
      beats = this._clampBeats(beats);

      this._playDrumNum(util, drumNum);

      this._startStackTimer(util, this._beatsToSec(beats));
    } else {
      this._checkStackTimer(util);
    }
  }
  /**
   * Play a drum sound using its 0-indexed number.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} drumNum - the number of the drum to play.
   * @private
   */


  _playDrumNum(util, drumNum) {
    if (util.runtime.audioEngine === null) return;
    if (util.target.sprite.soundBank === null) return; // If we're playing too many sounds, do not play the drum sound.

    if (this._concurrencyCounter > kidMusicBlocks.CONCURRENCY_LIMIT) {
      return;
    }

    const player = this._drumPlayers[drumNum];
    if (typeof player === "undefined") return;

    if (player.isPlaying && !player.isStarting) {
      // Take the internal player state and create a new player with it.
      // `.play` does this internally but then instructs the sound to
      // stop.
      player.take();
    }

    const engine = util.runtime.audioEngine;
    const context = engine.audioContext;
    const volumeGain = context.createGain();
    volumeGain.gain.setValueAtTime(util.target.volume / 100, engine.currentTime);
    volumeGain.connect(engine.getInputNode());
    this._concurrencyCounter++;
    player.once("stop", () => {
      this._concurrencyCounter--;
    });
    player.play(); // Connect the player to the gain node.

    player.connect({
      getInputNode() {
        return volumeGain;
      }

    });
  }
  /**
   * Rest for some number of beats.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} BEATS - the duration in beats of the rest.
   */


  restForBeats(args, util) {
    if (this._stackTimerNeedsInit(util)) {
      let beats = Utility.toNumber(args.BEATS);
      beats = this._clampBeats(beats);

      this._startStackTimer(util, this._beatsToSec(beats));
    } else {
      this._checkStackTimer(util);
    }
  }
  /**
   * Play a note using the current musical instrument for some number of beats.
   * This function processes the arguments, and handles the timing of the block's execution.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} NOTE - the pitch of the note to play, interpreted as a MIDI note number.
   * @property {number} BEATS - the duration in beats of the note.
   */


  playNoteForBeats(args, util) {
    if (this._stackTimerNeedsInit(util)) {
      let note = Utility.toNumber(args.NOTE);
      note = Utility.clamp(note, kidMusicBlocks.MIDI_NOTE_RANGE.min, kidMusicBlocks.MIDI_NOTE_RANGE.max);
      let beats = Utility.toNumber(args.BEATS);
      beats = this._clampBeats(beats); // If the duration is 0, do not play the note. In Scratch 2.0, "play drum for 0 beats" plays the drum,
      // but "play note for 0 beats" is silent.

      if (beats === 0) return;

      const durationSec = this._beatsToSec(beats);

      this._playNote(util, note, durationSec);

      this._startStackTimer(util, durationSec);
    } else {
      this._checkStackTimer(util);
    }
  }

  _playNoteForPicker(noteNum, category) {
    if (category !== this.getInfo().name) return;
    const util = {
      runtime: this.runtime,
      target: this.runtime.getEditingTarget()
    };

    this._playNote(util, noteNum, 0.25);
  }
  /**
   * Play a note using the current instrument for a duration in seconds.
   * This function actually plays the sound, and handles the timing of the sound, including the
   * "release" portion of the sound, which continues briefly after the block execution has finished.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} note - the pitch of the note to play, interpreted as a MIDI note number.
   * @param {number} durationSec - the duration in seconds to play the note.
   * @private
   */


  _playNote(util, note, durationSec) {
    if (util.runtime.audioEngine === null) return;
    if (util.target.sprite.soundBank === null) return; // If we're playing too many sounds, do not play the note.

    if (this._concurrencyCounter > kidMusicBlocks.CONCURRENCY_LIMIT) {
      return;
    } // Determine which of the audio samples for this instrument to play


    const musicState = this._getMusicState(util.target);

    const inst = musicState.currentInstrument;
    const instrumentInfo = this.INSTRUMENT_INFO[inst];
    const sampleArray = instrumentInfo.samples;

    const sampleIndex = this._selectSampleIndexForNote(note, sampleArray); // If the audio sample has not loaded yet, bail out


    if (typeof this._instrumentPlayerArrays[inst] === "undefined") return;
    if (typeof this._instrumentPlayerArrays[inst][sampleIndex] === "undefined") return; // Fetch the sound player to play the note.

    const engine = util.runtime.audioEngine;

    if (!this._instrumentPlayerNoteArrays[inst][note]) {
      this._instrumentPlayerNoteArrays[inst][note] = this._instrumentPlayerArrays[inst][sampleIndex].take();
    }

    const player = this._instrumentPlayerNoteArrays[inst][note];

    if (player.isPlaying && !player.isStarting) {
      // Take the internal player state and create a new player with it.
      // `.play` does this internally but then instructs the sound to
      // stop.
      player.take();
    } // Set its pitch.


    const sampleNote = sampleArray[sampleIndex];

    const notePitchInterval = this._ratioForPitchInterval(note - sampleNote); // Create gain nodes for this note's volume and release, and chain them
    // to the output.


    const context = engine.audioContext;
    const volumeGain = context.createGain();
    volumeGain.gain.setValueAtTime(util.target.volume / 100, engine.currentTime);
    const releaseGain = context.createGain();
    volumeGain.connect(releaseGain);
    releaseGain.connect(engine.getInputNode()); // Schedule the release of the note, ramping its gain down to zero,
    // and then stopping the sound.

    let releaseDuration = this.INSTRUMENT_INFO[inst].releaseTime;

    if (typeof releaseDuration === "undefined") {
      releaseDuration = 0.01;
    }

    const releaseStart = context.currentTime + durationSec;
    const releaseEnd = releaseStart + releaseDuration;
    releaseGain.gain.setValueAtTime(1, releaseStart);
    releaseGain.gain.linearRampToValueAtTime(0.0001, releaseEnd);
    this._concurrencyCounter++;
    player.once("stop", () => {
      this._concurrencyCounter--;
    }); // Start playing the note

    player.play(); // Connect the player to the gain node.

    player.connect({
      getInputNode() {
        return volumeGain;
      }

    }); // Set playback now after play creates the outputNode.

    player.outputNode.playbackRate.value = notePitchInterval; // Schedule playback to stop.

    player.outputNode.stop(releaseEnd);
  }
  /**
   * The samples array for each instrument is the set of pitches of the available audio samples.
   * This function selects the best one to use to play a given input note, and returns its index
   * in the samples array.
   * @param  {number} note - the input note to select a sample for.
   * @param  {number[]} samples - an array of the pitches of the available samples.
   * @return {index} the index of the selected sample in the samples array.
   * @private
   */


  _selectSampleIndexForNote(note, samples) {
    // Step backwards through the array of samples, i.e. in descending pitch, in order to find
    // the sample that is the closest one below (or matching) the pitch of the input note.
    for (let i = samples.length - 1; i >= 0; i--) {
      if (note >= samples[i]) {
        return i;
      }
    }

    return 0;
  }
  /**
   * Calcuate the frequency ratio for a given musical interval.
   * @param  {number} interval - the pitch interval to convert.
   * @return {number} a ratio corresponding to the input interval.
   * @private
   */


  _ratioForPitchInterval(interval) {
    return Math.pow(2, interval / 12);
  }
  /**
   * Clamp a duration in beats to the allowed min and max duration.
   * @param  {number} beats - a duration in beats.
   * @return {number} - the clamped duration.
   * @private
   */


  _clampBeats(beats) {
    return Utility.clamp(beats, kidMusicBlocks.BEAT_RANGE.min, kidMusicBlocks.BEAT_RANGE.max);
  }
  /**
   * Convert a number of beats to a number of seconds, using the current tempo.
   * @param  {number} beats - number of beats to convert to secs.
   * @return {number} seconds - number of seconds `beats` will last.
   * @private
   */


  _beatsToSec(beats) {
    return 60 / this.getTempo() * beats;
  }
  /**
   * Check if the stack timer needs initialization.
   * @param {object} util - utility object provided by the runtime.
   * @return {boolean} - true if the stack timer needs to be initialized.
   * @private
   */


  _stackTimerNeedsInit(util) {
    return !util.stackFrame.timer;
  }
  /**
   * Start the stack timer and the yield the thread if necessary.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} duration - a duration in seconds to set the timer for.
   * @private
   */


  _startStackTimer(util, duration) {
    util.stackFrame.timer = new Timer();
    util.stackFrame.timer.start();
    util.stackFrame.duration = duration;
    util.yield();
  }
  /**
   * Check the stack timer, and if its time is not up yet, yield the thread.
   * @param {object} util - utility object provided by the runtime.
   * @private
   */


  _checkStackTimer(util) {
    const timeElapsed = util.stackFrame.timer.timeElapsed();

    if (timeElapsed < util.stackFrame.duration * 1000) {
      util.yield();
    }
  }
  /**
   * Select an instrument for playing notes.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} INSTRUMENT - the number of the instrument to select.
   */


  setInstrument(args, util) {
    this._setInstrument(args.INSTRUMENT, util, false);
  }
  /**
   * Select an instrument for playing notes according to a mapping of MIDI codes to Scratch instrument numbers.
   * This block is implemented for compatibility with old Scratch projects that use the 'midiInstrument:' block.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} INSTRUMENT - the MIDI number of the instrument to select.
   */


  midiSetInstrument(args, util) {
    this._setInstrument(args.INSTRUMENT, util, true);
  }
  /**
   * Internal code to select an instrument for playing notes. If mapMidi is true, set the instrument according to
   * the MIDI to Scratch instrument mapping.
   * @param {number} instNum - the instrument number.
   * @param {object} util - utility object provided by the runtime.
   * @param {boolean} mapMidi - whether or not instNum is a MIDI instrument number.
   */


  _setInstrument(instNum, util, mapMidi) {
    const musicState = this._getMusicState(util.target);

    instNum = Utility.toNumber(instNum);
    instNum = Math.round(instNum);
    instNum -= 1; // instruments are one-indexed

    if (mapMidi) {
      instNum = (this.MIDI_INSTRUMENTS[instNum] || 0) - 1;
    }

    instNum = Utility.wrapClamp(instNum, 0, this.INSTRUMENT_INFO.length - 1);
    musicState.currentInstrument = instNum;
  }
  /**
   * Set the current tempo to a new value.
   * @param {object} args - the block arguments.
   * @property {number} TEMPO - the tempo, in beats per minute.
   */


  setTempo(args) {
    const tempo = Utility.toNumber(args.TEMPO);

    this._updateTempo(tempo);
  }
  /**
   * Change the current tempo by some amount.
   * @param {object} args - the block arguments.
   * @property {number} TEMPO - the amount to change the tempo, in beats per minute.
   */


  changeTempo(args) {
    const change = Utility.toNumber(args.TEMPO);
    const tempo = change + this.getTempo();

    this._updateTempo(tempo);
  }
  /**
   * Update the current tempo, clamping it to the min and max allowable range.
   * @param {number} tempo - the tempo to set, in beats per minute.
   * @private
   */


  _updateTempo(tempo) {
    tempo = Utility.clamp(tempo, kidMusicBlocks.TEMPO_RANGE.min, kidMusicBlocks.TEMPO_RANGE.max);
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      stage.tempo = tempo;
    }
  }
  /**
   * Get the current tempo.
   * @return {number} - the current tempo, in beats per minute.
   */


  getTempo() {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      return stage.tempo;
    }

    return 60;
  }

} // 这些扩展当前内置于VM存储库中，但不应在启动时加载.
// TODO: 将它们移到单独的存储库中?
// TODO: 更改扩展规范，以便可以通过静态方法收集库信息（包括扩展ID）


const builtinExtensions = {
  // 此示例未与其他核心模块一起加载，但作为将核心模块作为扩展加载的参考.
  coreExample: () => KidCoreExample,
  // 这些是非核心内置扩展.
  pen: () => kidPenBlocksExtensions,
  wedo2: () => __webpack_require__(/*! ../extensions/scratch3_wedo2 */ "./src/extensions/scratch3_wedo2/index.js"),
  music: () => kidMusicBlocks,
  microbit: () => __webpack_require__(/*! ../extensions/scratch3_microbit */ "./src/extensions/scratch3_microbit/index.js"),
  text2speech: () => __webpack_require__(/*! ../extensions/scratch3_text2speech */ "./src/extensions/scratch3_text2speech/index.js"),
  translate: () => __webpack_require__(/*! ../extensions/scratch3_translate */ "./src/extensions/scratch3_translate/index.js"),
  videoSensing: () => __webpack_require__(/*! ../extensions/scratch3_video_sensing */ "./src/extensions/scratch3_video_sensing/index.js"),
  ev3: () => __webpack_require__(/*! ../extensions/scratch3_ev3 */ "./src/extensions/scratch3_ev3/index.js"),
  makeymakey: () => __webpack_require__(/*! ../extensions/scratch3_makeymakey */ "./src/extensions/scratch3_makeymakey/index.js"),
  boost: () => __webpack_require__(/*! ../extensions/scratch3_boost */ "./src/extensions/scratch3_boost/index.js") // gdxfor: () => require("../extensions/scratch3_gdx_for"),z

};
console.warn("扩展", builtinExtensions);
/**
 * @typedef {object} ArgumentInfo - Information about an extension block argument
 * @property {ArgumentType} type - the type of value this argument can take
 * @property {*|undefined} default - the default value of this argument (default: blank)
 */

/**
 * @typedef {object} ConvertedBlockInfo - Raw extension block data paired with processed data ready for scratch-blocks
 * @property {ExtensionBlockMetadata} info - the raw block info
 * @property {object} json - the scratch-blocks JSON definition for this block
 * @property {string} xml - the scratch-blocks XML definition for this block
 */

/**
 * @typedef {object} CategoryInfo - Information about a block category
 * @property {string} id - the unique ID of this category
 * @property {string} name - the human-readable name of this category
 * @property {string|undefined} blockIconURI - optional URI for the block icon image
 * @property {string} color1 - the primary color for this category, in '#rrggbb' format
 * @property {string} color2 - the secondary color for this category, in '#rrggbb' format
 * @property {string} color3 - the tertiary color for this category, in '#rrggbb' format
 * @property {Array.<ConvertedBlockInfo>} blocks - the blocks, separators, etc. in this category
 * @property {Array.<object>} menus - the menus provided by this category
 */

/**
 * @typedef {object} PendingExtensionWorker - Information about an extension worker still initializing
 * @property {string} extensionURL - the URL of the extension to be loaded by this worker
 * @property {Function} resolve - function to call on successful worker startup
 * @property {Function} reject - function to call on failed worker startup
 */

class ExtensionManager {
  constructor(runtime) {
    /**
     * The ID number to provide to the next extension worker.
     * @type {int}
     */
    this.nextExtensionWorker = 0;
    /**
     * FIFO queue of extensions which have been requested but not yet loaded in a worker,along with promise resolution functions to call once the worker is ready or failed.
     *
     * @type {Array.<PendingExtensionWorker>}
     */

    this.pendingExtensions = [];
    /**
     * Map of worker ID to workers which have been allocated but have not yet finished initialization.
     * @type {Array.<PendingExtensionWorker>}
     */

    this.pendingWorkers = [];
    /**
     * Set of loaded extension URLs/IDs (equivalent for built-in extensions).
     * @type {Set.<string>}
     * @private
     */

    this._loadedExtensions = new Map();
    /**
     * Keep a reference to the runtime so we can construct internal extension objects.
     * TODO: remove this in favor of extensions accessing the runtime as a service.
     * @type {Runtime}
     */

    this.runtime = runtime;
    dispatch.setService("extensions", this).catch(e => {
      console.error(`ExtensionManager was unable to register extension service: ${JSON.stringify(e)}`);
    });
  }
  /**
   * Check whether an extension is registered or is in the process of loading. This is intended to control loading or
   * adding extensions so it may return `true` before the extension is ready to be used. Use the promise returned by
   * `loadExtensionURL` if you need to wait until the extension is truly ready.
   * @param {string} extensionID - the ID of the extension.
   * @returns {boolean} - true if loaded, false otherwise.
   */


  isExtensionLoaded(extensionID) {
    return this._loadedExtensions.has(extensionID);
  }
  /**
   * Synchronously load an internal extension (core or non-core) by ID. This call will
   * fail if the provided id is not does not match an internal extension.
   * @param {string} extensionId - the ID of an internal extension
   */


  loadExtensionIdSync(extensionId) {
    if (!builtinExtensions.hasOwnProperty(extensionId)) {
      console.warn(`Could not find extension ${extensionId} in the built in extensions.`);
      return;
    }
    /** @TODO dupe handling for non-builtin extensions. See commit 670e51d33580e8a2e852b3b038bb3afc282f81b9 */


    if (this.isExtensionLoaded(extensionId)) {
      const message = `Rejecting attempt to load a second extension with ID ${extensionId}`;
      console.warn(message);
      return;
    }

    const extension = builtinExtensions[extensionId]();
    const extensionInstance = new extension(this.runtime);

    const serviceName = this._registerInternalExtension(extensionInstance);

    this._loadedExtensions.set(extensionId, serviceName);
  }
  /**
   * Load an extension by URL or internal extension ID
   * @param {string} extensionURL - the URL for the extension to load OR the ID of an internal extension
   * @returns {Promise} resolved once the extension is loaded and initialized or rejected on failure
   */


  loadExtensionURL(extensionURL) {
    if (builtinExtensions.hasOwnProperty(extensionURL)) {
      /** @TODO dupe handling for non-builtin extensions. See commit 670e51d33580e8a2e852b3b038bb3afc282f81b9 */
      if (this.isExtensionLoaded(extensionURL)) {
        const message = `Rejecting attempt to load a second extension with ID ${extensionURL}`;
        console.warn(message);
        return Promise.resolve();
      }

      const extension = builtinExtensions[extensionURL]();
      const extensionInstance = new extension(this.runtime);

      const serviceName = this._registerInternalExtension(extensionInstance);

      this._loadedExtensions.set(extensionURL, serviceName);

      return Promise.resolve();
    }

    return new Promise((resolve, reject) => {
      // 如果我们在全局一级“require”这样做，则会破坏非Webpack目标，包括测试
      const ExtensionWorker = __webpack_require__(/*! worker-loader?name=extension-worker.js!./extension-worker */ "./node_modules/worker-loader/dist/cjs.js?name=extension-worker.js!./src/extension-support/extension-worker.js");

      this.pendingExtensions.push({
        extensionURL,
        resolve,
        reject
      });
      dispatch.addWorker(new ExtensionWorker());
    });
  }
  /**
   * Regenerate blockinfo for any loaded extensions
   * @returns {Promise} resolved once all the extensions have been reinitialized
   */


  refreshBlocks() {
    const allPromises = Array.from(this._loadedExtensions.values()).map(serviceName => dispatch.call(serviceName, "getInfo").then(info => {
      info = this._prepareExtensionInfo(serviceName, info);
      dispatch.call("runtime", "_refreshExtensionPrimitives", info);
    }).catch(e => {
      console.error(`Failed to refresh built-in extension primitives: ${JSON.stringify(e)}`);
    }));
    return Promise.all(allPromises);
  }

  allocateWorker() {
    const id = this.nextExtensionWorker++;
    const workerInfo = this.pendingExtensions.shift();
    this.pendingWorkers[id] = workerInfo;
    return [id, workerInfo.extensionURL];
  }
  /**
   * Synchronously collect extension metadata from the specified service and begin the extension registration process.
   * @param {string} serviceName - the name of the service hosting the extension.
   */


  registerExtensionServiceSync(serviceName) {
    const info = dispatch.callSync(serviceName, "getInfo");

    this._registerExtensionInfo(serviceName, info);
  }
  /**
   * Collect extension metadata from the specified service and begin the extension registration process.
   * @param {string} serviceName - the name of the service hosting the extension.
   */


  registerExtensionService(serviceName) {
    dispatch.call(serviceName, "getInfo").then(info => {
      this._registerExtensionInfo(serviceName, info);
    });
  }
  /**
   * Called by an extension worker to indicate that the worker has finished initialization.
   * @param {int} id - the worker ID.
   * @param {*?} e - the error encountered during initialization, if any.
   */


  onWorkerInit(id, e) {
    const workerInfo = this.pendingWorkers[id];
    delete this.pendingWorkers[id];

    if (e) {
      workerInfo.reject(e);
    } else {
      workerInfo.resolve(id);
    }
  }
  /**
   * Register an internal (non-Worker) extension object
   * @param {object} extensionObject - the extension object to register
   * @returns {string} The name of the registered extension service
   */


  _registerInternalExtension(extensionObject) {
    const extensionInfo = extensionObject.getInfo();
    const fakeWorkerId = this.nextExtensionWorker++;
    const serviceName = `extension_${fakeWorkerId}_${extensionInfo.id}`;
    dispatch.setServiceSync(serviceName, extensionObject);
    dispatch.callSync("extensions", "registerExtensionServiceSync", serviceName);
    return serviceName;
  }
  /**
   * Sanitize extension info then register its primitives with the VM.
   * @param {string} serviceName - the name of the service hosting the extension
   * @param {ExtensionInfo} extensionInfo - the extension's metadata
   * @private
   */


  _registerExtensionInfo(serviceName, extensionInfo) {
    extensionInfo = this._prepareExtensionInfo(serviceName, extensionInfo);
    dispatch.call("runtime", "_registerExtensionPrimitives", extensionInfo).catch(e => {
      console.error(`Failed to register primitives for extension on service ${serviceName}:`, e);
    });
  }
  /**
   * Modify the provided text as necessary to ensure that it may be used as an attribute value in valid XML.
   * @param {string} text - the text to be sanitized
   * @returns {string} - the sanitized text
   * @private
   */


  _sanitizeID(text) {
    return text.toString().replace(/[<"&]/, "_");
  }
  /**
   * Apply minor cleanup and defaults for optional extension fields.
   * TODO: make the ID unique in cases where two copies of the same extension are loaded.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {ExtensionInfo} extensionInfo - the extension info to be sanitized
   * @returns {ExtensionInfo} - a new extension info object with cleaned-up values
   * @private
   */


  _prepareExtensionInfo(serviceName, extensionInfo) {
    extensionInfo = Object.assign({}, extensionInfo);

    if (!/^[a-z0-9]+$/i.test(extensionInfo.id)) {
      throw new Error("Invalid extension id");
    }

    extensionInfo.name = extensionInfo.name || extensionInfo.id;
    extensionInfo.blocks = extensionInfo.blocks || [];
    extensionInfo.targetTypes = extensionInfo.targetTypes || [];
    extensionInfo.blocks = extensionInfo.blocks.reduce((results, blockInfo) => {
      try {
        let result;

        switch (blockInfo) {
          case "---":
            // separator
            result = "---";
            break;

          default:
            // an ExtensionBlockMetadata object
            result = this._prepareBlockInfo(serviceName, blockInfo);
            break;
        }

        results.push(result);
      } catch (e) {
        // TODO: more meaningful error reporting
        console.error(`Error processing block: ${e.message}, Block:\n${JSON.stringify(blockInfo)}`);
      }

      return results;
    }, []);
    extensionInfo.menus = extensionInfo.menus || {};
    extensionInfo.menus = this._prepareMenuInfo(serviceName, extensionInfo.menus);
    return extensionInfo;
  }
  /**
   * Prepare extension menus. e.g. setup binding for dynamic menu functions.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {Array.<MenuInfo>} menus - the menu defined by the extension.
   * @returns {Array.<MenuInfo>} - a menuInfo object with all preprocessing done.
   * @private
   */


  _prepareMenuInfo(serviceName, menus) {
    const menuNames = Object.getOwnPropertyNames(menus);

    for (let i = 0; i < menuNames.length; i++) {
      const menuName = menuNames[i];
      let menuInfo = menus[menuName]; // If the menu description is in short form (items only) then normalize it to general form: an object with
      // its items listed in an `items` property.

      if (!menuInfo.items) {
        menuInfo = {
          items: menuInfo
        };
        menus[menuName] = menuInfo;
      } // If `items` is a string, it should be the name of a function in the extension object. Calling the
      // function should return an array of items to populate the menu when it is opened.


      if (typeof menuInfo.items === "string") {
        const menuItemFunctionName = menuInfo.items;
        const serviceObject = dispatch.services[serviceName]; // Bind the function here so we can pass a simple item generation function to Scratch Blocks later.

        menuInfo.items = this._getExtensionMenuItems.bind(this, serviceObject, menuItemFunctionName);
      }
    }

    return menus;
  }
  /**
   * Fetch the items for a particular extension menu, providing the target ID for context.
   * @param {object} extensionObject - the extension object providing the menu.
   * @param {string} menuItemFunctionName - the name of the menu function to call.
   * @returns {Array} menu items ready for scratch-blocks.
   * @private
   */


  _getExtensionMenuItems(extensionObject, menuItemFunctionName) {
    // Fetch the items appropriate for the target currently being edited. This assumes that menus only
    // collect items when opened by the user while editing a particular target.
    const editingTarget = this.runtime.getEditingTarget() || this.runtime.getTargetForStage();
    const editingTargetID = editingTarget ? editingTarget.id : null;
    const extensionMessageContext = this.runtime.makeMessageContextForTarget(editingTarget); // TODO: Fix this to use dispatch.call when extensions are running in workers.

    const menuFunc = extensionObject[menuItemFunctionName];
    const menuItems = menuFunc.call(extensionObject, editingTargetID).map(item => {
      item = maybeFormatMessage(item, extensionMessageContext);

      switch (typeof item) {
        case "object":
          return [maybeFormatMessage(item.text, extensionMessageContext), item.value];

        case "string":
          return [item, item];

        default:
          return item;
      }
    });

    if (!menuItems || menuItems.length < 1) {
      throw new Error(`Extension menu returned no items: ${menuItemFunctionName}`);
    }

    return menuItems;
  }
  /**
   * Apply defaults for optional block fields.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {ExtensionBlockMetadata} blockInfo - the block info from the extension
   * @returns {ExtensionBlockMetadata} - a new block info object which has values for all relevant optional fields.
   * @private
   */


  _prepareBlockInfo(serviceName, blockInfo) {
    blockInfo = Object.assign({}, {
      blockType: BlockType.COMMAND,
      terminal: false,
      blockAllThreads: false,
      arguments: {}
    }, blockInfo);
    blockInfo.opcode = blockInfo.opcode && this._sanitizeID(blockInfo.opcode);
    blockInfo.text = blockInfo.text || blockInfo.opcode;

    switch (blockInfo.blockType) {
      case BlockType.EVENT:
        if (blockInfo.func) {
          console.warn(`Ignoring function "${blockInfo.func}" for event block ${blockInfo.opcode}`);
        }

        break;

      case BlockType.BUTTON:
        if (blockInfo.opcode) {
          console.warn(`Ignoring opcode "${blockInfo.opcode}" for button with text: ${blockInfo.text}`);
        }

        break;

      default:
        {
          if (!blockInfo.opcode) {
            throw new Error("Missing opcode for block");
          }

          const funcName = blockInfo.func ? this._sanitizeID(blockInfo.func) : blockInfo.opcode;
          const getBlockInfo = blockInfo.isDynamic ? args => args && args.mutation && args.mutation.blockInfo : () => blockInfo;

          const callBlockFunc = (() => {
            if (dispatch._isRemoteService(serviceName)) {
              return (args, util, realBlockInfo) => dispatch.call(serviceName, funcName, args, util, realBlockInfo);
            } // avoid promise latency if we can call direct


            const serviceObject = dispatch.services[serviceName];

            if (!serviceObject[funcName]) {
              // The function might show up later as a dynamic property of the service object
              console.warn(`Could not find extension block function called ${funcName}`);
            }

            return (args, util, realBlockInfo) => serviceObject[funcName](args, util, realBlockInfo);
          })();

          blockInfo.func = (args, util) => {
            const realBlockInfo = getBlockInfo(args); // TODO: filter args using the keys of realBlockInfo.arguments? maybe only if sandboxed?

            return callBlockFunc(args, util, realBlockInfo);
          };

          break;
        }
    }

    return blockInfo;
  }

}

module.exports = ExtensionManager;

/***/ }),

/***/ "./src/extension-support/target-type.js":
/*!**********************************************!*\
  !*** ./src/extension-support/target-type.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Default types of Target supported by the VM
 * @enum {string}
 */
const TargetType = {
  /**
   * Rendered target which can move, change costumes, etc.
   */
  SPRITE: 'sprite',

  /**
   * Rendered target which cannot move but can change backdrops
   */
  STAGE: 'stage'
};
module.exports = TargetType;

/***/ }),

/***/ "./src/extensions/scratch3_boost/index.js":
/*!************************************************!*\
  !*** ./src/extensions/scratch3_boost/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");

const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");
/**
 * The LEGO Wireless Protocol documentation used to create this extension can be found at:
 * https://lego.github.io/lego-ble-wireless-protocol-docs/index.html
 */

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const iconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACpQTFRF////fIel5ufolZ62/2YavsPS+YZOkJmy9/j53+Hk6+zs6N/b6dfO////tDhMHAAAAA50Uk5T/////////////////wBFwNzIAAAA6ElEQVR42uzX2w6DIBAEUGDVtlr//3dLaLwgiwUd2z7MJPJg5EQWiGhGcAxBggQJEiT436CIfqXJPTn3MKNYYMSDFpoAmp24OaYgvwKnFgL2zvVTCwHrMoMi+nUQLFthaNCCa0iwclLkDgYVsQp0mzxuqXgK1MRzoCLWgkPXNN2wI/q6Kvt7u/cX0HtejN8x2sXpnpb8J8D3b0Keuhh3X975M+i0xNVbg3s1TIasgK21bQyGO+s2PykaGMYbge8KrNrssvkOWDXkErB8UuBHETjoYLkKBA8ZfuDkbwVBggQJEiR4MC8BBgDTtMZLx2nFCQAAAABJRU5ErkJggg==";
/**
 * Boost BLE UUIDs.
 * @enum {string}
 */

const BoostBLE = {
  service: "00001623-1212-efde-1623-785feabcd123",
  characteristic: "00001624-1212-efde-1623-785feabcd123",
  sendInterval: 100,
  sendRateMax: 20
};
/**
 * Boost Motor Max Power Add. Defines how much more power than the target speed
 * the motors may supply to reach the target speed faster.
 * Lower number == softer, slower reached target speed.
 * Higher number == harder, faster reached target speed.
 * @constant {number}
 */

const BoostMotorMaxPowerAdd = 10;
/**
 * A time interval to wait (in milliseconds) in between battery check calls.
 * @type {number}
 */

const BoostPingInterval = 5000;
/**
 * The number of continuous samples the color-sensor will evaluate color from.
 * @type {number}
 */

const BoostColorSampleSize = 5;
/**
 * Enum for Boost sensor and actuator types.
 * @readonly
 * @enum {number}
 */

const BoostIO = {
  MOTOR_WEDO: 0x01,
  MOTOR_SYSTEM: 0x02,
  BUTTON: 0x05,
  LIGHT: 0x08,
  VOLTAGE: 0x14,
  CURRENT: 0x15,
  PIEZO: 0x16,
  LED: 0x17,
  TILT_EXTERNAL: 0x22,
  MOTION_SENSOR: 0x23,
  COLOR: 0x25,
  MOTOREXT: 0x26,
  MOTORINT: 0x27,
  TILT: 0x28
};
/**
 * Enum for ids for various output command feedback types on the Boost.
 * @readonly
 * @enum {number}
 */

const BoostPortFeedback = {
  IN_PROGRESS: 0x01,
  COMPLETED: 0x02,
  DISCARDED: 0x04,
  IDLE: 0x08,
  BUSY_OR_FULL: 0x10
};
/**
 * Enum for physical Boost Ports
 * @readonly
 * @enum {number}
 */

const BoostPort10000223OrOlder = {
  A: 55,
  B: 56,
  C: 1,
  D: 2
};
const BoostPort10000224OrNewer = {
  A: 0,
  B: 1,
  C: 2,
  D: 3
}; // Set default port mapping to support the newer firmware

let BoostPort = BoostPort10000224OrNewer;
/**
 * Ids for each color sensor value used by the extension.
 * @readonly
 * @enum {string}
 */

const BoostColor = {
  ANY: "any",
  NONE: "none",
  RED: "red",
  BLUE: "blue",
  GREEN: "green",
  YELLOW: "yellow",
  WHITE: "white",
  BLACK: "black"
};
/**
 * Enum for indices for each color sensed by the Boost vision sensor.
 * @readonly
 * @enum {number}
 */

const BoostColorIndex = {
  [BoostColor.NONE]: 255,
  [BoostColor.RED]: 9,
  [BoostColor.BLUE]: 3,
  [BoostColor.GREEN]: 5,
  [BoostColor.YELLOW]: 7,
  [BoostColor.WHITE]: 10,
  [BoostColor.BLACK]: 0
};
/**
 * Enum for Message Types
 * @readonly
 * @enum {number}
 */

const BoostMessage = {
  HUB_PROPERTIES: 0x01,
  HUB_ACTIONS: 0x02,
  HUB_ALERTS: 0x03,
  HUB_ATTACHED_IO: 0x04,
  ERROR: 0x05,
  PORT_INPUT_FORMAT_SETUP_SINGLE: 0x41,
  PORT_INPUT_FORMAT_SETUP_COMBINED: 0x42,
  PORT_INFORMATION: 0x43,
  PORT_MODEINFORMATION: 0x44,
  PORT_VALUE: 0x45,
  PORT_VALUE_COMBINED: 0x46,
  PORT_INPUT_FORMAT: 0x47,
  PORT_INPUT_FORMAT_COMBINED: 0x48,
  OUTPUT: 0x81,
  PORT_FEEDBACK: 0x82
};
/**
 * Enum for Hub Property Types
 * @readonly
 * @enum {number}
 */

const BoostHubProperty = {
  ADVERTISEMENT_NAME: 0x01,
  BUTTON: 0x02,
  FW_VERSION: 0x03,
  HW_VERSION: 0x04,
  RSSI: 0x05,
  BATTERY_VOLTAGE: 0x06,
  BATTERY_TYPE: 0x07,
  MANUFACTURER_NAME: 0x08,
  RADIO_FW_VERSION: 0x09,
  LEGO_WP_VERSION: 0x0a,
  SYSTEM_TYPE_ID: 0x0b,
  HW_NETWORK_ID: 0x0c,
  PRIMARY_MAC: 0x0d,
  SECONDARY_MAC: 0x0e,
  HW_NETWORK_FAMILY: 0x0f
};
/**
 * Enum for Hub Property Operations
 * @readonly
 * @enum {number}
 */

const BoostHubPropertyOperation = {
  SET: 0x01,
  ENABLE_UPDATES: 0x02,
  DISABLE_UPDATES: 0x03,
  RESET: 0x04,
  REQUEST_UPDATE: 0x05,
  UPDATE: 0x06
};
/**
 * Enum for Motor Subcommands (for 0x81)
 * @readonly
 * @enum {number}
 */

const BoostOutputSubCommand = {
  START_POWER: 0x01,
  START_POWER_PAIR: 0x02,
  SET_ACC_TIME: 0x05,
  SET_DEC_TIME: 0x06,
  START_SPEED: 0x07,
  START_SPEED_PAIR: 0x08,
  START_SPEED_FOR_TIME: 0x09,
  START_SPEED_FOR_TIME_PAIR: 0x0a,
  START_SPEED_FOR_DEGREES: 0x0b,
  START_SPEED_FOR_DEGREES_PAIR: 0x0c,
  GO_TO_ABS_POSITION: 0x0d,
  GO_TO_ABS_POSITION_PAIR: 0x0e,
  PRESET_ENCODER: 0x14,
  WRITE_DIRECT_MODE_DATA: 0x51
};
/**
 * Enum for Startup/Completion information for an output command.
 * Startup and completion bytes must be OR'ed to be combined to a single byte.
 * @readonly
 * @enum {number}
 */

const BoostOutputExecution = {
  // Startup information
  BUFFER_IF_NECESSARY: 0x00,
  EXECUTE_IMMEDIATELY: 0x10,
  // Completion information
  NO_ACTION: 0x00,
  COMMAND_FEEDBACK: 0x01
};
/**
 * Enum for Boost Motor end states
 * @readonly
 * @enum {number}
 */

const BoostMotorEndState = {
  FLOAT: 0,
  HOLD: 126,
  BRAKE: 127
};
/**
 * Enum for Boost Motor acceleration/deceleration profiles
 * @readyonly
 * @enum {number}
 */

const BoostMotorProfile = {
  DO_NOT_USE: 0x00,
  ACCELERATION: 0x01,
  DECELERATION: 0x02
};
/**
 * Enum for when Boost IO's are attached/detached
 * @readonly
 * @enum {number}
 */

const BoostIOEvent = {
  ATTACHED: 0x01,
  DETACHED: 0x00,
  ATTACHED_VIRTUAL: 0x02
};
/**
 * Enum for selected sensor modes.
 * @enum {number}
 */

const BoostMode = {
  TILT: 0,
  // angle (pitch/yaw)
  LED: 1,
  // Set LED to accept RGB values
  COLOR: 0,
  // Read indexed colors from Vision Sensor
  MOTOR_SENSOR: 2,
  // Set motors to report their position
  UNKNOWN: 0 // Anything else will use the default mode (mode 0)

};
/**
 * Enum for Boost motor states.
 * @param {number}
 */

const BoostMotorState = {
  OFF: 0,
  ON_FOREVER: 1,
  ON_FOR_TIME: 2,
  ON_FOR_ROTATION: 3
};
/**
 * Helper function for converting a JavaScript number to an INT32-number
 * @param {number} number - a number
 * @return {array} - a 4-byte array of Int8-values representing an INT32-number
 */

const numberToInt32Array = function (number) {
  const buffer = new ArrayBuffer(4);
  const dataview = new DataView(buffer);
  dataview.setInt32(0, number);
  return [dataview.getInt8(3), dataview.getInt8(2), dataview.getInt8(1), dataview.getInt8(0)];
};
/**
 * Helper function for converting a regular array to a Little Endian INT32-value
 * @param {Array} array - an array containing UInt8-values
 * @return {number} - a number
 */


const int32ArrayToNumber = function (array) {
  const i = Uint8Array.from(array);
  const d = new DataView(i.buffer);
  return d.getInt32(0, true);
};
/**
 * Manage power, direction, position, and timers for one Boost motor.
 */


class BoostMotor {
  /**
   * Construct a Boost Motor instance.
   * @param {Boost} parent - the Boost peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   */
  constructor(parent, index) {
    /**
     * The Boost peripheral which owns this motor.
     * @type {Boost}
     * @private
     */
    this._parent = parent;
    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */

    this._index = index;
    /**
     * This motor's current direction: 1 for "this way" or -1 for "that way"
     * @type {number}
     * @private
     */

    this._direction = 1;
    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */

    this._power = 50;
    /**
     * This motor's current relative position
     * @type {number}
     * @private
     */

    this._position = 0;
    /**
     * Is this motor currently moving?
     * @type {boolean}
     * @private
     */

    this._status = BoostMotorState.OFF;
    /**
     * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for
     * the end-of-action handler. Cancel this when changing plans.
     * @type {Object}
     * @private
     */

    this._pendingDurationTimeoutId = null;
    /**
     * The starting time for the pending duration timeout.
     * @type {number}
     * @private
     */

    this._pendingDurationTimeoutStartTime = null;
    /**
     * The delay/duration of the pending duration timeout.
     * @type {number}
     * @private
     */

    this._pendingDurationTimeoutDelay = null;
    /**
     * The target position of a turn-based command.
     * @type {number}
     * @private
     */

    this._pendingRotationDestination = null;
    /**
     * If the motor has been turned on run for a specific rotation, this is the function
     * that will be called once Scratch VM gets a notification from the Move Hub.
     * @type {Object}
     * @private
     */

    this._pendingRotationPromise = null;
    this.turnOff = this.turnOff.bind(this);
  }
  /**
   * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
   */


  get direction() {
    return this._direction;
  }
  /**
   * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
   */


  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }
  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */


  get power() {
    return this._power;
  }
  /**
   * @param {int} value - this motor's new power level, in the range [10,100].
   */


  set power(value) {
    /**
     * Scale the motor power to a range between 10 and 100,
     * to make sure the motors will run with something built onto them.
     */
    if (value === 0) {
      this._power = 0;
    } else {
      this._power = Utility.scale(value, 1, 100, 10, 100);
    }
  }
  /**
   * @return {int} - this motor's current position, in the range of [-MIN_INT32,MAX_INT32]
   */


  get position() {
    return this._position;
  }
  /**
   * @param {int} value - set this motor's current position.
   */


  set position(value) {
    this._position = value;
  }
  /**
   * @return {BoostMotorState} - the motor's current state.
   */


  get status() {
    return this._status;
  }
  /**
   * @param {BoostMotorState} value - set this motor's state.
   */


  set status(value) {
    this._clearRotationState();

    this._clearDurationTimeout();

    this._status = value;
  }
  /**
   * @return {number} - time, in milliseconds, of when the pending duration timeout began.
   */


  get pendingDurationTimeoutStartTime() {
    return this._pendingDurationTimeoutStartTime;
  }
  /**
   * @return {number} - delay, in milliseconds, of the pending duration timeout.
   */


  get pendingDurationTimeoutDelay() {
    return this._pendingDurationTimeoutDelay;
  }
  /**
   * @return {number} - target position, in degrees, of the pending rotation.
   */


  get pendingRotationDestination() {
    return this._pendingRotationDestination;
  }
  /**
   * @return {Promise} - the Promise function for the pending rotation.
   */


  get pendingRotationPromise() {
    return this._pendingRotationPromise;
  }
  /**
   * @param {function} func - function to resolve pending rotation Promise
   */


  set pendingRotationPromise(func) {
    this._pendingRotationPromise = func;
  }
  /**
   * Turn this motor on indefinitely
   * @private
   */


  _turnOn() {
    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_SPEED, [this.power * this.direction, Utility.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorProfile.DO_NOT_USE]);

    this._parent.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Turn this motor on indefinitely
   */


  turnOnForever() {
    this.status = BoostMotorState.ON_FOREVER;

    this._turnOn();
  }
  /**
   * Turn this motor on for a specific duration.
   * @param {number} milliseconds - run the motor for this long.
   */


  turnOnFor(milliseconds) {
    milliseconds = Math.max(0, milliseconds);
    this.status = BoostMotorState.ON_FOR_TIME;

    this._turnOn();

    this._setNewDurationTimeout(this.turnOff, milliseconds);
  }
  /**
   * Turn this motor on for a specific rotation in degrees.
   * @param {number} degrees - run the motor for this amount of degrees.
   * @param {number} direction - rotate in this direction
   */


  turnOnForDegrees(degrees, direction) {
    degrees = Math.max(0, degrees);

    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.START_SPEED_FOR_DEGREES, [...numberToInt32Array(degrees), this.power * this.direction * direction, Utility.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorEndState.BRAKE, BoostMotorProfile.DO_NOT_USE]);

    this.status = BoostMotorState.ON_FOR_ROTATION;
    this._pendingRotationDestination = this.position + degrees * this.direction * direction;

    this._parent.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Turn this motor off.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   */


  turnOff(useLimiter = true) {
    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_POWER, [BoostMotorEndState.FLOAT]);

    this.status = BoostMotorState.OFF;

    this._parent.send(BoostBLE.characteristic, cmd, useLimiter);
  }
  /**
   * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.
   * @private
   */


  _clearDurationTimeout() {
    if (this._pendingDurationTimeoutId !== null) {
      clearTimeout(this._pendingDurationTimeoutId);
      this._pendingDurationTimeoutId = null;
      this._pendingDurationTimeoutStartTime = null;
      this._pendingDurationTimeoutDelay = null;
    }
  }
  /**
   * Set a new motor action timeout, after clearing an existing one if necessary.
   * @param {Function} callback - to be called at the end of the timeout.
   * @param {int} delay - wait this many milliseconds before calling the callback.
   * @private
   */


  _setNewDurationTimeout(callback, delay) {
    this._clearDurationTimeout();

    const timeoutID = setTimeout(() => {
      if (this._pendingDurationTimeoutId === timeoutID) {
        this._pendingDurationTimeoutId = null;
        this._pendingDurationTimeoutStartTime = null;
        this._pendingDurationTimeoutDelay = null;
      }

      callback();
    }, delay);
    this._pendingDurationTimeoutId = timeoutID;
    this._pendingDurationTimeoutStartTime = Date.now();
    this._pendingDurationTimeoutDelay = delay;
  }
  /**
   * Clear the motor states related to rotation-based commands, if any.
   * Safe to call even when there is no pending promise function.
   * @private
   */


  _clearRotationState() {
    if (this._pendingRotationPromise !== null) {
      this._pendingRotationPromise();

      this._pendingRotationPromise = null;
    }

    this._pendingRotationDestination = null;
  }

}
/**
 * Manage communication with a Boost peripheral over a Bluetooth Low Energy client socket.
 */


class Boost {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    this._runtime.on("PROJECT_STOP_ALL", this.stopAll.bind(this));
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * A list of the ids of the physical or virtual sensors.
     * @type {string[]}
     * @private
     */

    this._ports = [];
    /**
     * A list of motors registered by the Boost hardware.
     * @type {BoostMotor[]}
     * @private
     */

    this._motors = [];
    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */

    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      color: BoostColor.NONE,
      previousColor: BoostColor.NONE
    };
    /**
     * An array of values from the Boost Vision Sensor.
     * @type {Array}
     * @private
     */

    this._colorSamples = [];
    /**
     * The Bluetooth connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * A rate limiter utility, to help limit the rate at which we send BLE messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */


    this._rateLimiter = new RateLimiter(BoostBLE.sendRateMax);
    /**
     * An interval id for the battery check interval.
     * @type {number}
     * @private
     */

    this._pingDeviceId = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._pingDevice = this._pingDevice.bind(this);
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */


  get tiltX() {
    return this._sensors.tiltX;
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */


  get tiltY() {
    return this._sensors.tiltY;
  }
  /**
   * @return {number} - the latest color value received from the vision sensor.
   */


  get color() {
    return this._sensors.color;
  }
  /**
   * @return {number} - the previous color value received from the vision sensor.
   */


  get previousColor() {
    return this._sensors.previousColor;
  }
  /**
   * Look up the color id for an index received from the vision sensor.
   * @param {number} index - the color index to look up.
   * @return {BoostColor} the color id for this index.
   */


  boostColorForIndex(index) {
    const colorForIndex = Object.keys(BoostColorIndex).find(key => BoostColorIndex[key] === index);
    return colorForIndex || BoostColor.NONE;
  }
  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the index of the desired motor.
   * @return {BoostMotor} - the BoostMotor instance, if any, at that index.
   */


  motor(index) {
    return this._motors[index];
  }
  /**
   * Stop all the motors that are currently running.
   */


  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        // Send the motor off command without using the rate limiter.
        // This allows the stop button to stop motors even if we are
        // otherwise flooded with commands.
        motor.turnOff(false);
      }
    });
  }
  /**
   * Set the Boost peripheral's LED to a specific color.
   * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.
   * @return {Promise} - a promise of the completion of the set led send operation.
   */


  setLED(inputRGB) {
    const rgb = [inputRGB >> 16 & 0x000000ff, inputRGB >> 8 & 0x000000ff, inputRGB & 0x000000ff];
    const cmd = this.generateOutputCommand(this._ports.indexOf(BoostIO.LED), BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.WRITE_DIRECT_MODE_DATA, [BoostMode.LED, ...rgb]);
    return this.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Sets the input mode of the LED to RGB.
   * @return {Promise} - a promise returned by the send operation.
   */


  setLEDMode() {
    const cmd = this.generateInputCommand(this._ports.indexOf(BoostIO.LED), BoostMode.LED, 0, false);
    return this.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Stop the motors on the Boost peripheral.
   */


  stopAll() {
    if (!this.isConnected()) return;
    this.stopAllMotors();
  }
  /**
   * Called by the runtime when user wants to scan for a Boost peripheral.
   */


  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BoostBLE.service],
        manufacturerData: {
          0x0397: {
            dataPrefix: [0x00, 0x40],
            mask: [0x00, 0xff]
          }
        }
      }],
      optionalServices: []
    }, this._onConnect, this.reset);
  }
  /**
   * Called by the runtime when user wants to connect to a certain Boost peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }
  /**
   * Disconnects from the current BLE socket and resets state.
   */


  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    this._ports = [];
    this._motors = [];
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      color: BoostColor.NONE,
      previousColor: BoostColor.NONE
    };

    if (this._pingDeviceId) {
      window.clearInterval(this._pingDeviceId);
      this._pingDeviceId = null;
    }
  }
  /**
   * Called by the runtime to detect whether the Boost peripheral is connected.
   * @return {boolean} - the connected state.
   */


  isConnected() {
    let connected = false;

    if (this._ble) {
      connected = this._ble.isConnected();
    }

    return connected;
  }
  /**
   * Write a message to the Boost peripheral BLE socket.
   * @param {number} uuid - the UUID of the characteristic to write to
   * @param {Array} message - the message to write.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the write operation
   */


  send(uuid, message, useLimiter = true) {
    if (!this.isConnected()) return Promise.resolve();

    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }

    return this._ble.write(BoostBLE.service, uuid, Utility.uint8ArrayToBase64(message), "base64");
  }
  /**
   * Generate a Boost 'Output Command' in the byte array format
   * (COMMON HEADER, PORT ID, EXECUTION BYTE, SUBCOMMAND ID, PAYLOAD).
   *
   * Payload is accepted as an array since these vary across different subcommands.
   *
   * @param  {number} portID - the port (Connect ID) to send a command to.
   * @param  {number} execution - Byte containing startup/completion information
   * @param  {number} subCommand - the id of the subcommand byte.
   * @param  {array}  payload    - the list of bytes to send as subcommand payload
   * @return {array}            - a generated output command.
   */


  generateOutputCommand(portID, execution, subCommand, payload) {
    const hubID = 0x00;
    const command = [hubID, BoostMessage.OUTPUT, portID, execution, subCommand, ...payload];
    command.unshift(command.length + 1); // Prepend payload with length byte;

    return command;
  }
  /**
   * Generate a Boost 'Input Command' in the byte array format
   * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),
   * UNIT, NOTIFICATIONS ENABLED).
   *
   * This sends a command to the Boost that sets that input format
   * of the specified inputs and sets value change notifications.
   *
   * @param  {number}  portID           - the port (Connect ID) to send a command to.
   * @param  {number}  mode                - the mode of the input sensor.
   * @param  {number}  delta               - the delta change needed to trigger notification.
   * @param  {boolean} enableNotifications - whether to enable notifications.
   * @return {array}                       - a generated input command.
   */


  generateInputCommand(portID, mode, delta, enableNotifications) {
    const command = [0x00, // Hub ID
    BoostMessage.PORT_INPUT_FORMAT_SETUP_SINGLE, portID, mode].concat(numberToInt32Array(delta)).concat([enableNotifications]);
    command.unshift(command.length + 1); // Prepend payload with length byte;

    return command;
  }
  /**
   * Starts reading data from peripheral after BLE has connected.
   * @private
   */


  _onConnect() {
    this._ble.startNotifications(BoostBLE.service, BoostBLE.characteristic, this._onMessage);

    this._pingDeviceId = window.setInterval(this._pingDevice, BoostPingInterval); // Send a request for firmware version.

    setTimeout(() => {
      const command = [0x00, // Hub ID
      BoostMessage.HUB_PROPERTIES, BoostHubProperty.FW_VERSION, BoostHubPropertyOperation.REQUEST_UPDATE];
      command.unshift(command.length + 1);
      this.send(BoostBLE.characteristic, command, false);
    }, 500);
  }
  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */


  _onMessage(base64) {
    const data = Utility.base64ToUint8Array(base64);
    /**
     * First three bytes are the common header:
     * 0: Length of message
     * 1: Hub ID (always 0x00 at the moment, unused)
     * 2: Message Type
     * 3: Port ID
     * We base our switch-case on Message Type
     */

    const messageType = data[2];
    const portID = data[3];

    switch (messageType) {
      case BoostMessage.HUB_PROPERTIES:
        {
          const property = data[3];

          switch (property) {
            case BoostHubProperty.FW_VERSION:
              {
                // Establish firmware version 1.0.00.0224 as a 32-bit signed integer (little endian)
                const fwVersion10000224 = int32ArrayToNumber([0x24, 0x02, 0x00, 0x10]);
                const fwHub = int32ArrayToNumber(data.slice(5, data.length));

                if (fwHub < fwVersion10000224) {
                  BoostPort = BoostPort10000223OrOlder;
                  console.info("Move Hub firmware older than version 1.0.00.0224 detected. Using old port mapping.");
                } else {
                  BoostPort = BoostPort10000224OrNewer;
                }

                break;
              }
          }

          break;
        }

      case BoostMessage.HUB_ATTACHED_IO:
        {
          // IO Attach/Detach events
          const event = data[4];
          const typeId = data[5];

          switch (event) {
            case BoostIOEvent.ATTACHED:
              this._registerSensorOrMotor(portID, typeId);

              break;

            case BoostIOEvent.DETACHED:
              this._clearPort(portID);

              break;

            case BoostIOEvent.ATTACHED_VIRTUAL:
            default:
          }

          break;
        }

      case BoostMessage.PORT_VALUE:
        {
          const type = this._ports[portID];

          switch (type) {
            case BoostIO.TILT:
              this._sensors.tiltX = data[4];
              this._sensors.tiltY = data[5];
              break;

            case BoostIO.COLOR:
              this._colorSamples.unshift(data[4]);

              if (this._colorSamples.length > BoostColorSampleSize) {
                this._colorSamples.pop();

                if (this._colorSamples.every((v, i, arr) => v === arr[0])) {
                  this._sensors.previousColor = this._sensors.color;
                  this._sensors.color = this.boostColorForIndex(this._colorSamples[0]);
                } else {
                  this._sensors.color = BoostColor.NONE;
                }
              } else {
                this._sensors.color = BoostColor.NONE;
              }

              break;

            case BoostIO.MOTOREXT:
            case BoostIO.MOTORINT:
              this.motor(portID).position = int32ArrayToNumber(data.slice(4, 8));
              break;

            case BoostIO.CURRENT:
            case BoostIO.VOLTAGE:
            case BoostIO.LED:
              break;

            default:
              console.warn(`Unknown sensor value! Type: ${type}`);
          }

          break;
        }

      case BoostMessage.PORT_FEEDBACK:
        {
          const feedback = data[4];
          const motor = this.motor(portID);

          if (motor) {
            // Makes sure that commands resolve both when they actually complete and when they fail
            const isBusy = feedback & BoostPortFeedback.IN_PROGRESS;
            const commandCompleted = feedback & (BoostPortFeedback.COMPLETED ^ BoostPortFeedback.DISCARDED);

            if (!isBusy && commandCompleted) {
              if (motor.status === BoostMotorState.ON_FOR_ROTATION) {
                motor.status = BoostMotorState.OFF;
              }
            }
          }

          break;
        }

      case BoostMessage.ERROR:
        console.warn(`Error reported by hub: ${data}`);
        break;
    }
  }
  /**
   * Ping the Boost hub. If the Boost hub has disconnected
   * for some reason, the BLE socket will get an error back and automatically
   * close the socket.
   * @private
   */


  _pingDevice() {
    this._ble.read(BoostBLE.service, BoostBLE.characteristic, false);
  }
  /**
   * Register a new sensor or motor connected at a port.  Store the type of
   * sensor or motor internally, and then register for notifications on input
   * values if it is a sensor.
   * @param {number} portID - the port to register a sensor or motor on.
   * @param {number} type - the type ID of the sensor or motor
   * @private
   */


  _registerSensorOrMotor(portID, type) {
    // Record which port is connected to what type of device
    this._ports[portID] = type; // Record motor port

    if (type === BoostIO.MOTORINT || type === BoostIO.MOTOREXT) {
      this._motors[portID] = new BoostMotor(this, portID);
    } // Set input format for tilt or distance sensor


    let mode = null;
    let delta = 1;

    switch (type) {
      case BoostIO.MOTORINT:
      case BoostIO.MOTOREXT:
        mode = BoostMode.MOTOR_SENSOR;
        break;

      case BoostIO.COLOR:
        mode = BoostMode.COLOR;
        delta = 0;
        break;

      case BoostIO.LED:
        mode = BoostMode.LED;
        /**
         * Sets the LED to blue to give an indication on the hub
         * that it has connected successfully.
         */

        this.setLEDMode();
        this.setLED(0x0000ff);
        break;

      case BoostIO.TILT:
        mode = BoostMode.TILT;
        break;

      default:
        mode = BoostMode.UNKNOWN;
    }

    const cmd = this.generateInputCommand(portID, mode, delta, true // Receive feedback
    );
    this.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Clear the sensors or motors present on the ports.
   * @param {number} portID - the port to clear.
   * @private
   */


  _clearPort(portID) {
    const type = this._ports[portID];

    if (type === BoostIO.TILT) {
      this._sensors.tiltX = this._sensors.tiltY = 0;
    }

    if (type === BoostIO.COLOR) {
      this._sensors.color = BoostColor.NONE;
    }

    this._ports[portID] = "none";
    this._motors[portID] = null;
  }

}
/**
 * Enum for motor specification.
 * @readonly
 * @enum {string}
 */


const BoostMotorLabel = {
  A: "A",
  B: "B",
  C: "C",
  D: "D",
  AB: "AB",
  ALL: "ABCD"
};
/**
 * Enum for motor direction specification.
 * @readonly
 * @enum {string}
 */

const BoostMotorDirection = {
  FORWARD: "this way",
  BACKWARD: "that way",
  REVERSE: "reverse"
};
/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */

const BoostTiltDirection = {
  UP: "up",
  DOWN: "down",
  LEFT: "left",
  RIGHT: "right",
  ANY: "any"
};
/**
 * Scratch 3.0 blocks to interact with a LEGO Boost peripheral.
 */

class Scratch3BoostBlocks {
  /**
   * @return {string} - the ID of this extension.
   */
  static get EXTENSION_ID() {
    return "boost";
  }
  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */


  static get TILT_THRESHOLD() {
    return 15;
  }
  /**
   * Construct a set of Boost blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new Boost peripheral instance

    this._peripheral = new Boost(this.runtime, Scratch3BoostBlocks.EXTENSION_ID);
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: Scratch3BoostBlocks.EXTENSION_ID,
      name: "BOOST",
      blockIconURI: iconURI,
      showStatusButton: true,
      blocks: [{
        opcode: "motorOnFor",
        text: formatMessage({
          id: "boost.motorOnFor",
          default: "turn motor [MOTOR_ID] for [DURATION] seconds",
          description: "turn a motor on for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.A
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: "motorOnForRotation",
        text: formatMessage({
          id: "boost.motorOnForRotation",
          default: "turn motor [MOTOR_ID] for [ROTATION] rotations",
          description: "turn a motor on for rotation"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.A
          },
          ROTATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: "motorOn",
        text: formatMessage({
          id: "boost.motorOn",
          default: "turn motor [MOTOR_ID] on",
          description: "turn a motor on indefinitely"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: "motorOff",
        text: formatMessage({
          id: "boost.motorOff",
          default: "turn motor [MOTOR_ID] off",
          description: "turn a motor off"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: "setMotorPower",
        text: formatMessage({
          id: "boost.setMotorPower",
          default: "set motor [MOTOR_ID] speed to [POWER] %",
          description: "set the motor's speed without turning it on"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.ALL
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: "setMotorDirection",
        text: formatMessage({
          id: "boost.setMotorDirection",
          default: "set motor [MOTOR_ID] direction [MOTOR_DIRECTION]",
          description: "set the motor's turn direction without turning it on"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: BoostMotorLabel.A
          },
          MOTOR_DIRECTION: {
            type: ArgumentType.STRING,
            menu: "MOTOR_DIRECTION",
            defaultValue: BoostMotorDirection.FORWARD
          }
        }
      }, {
        opcode: "getMotorPosition",
        text: formatMessage({
          id: "boost.getMotorPosition",
          default: "motor [MOTOR_REPORTER_ID] position",
          description: "the position returned by the motor"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          MOTOR_REPORTER_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_REPORTER_ID",
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: "whenColor",
        text: formatMessage({
          id: "boost.whenColor",
          default: "when [COLOR] brick seen",
          description: "check for when color"
        }),
        blockType: BlockType.HAT,
        arguments: {
          COLOR: {
            type: ArgumentType.STRING,
            menu: "COLOR",
            defaultValue: BoostColor.ANY
          }
        }
      }, {
        opcode: "seeingColor",
        text: formatMessage({
          id: "boost.seeingColor",
          default: "seeing [COLOR] brick?",
          description: "is the color sensor seeing a certain color?"
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          COLOR: {
            type: ArgumentType.STRING,
            menu: "COLOR",
            defaultValue: BoostColor.ANY
          }
        }
      }, {
        opcode: "whenTilted",
        text: formatMessage({
          id: "boost.whenTilted",
          default: "when tilted [TILT_DIRECTION_ANY]",
          description: "check when tilted in a certain direction"
        }),
        func: "isTilted",
        blockType: BlockType.HAT,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: "TILT_DIRECTION_ANY",
            defaultValue: BoostTiltDirection.ANY
          }
        }
      }, {
        opcode: "getTiltAngle",
        text: formatMessage({
          id: "boost.getTiltAngle",
          default: "tilt angle [TILT_DIRECTION]",
          description: "the angle returned by the tilt sensor"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          TILT_DIRECTION: {
            type: ArgumentType.STRING,
            menu: "TILT_DIRECTION",
            defaultValue: BoostTiltDirection.UP
          }
        }
      }, {
        opcode: "setLightHue",
        text: formatMessage({
          id: "boost.setLightHue",
          default: "set light color to [HUE]",
          description: "set the LED color"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }],
      menus: {
        MOTOR_ID: {
          acceptReporters: true,
          items: [{
            text: "A",
            value: BoostMotorLabel.A
          }, {
            text: "B",
            value: BoostMotorLabel.B
          }, {
            text: "C",
            value: BoostMotorLabel.C
          }, {
            text: "D",
            value: BoostMotorLabel.D
          }, {
            text: "AB",
            value: BoostMotorLabel.AB
          }, {
            text: "ABCD",
            value: BoostMotorLabel.ALL
          }]
        },
        MOTOR_REPORTER_ID: {
          acceptReporters: true,
          items: [{
            text: "A",
            value: BoostMotorLabel.A
          }, {
            text: "B",
            value: BoostMotorLabel.B
          }, {
            text: "C",
            value: BoostMotorLabel.C
          }, {
            text: "D",
            value: BoostMotorLabel.D
          }]
        },
        MOTOR_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "boost.motorDirection.forward",
              default: "this way",
              description: "label for forward element in motor direction menu for LEGO Boost extension"
            }),
            value: BoostMotorDirection.FORWARD
          }, {
            text: formatMessage({
              id: "boost.motorDirection.backward",
              default: "that way",
              description: "label for backward element in motor direction menu for LEGO Boost extension"
            }),
            value: BoostMotorDirection.BACKWARD
          }, {
            text: formatMessage({
              id: "boost.motorDirection.reverse",
              default: "reverse",
              description: "label for reverse element in motor direction menu for LEGO Boost extension"
            }),
            value: BoostMotorDirection.REVERSE
          }]
        },
        TILT_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "boost.tiltDirection.up",
              default: "up",
              description: "label for up element in tilt direction menu for LEGO Boost extension"
            }),
            value: BoostTiltDirection.UP
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.down",
              default: "down",
              description: "label for down element in tilt direction menu for LEGO Boost extension"
            }),
            value: BoostTiltDirection.DOWN
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.left",
              default: "left",
              description: "label for left element in tilt direction menu for LEGO Boost extension"
            }),
            value: BoostTiltDirection.LEFT
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.right",
              default: "right",
              description: "label for right element in tilt direction menu for LEGO Boost extension"
            }),
            value: BoostTiltDirection.RIGHT
          }]
        },
        TILT_DIRECTION_ANY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "boost.tiltDirection.up",
              default: "up"
            }),
            value: BoostTiltDirection.UP
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.down",
              default: "down"
            }),
            value: BoostTiltDirection.DOWN
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.left",
              default: "left"
            }),
            value: BoostTiltDirection.LEFT
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.right",
              default: "right"
            }),
            value: BoostTiltDirection.RIGHT
          }, {
            text: formatMessage({
              id: "boost.tiltDirection.any",
              default: "any",
              description: "label for any element in tilt direction menu for LEGO Boost extension"
            }),
            value: BoostTiltDirection.ANY
          }]
        },
        COLOR: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "boost.color.red",
              default: "red",
              description: "the color red"
            }),
            value: BoostColor.RED
          }, {
            text: formatMessage({
              id: "boost.color.blue",
              default: "blue",
              description: "the color blue"
            }),
            value: BoostColor.BLUE
          }, {
            text: formatMessage({
              id: "boost.color.green",
              default: "green",
              description: "the color green"
            }),
            value: BoostColor.GREEN
          }, {
            text: formatMessage({
              id: "boost.color.yellow",
              default: "yellow",
              description: "the color yellow"
            }),
            value: BoostColor.YELLOW
          }, {
            text: formatMessage({
              id: "boost.color.white",
              default: "white",
              desription: "the color white"
            }),
            value: BoostColor.WHITE
          }, {
            text: formatMessage({
              id: "boost.color.black",
              default: "black",
              description: "the color black"
            }),
            value: BoostColor.BLACK
          }, {
            text: formatMessage({
              id: "boost.color.any",
              default: "any color",
              description: "any color"
            }),
            value: BoostColor.ANY
          }]
        }
      }
    };
  }
  /**
   * Turn specified motor(s) on for a specified duration.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} DURATION - the amount of time to run the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  motorOnFor(args) {
    // TODO: cast args.MOTOR_ID?
    let durationMS = Utility.toNumber(args.DURATION) * 1000;
    durationMS = Utility.clamp(durationMS, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(args.MOTOR_ID, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) motor.turnOnFor(durationMS);
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, durationMS);
    });
  }
  /**
   * Turn specified motor(s) on for a specified rotation in full rotations.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} ROTATION - the amount of full rotations to turn the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  motorOnForRotation(args) {
    // TODO: cast args.MOTOR_ID?
    let degrees = Utility.toNumber(args.ROTATION) * 360; // TODO: Clamps to 100 rotations. Consider changing.

    const sign = Math.sign(degrees);
    degrees = Math.abs(Utility.clamp(degrees, -360000, 360000));
    const motors = [];

    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      motors.push(motorIndex);
    });
    /**
     * Checks that the motors given in args.MOTOR_ID exist,
     * and maps a promise for each of the motor-commands to an array.
     */


    const promises = motors.map(portID => {
      const motor = this._peripheral.motor(portID);

      if (motor) {
        // to avoid a hanging block if power is 0, return an immediately resolving promise.
        if (motor.power === 0) return Promise.resolve();
        return new Promise(resolve => {
          motor.turnOnForDegrees(degrees, sign);
          motor.pendingRotationPromise = resolve;
        });
      }

      return null;
    });
    /**
     * Make sure all promises are resolved, i.e. all motor-commands have completed.
     * To prevent the block from returning a value, an empty function is added to the .then
     */

    return Promise.all(promises).then(() => {});
  }
  /**
   * Turn specified motor(s) on indefinitely.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOn(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) motor.turnOnForever();
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOff(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) motor.turnOff();
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * Set the power level of the specified motor(s).
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {int} POWER - the new power level for the motor(s).
   * @return {Promise} - returns a promise to make sure the block yields.
   */


  setMotorPower(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.power = Utility.clamp(Utility.toNumber(args.POWER), 0, 100);

        switch (motor.status) {
          case BoostMotorState.ON_FOREVER:
            motor.turnOnForever();
            break;

          case BoostMotorState.ON_FOR_TIME:
            motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());
            break;
        }
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * Set the direction of rotation for specified motor(s).
   * If the direction is 'reverse' the motor(s) will be reversed individually.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).
   * @return {Promise} - returns a promise to make sure the block yields.
   */


  setMotorDirection(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        switch (args.MOTOR_DIRECTION) {
          case BoostMotorDirection.FORWARD:
            motor.direction = 1;
            break;

          case BoostMotorDirection.BACKWARD:
            motor.direction = -1;
            break;

          case BoostMotorDirection.REVERSE:
            motor.direction = -motor.direction;
            break;

          default:
            console.warn(`Unknown motor direction in setMotorDirection: ${args.DIRECTION}`);
            break;
        } // keep the motor on if it's running, and update the pending timeout if needed


        if (motor) {
          switch (motor.status) {
            case BoostMotorState.ON_FOREVER:
              motor.turnOnForever();
              break;

            case BoostMotorState.ON_FOR_TIME:
              motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());
              break;
          }
        }
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * @param {object} args - the block's arguments.
   * @return {number} - returns the motor's position.
   */


  getMotorPosition(args) {
    let portID = null;

    switch (args.MOTOR_REPORTER_ID) {
      case BoostMotorLabel.A:
        portID = BoostPort.A;
        break;

      case BoostMotorLabel.B:
        portID = BoostPort.B;
        break;

      case BoostMotorLabel.C:
        portID = BoostPort.C;
        break;

      case BoostMotorLabel.D:
        portID = BoostPort.D;
        break;

      default:
        console.warn("Asked for a motor position that doesnt exist!");
        return false;
    }

    if (portID !== null && this._peripheral.motor(portID)) {
      let val = this._peripheral.motor(portID).position; // Boost motor A position direction is reversed by design
      // so we have to reverse the position here


      if (portID === BoostPort.A) {
        val *= -1;
      }

      return Utility.wrapClamp(val, 0, 360);
    }

    return 0;
  }
  /**
   * Call a callback for each motor indexed by the provided motor ID.
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */


  _forEachMotor(motorID, callback) {
    let motors;

    switch (motorID) {
      case BoostMotorLabel.A:
        motors = [BoostPort.A];
        break;

      case BoostMotorLabel.B:
        motors = [BoostPort.B];
        break;

      case BoostMotorLabel.C:
        motors = [BoostPort.C];
        break;

      case BoostMotorLabel.D:
        motors = [BoostPort.D];
        break;

      case BoostMotorLabel.AB:
        motors = [BoostPort.A, BoostPort.B];
        break;

      case BoostMotorLabel.ALL:
        motors = [BoostPort.A, BoostPort.B, BoostPort.C, BoostPort.D];
        break;

      default:
        console.warn(`Invalid motor ID: ${motorID}`);
        motors = [];
        break;
    }

    for (const index of motors) {
      callback(index);
    }
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  whenTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  isTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   */


  getTiltAngle(args) {
    return this._getTiltAngle(args.TILT_DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */


  _isTilted(direction) {
    switch (direction) {
      case BoostTiltDirection.ANY:
        return Math.abs(this._peripheral.tiltX) >= Scratch3BoostBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY) >= Scratch3BoostBlocks.TILT_THRESHOLD;

      default:
        return this._getTiltAngle(direction) >= Scratch3BoostBlocks.TILT_THRESHOLD;
    }
  }
  /**
   * @param {TiltDirection} direction - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */


  _getTiltAngle(direction) {
    switch (direction) {
      case BoostTiltDirection.UP:
        return this._peripheral.tiltY > 90 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;

      case BoostTiltDirection.DOWN:
        return this._peripheral.tiltY > 90 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;

      case BoostTiltDirection.LEFT:
        return this._peripheral.tiltX > 90 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;

      case BoostTiltDirection.RIGHT:
        return this._peripheral.tiltX > 90 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;

      default:
        console.warn(`Unknown tilt direction in _getTiltAngle: ${direction}`);
    }
  }
  /**
   * Edge-triggering hat function, for when the vision sensor is detecting
   * a certain color.
   * @param {object} args - the block's arguments.
   * @return {boolean} - true when the color sensor senses the specified color.
   */


  whenColor(args) {
    if (args.COLOR === BoostColor.ANY) {
      // For "any" color, return true if the color is not "none", and
      // the color is different from the previous color detected. This
      // allows the hat to trigger when the color changes from one color
      // to another.
      return this._peripheral.color !== BoostColor.NONE && this._peripheral.color !== this._peripheral.previousColor;
    }

    return args.COLOR === this._peripheral.color;
  }
  /**
   * A boolean reporter function, for whether the vision sensor is detecting
   * a certain color.
   * @param {object} args - the block's arguments.
   * @return {boolean} - true when the color sensor senses the specified color.
   */


  seeingColor(args) {
    if (args.COLOR === BoostColor.ANY) {
      return this._peripheral.color !== BoostColor.NONE;
    }

    return args.COLOR === this._peripheral.color;
  }
  /**
   * Set the LED's hue.
   * @param {object} args - the block's arguments.
   * @property {number} HUE - the hue to set, in the range [0,100].
   * @return {Promise} - a Promise that resolves after some delay.
   */


  setLightHue(args) {
    // Convert from [0,100] to [0,360]
    let inputHue = Utility.toNumber(args.HUE);
    inputHue = Utility.wrapClamp(inputHue, 0, 100);
    const hue = inputHue * 360 / 100;
    const rgbObject = Utility.hsvToRgb({
      h: hue,
      s: 1,
      v: 1
    });
    const rgbDecimal = Utility.rgbToDecimal(rgbObject);
    this._peripheral._led = inputHue;

    this._peripheral.setLED(rgbDecimal);

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }

}

module.exports = Scratch3BoostBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_ev3/index.js":
/*!**********************************************!*\
  !*** ./src/extensions/scratch3_ev3/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const BT = __webpack_require__(/*! ../../io/bt */ "./src/io/bt.js");

const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUwLjIgKDU1MDQ3KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5ldjMtYmxvY2staWNvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJldjMtYmxvY2staWNvbiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImV2MyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNS41MDAwMDAsIDMuNTAwMDAwKSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS1wYXRoIiBzdHJva2U9IiM3Qzg3QTUiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgeD0iMC41IiB5PSIzLjU5IiB3aWR0aD0iMjgiIGhlaWdodD0iMjUuODEiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgc3Ryb2tlPSIjN0M4N0E1IiBmaWxsPSIjRTZFN0U4IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjIuNSIgeT0iMC41IiB3aWR0aD0iMjQiIGhlaWdodD0iMzIiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgc3Ryb2tlPSIjN0M4N0E1IiBmaWxsPSIjRkZGRkZGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjIuNSIgeT0iMTQuNSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjEzIj48L3JlY3Q+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC41LDEwLjUgTDE0LjUsMTQuNSIgaWQ9IlNoYXBlIiBzdHJva2U9IiM3Qzg3QTUiIGZpbGw9IiNFNkU3RTgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PC9wYXRoPgogICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIGZpbGw9IiM0MTQ3NTciIHg9IjQuNSIgeT0iMi41IiB3aWR0aD0iMjAiIGhlaWdodD0iMTAiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgZmlsbD0iIzdDODdBNSIgb3BhY2l0eT0iMC41IiB4PSIxMy41IiB5PSIyMC4xMyIgd2lkdGg9IjIiIGhlaWdodD0iMiIgcng9IjAuNSI+PC9yZWN0PgogICAgICAgICAgICA8cGF0aCBkPSJNOS4wNiwyMC4xMyBMMTAuNTYsMjAuMTMgQzEwLjgzNjE0MjQsMjAuMTMgMTEuMDYsMjAuMzUzODU3NiAxMS4wNiwyMC42MyBMMTEuMDYsMjEuNjMgQzExLjA2LDIxLjkwNjE0MjQgMTAuODM2MTQyNCwyMi4xMyAxMC41NiwyMi4xMyBMOS4wNiwyMi4xMyBDOC41MDc3MTUyNSwyMi4xMyA4LjA2LDIxLjY4MjI4NDcgOC4wNiwyMS4xMyBDOC4wNiwyMC41Nzc3MTUzIDguNTA3NzE1MjUsMjAuMTMgOS4wNiwyMC4xMyBaIiBpZD0iU2hhcGUiIGZpbGw9IiM3Qzg3QTUiIG9wYWNpdHk9IjAuNSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMTguOTEsMjAuMTMgTDIwLjQyLDIwLjEzIEMyMC42OTYxNDI0LDIwLjEzIDIwLjkyLDIwLjM1Mzg1NzYgMjAuOTIsMjAuNjMgTDIwLjkyLDIxLjYzIEMyMC45MiwyMS45MDYxNDI0IDIwLjY5NjE0MjQsMjIuMTMgMjAuNDIsMjIuMTMgTDE4LjkyLDIyLjEzIEMxOC4zNjc3MTUzLDIyLjEzIDE3LjkyLDIxLjY4MjI4NDcgMTcuOTIsMjEuMTMgQzE3LjkxOTk3MjYsMjAuNTgxNTk3IDE4LjM2MTYyNDUsMjAuMTM1NDg0IDE4LjkxLDIwLjEzIFoiIGlkPSJTaGFwZSIgZmlsbD0iIzdDODdBNSIgb3BhY2l0eT0iMC41IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOS40MjAwMDAsIDIxLjEzMDAwMCkgcm90YXRlKC0xODAuMDAwMDAwKSB0cmFuc2xhdGUoLTE5LjQyMDAwMCwgLTIxLjEzMDAwMCkgIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik04LjIzLDE3LjUgTDUsMTcuNSBDNC43MjM4NTc2MywxNy41IDQuNSwxNy4yNzYxNDI0IDQuNSwxNyBMNC41LDE0LjUgTDEwLjUsMTQuNSBMOC42NSwxNy4yOCBDOC41NTQ2Njk2MSwxNy40MTc5MDgyIDguMzk3NjUwMDYsMTcuNTAwMTU2NiA4LjIzLDE3LjUgWiIgaWQ9IlNoYXBlIiBmaWxsPSIjN0M4N0E1IiBvcGFjaXR5PSIwLjUiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTE4LjE1LDE4Ljg1IEwxNy42NSwxOS4zNSBDMTcuNTUyMzQxNiwxOS40NDQwNzU2IDE3LjQ5ODAzMzksMTkuNTc0NDE0MiAxNy41LDE5LjcxIEwxNy41LDIwIEMxNy41LDIwLjI3NjE0MjQgMTcuMjc2MTQyNCwyMC41IDE3LDIwLjUgTDE2LjUsMjAuNSBDMTYuMjIzODU3NiwyMC41IDE2LDIwLjI3NjE0MjQgMTYsMjAgQzE2LDE5LjcyMzg1NzYgMTUuNzc2MTQyNCwxOS41IDE1LjUsMTkuNSBMMTMuNSwxOS41IEMxMy4yMjM4NTc2LDE5LjUgMTMsMTkuNzIzODU3NiAxMywyMCBDMTMsMjAuMjc2MTQyNCAxMi43NzYxNDI0LDIwLjUgMTIuNSwyMC41IEwxMiwyMC41IEMxMS43MjM4NTc2LDIwLjUgMTEuNSwyMC4yNzYxNDI0IDExLjUsMjAgTDExLjUsMTkuNzEgQzExLjUwMTk2NjEsMTkuNTc0NDE0MiAxMS40NDc2NTg0LDE5LjQ0NDA3NTYgMTEuMzUsMTkuMzUgTDEwLjg1LDE4Ljg1IEMxMC42NTgyMTY3LDE4LjY1MjE4NjMgMTAuNjU4MjE2NywxOC4zMzc4MTM3IDEwLjg1LDE4LjE0IEwxMi4zNiwxNi42NSBDMTIuNDUwMjgwMywxNi41NTI4NjE3IDEyLjU3NzM5NjEsMTYuNDk4MzgzNSAxMi43MSwxNi41IEwxNi4yOSwxNi41IEMxNi40MjI2MDM5LDE2LjQ5ODM4MzUgMTYuNTQ5NzE5NywxNi41NTI4NjE3IDE2LjY0LDE2LjY1IEwxOC4xNSwxOC4xNCBDMTguMzQxNzgzMywxOC4zMzc4MTM3IDE4LjM0MTc4MzMsMTguNjUyMTg2MyAxOC4xNSwxOC44NSBaIiBpZD0iU2hhcGUiIGZpbGw9IiM3Qzg3QTUiIG9wYWNpdHk9IjAuNSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMTAuODUsMjMuNDUgTDExLjM1LDIyLjk1IEMxMS40NDc2NTg0LDIyLjg1NTkyNDQgMTEuNTAxOTY2MSwyMi43MjU1ODU4IDExLjUsMjIuNTkgTDExLjUsMjIuMyBDMTEuNSwyMi4wMjM4NTc2IDExLjcyMzg1NzYsMjEuOCAxMiwyMS44IEwxMi41LDIxLjggQzEyLjc3NjE0MjQsMjEuOCAxMywyMi4wMjM4NTc2IDEzLDIyLjMgQzEzLDIyLjU3NjE0MjQgMTMuMjIzODU3NiwyMi44IDEzLjUsMjIuOCBMMTUuNSwyMi44IEMxNS43NzYxNDI0LDIyLjggMTYsMjIuNTc2MTQyNCAxNiwyMi4zIEMxNiwyMi4wMjM4NTc2IDE2LjIyMzg1NzYsMjEuOCAxNi41LDIxLjggTDE3LDIxLjggQzE3LjI3NjE0MjQsMjEuOCAxNy41LDIyLjAyMzg1NzYgMTcuNSwyMi4zIEwxNy41LDIyLjU5IEMxNy40OTgwMzM5LDIyLjcyNTU4NTggMTcuNTUyMzQxNiwyMi44NTU5MjQ0IDE3LjY1LDIyLjk1IEwxOC4xNSwyMy40NSBDMTguMzQwNTcxNCwyMy42NDQ0MjE4IDE4LjM0MDU3MTQsMjMuOTU1NTc4MiAxOC4xNSwyNC4xNSBMMTYuNjQsMjUuNjUgQzE2LjU0OTcxOTcsMjUuNzQ3MTM4MyAxNi40MjI2MDM5LDI1LjgwMTYxNjUgMTYuMjksMjUuOCBMMTIuNzEsMjUuOCBDMTIuNTc3Mzk2MSwyNS44MDE2MTY1IDEyLjQ1MDI4MDMsMjUuNzQ3MTM4MyAxMi4zNiwyNS42NSBMMTAuODUsMjQuMTUgQzEwLjY1OTQyODYsMjMuOTU1NTc4MiAxMC42NTk0Mjg2LDIzLjY0NDQyMTggMTAuODUsMjMuNDUgWiIgaWQ9IlNoYXBlIiBmaWxsPSIjN0M4N0E1IiBvcGFjaXR5PSIwLjUiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTIxLjUsMjcuNSBMMjYuNSwyNy41IEwyNi41LDMxLjUgQzI2LjUsMzIuMDUyMjg0NyAyNi4wNTIyODQ3LDMyLjUgMjUuNSwzMi41IEwyMS41LDMyLjUgTDIxLjUsMjcuNSBaIiBpZD0iU2hhcGUiIHN0cm9rZT0iI0NDNEMyMyIgZmlsbD0iI0YxNUEyOSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48L3BhdGg+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=";
/**
 * String with Ev3 expected pairing pin.
 * @readonly
 */

const Ev3PairingPin = "1234";
/**
 * A maximum number of BT message sends per second, to be enforced by the rate limiter.
 * @type {number}
 */

const BTSendRateMax = 40;
/**
 * Enum for Ev3 parameter encodings of various argument and return values.
 * Found in the 'EV3 Firmware Developer Kit', section4, page 9, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 *
 * The format for these values is:
 * 0xxxxxxx for Short Format
 * 1ttt-bbb for Long Format
 *
 * @readonly
 * @enum {number}
 */

const Ev3Encoding = {
  ONE_BYTE: 0x81,
  // = 0b1000-001, "1 byte to follow"
  TWO_BYTES: 0x82,
  // = 0b1000-010, "2 bytes to follow"
  FOUR_BYTES: 0x83,
  // = 0b1000-011, "4 bytes to follow"
  GLOBAL_VARIABLE_ONE_BYTE: 0xe1,
  // = 0b1110-001, "1 byte to follow"
  GLOBAL_CONSTANT_INDEX_0: 0x20,
  // = 0b00100000
  GLOBAL_VARIABLE_INDEX_0: 0x60 // = 0b01100000

};
/**
 * Enum for Ev3 direct command types.
 * Found in the 'EV3 Communication Developer Kit', section 4, page 24, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Command = {
  DIRECT_COMMAND_REPLY: 0x00,
  DIRECT_COMMAND_NO_REPLY: 0x80,
  DIRECT_REPLY: 0x02
};
/**
 * Enum for Ev3 commands opcodes.
 * Found in the 'EV3 Firmware Developer Kit', section 4, page 10, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Opcode = {
  OPOUTPUT_STEP_SPEED: 0xae,
  OPOUTPUT_TIME_SPEED: 0xaf,
  OPOUTPUT_STOP: 0xa3,
  OPOUTPUT_RESET: 0xa2,
  OPOUTPUT_STEP_SYNC: 0xb0,
  OPOUTPUT_TIME_SYNC: 0xb1,
  OPOUTPUT_GET_COUNT: 0xb3,
  OPSOUND: 0x94,
  OPSOUND_CMD_TONE: 1,
  OPSOUND_CMD_STOP: 0,
  OPINPUT_DEVICE_LIST: 0x98,
  OPINPUT_READSI: 0x9d
};
/**
 * Enum for Ev3 values used as arguments to various opcodes.
 * Found in the 'EV3 Firmware Developer Kit', section4, page 10-onwards, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Args = {
  LAYER: 0,
  // always 0, chained EV3s not supported
  COAST: 0,
  BRAKE: 1,
  RAMP: 50,
  // time in milliseconds
  DO_NOT_CHANGE_TYPE: 0,
  MAX_DEVICES: 32 // 'Normally 32' from pg. 46

};
/**
 * Enum for Ev3 device type numbers.
 * Found in the 'EV3 Firmware Developer Kit', section 5, page 100, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {string}
 */

const Ev3Device = {
  29: "color",
  30: "ultrasonic",
  32: "gyro",
  16: "touch",
  8: "mediumMotor",
  7: "largeMotor",
  126: "none",
  125: "none"
};
/**
 * Enum for Ev3 device modes.
 * Found in the 'EV3 Firmware Developer Kit', section 5, page 100, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Mode = {
  touch: 0,
  // touch
  color: 1,
  // ambient
  ultrasonic: 1,
  // inch
  none: 0
};
/**
 * Enum for Ev3 device labels used in the Scratch blocks/UI.
 * @readonly
 * @enum {string}
 */

const Ev3Label = {
  touch: "button",
  color: "brightness",
  ultrasonic: "distance"
};
/**
 * Manage power, direction, and timers for one EV3 motor.
 */

class EV3Motor {
  /**
   * Construct a EV3 Motor instance, which could be of type 'largeMotor' or
   * 'mediumMotor'.
   *
   * @param {EV3} parent - the EV3 peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   * @param {string} type - the type of motor (i.e. 'largeMotor' or 'mediumMotor').
   */
  constructor(parent, index, type) {
    /**
     * The EV3 peripheral which owns this motor.
     * @type {EV3}
     * @private
     */
    this._parent = parent;
    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */

    this._index = index;
    /**
     * The type of EV3 motor this could be: 'largeMotor' or 'mediumMotor'.
     * @type {string}
     * @private
     */

    this._type = type;
    /**
     * This motor's current direction: 1 for "clockwise" or -1 for "counterclockwise"
     * @type {number}
     * @private
     */

    this._direction = 1;
    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */

    this._power = 50;
    /**
     * This motor's current position, in the range [0,360].
     * @type {number}
     * @private
     */

    this._position = 0;
    /**
     * An ID for the current coast command, to help override multiple coast
     * commands sent in succession.
     * @type {number}
     * @private
     */

    this._commandID = null;
    /**
     * A delay, in milliseconds, to add to coasting, to make sure that a brake
     * first takes effect if one was sent.
     * @type {number}
     * @private
     */

    this._coastDelay = 1000;
  }
  /**
   * @return {string} - this motor's type: 'largeMotor' or 'mediumMotor'
   */


  get type() {
    return this._type;
  }
  /**
   * @param {string} value - this motor's new type: 'largeMotor' or 'mediumMotor'
   */


  set type(value) {
    this._type = value;
  }
  /**
   * @return {int} - this motor's current direction: 1 for "clockwise" or -1 for "counterclockwise"
   */


  get direction() {
    return this._direction;
  }
  /**
   * @param {int} value - this motor's new direction: 1 for "clockwise" or -1 for "counterclockwise"
   */


  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }
  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */


  get power() {
    return this._power;
  }
  /**
   * @param {int} value - this motor's new power level, in the range [0,100].
   */


  set power(value) {
    this._power = value;
  }
  /**
   * @return {int} - this motor's current position, in the range [-inf,inf].
   */


  get position() {
    return this._position;
  }
  /**
   * @param {int} array - this motor's new position, in the range [0,360].
   */


  set position(array) {
    // tachoValue from Paula
    let value = array[0] + array[1] * 256 + array[2] * 256 * 256 + array[3] * 256 * 256 * 256;

    if (value > 0x7fffffff) {
      value = value - 0x100000000;
    }

    this._position = value;
  }
  /**
   * Turn this motor on for a specific duration.
   * Found in the 'EV3 Firmware Developer Kit', page 56, at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
   *
   * Opcode arguments:
   * (Data8) LAYER – Specify chain layer number [0 - 3]
   * (Data8) NOS – Output bit field [0x00 – 0x0F]
   * (Data8) SPEED – Power level, [-100 – 100]
   * (Data32) STEP1 – Time in milliseconds for ramp up
   * (Data32) STEP2 – Time in milliseconds for continues run
   * (Data32) STEP3 – Time in milliseconds for ramp down
   * (Data8) BRAKE - Specify break level [0: Float, 1: Break]
   *
   * @param {number} milliseconds - run the motor for this long.
   */


  turnOnFor(milliseconds) {
    if (this._power === 0) return;

    const port = this._portMask(this._index);

    let n = milliseconds;
    let speed = this._power * this._direction;
    const ramp = Ev3Args.RAMP;
    let byteCommand = [];
    byteCommand[0] = Ev3Opcode.OPOUTPUT_TIME_SPEED; // If speed is less than zero, make it positive and multiply the input
    // value by -1

    if (speed < 0) {
      speed = -1 * speed;
      n = -1 * n;
    } // If the input value is less than 0


    const dir = n < 0 ? 0x100 - speed : speed; // step negative or positive

    n = Math.abs(n); // Setup motor run duration and ramping behavior

    let rampup = ramp;
    let rampdown = ramp;
    let run = n - ramp * 2;

    if (run < 0) {
      rampup = Math.floor(n / 2);
      run = 0;
      rampdown = n - rampup;
    } // Generate motor command values


    const runcmd = this._runValues(run);

    byteCommand = byteCommand.concat([Ev3Args.LAYER, port, Ev3Encoding.ONE_BYTE, dir & 0xff, Ev3Encoding.ONE_BYTE, rampup]).concat(runcmd.concat([Ev3Encoding.ONE_BYTE, rampdown, Ev3Args.BRAKE]));

    const cmd = this._parent.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, byteCommand);

    this._parent.send(cmd);

    this.coastAfter(milliseconds);
  }
  /**
   * Set the motor to coast after a specified amount of time.
   * @param {number} time - the time in milliseconds.
   */


  coastAfter(time) {
    if (this._power === 0) return; // Set the motor command id to check before starting coast

    console.warn("index:", Utility.uid());
    const commandId = Utility.uid();
    this._commandID = commandId; // Send coast message

    setTimeout(() => {
      // Do not send coast if another motor command changed the command id.
      if (this._commandID === commandId) {
        this.coast();
        this._commandID = null;
      }
    }, time + this._coastDelay); // add a delay so the brake takes effect
  }
  /**
   * Set the motor to coast.
   */


  coast() {
    if (this._power === 0) return;

    const cmd = this._parent.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPOUTPUT_STOP, Ev3Args.LAYER, this._portMask(this._index), // port output bit field
    Ev3Args.COAST]);

    this._parent.send(cmd, false); // don't use rate limiter to ensure motor stops

  }
  /**
   * Generate motor run values for a given input.
   * @param  {number} run - run input.
   * @return {array} - run values as a byte array.
   */


  _runValues(run) {
    // If run duration is less than max 16-bit integer
    if (run < 0x7fff) {
      return [Ev3Encoding.TWO_BYTES, run & 0xff, run >> 8 & 0xff];
    } // Run forever


    return [Ev3Encoding.FOUR_BYTES, run & 0xff, run >> 8 & 0xff, run >> 16 & 0xff, run >> 24 & 0xff];
  }
  /**
   * Return a port value for the EV3 that is in the format for 'output bit field'
   * as 1/2/4/8, generally needed for motor ports, instead of the typical 0/1/2/3.
   * The documentation in the 'EV3 Firmware Developer Kit' for motor port arguments
   * is sometimes mistaken, but we believe motor ports are mostly addressed this way.
   * @param {number} port - the port number to convert to an 'output bit field'.
   * @return {number} - the converted port number.
   */


  _portMask(port) {
    return Math.pow(2, port);
  }

}

class EV3 {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    this._runtime.on("PROJECT_STOP_ALL", this.stopAll.bind(this));
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * A list of the names of the sensors connected in ports 1,2,3,4.
     * @type {string[]}
     * @private
     */

    this._sensorPorts = [];
    /**
     * A list of the names of the motors connected in ports A,B,C,D.
     * @type {string[]}
     * @private
     */

    this._motorPorts = [];
    /**
     * The state of all sensor values.
     * @type {string[]}
     * @private
     */

    this._sensors = {
      distance: 0,
      brightness: 0,
      buttons: [0, 0, 0, 0]
    };
    /**
     * The motors which this EV3 could possibly have connected.
     * @type {string[]}
     * @private
     */

    this._motors = [null, null, null, null];
    /**
     * The polling interval, in milliseconds.
     * @type {number}
     * @private
     */

    this._pollingInterval = 150;
    /**
     * The polling interval ID.
     * @type {number}
     * @private
     */

    this._pollingIntervalID = null;
    /**
     * The counter keeping track of polling cycles.
     * @type {string[]}
     * @private
     */

    this._pollingCounter = 0;
    /**
     * The Bluetooth socket connection for reading/writing peripheral data.
     * @type {BT}
     * @private
     */

    this._bt = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * A rate limiter utility, to help limit the rate at which we send BT messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */


    this._rateLimiter = new RateLimiter(BTSendRateMax);
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._pollValues = this._pollValues.bind(this);
  }

  get distance() {
    let value = this._sensors.distance > 100 ? 100 : this._sensors.distance;
    value = value < 0 ? 0 : value;
    value = Math.round(100 * value) / 100;
    return value;
  }

  get brightness() {
    return this._sensors.brightness;
  }
  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the zero-based index of the desired motor.
   * @return {EV3Motor} - the EV3Motor instance, if any, at that index.
   */


  motor(index) {
    return this._motors[index];
  }

  isButtonPressed(port) {
    return this._sensors.buttons[port] === 1;
  }

  beep(freq, time) {
    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPSOUND, Ev3Opcode.OPSOUND_CMD_TONE, Ev3Encoding.ONE_BYTE, 2, Ev3Encoding.TWO_BYTES, freq, freq >> 8, Ev3Encoding.TWO_BYTES, time, time >> 8]);
    this.send(cmd);
  }

  stopAll() {
    this.stopAllMotors();
    this.stopSound();
  }

  stopSound() {
    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPSOUND, Ev3Opcode.OPSOUND_CMD_STOP]);
    this.send(cmd, false); // don't use rate limiter to ensure sound stops
  }

  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        motor.coast();
      }
    });
  }
  /**
   * Called by the runtime when user wants to scan for an EV3 peripheral.
   */


  scan() {
    if (this._bt) {
      this._bt.disconnect();
    }

    this._bt = new BT(this._runtime, this._extensionId, {
      majorDeviceClass: 8,
      minorDeviceClass: 1
    }, this._onConnect, this.reset, this._onMessage);
  }
  /**
   * Called by the runtime when user wants to connect to a certain EV3 peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._bt) {
      this._bt.connectPeripheral(id, Ev3PairingPin);
    }
  }
  /**
   * Called by the runtime when user wants to disconnect from the EV3 peripheral.
   */


  disconnect() {
    if (this._bt) {
      this._bt.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    this._sensorPorts = [];
    this._motorPorts = [];
    this._sensors = {
      distance: 0,
      brightness: 0,
      buttons: [0, 0, 0, 0]
    };
    this._motors = [null, null, null, null];

    if (this._pollingIntervalID) {
      window.clearInterval(this._pollingIntervalID);
      this._pollingIntervalID = null;
    }
  }
  /**
   * Called by the runtime to detect whether the EV3 peripheral is connected.
   * @return {boolean} - the connected state.
   */


  isConnected() {
    let connected = false;

    if (this._bt) {
      connected = this._bt.isConnected();
    }

    return connected;
  }
  /**
   * Send a message to the peripheral BT socket.
   * @param {Uint8Array} message - the message to send.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the send operation.
   */


  send(message, useLimiter = true) {
    if (!this.isConnected()) return Promise.resolve();

    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }

    return this._bt.sendMessage({
      message: Utility.uint8ArrayToBase64(message),
      encoding: "base64"
    });
  }
  /**
   * Genrates direct commands that are sent to the EV3 as a single or compounded byte arrays.
   * See 'EV3 Communication Developer Kit', section 4, page 24 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
   *
   * Direct commands are one of two types:
   * DIRECT_COMMAND_NO_REPLY = a direct command where no reply is expected
   * DIRECT_COMMAND_REPLY = a direct command where a reply is expected, and the
   * number and length of returned values needs to be specified.
   *
   * The direct command byte array sent takes the following format:
   * Byte 0 - 1: Command size, Little Endian. Command size not including these 2 bytes
   * Byte 2 - 3: Message counter, Little Endian. Forth running counter
   * Byte 4:     Command type. Either DIRECT_COMMAND_REPLY or DIRECT_COMMAND_NO_REPLY
   * Byte 5 - 6: Reservation (allocation) of global and local variables using a compressed format
   *             (globals reserved in byte 5 and the 2 lsb of byte 6, locals reserved in the upper
   *             6 bits of byte 6) – see documentation for more details.
   * Byte 7 - n: Byte codes as a single command or compound commands (I.e. more commands composed
   *             as a small program)
   *
   * @param {number} type - the direct command type.
   * @param {string} byteCommands - a compound array of EV3 Opcode + arguments.
   * @param {number} allocation - the allocation of global and local vars needed for replies.
   * @return {array} - generated complete command byte array, with header and compounded commands.
   */


  generateCommand(type, byteCommands, allocation = 0) {
    // Header (Bytes 0 - 6)
    let command = [];
    command[2] = 0; // Message counter unused for now

    command[3] = 0; // Message counter unused for now

    command[4] = type;
    command[5] = allocation & 0xff;
    command[6] = allocation >> 8 && 0xff; // Bytecodes (Bytes 7 - n)

    command = command.concat(byteCommands); // Calculate command length minus first two header bytes

    const len = command.length - 2;
    command[0] = len & 0xff;
    command[1] = len >> 8 && 0xff;
    return command;
  }
  /**
   * When the EV3 peripheral connects, start polling for sensor and motor values.
   * @private
   */


  _onConnect() {
    this._pollingIntervalID = window.setInterval(this._pollValues, this._pollingInterval);
  }
  /**
   * Poll the EV3 for sensor and motor input values, based on the list of
   * known connected sensors and motors. This is sent as many compound commands
   * in a direct command, with a reply expected.
   *
   * See 'EV3 Firmware Developer Kit', section 4.8, page 46, at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for a list of polling/input device commands and their arguments.
   *
   * @private
   */


  _pollValues() {
    if (!this.isConnected()) {
      window.clearInterval(this._pollingIntervalID);
      return;
    }

    const cmds = []; // compound command

    let allocation = 0;
    let sensorCount = 0; // Reset the list of devices every 20 counts

    if (this._pollingCounter % 20 === 0) {
      // GET DEVICE LIST
      cmds[0] = Ev3Opcode.OPINPUT_DEVICE_LIST;
      cmds[1] = Ev3Encoding.ONE_BYTE;
      cmds[2] = Ev3Args.MAX_DEVICES;
      cmds[3] = Ev3Encoding.GLOBAL_VARIABLE_INDEX_0;
      cmds[4] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
      cmds[5] = Ev3Encoding.GLOBAL_CONSTANT_INDEX_0; // Command and payload lengths

      allocation = 33;
      this._updateDevices = true;
    } else {
      // GET SENSOR VALUES FOR CONNECTED SENSORS
      let index = 0;

      for (let i = 0; i < 4; i++) {
        if (this._sensorPorts[i] !== "none") {
          cmds[index + 0] = Ev3Opcode.OPINPUT_READSI;
          cmds[index + 1] = Ev3Args.LAYER;
          cmds[index + 2] = i; // PORT

          cmds[index + 3] = Ev3Args.DO_NOT_CHANGE_TYPE;
          cmds[index + 4] = Ev3Mode[this._sensorPorts[i]];
          cmds[index + 5] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
          cmds[index + 6] = sensorCount * 4; // GLOBAL INDEX

          index += 7;
        }

        sensorCount++;
      } // GET MOTOR POSITION VALUES, EVEN IF NO MOTOR PRESENT


      for (let i = 0; i < 4; i++) {
        cmds[index + 0] = Ev3Opcode.OPOUTPUT_GET_COUNT;
        cmds[index + 1] = Ev3Args.LAYER;
        cmds[index + 2] = i; // PORT (incorrectly specified as 'Output bit field' in LEGO docs)

        cmds[index + 3] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
        cmds[index + 4] = sensorCount * 4; // GLOBAL INDEX

        index += 5;
        sensorCount++;
      } // Command and payload lengths


      allocation = sensorCount * 4;
    }

    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_REPLY, cmds, allocation);
    this.send(cmd);
    this._pollingCounter++;
  }
  /**
   * Message handler for incoming EV3 reply messages, either a list of connected
   * devices (sensors and motors) or the values of the connected sensors and motors.
   *
   * See 'EV3 Communication Developer Kit', section 4.1, page 24 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for more details on direct reply formats.
   *
   * The direct reply byte array sent takes the following format:
   * Byte 0 – 1: Reply size, Little Endian. Reply size not including these 2 bytes
   * Byte 2 – 3: Message counter, Little Endian. Equals the Direct Command
   * Byte 4:     Reply type. Either DIRECT_REPLY or DIRECT_REPLY_ERROR
   * Byte 5 - n: Resonse buffer. I.e. the content of the by the Command reserved global variables.
   *             I.e. if the command reserved 64 bytes, these bytes will be placed in the reply
   *             packet as the bytes 5 to 68.
   *
   * See 'EV3 Firmware Developer Kit', section 4.8, page 56 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for direct response buffer formats for various commands.
   *
   * @param {object} params - incoming message parameters
   * @private
   */


  _onMessage(params) {
    const message = params.message;
    const data = Utility.base64ToUint8Array(message);

    if (data[4] !== Ev3Command.DIRECT_REPLY) {
      return;
    }

    if (this._updateDevices) {
      // PARSE DEVICE LIST
      for (let i = 0; i < 4; i++) {
        const deviceType = Ev3Device[data[i + 5]]; // if returned device type is null, use 'none'

        this._sensorPorts[i] = deviceType ? deviceType : "none";
      }

      for (let i = 0; i < 4; i++) {
        const deviceType = Ev3Device[data[i + 21]]; // if returned device type is null, use 'none'

        this._motorPorts[i] = deviceType ? deviceType : "none";
      }

      for (let m = 0; m < 4; m++) {
        const type = this._motorPorts[m];

        if (type !== "none" && !this._motors[m]) {
          // add new motor if don't already have one
          this._motors[m] = new EV3Motor(this, m, type);
        }

        if (type === "none" && this._motors[m]) {
          // clear old motor
          this._motors[m] = null;
        }
      }

      this._updateDevices = false; // eslint-disable-next-line no-undefined
    } else if (!this._sensorPorts.includes(undefined) && !this._motorPorts.includes(undefined)) {
      // PARSE SENSOR VALUES
      let offset = 5; // start reading sensor values at byte 5

      for (let i = 0; i < 4; i++) {
        // array 2 float
        const buffer = new Uint8Array([data[offset], data[offset + 1], data[offset + 2], data[offset + 3]]).buffer;
        const view = new DataView(buffer);
        const value = view.getFloat32(0, true);

        if (Ev3Label[this._sensorPorts[i]] === "button") {
          // Read a button value per port
          this._sensors.buttons[i] = value ? value : 0;
        } else if (Ev3Label[this._sensorPorts[i]]) {
          // if valid
          // Read brightness / distance values and set to 0 if null
          this._sensors[Ev3Label[this._sensorPorts[i]]] = value ? value : 0;
        }

        offset += 4;
      } // PARSE MOTOR POSITION VALUES, EVEN IF NO MOTOR PRESENT


      for (let i = 0; i < 4; i++) {
        const positionArray = [data[offset], data[offset + 1], data[offset + 2], data[offset + 3]];

        if (this._motors[i]) {
          this._motors[i].position = positionArray;
        }

        offset += 4;
      }
    }
  }

}
/**
 * Enum for motor port names.
 * Note: if changed, will break compatibility with previously saved projects.
 * @readonly
 * @enum {string}
 */


const Ev3MotorMenu = ["A", "B", "C", "D"];
/**
 * Enum for sensor port names.
 * Note: if changed, will break compatibility with previously saved projects.
 * @readonly
 * @enum {string}
 */

const Ev3SensorMenu = ["1", "2", "3", "4"];

class Scratch3Ev3Blocks {
  /**
   * The ID of the extension.
   * @return {string} the id
   */
  static get EXTENSION_ID() {
    return "ev3";
  }
  /**
   * Creates a new instance of the EV3 extension.
   * @param  {object} runtime VM runtime
   * @constructor
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new EV3 peripheral instance

    this._peripheral = new EV3(this.runtime, Scratch3Ev3Blocks.EXTENSION_ID);
    this._playNoteForPicker = this._playNoteForPicker.bind(this);
    this.runtime.on("PLAY_NOTE", this._playNoteForPicker);
  }
  /**
   * Define the EV3 extension.
   * @return {object} Extension description.
   */


  getInfo() {
    return {
      id: Scratch3Ev3Blocks.EXTENSION_ID,
      name: "LEGO EV3",
      blockIconURI: blockIconURI,
      showStatusButton: true,
      blocks: [{
        opcode: "motorTurnClockwise",
        text: formatMessage({
          id: "ev3.motorTurnClockwise",
          default: "motor [PORT] turn this way for [TIME] seconds",
          description: "turn a motor clockwise for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "motorPorts",
            defaultValue: 0
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: "motorTurnCounterClockwise",
        text: formatMessage({
          id: "ev3.motorTurnCounterClockwise",
          default: "motor [PORT] turn that way for [TIME] seconds",
          description: "turn a motor counter-clockwise for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "motorPorts",
            defaultValue: 0
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: "motorSetPower",
        text: formatMessage({
          id: "ev3.motorSetPower",
          default: "motor [PORT] set power [POWER] %",
          description: "set a motor's power to some value"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "motorPorts",
            defaultValue: 0
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: "getMotorPosition",
        text: formatMessage({
          id: "ev3.getMotorPosition",
          default: "motor [PORT] position",
          description: "get the measured degrees a motor has turned"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "motorPorts",
            defaultValue: 0
          }
        }
      }, {
        opcode: "whenButtonPressed",
        text: formatMessage({
          id: "ev3.whenButtonPressed",
          default: "when button [PORT] pressed",
          description: "when a button connected to a port is pressed"
        }),
        blockType: BlockType.HAT,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "sensorPorts",
            defaultValue: 0
          }
        }
      }, {
        opcode: "whenDistanceLessThan",
        text: formatMessage({
          id: "ev3.whenDistanceLessThan",
          default: "when distance < [DISTANCE]",
          description: "when the value measured by the distance sensor is less than some value"
        }),
        blockType: BlockType.HAT,
        arguments: {
          DISTANCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 5
          }
        }
      }, {
        opcode: "whenBrightnessLessThan",
        text: formatMessage({
          id: "ev3.whenBrightnessLessThan",
          default: "when brightness < [DISTANCE]",
          description: "when value measured by brightness sensor is less than some value"
        }),
        blockType: BlockType.HAT,
        arguments: {
          DISTANCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: "buttonPressed",
        text: formatMessage({
          id: "ev3.buttonPressed",
          default: "button [PORT] pressed?",
          description: "is a button on some port pressed?"
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: "sensorPorts",
            defaultValue: 0
          }
        }
      }, {
        opcode: "getDistance",
        text: formatMessage({
          id: "ev3.getDistance",
          default: "distance",
          description: "gets measured distance"
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: "getBrightness",
        text: formatMessage({
          id: "ev3.getBrightness",
          default: "brightness",
          description: "gets measured brightness"
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: "beep",
        text: formatMessage({
          id: "ev3.beepNote",
          default: "beep note [NOTE] for [TIME] secs",
          description: "play some note on EV3 for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          NOTE: {
            type: ArgumentType.NOTE,
            defaultValue: 60
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.5
          }
        }
      }],
      menus: {
        motorPorts: {
          acceptReporters: true,
          items: this._formatMenu(Ev3MotorMenu)
        },
        sensorPorts: {
          acceptReporters: true,
          items: this._formatMenu(Ev3SensorMenu)
        }
      }
    };
  }

  motorTurnClockwise(args) {
    const port = Utility.toNumber(args.PORT);
    let time = Utility.toNumber(args.TIME) * 1000;
    time = Utility.clamp(time, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(port, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) {
          motor.direction = 1;
          motor.turnOnFor(time);
        }
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, time);
    });
  }

  motorTurnCounterClockwise(args) {
    const port = Utility.toNumber(args.PORT);
    let time = Utility.toNumber(args.TIME) * 1000;
    time = Utility.clamp(time, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(port, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) {
          motor.direction = -1;
          motor.turnOnFor(time);
        }
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, time);
    });
  }

  motorSetPower(args) {
    const port = Utility.toNumber(args.PORT);
    const power = Utility.clamp(Utility.toNumber(args.POWER), 0, 100);

    this._forEachMotor(port, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.power = power;
      }
    });
  }

  getMotorPosition(args) {
    const port = Utility.toNumber(args.PORT);

    if (![0, 1, 2, 3].includes(port)) {
      return;
    }

    const motor = this._peripheral.motor(port);

    let position = 0;

    if (motor) {
      position = Utility.wrapClamp(motor.position, 0, 360);
    }

    return position;
  }

  whenButtonPressed(args) {
    const port = Utility.toNumber(args.PORT);

    if (![0, 1, 2, 3].includes(port)) {
      return;
    }

    return this._peripheral.isButtonPressed(port);
  }

  whenDistanceLessThan(args) {
    const distance = Utility.clamp(Utility.toNumber(args.DISTANCE), 0, 100);
    return this._peripheral.distance < distance;
  }

  whenBrightnessLessThan(args) {
    const brightness = Utility.clamp(Utility.toNumber(args.DISTANCE), 0, 100);
    return this._peripheral.brightness < brightness;
  }

  buttonPressed(args) {
    const port = Utility.toNumber(args.PORT);

    if (![0, 1, 2, 3].includes(port)) {
      return;
    }

    return this._peripheral.isButtonPressed(port);
  }

  getDistance() {
    return this._peripheral.distance;
  }

  getBrightness() {
    return this._peripheral.brightness;
  }

  _playNoteForPicker(note, category) {
    if (category !== this.getInfo().name) return;
    this.beep({
      NOTE: note,
      TIME: 0.25
    });
  }

  beep(args) {
    const note = Utility.clamp(Utility.toNumber(args.NOTE), 47, 99); // valid EV3 sounds

    let time = Utility.toNumber(args.TIME) * 1000;
    time = Utility.clamp(time, 0, 3000);

    if (time === 0) {
      return; // don't send a beep time of 0
    }

    return new Promise(resolve => {
      // https://en.wikipedia.org/wiki/MIDI_tuning_standard#Frequency_values
      const freq = Math.pow(2, (note - 69 + 12) / 12) * 440;

      this._peripheral.beep(freq, time); // Run for some time even when no piezo is connected.


      setTimeout(resolve, time);
    });
  }
  /**
   * Call a callback for each motor indexed by the provided motor ID.
   *
   * Note: This way of looping through motors is currently unnecessary, but could be
   * useful if an 'all motors' option is added in the future (see WeDo2 extension).
   *
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */


  _forEachMotor(motorID, callback) {
    let motors;

    switch (motorID) {
      case 0:
        motors = [0];
        break;

      case 1:
        motors = [1];
        break;

      case 2:
        motors = [2];
        break;

      case 3:
        motors = [3];
        break;

      default:
        console.warn(`Invalid motor ID: ${motorID}`);
        motors = [];
        break;
    }

    for (const index of motors) {
      callback(index);
    }
  }
  /**
   * Formats menus into a format suitable for block menus, and loading previously
   * saved projects:
   * [
   *   {
   *    text: label,
   *    value: index
   *   },
   *   {
   *    text: label,
   *    value: index
   *   },
   *   etc...
   * ]
   *
   * @param {array} menu - a menu to format.
   * @return {object} - a formatted menu as an object.
   * @private
   */


  _formatMenu(menu) {
    const m = [];

    for (let i = 0; i < menu.length; i++) {
      const obj = {};
      obj.text = menu[i];
      obj.value = i.toString();
      m.push(obj);
    }

    return m;
  }

}

module.exports = Scratch3Ev3Blocks;

/***/ }),

/***/ "./src/extensions/scratch3_makeymakey/index.js":
/*!*****************************************************!*\
  !*** ./src/extensions/scratch3_makeymakey/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MCA0MCI+PHN0eWxlPi5zdDJ7ZmlsbDpyZWR9LnN0M3tmaWxsOiNlMGUwZTB9LnN0NHtmaWxsOm5vbmU7c3Ryb2tlOiM2NjY7c3Ryb2tlLXdpZHRoOi41O3N0cm9rZS1taXRlcmxpbWl0OjEwfTwvc3R5bGU+PHBhdGggZD0iTTM1IDI4SDVhMSAxIDAgMCAxLTEtMVYxMmMwLS42LjQtMSAxLTFoMzBjLjUgMCAxIC40IDEgMXYxNWMwIC41LS41IDEtMSAxeiIgZmlsbD0iI2ZmZiIgaWQ9IkxheWVyXzYiLz48ZyBpZD0iTGF5ZXJfNCI+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQgMjVoMzJ2Mi43SDR6TTEzIDI0aC0yLjJhMSAxIDAgMCAxLTEtMXYtOS43YzAtLjYuNC0xIDEtMUgxM2MuNiAwIDEgLjQgMSAxVjIzYzAgLjYtLjUgMS0xIDF6Ii8+PHBhdGggY2xhc3M9InN0MiIgZD0iTTYuMSAxOS4zdi0yLjJjMC0uNS40LTEgMS0xaDkuN2MuNSAwIDEgLjUgMSAxdjIuMmMwIC41LS41IDEtMSAxSDcuMWExIDEgMCAwIDEtMS0xeiIvPjxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjIyLjgiIGN5PSIxOC4yIiByPSIzLjQiLz48Y2lyY2xlIGNsYXNzPSJzdDIiIGN4PSIzMC42IiBjeT0iMTguMiIgcj0iMy40Ii8+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQuMiAyN2gzMS45di43SDQuMnoiLz48L2c+PGcgaWQ9IkxheWVyXzUiPjxjaXJjbGUgY2xhc3M9InN0MyIgY3g9IjIyLjgiIGN5PSIxOC4yIiByPSIyLjMiLz48Y2lyY2xlIGNsYXNzPSJzdDMiIGN4PSIzMC42IiBjeT0iMTguMiIgcj0iMi4zIi8+PHBhdGggY2xhc3M9InN0MyIgZD0iTTEyLjUgMjIuOWgtMS4yYy0uMyAwLS41LS4yLS41LS41VjE0YzAtLjMuMi0uNS41LS41aDEuMmMuMyAwIC41LjIuNS41djguNGMwIC4zLS4yLjUtLjUuNXoiLz48cGF0aCBjbGFzcz0ic3QzIiBkPSJNNy4yIDE4Ljd2LTEuMmMwLS4zLjItLjUuNS0uNWg4LjRjLjMgMCAuNS4yLjUuNXYxLjJjMCAuMy0uMi41LS41LjVINy43Yy0uMyAwLS41LS4yLS41LS41ek00IDI2aDMydjJINHoiLz48L2c+PGcgaWQ9IkxheWVyXzMiPjxwYXRoIGNsYXNzPSJzdDQiIGQ9Ik0zNS4yIDI3LjlINC44YTEgMSAwIDAgMS0xLTFWMTIuMWMwLS42LjUtMSAxLTFoMzAuNWMuNSAwIDEgLjQgMSAxVjI3YTEgMSAwIDAgMS0xLjEuOXoiLz48cGF0aCBjbGFzcz0ic3Q0IiBkPSJNMzUuMiAyNy45SDQuOGExIDEgMCAwIDEtMS0xVjEyLjFjMC0uNi41LTEgMS0xaDMwLjVjLjUgMCAxIC40IDEgMVYyN2ExIDEgMCAwIDEtMS4xLjl6Ii8+PC9nPjwvc3ZnPg==";
/**
 * Length of the buffer to store key presses for the "when keys pressed in order" hat
 * @type {number}
 */

const KEY_BUFFER_LENGTH = 100;
/**
 * Timeout in milliseconds to reset the completed flag for a sequence.
 * @type {number}
 */

const SEQUENCE_HAT_TIMEOUT = 100;
/**
 * An id for the space key on a keyboard.
 */

const KEY_ID_SPACE = "SPACE";
/**
 * An id for the left arrow key on a keyboard.
 */

const KEY_ID_LEFT = "LEFT";
/**
 * An id for the right arrow key on a keyboard.
 */

const KEY_ID_RIGHT = "RIGHT";
/**
 * An id for the up arrow key on a keyboard.
 */

const KEY_ID_UP = "UP";
/**
 * An id for the down arrow key on a keyboard.
 */

const KEY_ID_DOWN = "DOWN";
/**
 * Names used by keyboard io for keys used in scratch.
 * @enum {string}
 */

const SCRATCH_KEY_NAME = {
  [KEY_ID_SPACE]: "space",
  [KEY_ID_LEFT]: "left arrow",
  [KEY_ID_UP]: "up arrow",
  [KEY_ID_RIGHT]: "right arrow",
  [KEY_ID_DOWN]: "down arrow"
};
/**
 * Class for the makey makey blocks in Scratch 3.0
 * @constructor
 */

class Scratch3MakeyMakeyBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * A toggle that alternates true and false each frame, so that an
     * edge-triggered hat can trigger on every other frame.
     * @type {boolean}
     */

    this.frameToggle = false; // Set an interval that toggles the frameToggle every frame.

    setInterval(() => {
      this.frameToggle = !this.frameToggle;
    }, this.runtime.currentStepTime);
    this.keyPressed = this.keyPressed.bind(this);
    this.runtime.on("KEY_PRESSED", this.keyPressed);
    this._clearkeyPressBuffer = this._clearkeyPressBuffer.bind(this);
    this.runtime.on("PROJECT_STOP_ALL", this._clearkeyPressBuffer);
    /*
     * An object containing a set of sequence objects.
     * These are the key sequences currently being detected by the "when
     * keys pressed in order" hat block. Each sequence is keyed by its
     * string representation (the sequence's value in the menu, which is a
     * string of KEY_IDs separated by spaces). Each sequence object
     * has an array property (an array of KEY_IDs) and a boolean
     * completed property that is true when the sequence has just been
     * pressed.
     * @type {object}
     */

    this.sequences = {};
    /*
     * An array of the key codes of recently pressed keys.
     * @type {array}
     */

    this.keyPressBuffer = [];
  }
  /*
   * Localized short-form names of the space bar and arrow keys, for use in the
   * displayed menu items of the "when keys pressed in order" block.
   * @type {object}
   */


  get KEY_TEXT_SHORT() {
    return {
      [KEY_ID_SPACE]: formatMessage({
        id: "makeymakey.spaceKey",
        default: "space",
        description: "The space key on a computer keyboard."
      }),
      [KEY_ID_LEFT]: formatMessage({
        id: "makeymakey.leftArrowShort",
        default: "left",
        description: "Short name for the left arrow key on a computer keyboard."
      }),
      [KEY_ID_UP]: formatMessage({
        id: "makeymakey.upArrowShort",
        default: "up",
        description: "Short name for the up arrow key on a computer keyboard."
      }),
      [KEY_ID_RIGHT]: formatMessage({
        id: "makeymakey.rightArrowShort",
        default: "right",
        description: "Short name for the right arrow key on a computer keyboard."
      }),
      [KEY_ID_DOWN]: formatMessage({
        id: "makeymakey.downArrowShort",
        default: "down",
        description: "Short name for the down arrow key on a computer keyboard."
      })
    };
  }
  /*
   * An array of strings of KEY_IDs representing the default set of
   * key sequences for use by the "when keys pressed in order" block.
   * @type {array}
   */


  get DEFAULT_SEQUENCES() {
    return [`${KEY_ID_LEFT} ${KEY_ID_UP} ${KEY_ID_RIGHT}`, `${KEY_ID_RIGHT} ${KEY_ID_UP} ${KEY_ID_LEFT}`, `${KEY_ID_LEFT} ${KEY_ID_RIGHT}`, `${KEY_ID_RIGHT} ${KEY_ID_LEFT}`, `${KEY_ID_UP} ${KEY_ID_DOWN}`, `${KEY_ID_DOWN} ${KEY_ID_UP}`, `${KEY_ID_UP} ${KEY_ID_RIGHT} ${KEY_ID_DOWN} ${KEY_ID_LEFT}`, `${KEY_ID_UP} ${KEY_ID_LEFT} ${KEY_ID_DOWN} ${KEY_ID_RIGHT}`, `${KEY_ID_UP} ${KEY_ID_UP} ${KEY_ID_DOWN} ${KEY_ID_DOWN} ` + `${KEY_ID_LEFT} ${KEY_ID_RIGHT} ${KEY_ID_LEFT} ${KEY_ID_RIGHT}`];
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: "makeymakey",
      name: "Makey Makey",
      blockIconURI: blockIconURI,
      blocks: [{
        opcode: "whenMakeyKeyPressed",
        text: formatMessage({
          id: "makeymakey.whenKeyPressed",
          default: "when [KEY] key pressed",
          description: "when a keyboard key is pressed"
        }),
        blockType: BlockType.HAT,
        arguments: {
          KEY: {
            type: ArgumentType.STRING,
            menu: "KEY",
            defaultValue: KEY_ID_SPACE
          }
        }
      }, {
        opcode: "whenCodePressed",
        text: formatMessage({
          id: "makeymakey.whenKeysPressedInOrder",
          default: "when [SEQUENCE] pressed in order",
          description: "when a sequence of keyboard keys is pressed in a specific order"
        }),
        blockType: BlockType.HAT,
        arguments: {
          SEQUENCE: {
            type: ArgumentType.STRING,
            menu: "SEQUENCE",
            defaultValue: this.DEFAULT_SEQUENCES[0]
          }
        }
      }],
      menus: {
        KEY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "makeymakey.spaceKey",
              default: "space",
              description: "The space key on a computer keyboard."
            }),
            value: KEY_ID_SPACE
          }, {
            text: formatMessage({
              id: "makeymakey.upArrow",
              default: "up arrow",
              description: "The up arrow key on a computer keyboard."
            }),
            value: KEY_ID_UP
          }, {
            text: formatMessage({
              id: "makeymakey.downArrow",
              default: "down arrow",
              description: "The down arrow key on a computer keyboard."
            }),
            value: KEY_ID_DOWN
          }, {
            text: formatMessage({
              id: "makeymakey.rightArrow",
              default: "right arrow",
              description: "The right arrow key on a computer keyboard."
            }),
            value: KEY_ID_RIGHT
          }, {
            text: formatMessage({
              id: "makeymakey.leftArrow",
              default: "left arrow",
              description: "The left arrow key on a computer keyboard."
            }),
            value: KEY_ID_LEFT
          }, {
            text: "w",
            value: "w"
          }, {
            text: "a",
            value: "a"
          }, {
            text: "s",
            value: "s"
          }, {
            text: "d",
            value: "d"
          }, {
            text: "f",
            value: "f"
          }, {
            text: "g",
            value: "g"
          }]
        },
        SEQUENCE: {
          acceptReporters: true,
          items: this.buildSequenceMenu(this.DEFAULT_SEQUENCES)
        }
      }
    };
  }
  /*
   * Build the menu of key sequences.
   * @param {array} sequencesArray an array of strings of KEY_IDs.
   * @returns {array} an array of objects with text and value properties.
   */


  buildSequenceMenu(sequencesArray) {
    return sequencesArray.map(str => this.getMenuItemForSequenceString(str));
  }
  /*
   * Create a menu item for a sequence string.
   * @param {string} sequenceString a string of KEY_IDs.
   * @return {object} an object with text and value properties.
   */


  getMenuItemForSequenceString(sequenceString) {
    let sequenceArray = sequenceString.split(" ");
    sequenceArray = sequenceArray.map(str => this.KEY_TEXT_SHORT[str]);
    return {
      text: sequenceArray.join(" "),
      value: sequenceString
    };
  }
  /*
   * Check whether a keyboard key is currently pressed.
   * Also, toggle the results of the test on alternate frames, so that the
   * hat block fires repeatedly.
   * @param {object} args - the block arguments.
   * @property {number} KEY - a key code.
   * @param {object} util - utility object provided by the runtime.
   */


  whenMakeyKeyPressed(args, util) {
    let key = args.KEY; // Convert the key arg, if it is a KEY_ID, to the key name used by
    // the Keyboard io module.

    if (SCRATCH_KEY_NAME[args.KEY]) {
      key = SCRATCH_KEY_NAME[args.KEY];
    }

    const isDown = util.ioQuery("keyboard", "getKeyIsDown", [key]);
    return isDown && this.frameToggle;
  }
  /*
   * A function called on the KEY_PRESSED event, to update the key press
   * buffer and check if any of the key sequences have been completed.
   * @param {string} key A scratch key name.
   */


  keyPressed(key) {
    // Store only the first word of the Scratch key name, so that e.g. when
    // "left arrow" is pressed, we store "LEFT", which matches KEY_ID_LEFT
    key = key.split(" ")[0];
    key = key.toUpperCase();
    this.keyPressBuffer.push(key); // Keep the buffer under the length limit

    if (this.keyPressBuffer.length > KEY_BUFFER_LENGTH) {
      this.keyPressBuffer.shift();
    } // Check the buffer for each sequence in use


    for (const str in this.sequences) {
      const arr = this.sequences[str].array; // Bail out if we don't have enough presses for this sequence

      if (this.keyPressBuffer.length < arr.length) {
        continue;
      }

      let missFlag = false; // Slice the buffer to the length of the sequence we're checking

      const bufferSegment = this.keyPressBuffer.slice(-1 * arr.length);

      for (let i = 0; i < arr.length; i++) {
        if (arr[i] !== bufferSegment[i]) {
          missFlag = true;
        }
      } // If the miss flag is false, the sequence matched the buffer


      if (!missFlag) {
        this.sequences[str].completed = true; // Clear the completed flag after a timeout. This is necessary because
        // the hat is edge-triggered (not event triggered). Multiple hats
        // may be checking the same sequence, so this timeout gives them enough
        // time to all trigger before resetting the flag.

        setTimeout(() => {
          this.sequences[str].completed = false;
        }, SEQUENCE_HAT_TIMEOUT);
      }
    }
  }
  /**
   * Clear the key press buffer.
   */


  _clearkeyPressBuffer() {
    this.keyPressBuffer = [];
  }
  /*
   * Add a key sequence to the set currently being checked on each key press.
   * @param {string} sequenceString a string of space-separated KEY_IDs.
   * @param {array} sequenceArray an array of KEY_IDs.
   */


  addSequence(sequenceString, sequenceArray) {
    // If we already have this sequence string, return.
    if (this.sequences.hasOwnProperty(sequenceString)) {
      return;
    }

    this.sequences[sequenceString] = {
      array: sequenceArray,
      completed: false
    };
  }
  /*
   * Check whether a key sequence was recently completed.
   * @param {object} args The block arguments.
   * @property {number} SEQUENCE A string of KEY_IDs.
   */


  whenCodePressed(args) {
    const sequenceString = String(args.SEQUENCE).toUpperCase();
    const sequenceArray = sequenceString.split(" ");

    if (sequenceArray.length < 2) {
      return;
    }

    this.addSequence(sequenceString, sequenceArray);
    return this.sequences[sequenceString].completed;
  }

}

module.exports = Scratch3MakeyMakeyBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_microbit/index.js":
/*!***************************************************!*\
  !*** ./src/extensions/scratch3_microbit/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");
/**
 * Icon png to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAKcElEQVR42u2cfXAU9RnHv7u3L3d7l9yR5PIGXO7MkQKaYiCUWqJhFGvRMk4JZXSc8aXVaSmiYlthVHQEW99FxiIdrVY6teiMdoa+ICqhIqgQAsjwMgYDOQKXl7uY17u9293b3f5x5JKYe8+FJGSfvzbP/n77e/azz+95nt9v90KoqgpN0hdSQ6AB1ABqADWAmmgANYAaQA2gJhpADeBEE2q8GPLaWzu/CslyiY4k9dOn5uijtXGd7+jWkaReVpT3Hrhv6d0awEFC07rgD+ZeYYnXprhwigUAvjj0zbjxQCLebozT7iDzK1ZUWCru2K7L//6MVC8ue45Blz8n6rlQ815QtuohOlXiEdy/AUqPa6y59Mkh6Q1345GNja6m7pHEQKNl3t0704EXat4L6fSOmOeEI1vHKzwAyNJR9MPFpRUPOu0ONm2A0xatWaTLm5WfDrzvAppA8AbiG03fC8CQNkDKZK2YrPAuRrhpifJERsuYywveJc7CqcIDMAyeLm82dEXzw39I/qjXkpr3QuW9lxfAdOABGAKPslWDnbsy7Jl8BxTeM3SqmO0gaA5U6c3jymup0YSn9JyLee67wpTfBQAQjmyF3HFqiJcRtDECjy5dAmbmcgQPvjjxl3Lx4IVjnD/5cE1zkWtyP34VBGcdKLJnLgc9cznk1kMXFdzEn8KJ4KUqqsSHvcxWDf7j1UM8UPr6/YgHhhX8xAaYaXgAIB7fBnbuSrBzV8aNgarEQ/z6/YkLcDTg9V9XlXjQtuqoU1TpcUHlvZDOfDiuyh5qPMCLrJ1bDw3EuUtx81N/BH3pjQBJQ2HMF5V6iKfeRchVm9kkMtrwxmSdobeA9daBde8GwVlBcFYofS1Jw0vaAy9HeJHQwBUPzIBvGxDc92Rmp/BowJs10wkAONfsBs8HAAAltqngOAO8HZ3o6OiMqcvLy4E1Lwc8H8C5ZndMXdLJa/qNacNLCDBw/O8nFUNWxp/64+tWAwBefe1tHKg7CgC4/9d3ori4EHv3HcDrb26PqVt2602ovvaHaGlpw+8ffSamLqXYmya8jG8mpFy6iGLkWLh4HAwG4+r6j4VBfaPpLgU8IMGO9MLqW2pYQ9aQokuR5dgXIwCC1CUcNMj3hpdvLAdSF54EYpCHooRA0Swomo2pC0kCQpIAkqTA6LmYupgxL0X7m78+aG10NXVkpIwxsAwWXncDCESHLkohfPbpbiT6ZFPPZQ9fC0e58Wi6wTDj6UbT/rQAyiERS2pW4Kc3LQDLRO8miCEAKj7d83FcTxyLJJJJ+9MCqKoq9HomMrgkSThxsgEcZ8AMpwMkSYJlKDA0DVUFiHGWRDJp/4jXwqIo4uFHnkZXdw8AYGbZFXhs3WqQJDkhkkim7E8KoMlkxKbnn8DBunrwUli3e8/+yOAA0HjmHDq7upGXm5PUoDUr7hmWRB5Zt3FYwoime+vtd/H6G9uGJIxouniSyP6H7v8FystnY80jGzIA0MihsMAKu20aTp3JzFb6WCWRuDUvHwByw8cOhw2FBVaYjNzIAba1e3Hfb9aiq7MTNStuBwAsvr4KO3d9GnmKztIS5EyxTJiVSDT7p04tipx/9MnnYc7ORlu7NzMxsK3di5AkDHgGw2DTC+uHBeGJshJJZL/fxyMQEDKbRAiCQDAoQhBDYBkKNE2j4uqrhpUBoiSBIMZfEhkN+1NeiWSqEB2rlUg69md0JRIQRHy86z8jXsqNVRLJlP0jqgNJXXgAgjbCcONmCHUvQ+44NWG2s/rtH5Mt/ciToo0wLH4JBGO6LLazRiJk2vBYy4gHHw/bWSN+LZBKEhkMjzn/CaSiKgQOvJDyFB7L7axUJWNJZDA8IhQA1boPin7KZbMSGfUYyFx9b3hXg/cCsoBA2Z0AoYOaxlcC4+mdyCUDKBzanLFBJ3USyaRMuiSSKZmUSSSTMimTCABUlblRU9kAZ0E39p+eii21c+EL0jHbOwu6sfaWgyjND//U4oP6MmzZnfi79XT7mfQSNi7bh0JzOLG19XBY/89r49pYVebGqhuOosDsh1+gsWV3BXYdd2Q+BlaVuXFv9bHgkSbzk+vfcVRyjHhi47J9cftsXLYf7T36Ix8cLHlo6ydlv6qpPI2qssRZcuOy/Wjp4k5s+2zG+offKqtcUt6kJtNv7S0H0RtkvEufXTB/6bML5je2Wy7UVDbEbF9o9mPDsv2oP5v75vbPS26rP5u3fdXiozDppcwDrKlswOlWy9E//DX09Mt/azh8zzNM1RybF86C7pheVGD240CDeX3NWtfml94Rt+0+Mf3Lm8qbEnpfgdmPs+3G9+564vTT//pM/GrHYduWRP0AYOEMN/5S61xT92Vtfd2XtfWb/vu91fHALyxzw9tnkB/cTD5w+2Ou9375HHtfa7exM5mxRpKFaafdQQKgAcDERs98/foLHrXdaXfoABi8vczhWO2/28/TRR5z2h00gKymNl1ton79oigq6bQ7dE67Q+ew9mb1h4FYYwVESgLAXLSRa+3mWpIdK+UYuPiq89f8+XfT/+ftZQ4vLm9ZmUyfdcsv1M2fWfRaUCK8i8vdK1u6ktuAWPWTsztm24o/cnnYHUsrWzd1+fVJ9XtqxbG3XzFdNcPTawjcueibpxK1t+X26f/9R8a953jub4typOvm2b1XnvUmv8JKWMZcaZffX3XDERRP8cGaFRjWxtPLoZvXY4oxgPBNEsgxBhCUKEzL6Ru+JydS8Ak0giKFgESDJFQoKmCgQzAwIfQEWETzmoBIwd2VNaStu8uEHGO4Buz06zHHFv0dRkefAZ1+PQx0KNK2eIoPLCUj2zDc275qzgcBFWv+cf3IyxgTK2KOzQufEM5kfpGF12eGPSf8DXN+No/87HDWiwYYALw+M6ym8AscAxO++X7xCTRM7EDQzht0Da8v/NWo1dQDAxNCocUXs+303IGHdaptOmYXnh/SLlZbV+fwnwJm6UXEm/ojqgM/PFmJQ81OPHfrtqT7bN23BE8seTflYLvz5DwYGQHLKz5Puo/XZ8aLtT+D1dSDuxbsGQIymmz48DbwIguOESJOcce8XaO3oVpZ8k3Em5KVVAAMFnuOB9as1MbimCBunn04vBmR40ls29Wfgxf1KMn1gBdY+MXUCvK4ANvPndpLzrLzALjBN2VPwrDBksgLYkn1jBMp90nVY2++8vAw3RlPeLNYVZSPAEgjKWP6ZCn4lF+gMdnE08spQb73RQB9aXtgo6tJcNodf8rWz3L//Br340UW3sExEkXrFFKSSUVHqkRfkJZ8QSZk5gS6hw9H+GyDQAclSs41BVmSUIn+toAKIUTJskKoQUknCxKlkISKb/sM0NMyyVAhXW+AlYosfgOgQlUJVadTSUWBKoQoudvPioPbenq5oIUTaRUqenhWKi3oyVIUqKpKREoLggDhF6hQb4CV9LRM9rctMPN6glChp2SdTqeSskwoAECSKnG61fzFR/XsGu+FhmONriYl7TImsjoYKJyZSeB8CoBQo6spqU8TCO1fgE7gDVUNoCYaQA2gBlADqAHURAOoAdQAagA10QCOgfwfNp/hXbfBMCAAAAAASUVORK5CYII=";
/**
 * Enum for micro:bit BLE command protocol.
 * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md
 * @readonly
 * @enum {number}
 */

const BLECommand = {
  CMD_PIN_CONFIG: 0x80,
  CMD_DISPLAY_TEXT: 0x81,
  CMD_DISPLAY_LED: 0x82
};
/**
 * A time interval to wait (in milliseconds) before reporting to the BLE socket
 * that data has stopped coming from the peripheral.
 */

const BLETimeout = 4500;
/**
 * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
 * @type {number}
 */

const BLESendInterval = 100;
/**
 * A string to report to the BLE socket when the micro:bit has stopped receiving data.
 * @type {string}
 */

const BLEDataStoppedError = "micro:bit extension stopped receiving data";
/**
 * Enum for micro:bit protocol.
 * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md
 * @readonly
 * @enum {string}
 */

const BLEUUID = {
  service: 0xf005,
  rxChar: "5261da01-fa7e-42ab-850b-7c80220097cc",
  txChar: "5261da02-fa7e-42ab-850b-7c80220097cc"
};
/**
 * Manage communication with a MicroBit peripheral over a Scrath Link client socket.
 */

class MicroBit {
  /**
   * Construct a MicroBit communication object.
   * @param {Runtime} runtime - the Scratch 3.0 runtime
   * @param {string} extensionId - the id of the extension
   */
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;
    /**
     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */

    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      buttonA: 0,
      buttonB: 0,
      touchPins: [0, 0, 0],
      gestureState: 0,
      ledMatrixState: new Uint8Array(5)
    };
    /**
     * The most recently received value for each gesture.
     * @type {Object.<string, Object>}
     * @private
     */

    this._gestures = {
      moving: false,
      move: {
        active: false,
        timeout: false
      },
      shake: {
        active: false,
        timeout: false
      },
      jump: {
        active: false,
        timeout: false
      }
    };
    /**
     * Interval ID for data reading timeout.
     * @type {number}
     * @private
     */

    this._timeoutID = null;
    /**
     * A flag that is true while we are busy sending data to the BLE socket.
     * @type {boolean}
     * @private
     */

    this._busy = false;
    /**
     * ID for a timeout which is used to clear the busy flag if it has been
     * true for a long time.
     */

    this._busyTimeoutID = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
  }
  /**
   * @param {string} text - the text to display.
   * @return {Promise} - a Promise that resolves when writing to peripheral.
   */


  displayText(text) {
    const output = new Uint8Array(text.length);

    for (let i = 0; i < text.length; i++) {
      output[i] = text.charCodeAt(i);
    }

    return this.send(BLECommand.CMD_DISPLAY_TEXT, output);
  }
  /**
   * @param {Uint8Array} matrix - the matrix to display.
   * @return {Promise} - a Promise that resolves when writing to peripheral.
   */


  displayMatrix(matrix) {
    return this.send(BLECommand.CMD_DISPLAY_LED, matrix);
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */


  get tiltX() {
    return this._sensors.tiltX;
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */


  get tiltY() {
    return this._sensors.tiltY;
  }
  /**
   * @return {boolean} - the latest value received for the A button.
   */


  get buttonA() {
    return this._sensors.buttonA;
  }
  /**
   * @return {boolean} - the latest value received for the B button.
   */


  get buttonB() {
    return this._sensors.buttonB;
  }
  /**
   * @return {number} - the latest value received for the motion gesture states.
   */


  get gestureState() {
    return this._sensors.gestureState;
  }
  /**
   * @return {Uint8Array} - the current state of the 5x5 LED matrix.
   */


  get ledMatrixState() {
    return this._sensors.ledMatrixState;
  }
  /**
   * Called by the runtime when user wants to scan for a peripheral.
   */


  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BLEUUID.service]
      }]
    }, this._onConnect, this.reset);
  }
  /**
   * Called by the runtime when user wants to connect to a certain peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }
  /**
   * Disconnect from the micro:bit.
   */


  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    if (this._timeoutID) {
      window.clearTimeout(this._timeoutID);
      this._timeoutID = null;
    }
  }
  /**
   * Return true if connected to the micro:bit.
   * @return {boolean} - whether the micro:bit is connected.
   */


  isConnected() {
    let connected = false;

    if (this._ble) {
      connected = this._ble.isConnected();
    }

    return connected;
  }
  /**
   * Send a message to the peripheral BLE socket.
   * @param {number} command - the BLE command hex.
   * @param {Uint8Array} message - the message to write
   */


  send(command, message) {
    if (!this.isConnected()) return;
    if (this._busy) return; // Set a busy flag so that while we are sending a message and waiting for
    // the response, additional messages are ignored.

    this._busy = true; // Set a timeout after which to reset the busy flag. This is used in case
    // a BLE message was sent for which we never received a response, because
    // e.g. the peripheral was turned off after the message was sent. We reset
    // the busy flag after a while so that it is possible to try again later.

    this._busyTimeoutID = window.setTimeout(() => {
      this._busy = false;
    }, 5000);
    const output = new Uint8Array(message.length + 1);
    output[0] = command; // attach command to beginning of message

    for (let i = 0; i < message.length; i++) {
      output[i + 1] = message[i];
    }

    const data = Utility.uint8ArrayToBase64(output);

    this._ble.write(BLEUUID.service, BLEUUID.txChar, data, "base64", true).then(() => {
      this._busy = false;
      window.clearTimeout(this._busyTimeoutID);
    });
  }
  /**
   * Starts reading data from peripheral after BLE has connected to it.
   * @private
   */


  _onConnect() {
    this._ble.read(BLEUUID.service, BLEUUID.rxChar, true, this._onMessage);

    this._timeoutID = window.setTimeout(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
  }
  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */


  _onMessage(base64) {
    // parse data
    const data = Utility.base64ToUint8Array(base64);
    this._sensors.tiltX = data[1] | data[0] << 8;
    if (this._sensors.tiltX > 1 << 15) this._sensors.tiltX -= 1 << 16;
    this._sensors.tiltY = data[3] | data[2] << 8;
    if (this._sensors.tiltY > 1 << 15) this._sensors.tiltY -= 1 << 16;
    this._sensors.buttonA = data[4];
    this._sensors.buttonB = data[5];
    this._sensors.touchPins[0] = data[6];
    this._sensors.touchPins[1] = data[7];
    this._sensors.touchPins[2] = data[8];
    this._sensors.gestureState = data[9]; // cancel disconnect timeout and start a new one

    window.clearTimeout(this._timeoutID);
    this._timeoutID = window.setTimeout(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
  }
  /**
   * @param {number} pin - the pin to check touch state.
   * @return {number} - the latest value received for the touch pin states.
   * @private
   */


  _checkPinState(pin) {
    return this._sensors.touchPins[pin];
  }

}
/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */


const MicroBitTiltDirection = {
  FRONT: "front",
  BACK: "back",
  LEFT: "left",
  RIGHT: "right",
  ANY: "any"
};
/**
 * Enum for micro:bit gestures.
 * @readonly
 * @enum {string}
 */

const MicroBitGestures = {
  MOVED: "moved",
  SHAKEN: "shaken",
  JUMPED: "jumped"
};
/**
 * Enum for micro:bit buttons.
 * @readonly
 * @enum {string}
 */

const MicroBitButtons = {
  A: "A",
  B: "B",
  ANY: "any"
};
/**
 * Enum for micro:bit pin states.
 * @readonly
 * @enum {string}
 */

const MicroBitPinState = {
  ON: "on",
  OFF: "off"
};
/**
 * Scratch 3.0 blocks to interact with a MicroBit peripheral.
 */

class Scratch3MicroBitBlocks {
  /**
   * @return {string} - the name of this extension.
   */
  static get EXTENSION_NAME() {
    return "micro:bit";
  }
  /**
   * @return {string} - the ID of this extension.
   */


  static get EXTENSION_ID() {
    return "microbit";
  }
  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */


  static get TILT_THRESHOLD() {
    return 15;
  }
  /**
   * @return {array} - text and values for each buttons menu element
   */


  get BUTTONS_MENU() {
    return [{
      text: "A",
      value: MicroBitButtons.A
    }, {
      text: "B",
      value: MicroBitButtons.B
    }, {
      text: formatMessage({
        id: "microbit.buttonsMenu.any",
        default: "any",
        description: 'label for "any" element in button picker for micro:bit extension'
      }),
      value: MicroBitButtons.ANY
    }];
  }
  /**
   * @return {array} - text and values for each gestures menu element
   */


  get GESTURES_MENU() {
    return [{
      text: formatMessage({
        id: "microbit.gesturesMenu.moved",
        default: "moved",
        description: "label for moved gesture in gesture picker for micro:bit extension"
      }),
      value: MicroBitGestures.MOVED
    }, {
      text: formatMessage({
        id: "microbit.gesturesMenu.shaken",
        default: "shaken",
        description: "label for shaken gesture in gesture picker for micro:bit extension"
      }),
      value: MicroBitGestures.SHAKEN
    }, {
      text: formatMessage({
        id: "microbit.gesturesMenu.jumped",
        default: "jumped",
        description: "label for jumped gesture in gesture picker for micro:bit extension"
      }),
      value: MicroBitGestures.JUMPED
    }];
  }
  /**
   * @return {array} - text and values for each pin state menu element
   */


  get PIN_STATE_MENU() {
    return [{
      text: formatMessage({
        id: "microbit.pinStateMenu.on",
        default: "on",
        description: "label for on element in pin state picker for micro:bit extension"
      }),
      value: MicroBitPinState.ON
    }, {
      text: formatMessage({
        id: "microbit.pinStateMenu.off",
        default: "off",
        description: "label for off element in pin state picker for micro:bit extension"
      }),
      value: MicroBitPinState.OFF
    }];
  }
  /**
   * @return {array} - text and values for each tilt direction menu element
   */


  get TILT_DIRECTION_MENU() {
    return [{
      text: formatMessage({
        id: "microbit.tiltDirectionMenu.front",
        default: "front",
        description: "label for front element in tilt direction picker for micro:bit extension"
      }),
      value: MicroBitTiltDirection.FRONT
    }, {
      text: formatMessage({
        id: "microbit.tiltDirectionMenu.back",
        default: "back",
        description: "label for back element in tilt direction picker for micro:bit extension"
      }),
      value: MicroBitTiltDirection.BACK
    }, {
      text: formatMessage({
        id: "microbit.tiltDirectionMenu.left",
        default: "left",
        description: "label for left element in tilt direction picker for micro:bit extension"
      }),
      value: MicroBitTiltDirection.LEFT
    }, {
      text: formatMessage({
        id: "microbit.tiltDirectionMenu.right",
        default: "right",
        description: "label for right element in tilt direction picker for micro:bit extension"
      }),
      value: MicroBitTiltDirection.RIGHT
    }];
  }
  /**
   * @return {array} - text and values for each tilt direction (plus "any") menu element
   */


  get TILT_DIRECTION_ANY_MENU() {
    return [...this.TILT_DIRECTION_MENU, {
      text: formatMessage({
        id: "microbit.tiltDirectionMenu.any",
        default: "any",
        description: "label for any direction element in tilt direction picker for micro:bit extension"
      }),
      value: MicroBitTiltDirection.ANY
    }];
  }
  /**
   * Construct a set of MicroBit blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new MicroBit peripheral instance

    this._peripheral = new MicroBit(this.runtime, Scratch3MicroBitBlocks.EXTENSION_ID);
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: Scratch3MicroBitBlocks.EXTENSION_ID,
      name: Scratch3MicroBitBlocks.EXTENSION_NAME,
      blockIconURI: blockIconURI,
      showStatusButton: true,
      blocks: [{
        opcode: "whenButtonPressed",
        text: formatMessage({
          id: "microbit.whenButtonPressed",
          default: "when [BTN] button pressed",
          description: "when the selected button on the micro:bit is pressed"
        }),
        blockType: BlockType.HAT,
        arguments: {
          BTN: {
            type: ArgumentType.STRING,
            menu: "buttons",
            defaultValue: MicroBitButtons.A
          }
        }
      }, {
        opcode: "isButtonPressed",
        text: formatMessage({
          id: "microbit.isButtonPressed",
          default: "[BTN] button pressed?",
          description: "is the selected button on the micro:bit pressed?"
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          BTN: {
            type: ArgumentType.STRING,
            menu: "buttons",
            defaultValue: MicroBitButtons.A
          }
        }
      }, "---", {
        opcode: "whenGesture",
        text: formatMessage({
          id: "microbit.whenGesture",
          default: "when [GESTURE]",
          description: "when the selected gesture is detected by the micro:bit"
        }),
        blockType: BlockType.HAT,
        arguments: {
          GESTURE: {
            type: ArgumentType.STRING,
            menu: "gestures",
            defaultValue: MicroBitGestures.MOVED
          }
        }
      }, "---", {
        opcode: "displaySymbol",
        text: formatMessage({
          id: "microbit.displaySymbol",
          default: "display [MATRIX]",
          description: "display a pattern on the micro:bit display"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MATRIX: {
            type: ArgumentType.MATRIX,
            defaultValue: "0101010101100010101000100"
          }
        }
      }, {
        opcode: "displayText",
        text: formatMessage({
          id: "microbit.displayText",
          default: "display text [TEXT]",
          description: "display text on the micro:bit display"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          TEXT: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: "microbit.defaultTextToDisplay",
              default: "Hello!",
              description: `default text to display.
                                IMPORTANT - the micro:bit only supports letters a-z, A-Z.
                                Please substitute a default word in your language
                                that can be written with those characters,
                                substitute non-accented characters or leave it as "Hello!".
                                Check the micro:bit site documentation for details`
            })
          }
        }
      }, {
        opcode: "displayClear",
        text: formatMessage({
          id: "microbit.clearDisplay",
          default: "clear display",
          description: "display nothing on the micro:bit display"
        }),
        blockType: BlockType.COMMAND
      }, "---", {
        opcode: "whenTilted",
        text: formatMessage({
          id: "microbit.whenTilted",
          default: "when tilted [DIRECTION]",
          description: "when the micro:bit is tilted in a direction"
        }),
        blockType: BlockType.HAT,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: "tiltDirectionAny",
            defaultValue: MicroBitTiltDirection.ANY
          }
        }
      }, {
        opcode: "isTilted",
        text: formatMessage({
          id: "microbit.isTilted",
          default: "tilted [DIRECTION]?",
          description: "is the micro:bit is tilted in a direction?"
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: "tiltDirectionAny",
            defaultValue: MicroBitTiltDirection.ANY
          }
        }
      }, {
        opcode: "getTiltAngle",
        text: formatMessage({
          id: "microbit.tiltAngle",
          default: "tilt angle [DIRECTION]",
          description: "how much the micro:bit is tilted in a direction"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: "tiltDirection",
            defaultValue: MicroBitTiltDirection.FRONT
          }
        }
      }, "---", {
        opcode: "whenPinConnected",
        text: formatMessage({
          id: "microbit.whenPinConnected",
          default: "when pin [PIN] connected",
          description: "when the pin detects a connection to Earth/Ground"
        }),
        blockType: BlockType.HAT,
        arguments: {
          PIN: {
            type: ArgumentType.STRING,
            menu: "touchPins",
            defaultValue: "0"
          }
        }
      }],
      menus: {
        buttons: {
          acceptReporters: true,
          items: this.BUTTONS_MENU
        },
        gestures: {
          acceptReporters: true,
          items: this.GESTURES_MENU
        },
        pinState: {
          acceptReporters: true,
          items: this.PIN_STATE_MENU
        },
        tiltDirection: {
          acceptReporters: true,
          items: this.TILT_DIRECTION_MENU
        },
        tiltDirectionAny: {
          acceptReporters: true,
          items: this.TILT_DIRECTION_ANY_MENU
        },
        touchPins: {
          acceptReporters: true,
          items: ["0", "1", "2"]
        }
      }
    };
  }
  /**
   * Test whether the A or B button is pressed
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the button is pressed.
   */


  whenButtonPressed(args) {
    if (args.BTN === "any") {
      return this._peripheral.buttonA | this._peripheral.buttonB;
    } else if (args.BTN === "A") {
      return this._peripheral.buttonA;
    } else if (args.BTN === "B") {
      return this._peripheral.buttonB;
    }

    return false;
  }
  /**
   * Test whether the A or B button is pressed
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the button is pressed.
   */


  isButtonPressed(args) {
    if (args.BTN === "any") {
      return (this._peripheral.buttonA | this._peripheral.buttonB) !== 0;
    } else if (args.BTN === "A") {
      return this._peripheral.buttonA !== 0;
    } else if (args.BTN === "B") {
      return this._peripheral.buttonB !== 0;
    }

    return false;
  }
  /**
   * Test whether the micro:bit is moving
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the micro:bit is moving.
   */


  whenGesture(args) {
    const gesture = String(args.GESTURE);

    if (gesture === "moved") {
      return this._peripheral.gestureState >> 2 & 1;
    } else if (gesture === "shaken") {
      return this._peripheral.gestureState & 1;
    } else if (gesture === "jumped") {
      return this._peripheral.gestureState >> 1 & 1;
    }

    return false;
  }
  /**
   * Display a predefined symbol on the 5x5 LED matrix.
   * @param {object} args - the block's arguments.
   * @return {Promise} - a Promise that resolves after a tick.
   */


  displaySymbol(args) {
    const symbol = String(args.MATRIX).replace(/\s/g, "");

    const reducer = (accumulator, c, index) => {
      const value = c === "0" ? accumulator : accumulator + Math.pow(2, index);
      return value;
    };

    const hex = symbol.split("").reduce(reducer, 0);

    if (hex !== null) {
      this._peripheral.ledMatrixState[0] = hex & 0x1f;
      this._peripheral.ledMatrixState[1] = hex >> 5 & 0x1f;
      this._peripheral.ledMatrixState[2] = hex >> 10 & 0x1f;
      this._peripheral.ledMatrixState[3] = hex >> 15 & 0x1f;
      this._peripheral.ledMatrixState[4] = hex >> 20 & 0x1f;

      this._peripheral.displayMatrix(this._peripheral.ledMatrixState);
    }

    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Display text on the 5x5 LED matrix.
   * @param {object} args - the block's arguments.
   * @return {Promise} - a Promise that resolves after the text is done printing.
   * Note the limit is 19 characters
   * The print time is calculated by multiplying the number of horizontal pixels
   * by the default scroll delay of 120ms.
   * The number of horizontal pixels = 6px for each character in the string,
   * 1px before the string, and 5px after the string.
   */


  displayText(args) {
    const text = String(args.TEXT).substring(0, 19);
    if (text.length > 0) this._peripheral.displayText(text);
    const yieldDelay = 120 * (6 * text.length + 6);
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, yieldDelay);
    });
  }
  /**
   * Turn all 5x5 matrix LEDs off.
   * @return {Promise} - a Promise that resolves after a tick.
   */


  displayClear() {
    for (let i = 0; i < 5; i++) {
      this._peripheral.ledMatrixState[i] = 0;
    }

    this._peripheral.displayMatrix(this._peripheral.ledMatrixState);

    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  whenTilted(args) {
    return this._isTilted(args.DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  isTilted(args) {
    return this._isTilted(args.DIRECTION);
  }
  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the direction (front, back, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
   */


  getTiltAngle(args) {
    return this._getTiltAngle(args.DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */


  _isTilted(direction) {
    switch (direction) {
      case MicroBitTiltDirection.ANY:
        return Math.abs(this._peripheral.tiltX / 10) >= Scratch3MicroBitBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY / 10) >= Scratch3MicroBitBlocks.TILT_THRESHOLD;

      default:
        return this._getTiltAngle(direction) >= Scratch3MicroBitBlocks.TILT_THRESHOLD;
    }
  }
  /**
   * @param {TiltDirection} direction - the direction (front, back, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */


  _getTiltAngle(direction) {
    switch (direction) {
      case MicroBitTiltDirection.FRONT:
        return Math.round(this._peripheral.tiltY / -10);

      case MicroBitTiltDirection.BACK:
        return Math.round(this._peripheral.tiltY / 10);

      case MicroBitTiltDirection.LEFT:
        return Math.round(this._peripheral.tiltX / -10);

      case MicroBitTiltDirection.RIGHT:
        return Math.round(this._peripheral.tiltX / 10);

      default:
        console.warn(`Unknown tilt direction in _getTiltAngle: ${direction}`);
    }
  }
  /**
   * @param {object} args - the block's arguments.
   * @return {boolean} - the touch pin state.
   * @private
   */


  whenPinConnected(args) {
    const pin = parseInt(args.PIN, 10);
    if (isNaN(pin)) return;
    if (pin < 0 || pin > 2) return false;
    return this._peripheral._checkPinState(pin);
  }

}

module.exports = Scratch3MicroBitBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_text2speech/index.js":
/*!******************************************************!*\
  !*** ./src/extensions/scratch3_text2speech/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const nets = __webpack_require__(/*! nets */ "./node_modules/nets/index.js");

const languageNames = __webpack_require__(/*! scratch-translate-extension-languages */ "./node_modules/scratch-translate-extension-languages/languages.json");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");
/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const menuIconURI = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1RleHQtdG8tU3BlZWNoLU1lbnU8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZyBpZD0iRXh0ZW5zaW9ucy9Tb2Z0d2FyZS9UZXh0LXRvLVNwZWVjaC1NZW51IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0idGV4dDJzcGVlY2giIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIuMDAwMDAwLCAyLjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyI+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik01Ljc1LDguODM0NjcxNzMgQzUuNzUsOC4zMjY5NjM0NCA1LjAwMzAwNzI3LDguMDQyMjEzNzEgNC41NTYyODAxMiw4LjQ0NDE0OTk5IEwzLjIwNjI4MDEyLDkuNTI1MzU3MDIgQzIuNjk2NzMzNzgsOS45MzM0NDk2OCAyLjAzNzQ4Njc1LDEwLjE2NTg3ODggMS4zNSwxMC4xNjU4Nzg4IEwxLjE1LDEwLjE2NTg3ODggQzAuNjMyNTk2MTY1LDEwLjE2NTg3ODggMC4yNSwxMC41MTA2MDAyIDAuMjUsMTAuOTUyMDM1NSBMMC4yNSwxMy4wNjkzOTkzIEMwLjI1LDEzLjUxMDgzNDYgMC42MzI1OTYxNjUsMTMuODU1NTU2IDEuMTUsMTMuODU1NTU2IEwxLjM1LDEzLjg1NTU1NiBDMi4wNzg3Nzg0MSwxMy44NTU1NTYgMi43MjY4NjE2MSwxNC4wNjY3NjM2IDMuMjU5ODYwNDksMTQuNDk5IEw0LjU1OTIwMTQ3LDE1LjU3OTY2MDggQzUuMDEzMDkyNzYsMTUuOTU0NTM5NiA1Ljc1LDE1LjY3MzYzNDQgNS43NSwxNS4xNDE3MTI4IEw1Ljc1LDguODM0NjcxNzMgWiIgaWQ9InNwZWFrZXIiIHN0cm9rZS1vcGFjaXR5PSIwLjE1IiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBmaWxsPSIjNEQ0RDREIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMC43MDQ4MzEzLDggQzkuNzkwNjc0NjgsOS4xMzExNDg0NyA4LjMwNjYxODQsOS43MTQyODU3MSA3LjgzMzMzMzMzLDkuNzE0Mjg1NzEgQzcuODMzMzMzMzMsOS43MTQyODU3MSA3LjUsOS43MTQyODU3MSA3LjUsOS4zODA5NTIzOCBDNy41LDkuMDg1MjI2ODQgOC4wNjIyMDE2OCw4LjkwMTk0MTY0IDguMTg5MDYwNjcsNy41Njc1NDA1OCBDNi44ODk5Njk5MSw2LjkwNjc5MDA1IDYsNS41NTczMjY4MyA2LDQgQzYsMS43OTA4NjEgNy43OTA4NjEsNC4wNTgxMjI1MWUtMTYgMTAsMCBMMTIsMCBDMTQuMjA5MTM5LC00LjA1ODEyMjUxZS0xNiAxNiwxLjc5MDg2MSAxNiw0IEMxNiw2LjIwOTEzOSAxNC4yMDkxMzksOCAxMiw4IEwxMC43MDQ4MzEzLDggWiIgaWQ9InNwZWVjaCIgZmlsbD0iIzBFQkQ4QyI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+";
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const blockIconURI = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1RleHQtdG8tU3BlZWNoLUJsb2NrPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IkV4dGVuc2lvbnMvU29mdHdhcmUvVGV4dC10by1TcGVlY2gtQmxvY2siIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1vcGFjaXR5PSIwLjE1Ij4KICAgICAgICA8ZyBpZD0idGV4dDJzcGVlY2giIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQuMDAwMDAwLCA0LjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyIgc3Ryb2tlPSIjMDAwMDAwIj4KICAgICAgICAgICAgPHBhdGggZD0iTTExLjUsMTcuNjY5MzQzNSBDMTEuNSwxNi42NTM5MjY5IDEwLjAwNjAxNDUsMTYuMDg0NDI3NCA5LjExMjU2MDI0LDE2Ljg4ODMgTDYuNDEyNTYwMjQsMTkuMDUwNzE0IEM1LjM5MzQ2NzU1LDE5Ljg2Njg5OTQgNC4wNzQ5NzM1MSwyMC4zMzE3NTc1IDIuNywyMC4zMzE3NTc1IEwyLjMsMjAuMzMxNzU3NSBDMS4yNjUxOTIzMywyMC4zMzE3NTc1IDAuNSwyMS4wMjEyMDAzIDAuNSwyMS45MDQwNzEgTDAuNSwyNi4xMzg3OTg2IEMwLjUsMjcuMDIxNjY5MyAxLjI2NTE5MjMzLDI3LjcxMTExMiAyLjMsMjcuNzExMTEyIEwyLjcsMjcuNzExMTEyIEM0LjE1NzU1NjgyLDI3LjcxMTExMiA1LjQ1MzcyMzIyLDI4LjEzMzUyNzEgNi41MTk3MjA5OCwyOC45OTggTDkuMTE4NDAyOTMsMzEuMTU5MzIxNiBDMTAuMDI2MTg1NSwzMS45MDkwNzkzIDExLjUsMzEuMzQ3MjY4OSAxMS41LDMwLjI4MzQyNTUgTDExLjUsMTcuNjY5MzQzNSBaIiBpZD0ic3BlYWtlciIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMjEuNjQzNjA2NiwxNi41IEMxOS45NzcwMDk5LDE4LjQzNzAyMzQgMTcuMTA1MDI3NSwxOS45Mjg1NzE0IDE1LjY2NjY2NjcsMTkuOTI4NTcxNCBDMTUuNTEyNjM5NywxOS45Mjg1NzE0IDE1LjMxNjYyOTIsMTkuODk1OTAzIDE1LjEwOTcyNjUsMTkuNzkyNDUxNyBDMTQuNzM3NjAzOSwxOS42MDYzOTA0IDE0LjUsMTkuMjQ5OTg0NiAxNC41LDE4Ljc2MTkwNDggQzE0LjUsMTguNjU2ODA0MSAxNC41MTcwNTU1LDE4LjU1NDUwNzYgMTQuNTQ5NDQ2NywxOC40NTQwODQ0IEMxNC42MjU3NTQ1LDE4LjIxNzUwNjMgMTUuMTczNTcyMSwxNy40Njc1MzEgMTUuMjc3MjA3MSwxNy4yODA5ODgxIEMxNS41NDYzNTI2LDE2Ljc5NjUyNjEgMTUuNzM5MDI1LDE2LjIwNjM1NjEgMTUuODQzMjg5MSwxNS40MTYwMDM0IEMxMy4xODk3MDA1LDEzLjkyNjgzNjkgMTEuNSwxMS4xMTM5NjY4IDExLjUsOCBDMTEuNSwzLjMwNTU3OTYzIDE1LjMwNTU3OTYsLTAuNSAyMCwtMC41IEwyNCwtMC41IEMyOC42OTQ0MjA0LC0wLjUgMzIuNSwzLjMwNTU3OTYzIDMyLjUsOCBDMzIuNSwxMi42OTQ0MjA0IDI4LjY5NDQyMDQsMTYuNSAyNCwxNi41IEwyMS42NDM2MDY2LDE2LjUgWiIgaWQ9InNwZWVjaCIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+";
/**
 * The url of the synthesis server.
 * @type {string}
 */

const SERVER_HOST = "https://synthesis-service.scratch.mit.edu";
/**
 * How long to wait in ms before timing out requests to synthesis server.
 * @type {int}
 */

const SERVER_TIMEOUT = 10000; // 10 seconds

/**
 * Volume for playback of speech sounds, as a percentage.
 * @type {number}
 */

const SPEECH_VOLUME = 250;
/**
 * An id for one of the voices.
 */

const ALTO_ID = "ALTO";
/**
 * An id for one of the voices.
 */

const TENOR_ID = "TENOR";
/**
 * An id for one of the voices.
 */

const SQUEAK_ID = "SQUEAK";
/**
 * An id for one of the voices.
 */

const GIANT_ID = "GIANT";
/**
 * An id for one of the voices.
 */

const KITTEN_ID = "KITTEN";
/**
 * Playback rate for the tenor voice, for cases where we have only a female gender voice.
 */

const FEMALE_TENOR_RATE = 0.89; // -2 semitones

/**
 * Playback rate for the giant voice, for cases where we have only a female gender voice.
 */

const FEMALE_GIANT_RATE = 0.79; // -4 semitones

/**
 * Language ids. The value for each language id is a valid Scratch locale.
 */

const ARABIC_ID = "ar";
const CHINESE_ID = "zh-cn";
const DANISH_ID = "da";
const DUTCH_ID = "nl";
const ENGLISH_ID = "en";
const FRENCH_ID = "fr";
const GERMAN_ID = "de";
const HINDI_ID = "hi";
const ICELANDIC_ID = "is";
const ITALIAN_ID = "it";
const JAPANESE_ID = "ja";
const KOREAN_ID = "ko";
const NORWEGIAN_ID = "nb";
const POLISH_ID = "pl";
const PORTUGUESE_BR_ID = "pt-br";
const PORTUGUESE_ID = "pt";
const ROMANIAN_ID = "ro";
const RUSSIAN_ID = "ru";
const SPANISH_ID = "es";
const SPANISH_419_ID = "es-419";
const SWEDISH_ID = "sv";
const TURKISH_ID = "tr";
const WELSH_ID = "cy";
/**
 * Class for the text2speech blocks.
 * @constructor
 */

class Scratch3Text2SpeechBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * Map of soundPlayers by sound id.
     * @type {Map<string, SoundPlayer>}
     */

    this._soundPlayers = new Map();
    this._stopAllSpeech = this._stopAllSpeech.bind(this);

    if (this.runtime) {
      this.runtime.on("PROJECT_STOP_ALL", this._stopAllSpeech);
    }

    this._onTargetCreated = this._onTargetCreated.bind(this);

    if (this.runtime) {
      runtime.on("targetWasCreated", this._onTargetCreated);
    }
    /**
     * A list of all Scratch locales that are supported by the extension.
     * @type {Array}
     */


    this._supportedLocales = this._getSupportedLocales();
  }
  /**
   * An object with info for each voice.
   */


  get VOICE_INFO() {
    return {
      [ALTO_ID]: {
        name: formatMessage({
          id: "text2speech.alto",
          default: "alto",
          description: "Name for a voice with ambiguous gender."
        }),
        gender: "female",
        playbackRate: 1
      },
      [TENOR_ID]: {
        name: formatMessage({
          id: "text2speech.tenor",
          default: "tenor",
          description: "Name for a voice with ambiguous gender."
        }),
        gender: "male",
        playbackRate: 1
      },
      [SQUEAK_ID]: {
        name: formatMessage({
          id: "text2speech.squeak",
          default: "squeak",
          description: "Name for a funny voice with a high pitch."
        }),
        gender: "female",
        playbackRate: 1.19 // +3 semitones

      },
      [GIANT_ID]: {
        name: formatMessage({
          id: "text2speech.giant",
          default: "giant",
          description: "Name for a funny voice with a low pitch."
        }),
        gender: "male",
        playbackRate: 0.84 // -3 semitones

      },
      [KITTEN_ID]: {
        name: formatMessage({
          id: "text2speech.kitten",
          default: "kitten",
          description: "A baby cat."
        }),
        gender: "female",
        playbackRate: 1.41 // +6 semitones

      }
    };
  }
  /**
   * An object with information for each language.
   *
   * A note on the different sets of locales referred to in this extension:
   *
   * SCRATCH LOCALE
   *      Set by the editor, and used to store the language state in the project.
   *      Listed in l10n: https://github.com/LLK/scratch-l10n/blob/master/src/supported-locales.js
   * SUPPORTED LOCALE
   *      A Scratch locale that has a corresponding extension locale.
   * EXTENSION LOCALE
   *      A locale corresponding to one of the available spoken languages
   *      in the extension. There can be multiple supported locales for a single
   *      extension locale. For example, for both written versions of chinese,
   *      zh-cn and zh-tw, we use a single spoken language (Mandarin). So there
   *      are two supported locales, with a single extension locale.
   * SPEECH SYNTH LOCALE
   *      A different locale code system, used by our speech synthesis service.
   *      Each extension locale has a speech synth locale.
   */


  get LANGUAGE_INFO() {
    return {
      [ARABIC_ID]: {
        name: "Arabic",
        locales: ["ar"],
        speechSynthLocale: "arb",
        singleGender: true
      },
      [CHINESE_ID]: {
        name: "Chinese (Mandarin)",
        locales: ["zh-cn", "zh-tw"],
        speechSynthLocale: "cmn-CN",
        singleGender: true
      },
      [DANISH_ID]: {
        name: "Danish",
        locales: ["da"],
        speechSynthLocale: "da-DK"
      },
      [DUTCH_ID]: {
        name: "Dutch",
        locales: ["nl"],
        speechSynthLocale: "nl-NL"
      },
      [ENGLISH_ID]: {
        name: "English",
        locales: ["en"],
        speechSynthLocale: "en-US"
      },
      [FRENCH_ID]: {
        name: "French",
        locales: ["fr"],
        speechSynthLocale: "fr-FR"
      },
      [GERMAN_ID]: {
        name: "German",
        locales: ["de"],
        speechSynthLocale: "de-DE"
      },
      [HINDI_ID]: {
        name: "Hindi",
        locales: ["hi"],
        speechSynthLocale: "hi-IN",
        singleGender: true
      },
      [ICELANDIC_ID]: {
        name: "Icelandic",
        locales: ["is"],
        speechSynthLocale: "is-IS"
      },
      [ITALIAN_ID]: {
        name: "Italian",
        locales: ["it"],
        speechSynthLocale: "it-IT"
      },
      [JAPANESE_ID]: {
        name: "Japanese",
        locales: ["ja", "ja-hira"],
        speechSynthLocale: "ja-JP"
      },
      [KOREAN_ID]: {
        name: "Korean",
        locales: ["ko"],
        speechSynthLocale: "ko-KR",
        singleGender: true
      },
      [NORWEGIAN_ID]: {
        name: "Norwegian",
        locales: ["nb", "nn"],
        speechSynthLocale: "nb-NO",
        singleGender: true
      },
      [POLISH_ID]: {
        name: "Polish",
        locales: ["pl"],
        speechSynthLocale: "pl-PL"
      },
      [PORTUGUESE_BR_ID]: {
        name: "Portuguese (Brazilian)",
        locales: ["pt-br"],
        speechSynthLocale: "pt-BR"
      },
      [PORTUGUESE_ID]: {
        name: "Portuguese (European)",
        locales: ["pt"],
        speechSynthLocale: "pt-PT"
      },
      [ROMANIAN_ID]: {
        name: "Romanian",
        locales: ["ro"],
        speechSynthLocale: "ro-RO",
        singleGender: true
      },
      [RUSSIAN_ID]: {
        name: "Russian",
        locales: ["ru"],
        speechSynthLocale: "ru-RU"
      },
      [SPANISH_ID]: {
        name: "Spanish (European)",
        locales: ["es"],
        speechSynthLocale: "es-ES"
      },
      [SPANISH_419_ID]: {
        name: "Spanish (Latin American)",
        locales: ["es-419"],
        speechSynthLocale: "es-US"
      },
      [SWEDISH_ID]: {
        name: "Swedish",
        locales: ["sv"],
        speechSynthLocale: "sv-SE",
        singleGender: true
      },
      [TURKISH_ID]: {
        name: "Turkish",
        locales: ["tr"],
        speechSynthLocale: "tr-TR",
        singleGender: true
      },
      [WELSH_ID]: {
        name: "Welsh",
        locales: ["cy"],
        speechSynthLocale: "cy-GB",
        singleGender: true
      }
    };
  }
  /**
   * The key to load & store a target's text2speech state.
   * @return {string} The key.
   */


  static get STATE_KEY() {
    return "Scratch.text2speech";
  }
  /**
   * The default state, to be used when a target has no existing state.
   * @type {Text2SpeechState}
   */


  static get DEFAULT_TEXT2SPEECH_STATE() {
    return {
      voiceId: ALTO_ID
    };
  }
  /**
   * A default language to use for speech synthesis.
   * @type {string}
   */


  get DEFAULT_LANGUAGE() {
    return ENGLISH_ID;
  }
  /**
   * @param {Target} target - collect  state for this target.
   * @returns {Text2SpeechState} the mutable state associated with that target. This will be created if necessary.
   * @private
   */


  _getState(target) {
    let state = target.getCustomState(Scratch3Text2SpeechBlocks.STATE_KEY);

    if (!state) {
      state = Utility.cloneSimple(Scratch3Text2SpeechBlocks.DEFAULT_TEXT2SPEECH_STATE);
      target.setCustomState(Scratch3Text2SpeechBlocks.STATE_KEY, state);
    }

    return state;
  }
  /**
   * When a Target is cloned, clone the state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const state = sourceTarget.getCustomState(Scratch3Text2SpeechBlocks.STATE_KEY);

      if (state) {
        newTarget.setCustomState(Scratch3Text2SpeechBlocks.STATE_KEY, Utility.cloneSimple(state));
      }
    }
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    // Only localize the default input to the "speak" block if we are in a
    // supported language.
    let defaultTextToSpeak = "hello";

    if (this.isSupportedLanguage(this.getEditorLanguage())) {
      defaultTextToSpeak = formatMessage({
        id: "text2speech.defaultTextToSpeak",
        default: "hello",
        description: "hello: the default text to speak"
      });
    }

    return {
      id: "text2speech",
      name: formatMessage({
        id: "text2speech.categoryName",
        default: "Text to Speech",
        description: "Name of the Text to Speech extension."
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        opcode: "speakAndWait",
        text: formatMessage({
          id: "text2speech.speakAndWaitBlock",
          default: "speak [WORDS]",
          description: "Speak some words."
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          WORDS: {
            type: ArgumentType.STRING,
            defaultValue: defaultTextToSpeak
          }
        }
      }, {
        opcode: "setVoice",
        text: formatMessage({
          id: "text2speech.setVoiceBlock",
          default: "set voice to [VOICE]",
          description: "Set the voice for speech synthesis."
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          VOICE: {
            type: ArgumentType.STRING,
            menu: "voices",
            defaultValue: ALTO_ID
          }
        }
      }, {
        opcode: "setLanguage",
        text: formatMessage({
          id: "text2speech.setLanguageBlock",
          default: "set language to [LANGUAGE]",
          description: "Set the language for speech synthesis."
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          LANGUAGE: {
            type: ArgumentType.STRING,
            menu: "languages",
            defaultValue: this.getCurrentLanguage()
          }
        }
      }],
      menus: {
        voices: {
          acceptReporters: true,
          items: this.getVoiceMenu()
        },
        languages: {
          acceptReporters: true,
          items: this.getLanguageMenu()
        }
      }
    };
  }
  /**
   * Get the language code currently set in the editor, or fall back to the
   * browser locale.
   * @return {string} a Scratch locale code.
   */


  getEditorLanguage() {
    const locale = formatMessage.setup().locale || navigator.language || navigator.userLanguage || this.DEFAULT_LANGUAGE;
    return locale.toLowerCase();
  }
  /**
   * Get the language code currently set for the extension.
   * @returns {string} a Scratch locale code.
   */


  getCurrentLanguage() {
    const stage = this.runtime.getTargetForStage();
    if (!stage) return this.DEFAULT_LANGUAGE; // If no language has been set, set it to the editor locale (or default).

    if (!stage.textToSpeechLanguage) {
      this.setCurrentLanguage(this.getEditorLanguage());
    }

    return stage.textToSpeechLanguage;
  }
  /**
   * Set the language code for the extension.
   * It is stored in the stage so it can be saved and loaded with the project.
   * @param {string} locale a locale code.
   */


  setCurrentLanguage(locale) {
    const stage = this.runtime.getTargetForStage();
    if (!stage) return;

    if (this.isSupportedLanguage(locale)) {
      stage.textToSpeechLanguage = this._getExtensionLocaleForSupportedLocale(locale);
    } // Support language names dropped onto the menu via reporter block
    // such as a variable containing a language name (in any language),
    // or the translate extension's language reporter.


    const localeForDroppedName = languageNames.nameMap[locale.toLowerCase()];

    if (localeForDroppedName && this.isSupportedLanguage(localeForDroppedName)) {
      stage.textToSpeechLanguage = this._getExtensionLocaleForSupportedLocale(localeForDroppedName);
    } // If the language is null, set it to the default language.
    // This can occur e.g. if the extension was loaded with the editor
    // set to a language that is not in the list.


    if (!stage.textToSpeechLanguage) {
      stage.textToSpeechLanguage = this.DEFAULT_LANGUAGE;
    }
  }
  /**
   * Get the extension locale for a supported locale, or null.
   * @param {string} locale a locale code.
   * @returns {?string} a locale supported by the extension.
   */


  _getExtensionLocaleForSupportedLocale(locale) {
    for (const lang in this.LANGUAGE_INFO) {
      if (this.LANGUAGE_INFO[lang].locales.includes(locale)) {
        return lang;
      }
    }

    console.error(`cannot find extension locale for locale ${locale}`);
  }
  /**
   * Get the locale code used by the speech synthesis server corresponding to
   * the current language code set for the extension.
   * @returns {string} a speech synthesis locale.
   */


  _getSpeechSynthLocale() {
    let speechSynthLocale = this.LANGUAGE_INFO[this.DEFAULT_LANGUAGE].speechSynthLocale;

    if (this.LANGUAGE_INFO[this.getCurrentLanguage()]) {
      speechSynthLocale = this.LANGUAGE_INFO[this.getCurrentLanguage()].speechSynthLocale;
    }

    return speechSynthLocale;
  }
  /**
   * Get an array of the locales supported by this extension.
   * @returns {Array} An array of locale strings.
   */


  _getSupportedLocales() {
    return Object.keys(this.LANGUAGE_INFO).reduce((acc, lang) => acc.concat(this.LANGUAGE_INFO[lang].locales), []);
  }
  /**
   * Check if a Scratch language code is in the list of supported languages for the
   * speech synthesis service.
   * @param {string} languageCode the language code to check.
   * @returns {boolean} true if the language code is supported.
   */


  isSupportedLanguage(languageCode) {
    return this._supportedLocales.includes(languageCode);
  }
  /**
   * Get the menu of voices for the "set voice" block.
   * @return {array} the text and value for each menu item.
   */


  getVoiceMenu() {
    return Object.keys(this.VOICE_INFO).map(voiceId => ({
      text: this.VOICE_INFO[voiceId].name,
      value: voiceId
    }));
  }
  /**
   * Get the localized menu of languages for the "set language" block.
   * For each language:
   *   if there is a custom translated spoken language name, use that;
   *   otherwise use the translation in the languageNames menuMap;
   *   otherwise fall back to the untranslated name in LANGUAGE_INFO.
   * @return {array} the text and value for each menu item.
   */


  getLanguageMenu() {
    const editorLanguage = this.getEditorLanguage(); // Get the array of localized language names

    const localizedNameMap = {};
    let nameArray = languageNames.menuMap[editorLanguage];

    if (nameArray) {
      // Also get any localized names of spoken languages
      let spokenNameArray = [];

      if (languageNames.spokenLanguages) {
        spokenNameArray = languageNames.spokenLanguages[editorLanguage];
        nameArray = nameArray.concat(spokenNameArray);
      } // Create a map of language code to localized name
      // The localized spoken language names have been concatenated onto
      // the end of the name array, so the result of the forEach below is
      // when there is both a written language name (e.g. 'Chinese
      // (simplified)') and a spoken language name (e.g. 'Chinese
      // (Mandarin)', we always use the spoken version.


      nameArray.forEach(lang => {
        localizedNameMap[lang.code] = lang.name;
      });
    }

    return Object.keys(this.LANGUAGE_INFO).map(key => {
      let name = this.LANGUAGE_INFO[key].name;
      const localizedName = localizedNameMap[key];

      if (localizedName) {
        name = localizedName;
      } // Uppercase the first character of the name


      name = name.charAt(0).toUpperCase() + name.slice(1);
      return {
        text: name,
        value: key
      };
    });
  }
  /**
   * Set the voice for speech synthesis for this sprite.
   * @param  {object} args Block arguments
   * @param {object} util Utility object provided by the runtime.
   */


  setVoice(args, util) {
    const state = this._getState(util.target);

    let voice = args.VOICE; // If the arg is a dropped number, treat it as a voice index

    let voiceNum = parseInt(voice, 10);

    if (!isNaN(voiceNum)) {
      voiceNum -= 1; // Treat dropped args as one-indexed

      voiceNum = Utility.wrapClamp(voiceNum, 0, Object.keys(this.VOICE_INFO).length - 1);
      voice = Object.keys(this.VOICE_INFO)[voiceNum];
    } // Only set the voice if the arg is a valid voice id.


    if (Object.keys(this.VOICE_INFO).includes(voice)) {
      state.voiceId = voice;
    }
  }
  /**
   * Set the language for speech synthesis.
   * @param  {object} args Block arguments
   */


  setLanguage(args) {
    this.setCurrentLanguage(args.LANGUAGE);
  }
  /**
   * Stop all currently playing speech sounds.
   */


  _stopAllSpeech() {
    this._soundPlayers.forEach(player => {
      player.stop();
    });
  }
  /**
   * Convert the provided text into a sound file and then play the file.
   * @param  {object} args Block arguments
   * @param {object} util Utility object provided by the runtime.
   * @return {Promise} A promise that resolves after playing the sound
   */


  speakAndWait(args, util) {
    // Cast input to string
    let words = String(args.WORDS);

    let locale = this._getSpeechSynthLocale();

    const state = this._getState(util.target);

    let gender = this.VOICE_INFO[state.voiceId].gender;
    let playbackRate = this.VOICE_INFO[state.voiceId].playbackRate; // Special case for voices where the synthesis service only provides a
    // single gender voice. In that case, always request the female voice,
    // and set special playback rates for the tenor and giant voices.

    if (this.LANGUAGE_INFO[this.getCurrentLanguage()].singleGender) {
      gender = "female";

      if (state.voiceId === TENOR_ID) {
        playbackRate = FEMALE_TENOR_RATE;
      }

      if (state.voiceId === GIANT_ID) {
        playbackRate = FEMALE_GIANT_RATE;
      }
    }

    if (state.voiceId === KITTEN_ID) {
      words = words.replace(/\S+/g, "meow");
      locale = this.LANGUAGE_INFO[this.DEFAULT_LANGUAGE].speechSynthLocale;
    } // Build up URL


    let path = `${SERVER_HOST}/synth`;
    path += `?locale=${locale}`;
    path += `&gender=${gender}`;
    path += `&text=${encodeURIComponent(words.substring(0, 128))}`; // Perform HTTP request to get audio file

    return new Promise(resolve => {
      nets({
        url: path,
        timeout: SERVER_TIMEOUT
      }, (err, res, body) => {
        if (err) {
          console.warn(err);
          return resolve();
        }

        if (res.statusCode !== 200) {
          console.warn(res.statusCode);
          return resolve();
        } // Play the sound


        const sound = {
          data: {
            buffer: body.buffer
          }
        };
        this.runtime.audioEngine.decodeSoundPlayer(sound).then(soundPlayer => {
          this._soundPlayers.set(soundPlayer.id, soundPlayer);

          soundPlayer.setPlaybackRate(playbackRate); // Increase the volume

          const engine = this.runtime.audioEngine;
          const chain = engine.createEffectChain();
          chain.set("volume", SPEECH_VOLUME);
          soundPlayer.connect(chain);
          soundPlayer.play();
          soundPlayer.on("stop", () => {
            this._soundPlayers.delete(soundPlayer.id);

            resolve();
          });
        });
      });
    });
  }

}

module.exports = Scratch3Text2SpeechBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_translate/index.js":
/*!****************************************************!*\
  !*** ./src/extensions/scratch3_translate/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const nets = __webpack_require__(/*! nets */ "./node_modules/nets/index.js");

const languageNames = __webpack_require__(/*! scratch-translate-extension-languages */ "./node_modules/scratch-translate-extension-languages/languages.json");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const menuIconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAGAklEQVRYhe1YbUxTVxh+rh02o0KtkOEgKA4U4yeRWCdgxDoxCnH6h22iqSz76aasZlnijzkTBlvS4TJ/LGaJsmiyESe4hAVJvMJGxwQhLKECcRWkpWNZERs6Ctb2Lm97C/fe3n6Jyfzhk5y09z3nPPe57znnPe85DMdxeJ6x6LlW90LgM8BLchR1dXUZeXl5b3Ect+ppXsEwzHBfX98PVVVVY0GbmjW2AdgpaFYP4JxTZ+iLyCVdJFeuXNmdn59fn56enrFkyRIsWhSfk30+H1wuF+x2+1hPT4++oqLiJi/wEoA8AJslXSqdOsOlmARWV1dnlpeXd2ZnZ2fEK0xOqMViGWtoaNh++vRpa9CuZo1ZAJokQlc5dYYROR6RCq1WW56WlhZV3H0H8O9sZIHEQVzEKbTzQooBPBCYz4TlET4oFIosGtZoOHUN+Ph61GYgLuIU2tSscSmAYwAeCcx6NWs8o2aNxVKOkEUi9R55qv428Ng7b3viA/6eAs7dmrctVgD6bYBKGZ6LB4mrk7F/whcmokApfh8BWu6G2mc8ADsktuWmAbtzozGiLUJdu9QQVSC98JUkYNgBfPsboH4Z+GhPoK62FZiaAU7sCrTZmB5VHM3BPjVrrARwUVL1B4CD0vYxLVV68YFNQIICcLrn7SROtTjwEbGIE4iksFIpEVfs1BkeSdvGFUsObAz8Gm8CNTcC/49q42EIEbkLwKfhxCGWIRZC/zrQ/ifgcAWMK5YB+zc8nUBeZFuUORmfQIp/PsHGM/04YMta5oPT6cTs7Cw8Ho+oj9vtzmloaCgPZQtApVI96ejo6K2trR3lOM4nrRftJCzLfq3T6Y7LCfvuNtDL7wepfKgkTz6ZdeHdzePYlq30xz2lUintHhH0UbQ12my2+oKCguMcx7mE7aOHmWHgsxvzzzQP3ysMxMfzt2bxKmNHyZblSE5OjktYEImJidBoNFCr1frOzs5khmHe4Thubp8SCVQoFBwNUUJCwpyNwsfyZGBDOvB2fuCZQAH56KYJKJUpTy1OCOJYvXr1ocbGxjIAPwarRKvYZrNdn5iYEHV8LRW4cBj4oHheXBDT09PPRFwQxKXRaIQpmVjgkSNHfrFardcmJydjIqSMRehtOfzjmMTZmm/8hf5HAnF5vV7RVicSyHGcR6vVHh4YGPjKYrFMkTelq5JAH0B1MzMzUT+iu6cfdwfv+wv9jxchgZomaEFBwcmcnJxVY2NjXQqFQlQ/Pj6O/v7+s2az+U2Hw9Ec7X3tHXfm/v/c2hG3wLCruLm5+VBGRoY2mJGQJ0nc4ODgqZKSkjqKWSzL7olEPjJqx4PRv5CaqvE/OxyTflvWitj3xbBbnUql2kRxjYTRcA4MDHR1d3frguJiIW//NeC9/SVF2LplvcgWK8J6sKWl5UuVSrXO4/HYHj58+FNZWVkLx3HT8Rz0u3vN/t8Ho3aRaH3FgYULrKmpodT8jeBzvDcQ3T1m/5D6RXX0zNmn3TP+uq356xcmkE/NTwLoc+oMTXGpA3CnN7Bi99Hw5s8PL4mlulgFys5BXlwbn4I3qlnjsXgFBr22f+8OrFub7S/79u4Q1cWCEA8KxAmPhRfVrBFy51cK1nJnj+/rvwix0eqVswu5pJDzoPTMKhSZJzQolUoLZSLPCsRFnEI6OYE7I7xPdGYoKiq6YLVaByllWiiIg7iIM5rAYBouBB2yq5w6g+iATWGnqampZGhoqItiJSUP4YrcR9CQUh31JQ7iIk5hm7AXmPxdip5/dNIUCnduYBgm8fLly9tzc3NLwzlSqVTuW7NmzVphQkubwL179+xdXV3HKisrTVJxiJKwnuGHVM2XNjVrPCh3h8IT3+SLLKqrq+tKS0uvrly5UksJKvjsJSkpKd3r9TrkxCGSBxHwIoWXc7zAIOiIOOLUGULOsNHAMIzSZDJ9npmZeSIlJcWfTdPQm0ym8zqd7n257hGPnXxYyePv8py8mVb40ji1+UGZUmFh4Yetra1bzGbzteHh4SlKQNxu961wff7XS3Sau/w0c4VLQF7c8i8IAP4DcHKth/4Ur7MAAAAASUVORK5CYII=";
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const blockIconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAN+UlEQVR4Ae1ce2xT1xn/Tkhq4hqHJKRLDAlQGI+GUfFc14HaLmxuGd0ab93GgK6Vmm01y9BUsaU0RfyRFTakaRHq3So6jVapWEUxa9dRuU8x6IAGCoO6wa1KXiSQOE9jkjivO/2u7yWOuff6XvvekFb5SUdx7ON7v/vz9zrnO+cwnudpAokjZYK75DBBYJKYIDBJTBCYJCYITBJfOgIZYzbGWA5jLJ8xNm/z5s334a/4P1omYyzNsPt9WdIYxhiUId/j8azPz89fY7VaF6ampjqi+4TD4Qvd3d0f7t+/fx/HcTVE1M7z/EBS99VDoCikTWzWMdTgYSLqIaIQGs/zwzKyOaqrq1+aOnVqUUZGBqWnp5PFYqG0tDQaHh6mvr4+GhwcpFAoJLSenp4P9+7dW8Zx3Fme5zsTFSxVa0eovtPpnL1ly5YfzJgxw2WxWBYketNEAO25dOmSp7Ky8iBjrFbmoW12u70oOzubMjMzR32QkpJCVqtVeG2322lgYIACgcDK0tLS1+6+++4yxpiH5/krCQkGDYzXiCi3qqrKXVNTE7x48SLf0dHB9/X18WMF3Av3xL0hA2SBTNFyE9E8v9/PX758WbNUuCa+4/F4ymKvp7XF1UDGWK7H43m0sLBwZ05Ozg2/7lgApoiGe3d2dk5ZsWLFcx6Px84Y2xelOcHW1taXiOiRcDgsaJ2gljab0GDKscD1Jk2ahHd3ejwePOtenufb9TySKoEw26qqKhfIy83NFdT/ZiP6oauqqoKMsf2iObeuXr26vKKiwpOVlTXFbrfb8/LyFubk5KyBu1H68aVnGh4e3uZ2u08yxo7pCixKqgrX4XQ6l8JkoOrjDZAJskFGyBolt0UMcGhgJ19yP2rm3dDQwJ85c+akXlNWI9B++PDh38PvjFdANsgIWVUfksheUVHxfZDY3d0t+zT9/f2CP3S73feJWYZFC4FqJmxDtJ06daphRnuiluhrDqJbLcZcD7JBRiJ6Dj5Qrg9jDHfLhlm3tbUdslgsj8i5IvhI+MpNmzaVLlq0yCN+9wMiCvA8H1KSQY1AK3yHFP6ThfcTouePEaVNItrzI6LbpiR/TcgmplOyQmLE4XQ6C3fv3v0y+iEQIbggjZELKiB2+vTpxXl5ecUIRD6fr/nQoUNuxtjbPM/3yN1DLREWPsNNjUBNC9HgMFEKI2q5asglo2VTeo7sioqKP6anpwtBZObMmZSfny9LHokRG5+jn8PhoFtuucVRXFzMQdmVZPiyTyakIblGBqE3/QKZIBLDQafTmavUT/NIRA3XwkSlB4jaFD3FCPqHiJ5+Xb3PNBvRnoeN85UYyiUCmDHg9XoVn8wQDTxRR9RxjQjxLl4DgfH64Fq4pgEY6OjoONTe3q6bRPTH9zBmFsfgsjBEA4vmE/kuE30eiPzfN0B0WYyJGelEWQpx6FJXhNC0FKIcG9Fk0TUVZEWuaQBad+zYUbF79+6FjY2NC+DfpBGKGkBeY2MjBYPBC2VlZU9g1sZUAoFf3zvyGia9/u8RbRrmiSofvrG/1IeEaEn0/E+NkmQEmLVhjPmIaAMisRYSo8nbunXrBq/X6+N5PqzU35QgAt8177bI655+ovPNN/Z50xeJyIyIlswwQ4oI8PAgAWSAFJCjZM56ySMzo/DP7iJKTSEaGibi/jP6M2jfwbNEQzzRpBSin68yS4oItJCYCHlkJoEYcWSKvu9KkOjwxyOf7T9F1DsQ0b6CTGOS6niQIxEJNSVBHhnpA+Xwm28RPfOvSAL9t+NEy2cShcJEr5+P+EcQ+PT9ZkowGiBF8olIsMPhcBFmrnt7e4Voi4Chhzwym0BoYWFexAcODBGVvUbU3RshbxIjWrdobLQvGhKJXq+3xO12z1q3bt2aN9544x2O45A4Neshj8wmENjmJHr8ZaJQ/0iizcRk+fFvmn13eYgk1TLGWjiOwxQWKY1148H0oRwiMohiUYky8Oz3zL5zfIA0qSV6DdM18NWPiF4+FXnNogh84h9EW9cQ3TV7pC+ceVTVTNPooa5OGLLMYkgmE0fcqp8STCPwYhvRn94jauqKBBHJbOED4Q8xAtn1FtH8rxA9WUSUNthJiQy5Zs2aRX6/35usvBqqfrJQrAujmu/3+/3z5s3TJQgCxsEzRP9riuSAUsBYXhCJysCWVyP+EHkgiA0Hr9D9Xw3S/QuJJlvShIlSca4vASr0A5MG0Piuri68vnr69OmyjRs3aip1GqaByPNePRuZCMDwTSIuPY1oy32jTfWFDUQvniB67RzRta4rtDwvSN8tJBrnVT9ZGEIgpupf+C/RgGh90CpMEKwtJFq/XH5aCiOVb0zvpH+fipD3Baj6yUKNQIEOqLcWU4IPx9ANGue6k+iBQvX5PPi6lHD7dc0bD+RJgCxDQ0O0bNmyXU6n8wRjrFsxsKhUshznzp2r0VrSbAny/OcB7eU7VMdQBfuiV/3U8sAQohIcqxZgRHH7NO2/MlIVEitr4xVRVT+bkoiqBCKkIyp1dia8eEkRiHokVtbGK+JV/VQJhM17vd5ahPRAIICZCkMfU8r3xipVSQQaqn7qURjRB0u/ENIRleBYb0aaEQ+Btk4qfXLnqF7bn/oF3bFgjun3jjsWRh7kcrn2VVdXb25pablaW1uLXOl6xWo84LD36A1SHDl6akwk05QHgkTkQwjpsQsstSa/V65cGeUGMIbFMMwIyJFVfdpHj2zopVut6YbcQwmaZ2Ngzl6v9+zatWv/sHjx4u9UVlYKAzMUoOMB5HV1dV09cODAQ/NFOJ1OpxEPAKJ6evtueB/vnTrtM+IWqtA1nYXAwvM81GgAi3CUFi5KQKBobm4WyDt48OCm8vLy93me/xQNSmjEAxw5NqJ91vTJQpNQ/dE4I5AikwxWjuPWZGVlFWM9shLgI+vr6zHDcoHjuAdF8gwN5dd6eulUFEkrlhUKTQI+Q4AxE4lMqOasWrXqafg9uRREquiDvKamppe2bdv2kz179pwwmjyS8X3Lly4SWjSqT38s/2WDkMhkggUBJHbsCuIQndH6+/ubjxw58ju32/0eXKCeCUo9iDbfadMyr2sfzFjyi4ffOkZrnatNoi8xAoX1JjabrRhDnehZZBDn9/v3uFyuV+ItTEwWdQ3NVN9w+fpVViwdMV0QeeTYaeF1W1un0HdWgcNoEQQkYsJd27dvfxa+7dKlS9TQ0NBcV1d36OTJk5sLCwtXuVwujuf5WjPJIxnzvWf18uuvY834TZk80Sjo1kBxdPLp4sWLizBnKr4NewnqLQkmg1gCy575s+LVkOo8UWKOHAlV5cSAgGmadnG/WWCsyZPL/ZSAvmaNTHRroLho2xFdlGaMXRSDxZiQGJvf3bHgdtl+n1y4OOo70WZuFHQRCPKwaHvXrl1/sVqtK7EsYs6cOdsee+yxd8vLy3+Lir/ZJCKvi879Zhbk0fanfinb91dP7hSCCEXlhDnTjJ0M0WzCEnlYZ5eZmbly7ty5woLs2bNnYzxchPfxuaihpiE2r7tnlbJWRUdmMikn1ERgNHl2u33UIkUM5fA/3h8LEpHXRWPFskWKfWNNNva7RkDLZkNF8iTgf7yPFaDoh9VPZpnzvVEaZ7VOVjVJ5H4/fOjbRoswGnG2SIG8pSgu1dXV8UNDQ6pFGHyOfugv7mFT3C5FRHNRVBrLbbN6AdkgI2RNZK+cLvIkyJCYonB9XVW/mwHIBhkhayJVuWxEWyWzVYJkzjabbcGOHTvKUbBT6Kqr6nczANkgo9o2BzVWbEhVMGWllbzrF01JIXwPU16IMwrdTK36JQuxbHEVMiZEoNPpFKaaE62axSPd7KpfMoAskAmyQUa12STFKOz1egODg4PN9fX1Dqxb0TJ1LwG/HuYEg8Hgu5i9Ueo3Hqt+kB3k+Xy+p8QVWqrmoZbGtGOrJ3YrNjc3O6StonhAOTKx4h21D0xvYTYa6+0wOlHb5UMjBat9WMiDtShdXV1TvkjL21TPjcEpQJiB5jhOWM28ZMkSV0FBQTG2gsoBJU/MQp8/f/5tt9v9gZ5F20Yeq4LJXlhNPEjaRjELLEWz1eaYNR57AlWwYTs88iJsj5cDFgxhWz2218fbhq90ToN4zgF+obk4ykRvk7b2azn+JGabf754b9m0S3ceqPCAuTiYAQc0KAGCR53tIgklHQKh6RyCZFr0+QhNTU1x81f0OX78uMe0c2Ni0I7jknDiTzAYxNEiN3SA6VgsFmGV57lz50oDgcA7fr9f2ErQ0dFxlTH2ERE1mVUnwVwlY+z9lpaWB0tKSv4aDocXwOUo+VOkW6FQqJjjOI94gpG+FfsJmFk2TvqB6iudgCGZBzJ5aCsaRif4ztGjR19M9NfWKadl3bp1d+J+uG9bW5uiNra2tkojjpm675OgcLkSiXqGYjBvcWw5z2wC+RGf6uA4bqPP52v67LPPZImMGvPqliuhNdKxqUdvb+8UrJFRW6VAN2Epm+gmmhlj/ySiDzwez4/nz59f2tnZ6ZCOhEJqhvQFlUa1nFUJCS8ylxYcud3umpKSkl2hUGilJFRqaipNnjz5+hEjyLOwoa+7u1tKrk2t2MnIKmygYYzhBI5XqqqqHpgzZ84au93+dRwqgRQGlUaxzqMLSR/AKJ4Gme12uxeuX7/+0YyMjJWxORxGND09PTWNjY3vuFyu/UTUaFYQ0SizRcwOpIU0Q2JVUf8Pa6C/AZGZYuqSL+VkYh6H/3OQS46F7xvLNnGSeZKYOMU3SUwQmCQmCEwSEwQmiQkCkwER/R+aET3lwEIlXgAAAABJRU5ErkJggg==";
/**
 * The url of the translate server.
 * @type {string}
 */

const serverURL = "https://translate-service.scratch.mit.edu/";
/**
 * How long to wait in ms before timing out requests to translate server.
 * @type {int}
 */

const serverTimeoutMs = 10000; // 10 seconds (chosen arbitrarily).

/**
 * Class for the translate block in Scratch 3.0.
 * @constructor
 */

class Scratch3TranslateBlocks {
  constructor() {
    /**
     * Language code of the viewer, based on their locale.
     * @type {string}
     * @private
     */
    this._viewerLanguageCode = this.getViewerLanguageCode();
    /**
     * List of supported language name and language code pairs, for use in the block menu.
     * Filled in by getInfo so it is updated when the interface language changes.
     * @type {Array.<object.<string, string>>}
     * @private
     */

    this._supportedLanguages = [];
    /**
     * A randomly selected language code, for use as the default value in the language menu.
     * Properly filled in getInfo so it is updated when the interface languages changes.
     * @type {string}
     * @private
     */

    this._randomLanguageCode = "en";
    /**
     * The result from the most recent translation.
     * @type {string}
     * @private
     */

    this._translateResult = "";
    /**
     * The language of the text most recently translated.
     * @type {string}
     * @private
     */

    this._lastLangTranslated = "";
    /**
     * The text most recently translated.
     * @type {string}
     * @private
     */

    this._lastTextTranslated = "";
  }
  /**
   * The key to load & store a target's translate state.
   * @return {string} The key.
   */


  static get STATE_KEY() {
    return "Scratch.translate";
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    this._supportedLanguages = this._getSupportedLanguages(this.getViewerLanguageCode());
    this._randomLanguageCode = this._supportedLanguages[Math.floor(Math.random() * this._supportedLanguages.length)].value;
    return {
      id: "translate",
      name: formatMessage({
        id: "translate.categoryName",
        default: "Translate",
        description: "Name of extension that adds translate blocks"
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        opcode: "getTranslate",
        text: formatMessage({
          id: "translate.translateBlock",
          default: "translate [WORDS] to [LANGUAGE]",
          description: "translate some text to a different language"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          WORDS: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: "translate.defaultTextToTranslate",
              default: "hello",
              description: "hello: the default text to translate"
            })
          },
          LANGUAGE: {
            type: ArgumentType.STRING,
            menu: "languages",
            defaultValue: this._randomLanguageCode
          }
        }
      }, {
        opcode: "getViewerLanguage",
        text: formatMessage({
          id: "translate.viewerLanguage",
          default: "language",
          description: "the languge of the project viewer"
        }),
        blockType: BlockType.REPORTER,
        arguments: {}
      }],
      menus: {
        languages: {
          acceptReporters: true,
          items: this._supportedLanguages
        }
      }
    };
  }
  /**
   * Computes a list of language code and name pairs for the given language.
   * @param {string} code The language code to get the list of language pairs
   * @return {Array.<object.<string, string>>} An array of languge name and
   *   language code pairs.
   * @private
   */


  _getSupportedLanguages(code) {
    return languageNames.menuMap[code].map(entry => {
      const obj = {
        text: entry.name,
        value: entry.code
      };
      return obj;
    });
  }
  /**
   * Get the human readable language value for the reporter block.
   * @return {string} the language name of the project viewer.
   */


  getViewerLanguage() {
    this._viewerLanguageCode = this.getViewerLanguageCode();
    const names = languageNames.menuMap[this._viewerLanguageCode];
    let langNameObj = names.find(obj => obj.code === this._viewerLanguageCode); // If we don't have a name entry yet, try looking it up via the Google langauge
    // code instead of Scratch's (e.g. for es-419 we look up es to get espanol)

    if (!langNameObj && languageNames.scratchToGoogleMap[this._viewerLanguageCode]) {
      const lookupCode = languageNames.scratchToGoogleMap[this._viewerLanguageCode];
      langNameObj = names.find(obj => obj.code === lookupCode);
    }

    let langName = this._viewerLanguageCode;

    if (langNameObj) {
      langName = langNameObj.name;
    }

    return langName;
  }
  /**
   * Get the viewer's language code.
   * @return {string} the language code.
   */


  getViewerLanguageCode() {
    const locale = formatMessage.setup().locale;
    const viewerLanguages = [locale].concat(navigator.languages);
    const languageKeys = Object.keys(languageNames.menuMap); // Return the first entry in viewerLanguages that matches
    // one of the available language keys.

    const languageCode = viewerLanguages.reduce((acc, lang) => {
      if (acc) {
        return acc;
      }

      if (languageKeys.indexOf(lang.toLowerCase()) > -1) {
        return lang;
      }

      return acc;
    }, "") || "en";
    return languageCode.toLowerCase();
  }
  /**
   * Get a language code from a block argument. The arg can be a language code
   * or a language name, written in any language.
   * @param  {object} arg A block argument.
   * @return {string} A language code.
   */


  getLanguageCodeFromArg(arg) {
    const languageArg = String(arg).toLowerCase(); // Check if the arg matches a language code in the menu.

    if (languageNames.menuMap.hasOwnProperty(languageArg)) {
      return languageArg;
    } // Check for a dropped-in language name, and convert to a language code.


    if (languageNames.nameMap.hasOwnProperty(languageArg)) {
      return languageNames.nameMap[languageArg];
    } // There are some languages we launched in the language menu that Scratch did not
    // end up launching in. In order to keep projects that may have had that menu item
    // working, check for those language codes and let them through.
    // Examples: 'ab', 'hi'.


    if (languageNames.previouslySupported.indexOf(languageArg) !== -1) {
      return languageArg;
    } // Default to English.


    return "en";
  }
  /**
   * Translates the text in the translate block to the language specified in the menu.
   * @param {object} args - the block arguments.
   * @return {Promise} - a promise that resolves after the response from the translate server.
   */


  getTranslate(args) {
    // Don't remake the request if we already have the value.
    if (this._lastTextTranslated === args.WORDS && this._lastLangTranslated === args.LANGUAGE) {
      return this._translateResult;
    }

    const lang = this.getLanguageCodeFromArg(args.LANGUAGE);
    let urlBase = `${serverURL}translate?language=`;
    urlBase += lang;
    urlBase += "&text=";
    urlBase += encodeURIComponent(args.WORDS);
    const tempThis = this;
    const translatePromise = new Promise(resolve => {
      nets({
        url: urlBase,
        timeout: serverTimeoutMs
      }, (err, res, body) => {
        if (err) {
          console.warn(`error fetching translate result! ${res}`);
          resolve("");
          return "";
        }

        const translated = JSON.parse(body).result;
        tempThis._translateResult = translated; // Cache what we just translated so we don't keep making the
        // same call over and over.

        tempThis._lastTextTranslated = args.WORDS;
        tempThis._lastLangTranslated = args.LANGUAGE;
        resolve(translated);
        return translated;
      });
    });
    translatePromise.then(translatedText => translatedText);
    return translatePromise;
  }

}

module.exports = Scratch3TranslateBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_video_sensing/index.js":
/*!********************************************************!*\
  !*** ./src/extensions/scratch3_video_sensing/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Runtime = __webpack_require__(/*! ../../engine/runtime */ "./src/engine/runtime.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const Video = __webpack_require__(/*! ../../io/video */ "./src/io/video.js");

const VideoMotion = __webpack_require__(/*! ./library */ "./src/extensions/scratch3_video_sensing/library.js");
/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const menuIconURI = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctTWVudTwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxnIGlkPSJFeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctTWVudSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9InZpZGVvLW1vdGlvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDUuMDAwMDAwKSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjMEVCRDhDIiBvcGFjaXR5PSIwLjI1IiBjeD0iMTYiIGN5PSI4IiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjMEVCRDhDIiBvcGFjaXR5PSIwLjUiIGN4PSIxNiIgY3k9IjYiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLUNvcHkiIGZpbGw9IiMwRUJEOEMiIG9wYWNpdHk9IjAuNzUiIGN4PSIxNiIgY3k9IjQiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsIiBmaWxsPSIjMEVCRDhDIiBjeD0iMTYiIGN5PSIyIiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgPHBhdGggZD0iTTExLjMzNTk3MzksMi4yMDk3ODgyNSBMOC4yNSw0LjIwOTk1NjQ5IEw4LjI1LDMuMDUgQzguMjUsMi4wNDQ4ODIyNyA3LjQ2ODU5MDMxLDEuMjUgNi41LDEuMjUgTDIuMDUsMS4yNSBDMS4wMzgwNzExOSwxLjI1IDAuMjUsMi4wMzgwNzExOSAwLjI1LDMuMDUgTDAuMjUsNyBDMC4yNSw3Ljk2MzY5OTM3IDEuMDQyMjQ5MTksOC43NTU5NDg1NiAyLjA1LDguOCBMNi41LDguOCBDNy40NTA4MzAwOSw4LjggOC4yNSw3Ljk3MzI3MjUgOC4yNSw3IEw4LjI1LDUuODU4NDUyNDEgTDguNjI4NjIzOTQsNi4wODU2MjY3NyBMMTEuNDI2Nzc2Nyw3Ljc3MzIyMzMgQzExLjQzNjg5NDMsNy43ODMzNDA5MSAxMS40NzU3NjU1LDcuOCAxMS41LDcuOCBDMTEuNjMzNDkzMiw3LjggMTEuNzUsNy42OTEyNjAzNCAxMS43NSw3LjU1IEwxMS43NSwyLjQgQzExLjc1LDIuNDE4MzgyNjkgMTEuNzIxOTAyOSwyLjM1MjgyMjgyIDExLjY4NTYyNjgsMi4yNzg2MjM5NCBDMTEuNjEyOTUyOCwyLjE1NzUwMDY5IDExLjQ3MDc5NjgsMi4xMjkwNjk1IDExLjMzNTk3MzksMi4yMDk3ODgyNSBaIiBpZD0idmlkZW9fMzdfIiBzdHJva2Utb3BhY2l0eT0iMC4xNSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNSIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+";
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const blockIconURI = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctQmxvY2s8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZyBpZD0iRXh0ZW5zaW9ucy9Tb2Z0d2FyZS9WaWRlby1TZW5zaW5nLUJsb2NrIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2Utb3BhY2l0eT0iMC4xNSI+CiAgICAgICAgPGcgaWQ9InZpZGVvLW1vdGlvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwLjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyIgc3Ryb2tlPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjRkZGRkZGIiBvcGFjaXR5PSIwLjI1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGN4PSIzMiIgY3k9IjE2IiByPSI0LjUiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLUNvcHkiIGZpbGw9IiNGRkZGRkYiIG9wYWNpdHk9IjAuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjeD0iMzIiIGN5PSIxMiIgcj0iNC41Ij48L2NpcmNsZT4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjRkZGRkZGIiBvcGFjaXR5PSIwLjc1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGN4PSIzMiIgY3k9IjgiIHI9IjQuNSI+PC9jaXJjbGU+CiAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgY3g9IjMyIiBjeT0iNCIgcj0iNC41Ij48L2NpcmNsZT4KICAgICAgICAgICAgPHBhdGggZD0iTTIyLjY3MTk0NzcsNC40MTk1NzY0OSBMMTYuNSw4LjQxOTkxMjk4IEwxNi41LDYuMSBDMTYuNSw0LjA4OTc2NDU0IDE0LjkzNzE4MDYsMi41IDEzLDIuNSBMNC4xLDIuNSBDMi4wNzYxNDIzNywyLjUgMC41LDQuMDc2MTQyMzcgMC41LDYuMSBMMC41LDE0IEMwLjUsMTUuOTI3Mzk4NyAyLjA4NDQ5ODM5LDE3LjUxMTg5NzEgNC4xLDE3LjYgTDEzLDE3LjYgQzE0LjkwMTY2MDIsMTcuNiAxNi41LDE1Ljk0NjU0NSAxNi41LDE0IEwxNi41LDExLjcxNjkwNDggTDIyLjc1NzI0NzksMTUuNDcxMjUzNSBMMjIuODUzNTUzNCwxNS41NDY0NDY2IEMyMi44NzM3ODg2LDE1LjU2NjY4MTggMjIuOTUxNTMxLDE1LjYgMjMsMTUuNiBDMjMuMjY2OTg2NSwxNS42IDIzLjUsMTUuMzgyNTIwNyAyMy41LDE1LjEgTDIzLjUsNC44IEMyMy41LDQuODM2NzY1MzggMjMuNDQzODA1OCw0LjcwNTY0NTYzIDIzLjM3MTI1MzUsNC41NTcyNDc4OCBDMjMuMjI1OTA1Niw0LjMxNTAwMTM5IDIyLjk0MTU5MzcsNC4yNTgxMzg5OSAyMi42NzE5NDc3LDQuNDE5NTc2NDkgWiIgaWQ9InZpZGVvXzM3XyIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+";
/**
 * Sensor attribute video sensor block should report.
 * @readonly
 * @enum {string}
 */

const SensingAttribute = {
  /** The amount of motion. */
  MOTION: "motion",

  /** The direction of the motion. */
  DIRECTION: "direction"
};
/**
 * Subject video sensor block should report for.
 * @readonly
 * @enum {string}
 */

const SensingSubject = {
  /** The sensor traits of the whole stage. */
  STAGE: "Stage",

  /** The senosr traits of the area overlapped by this sprite. */
  SPRITE: "this sprite"
};
/**
 * States the video sensing activity can be set to.
 * @readonly
 * @enum {string}
 */

const VideoState = {
  /** Video turned off. */
  OFF: "off",

  /** Video turned on with default y axis mirroring. */
  ON: "on",

  /** Video turned on without default y axis mirroring. */
  ON_FLIPPED: "on-flipped"
};
/**
 * Class for the motion-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */

class Scratch3VideoSensingBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The motion detection algoritm used to power the motion amount and
     * direction values.
     * @type {VideoMotion}
     */

    this.detect = new VideoMotion();
    /**
     * The last millisecond epoch timestamp that the video stream was
     * analyzed.
     * @type {number}
     */

    this._lastUpdate = null;
    /**
     * A flag to determine if this extension has been installed in a project.
     * It is set to false the first time getInfo is run.
     * @type {boolean}
     */

    this.firstInstall = true;

    if (this.runtime.ioDevices) {
      // Configure the video device with values from globally stored locations.
      this.runtime.on(Runtime.PROJECT_LOADED, this.updateVideoDisplay.bind(this)); // Clear target motion state values when the project starts.

      this.runtime.on(Runtime.PROJECT_RUN_START, this.reset.bind(this)); // Kick off looping the analysis logic.

      this._loop();
    }
  }
  /**
   * After analyzing a frame the amount of milliseconds until another frame
   * is analyzed.
   * @type {number}
   */


  static get INTERVAL() {
    return 33;
  }
  /**
   * Dimensions the video stream is analyzed at after its rendered to the
   * sample canvas.
   * @type {Array.<number>}
   */


  static get DIMENSIONS() {
    return [480, 360];
  }
  /**
   * The key to load & store a target's motion-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.videoSensing";
  }
  /**
   * The default motion-related state, to be used when a target has no existing motion state.
   * @type {MotionState}
   */


  static get DEFAULT_MOTION_STATE() {
    return {
      motionFrameNumber: 0,
      motionAmount: 0,
      motionDirection: 0
    };
  }
  /**
   * The transparency setting of the video preview stored in a value
   * accessible by any object connected to the virtual machine.
   * @type {number}
   */


  get globalVideoTransparency() {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      return stage.videoTransparency;
    }

    return 50;
  }

  set globalVideoTransparency(transparency) {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      stage.videoTransparency = transparency;
    }

    return transparency;
  }
  /**
   * The video state of the video preview stored in a value accessible by any
   * object connected to the virtual machine.
   * @type {number}
   */


  get globalVideoState() {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      return stage.videoState;
    } // Though the default value for the stage is normally 'on', we need to default
    // to 'off' here to prevent the video device from briefly activating
    // while waiting for stage targets to be installed that say it should be off


    return VideoState.OFF;
  }

  set globalVideoState(state) {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      stage.videoState = state;
    }

    return state;
  }
  /**
   * Get the latest values for video transparency and state,
   * and set the video device to use them.
   */


  updateVideoDisplay() {
    this.setVideoTransparency({
      TRANSPARENCY: this.globalVideoTransparency
    });
    this.videoToggle({
      VIDEO_STATE: this.globalVideoState
    });
  }
  /**
   * Reset the extension's data motion detection data. This will clear out
   * for example old frames, so the first analyzed frame will not be compared
   * against a frame from before reset was called.
   */


  reset() {
    this.detect.reset();
    const targets = this.runtime.targets;

    for (let i = 0; i < targets.length; i++) {
      const state = targets[i].getCustomState(Scratch3VideoSensingBlocks.STATE_KEY);

      if (state) {
        state.motionAmount = 0;
        state.motionDirection = 0;
      }
    }
  }
  /**
   * Occasionally step a loop to sample the video, stamp it to the preview
   * skin, and add a TypedArray copy of the canvas's pixel data.
   * @private
   */


  _loop() {
    setTimeout(this._loop.bind(this), Math.max(this.runtime.currentStepTime, Scratch3VideoSensingBlocks.INTERVAL)); // Add frame to detector

    const time = Date.now();

    if (this._lastUpdate === null) {
      this._lastUpdate = time;
    }

    const offset = time - this._lastUpdate;

    if (offset > Scratch3VideoSensingBlocks.INTERVAL) {
      const frame = this.runtime.ioDevices.video.getFrame({
        format: Video.FORMAT_IMAGE_DATA,
        dimensions: Scratch3VideoSensingBlocks.DIMENSIONS
      });

      if (frame) {
        this._lastUpdate = time;
        this.detect.addFrame(frame.data);
      }
    }
  }
  /**
   * Create data for a menu in scratch-blocks format, consisting of an array
   * of objects with text and value properties. The text is a translated
   * string, and the value is one-indexed.
   * @param {object[]} info - An array of info objects each having a name
   *   property.
   * @return {array} - An array of objects with text and value properties.
   * @private
   */


  _buildMenu(info) {
    return info.map((entry, index) => {
      const obj = {};
      obj.text = entry.name;
      obj.value = entry.value || String(index + 1);
      return obj;
    });
  }
  /**
   * @param {Target} target - collect motion state for this target.
   * @returns {MotionState} the mutable motion state associated with that
   *   target. This will be created if necessary.
   * @private
   */


  _getMotionState(target) {
    let motionState = target.getCustomState(Scratch3VideoSensingBlocks.STATE_KEY);

    if (!motionState) {
      motionState = Utility.cloneSimple(Scratch3VideoSensingBlocks.DEFAULT_MOTION_STATE);
      target.setCustomState(Scratch3VideoSensingBlocks.STATE_KEY, motionState);
    }

    return motionState;
  }

  static get SensingAttribute() {
    return SensingAttribute;
  }
  /**
   * An array of choices of whether a reporter should return the frame's
   * motion amount or direction.
   * @type {object[]}
   * @param {string} name - the translatable name to display in sensor
   *   attribute menu
   * @param {string} value - the serializable value of the attribute
   */


  get ATTRIBUTE_INFO() {
    return [{
      name: formatMessage({
        id: "videoSensing.motion",
        default: "motion",
        description: 'Attribute for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingAttribute.MOTION
    }, {
      name: formatMessage({
        id: "videoSensing.direction",
        default: "direction",
        description: 'Attribute for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingAttribute.DIRECTION
    }];
  }

  static get SensingSubject() {
    return SensingSubject;
  }
  /**
   * An array of info about the subject choices.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the subject menu
   * @param {string} value - the serializable value of the subject
   */


  get SUBJECT_INFO() {
    return [{
      name: formatMessage({
        id: "videoSensing.sprite",
        default: "sprite",
        description: 'Subject for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingSubject.SPRITE
    }, {
      name: formatMessage({
        id: "videoSensing.stage",
        default: "stage",
        description: 'Subject for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingSubject.STAGE
    }];
  }
  /**
   * States the video sensing activity can be set to.
   * @readonly
   * @enum {string}
   */


  static get VideoState() {
    return VideoState;
  }
  /**
   * An array of info on video state options for the "turn video [STATE]" block.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the video state menu
   * @param {string} value - the serializable value stored in the block
   */


  get VIDEO_STATE_INFO() {
    return [{
      name: formatMessage({
        id: "videoSensing.off",
        default: "off",
        description: 'Option for the "turn video [STATE]" block'
      }),
      value: VideoState.OFF
    }, {
      name: formatMessage({
        id: "videoSensing.on",
        default: "on",
        description: 'Option for the "turn video [STATE]" block'
      }),
      value: VideoState.ON
    }, {
      name: formatMessage({
        id: "videoSensing.onFlipped",
        default: "on flipped",
        description: 'Option for the "turn video [STATE]" block that causes the video to be flipped' + " horizontally (reversed as in a mirror)"
      }),
      value: VideoState.ON_FLIPPED
    }];
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    // Set the video display properties to defaults the first time
    // getInfo is run. This turns on the video device when it is
    // first added to a project, and is overwritten by a PROJECT_LOADED
    // event listener that later calls updateVideoDisplay
    if (this.firstInstall) {
      this.globalVideoState = VideoState.ON;
      this.globalVideoTransparency = 50;
      this.updateVideoDisplay();
      this.firstInstall = false;
    } // Return extension definition


    return {
      id: "videoSensing",
      name: formatMessage({
        id: "videoSensing.categoryName",
        default: "Video Sensing",
        description: "Label for the video sensing extension category"
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        // @todo this hat needs to be set itself to restart existing
        // threads like Scratch 2's behaviour.
        opcode: "whenMotionGreaterThan",
        text: formatMessage({
          id: "videoSensing.whenMotionGreaterThan",
          default: "when video motion > [REFERENCE]",
          description: "Event that triggers when the amount of motion is greater than [REFERENCE]"
        }),
        blockType: BlockType.HAT,
        arguments: {
          REFERENCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 10
          }
        }
      }, {
        opcode: "videoOn",
        blockType: BlockType.REPORTER,
        text: formatMessage({
          id: "videoSensing.videoOn",
          default: "video [ATTRIBUTE] on [SUBJECT]",
          description: "Reporter that returns the amount of [ATTRIBUTE] for the selected [SUBJECT]"
        }),
        arguments: {
          ATTRIBUTE: {
            type: ArgumentType.NUMBER,
            menu: "ATTRIBUTE",
            defaultValue: SensingAttribute.MOTION
          },
          SUBJECT: {
            type: ArgumentType.NUMBER,
            menu: "SUBJECT",
            defaultValue: SensingSubject.SPRITE
          }
        }
      }, {
        opcode: "videoToggle",
        text: formatMessage({
          id: "videoSensing.videoToggle",
          default: "turn video [VIDEO_STATE]",
          description: "Controls display of the video preview layer"
        }),
        arguments: {
          VIDEO_STATE: {
            type: ArgumentType.NUMBER,
            menu: "VIDEO_STATE",
            defaultValue: VideoState.ON
          }
        }
      }, {
        opcode: "setVideoTransparency",
        text: formatMessage({
          id: "videoSensing.setVideoTransparency",
          default: "set video transparency to [TRANSPARENCY]",
          description: "Controls transparency of the video preview layer"
        }),
        arguments: {
          TRANSPARENCY: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }],
      menus: {
        ATTRIBUTE: {
          acceptReporters: true,
          items: this._buildMenu(this.ATTRIBUTE_INFO)
        },
        SUBJECT: {
          acceptReporters: true,
          items: this._buildMenu(this.SUBJECT_INFO)
        },
        VIDEO_STATE: {
          acceptReporters: true,
          items: this._buildMenu(this.VIDEO_STATE_INFO)
        }
      }
    };
  }
  /**
   * Analyze a part of the frame that a target overlaps.
   * @param {Target} target - a target to determine where to analyze
   * @returns {MotionState} the motion state for the given target
   */


  _analyzeLocalMotion(target) {
    const drawable = this.runtime.renderer._allDrawables[target.drawableID];

    const state = this._getMotionState(target);

    this.detect.getLocalMotion(drawable, state);
    return state;
  }
  /**
   * A scratch reporter block handle that analyzes the last two frames and
   * depending on the arguments, returns the motion or direction for the
   * whole stage or just the target sprite.
   * @param {object} args - the block arguments
   * @param {BlockUtility} util - the block utility
   * @returns {number} the motion amount or direction of the stage or sprite
   */


  videoOn(args, util) {
    this.detect.analyzeFrame();
    let state = this.detect;

    if (args.SUBJECT === SensingSubject.SPRITE) {
      state = this._analyzeLocalMotion(util.target);
    }

    if (args.ATTRIBUTE === SensingAttribute.MOTION) {
      return state.motionAmount;
    }

    return state.motionDirection;
  }
  /**
   * A scratch hat block edge handle that analyzes the last two frames where
   * the target sprite overlaps and if it has more motion than the given
   * reference value.
   * @param {object} args - the block arguments
   * @param {BlockUtility} util - the block utility
   * @returns {boolean} true if the sprite overlaps more motion than the
   *   reference
   */


  whenMotionGreaterThan(args, util) {
    this.detect.analyzeFrame();

    const state = this._analyzeLocalMotion(util.target);

    return state.motionAmount > Number(args.REFERENCE);
  }
  /**
   * A scratch command block handle that configures the video state from
   * passed arguments.
   * @param {object} args - the block arguments
   * @param {VideoState} args.VIDEO_STATE - the video state to set the device to
   */


  videoToggle(args) {
    const state = args.VIDEO_STATE;
    this.globalVideoState = state;

    if (state === VideoState.OFF) {
      this.runtime.ioDevices.video.disableVideo();
    } else {
      this.runtime.ioDevices.video.enableVideo(); // Mirror if state is ON. Do not mirror if state is ON_FLIPPED.

      this.runtime.ioDevices.video.mirror = state === VideoState.ON;
    }
  }
  /**
   * A scratch command block handle that configures the video preview's
   * transparency from passed arguments.
   * @param {object} args - the block arguments
   * @param {number} args.TRANSPARENCY - the transparency to set the video
   *   preview to
   */


  setVideoTransparency(args) {
    const transparency = Utility.toNumber(args.TRANSPARENCY);
    this.globalVideoTransparency = transparency;
    this.runtime.ioDevices.video.setPreviewGhost(transparency);
  }

}

module.exports = Scratch3VideoSensingBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_video_sensing/library.js":
/*!**********************************************************!*\
  !*** ./src/extensions/scratch3_video_sensing/library.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @file library.js
 *
 * Tony Hwang and John Maloney, January 2011
 * Michael "Z" Goddard, March 2018
 *
 * Video motion sensing primitives.
 */
const {
  motionVector,
  scratchAtan2
} = __webpack_require__(/*! ./math */ "./src/extensions/scratch3_video_sensing/math.js");
/**
 * The width of the intended resolution to analyze for motion.
 * @type {number}
 */


const WIDTH = 480;
/**
 * The height of the intended resolution to analyze for motion.
 * @type {number}
 */

const HEIGHT = 360;
/**
 * A constant value to scale the magnitude of the x and y components called u
 * and v. This creates the motionAmount value.
 *
 * Old note: chosen empirically to give a range of roughly 0-100
 *
 * @type {number}
 */

const AMOUNT_SCALE = 100;
/**
 * A constant value to scale the magnitude of the x and y components called u
 * and v in the local motion derivative. This creates the motionAmount value on
 * a target's motion state.
 *
 * Old note: note 2e-4 * activePixelNum is an experimentally tuned threshold
 * for my logitech Pro 9000 webcam - TTH
 *
 * @type {number}
 */

const LOCAL_AMOUNT_SCALE = AMOUNT_SCALE * 2e-4;
/**
 * The motion amount must be higher than the THRESHOLD to calculate a new
 * direction value.
 * @type {number}
 */

const THRESHOLD = 10;
/**
 * The size of the radius of the window of summarized values when considering
 * the motion inside the full resolution of the sample.
 * @type {number}
 */

const WINSIZE = 8;
/**
 * A ceiling for the motionAmount stored to a local target's motion state. The
 * motionAmount is not allowed to be larger than LOCAL_MAX_AMOUNT.
 * @type {number}
 */

const LOCAL_MAX_AMOUNT = 100;
/**
 * The motion amount for a target's local motion must be higher than the
 * LOCAL_THRESHOLD to calculate a new direction value.
 * @type {number}
 */

const LOCAL_THRESHOLD = THRESHOLD / 3;
/**
 * Store the necessary image pixel data to compares frames of a video and
 * detect an amount and direction of motion in the full sample or in a
 * specified area.
 * @constructor
 */

class VideoMotion {
  constructor() {
    /**
     * The number of frames that have been added from a source.
     * @type {number}
     */
    this.frameNumber = 0;
    /**
     * The frameNumber last analyzed.
     * @type {number}
     */

    this.lastAnalyzedFrame = 0;
    /**
     * The amount of motion detected in the current frame.
     * @type {number}
     */

    this.motionAmount = 0;
    /**
     * The direction the motion detected in the frame is general moving in.
     * @type {number}
     */

    this.motionDirection = 0;
    /**
     * A copy of the current frame's pixel values. A index of the array is
     * represented in RGBA. The lowest byte is red. The next is green. The
     * next is blue. And the last is the alpha value of that pixel.
     * @type {Uint32Array}
     */

    this.curr = null;
    /**
     * A copy of the last frame's pixel values.
     * @type {Uint32Array}
     */

    this.prev = null;
    /**
     * A buffer for holding one component of a pixel's full value twice.
     * One for the current value. And one for the last value.
     * @type {number}
     */

    this._arrays = new ArrayBuffer(WIDTH * HEIGHT * 2 * 1);
    /**
     * A clamped uint8 view of _arrays. One component of each index of the
     * curr member is copied into this array.
     * @type {number}
     */

    this._curr = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 0 * 1, WIDTH * HEIGHT);
    /**
     * A clamped uint8 view of _arrays. One component of each index of the
     * prev member is copied into this array.
     * @type {number}
     */

    this._prev = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 1 * 1, WIDTH * HEIGHT);
  }
  /**
   * Reset internal state so future frame analysis does not consider values
   * from before this method was called.
   */


  reset() {
    this.frameNumber = 0;
    this.lastAnalyzedFrame = 0;
    this.motionAmount = this.motionDirection = 0;
    this.prev = this.curr = null;
  }
  /**
   * Add a frame to be next analyzed. The passed array represent a pixel with
   * each index in the RGBA format.
   * @param {Uint32Array} source - a source frame of pixels to copy
   */


  addFrame(source) {
    this.frameNumber++; // Swap curr to prev.

    this.prev = this.curr; // Create a clone of the array so any modifications made to the source
    // array do not affect the work done in here.

    this.curr = new Uint32Array(source.buffer.slice(0)); // Swap _prev and _curr. Copy one of the color components of the new
    // array into _curr overwriting what was the old _prev data.

    const _tmp = this._prev;
    this._prev = this._curr;
    this._curr = _tmp;

    for (let i = 0; i < this.curr.length; i++) {
      this._curr[i] = this.curr[i] & 0xff;
    }
  }
  /**
   * Analyze the current frame against the previous frame determining the
   * amount of motion and direction of the motion.
   */


  analyzeFrame() {
    if (!this.curr || !this.prev) {
      this.motionAmount = this.motionDirection = -1; // Don't have two frames to analyze yet

      return;
    } // Return early if new data has not been received.


    if (this.lastAnalyzedFrame === this.frameNumber) {
      return;
    }

    this.lastAnalyzedFrame = this.frameNumber;
    const {
      _curr: curr,
      _prev: prev
    } = this;
    const winStep = WINSIZE * 2 + 1;
    const wmax = WIDTH - WINSIZE - 1;
    const hmax = HEIGHT - WINSIZE - 1; // Accumulate 2d motion vectors from groups of pixels and average it
    // later.

    let uu = 0;
    let vv = 0;
    let n = 0; // Iterate over groups of cells building up the components to determine
    // a motion vector for each cell instead of the whole frame to avoid
    // integer overflows.

    for (let i = WINSIZE + 1; i < hmax; i += winStep) {
      for (let j = WINSIZE + 1; j < wmax; j += winStep) {
        let A2 = 0;
        let A1B2 = 0;
        let B1 = 0;
        let C1 = 0;
        let C2 = 0; // This is a performance critical math region.

        let address = (i - WINSIZE) * WIDTH + j - WINSIZE;
        let nextAddress = address + winStep;
        const maxAddress = (i + WINSIZE) * WIDTH + j + WINSIZE;

        for (; address <= maxAddress; address += WIDTH - winStep, nextAddress += WIDTH) {
          for (; address <= nextAddress; address += 1) {
            // The difference in color between the last frame and
            // the current frame.
            const gradT = prev[address] - curr[address]; // The difference between the pixel to the left and the
            // pixel to the right.

            const gradX = curr[address - 1] - curr[address + 1]; // The difference between the pixel above and the pixel
            // below.

            const gradY = curr[address - WIDTH] - curr[address + WIDTH]; // Add the combined values of this pixel to previously
            // considered pixels.

            A2 += gradX * gradX;
            A1B2 += gradX * gradY;
            B1 += gradY * gradY;
            C2 += gradX * gradT;
            C1 += gradY * gradT;
          }
        } // Use the accumalated values from the for loop to determine a
        // motion direction.


        const {
          u,
          v
        } = motionVector(A2, A1B2, B1, C2, C1); // If u and v are within negative winStep to positive winStep,
        // add them to a sum that will later be averaged.

        if (-winStep < u && u < winStep && -winStep < v && v < winStep) {
          uu += u;
          vv += v;
          n++;
        }
      }
    } // Average the summed vector values of all of the motion groups.


    uu /= n;
    vv /= n; // Scale the magnitude of the averaged UV vector.

    this.motionAmount = Math.round(AMOUNT_SCALE * Math.hypot(uu, vv));

    if (this.motionAmount > THRESHOLD) {
      // Scratch direction
      this.motionDirection = scratchAtan2(vv, uu);
    }
  }
  /**
   * Build motion amount and direction values based on stored current and
   * previous frame that overlaps a given drawable.
   * @param {Drawable} drawable - touchable and bounded drawable to build motion for
   * @param {MotionState} state - state to store built values to
   */


  getLocalMotion(drawable, state) {
    if (!this.curr || !this.prev) {
      state.motionAmount = state.motionDirection = -1; // Don't have two frames to analyze yet

      return;
    } // Skip if the current frame has already been considered for this state.


    if (state.motionFrameNumber !== this.frameNumber) {
      const {
        _prev: prev,
        _curr: curr
      } = this; // The public APIs for Renderer#isTouching manage keeping the matrix and
      // silhouette up-to-date, which is needed for drawable#isTouching to work (used below)

      drawable.updateMatrix();
      if (drawable.skin) drawable.skin.updateSilhouette(); // Restrict the region the amount and direction are built from to
      // the area of the current frame overlapped by the given drawable's
      // bounding box.

      const boundingRect = drawable.getFastBounds(); // Transform the bounding box from scratch space to a space from 0,
      // 0 to WIDTH, HEIGHT.

      const xmin = Math.max(Math.floor(boundingRect.left + WIDTH / 2), 1);
      const xmax = Math.min(Math.floor(boundingRect.right + WIDTH / 2), WIDTH - 1);
      const ymin = Math.max(Math.floor(HEIGHT / 2 - boundingRect.top), 1);
      const ymax = Math.min(Math.floor(HEIGHT / 2 - boundingRect.bottom), HEIGHT - 1);
      let A2 = 0;
      let A1B2 = 0;
      let B1 = 0;
      let C1 = 0;
      let C2 = 0;
      let scaleFactor = 0;
      const position = [0, 0, 0]; // This is a performance critical math region.

      for (let i = ymin; i < ymax; i++) {
        for (let j = xmin; j < xmax; j++) {
          // i and j are in a coordinate planning ranging from 0 to
          // HEIGHT and 0 to WIDTH. Transform that into Scratch's
          // range of HEIGHT / 2 to -HEIGHT / 2 and -WIDTH / 2 to
          // WIDTH / 2;
          position[0] = j - WIDTH / 2;
          position[1] = HEIGHT / 2 - i; // Consider only pixels in the drawable that can touch the
          // edge or other drawables. Empty space in the current skin
          // is skipped.

          if (drawable.isTouching(position)) {
            const address = i * WIDTH + j; // The difference in color between the last frame and
            // the current frame.

            const gradT = prev[address] - curr[address]; // The difference between the pixel to the left and the
            // pixel to the right.

            const gradX = curr[address - 1] - curr[address + 1]; // The difference between the pixel above and the pixel
            // below.

            const gradY = curr[address - WIDTH] - curr[address + WIDTH]; // Add the combined values of this pixel to previously
            // considered pixels.

            A2 += gradX * gradX;
            A1B2 += gradX * gradY;
            B1 += gradY * gradY;
            C2 += gradX * gradT;
            C1 += gradY * gradT;
            scaleFactor++;
          }
        }
      } // Use the accumalated values from the for loop to determine a
      // motion direction.


      let {
        u,
        v
      } = motionVector(A2, A1B2, B1, C2, C1);
      let activePixelNum = 0;

      if (scaleFactor) {
        // Store the area of the sprite in pixels
        activePixelNum = scaleFactor;
        scaleFactor /= 2 * WINSIZE * 2 * WINSIZE;
        u = u / scaleFactor;
        v = v / scaleFactor;
      } // Scale the magnitude of the averaged UV vector and the number of
      // overlapping drawable pixels.


      state.motionAmount = Math.round(LOCAL_AMOUNT_SCALE * activePixelNum * Math.hypot(u, v));

      if (state.motionAmount > LOCAL_MAX_AMOUNT) {
        // Clip all magnitudes greater than 100.
        state.motionAmount = LOCAL_MAX_AMOUNT;
      }

      if (state.motionAmount > LOCAL_THRESHOLD) {
        // Scratch direction.
        state.motionDirection = scratchAtan2(v, u);
      } // Skip future calls on this state until a new frame is added.


      state.motionFrameNumber = this.frameNumber;
    }
  }

}

module.exports = VideoMotion;

/***/ }),

/***/ "./src/extensions/scratch3_video_sensing/math.js":
/*!*******************************************************!*\
  !*** ./src/extensions/scratch3_video_sensing/math.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A constant value helping to transform a value in radians to degrees.
 * @type {number}
 */
const TO_DEGREE = 180 / Math.PI;
/**
 * A object reused to save on memory allocation returning u and v vector from
 * motionVector.
 * @type {UV}
 */

const _motionVectorOut = {
  u: 0,
  v: 0
};
/**
 * Determine a motion vector combinations of the color component difference on
 * the x axis, y axis, and temporal axis.
 * @param {number} A2 - a sum of x axis squared
 * @param {number} A1B2 - a sum of x axis times y axis
 * @param {number} B1 - a sum of y axis squared
 * @param {number} C2 - a sum of x axis times temporal axis
 * @param {number} C1 - a sum of y axis times temporal axis
 * @param {UV} out - optional object to store return UV info in
 * @returns {UV} a uv vector representing the motion for the given input
 */

const motionVector = function (A2, A1B2, B1, C2, C1, out = _motionVectorOut) {
  // Compare sums of X * Y and sums of X squared and Y squared.
  const delta = A1B2 * A1B2 - A2 * B1;

  if (delta) {
    // System is not singular - solving by Kramer method.
    const deltaX = -(C1 * A1B2 - C2 * B1);
    const deltaY = -(A1B2 * C2 - A2 * C1);
    const Idelta = 8 / delta;
    out.u = deltaX * Idelta;
    out.v = deltaY * Idelta;
  } else {
    // Singular system - find optical flow in gradient direction.
    const Norm = (A1B2 + A2) * (A1B2 + A2) + (B1 + A1B2) * (B1 + A1B2);

    if (Norm) {
      const IGradNorm = 8 / Norm;
      const temp = -(C1 + C2) * IGradNorm;
      out.u = (A1B2 + A2) * temp;
      out.v = (B1 + A1B2) * temp;
    } else {
      out.u = 0;
      out.v = 0;
    }
  }

  return out;
};
/**
 * Translate an angle in degrees with the range -180 to 180 rotated to
 * Scratch's reference angle.
 * @param {number} degrees - angle in range -180 to 180
 * @returns {number} angle from Scratch's reference angle
 */


const scratchDegrees = function (degrees) {
  return (degrees + 270) % 360 - 180;
};
/**
 * Get the angle of the y and x component of a 2d vector in degrees in
 * Scratch's coordinate plane.
 * @param {number} y - the y component of a 2d vector
 * @param {number} x - the x component of a 2d vector
 * @returns {number} angle in degrees in Scratch's coordinate plane
 */


const scratchAtan2 = function (y, x) {
  return scratchDegrees(Math.atan2(y, x) * TO_DEGREE);
};

module.exports = {
  motionVector,
  scratchDegrees,
  scratchAtan2
};

/***/ }),

/***/ "./src/extensions/scratch3_wedo2/index.js":
/*!************************************************!*\
  !*** ./src/extensions/scratch3_wedo2/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");

const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const iconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAF8klEQVR4Ae2cbWxTVRjH/7ctbVc2tyEMNpWBk0VIkLcEjSAQgglTE5HEaKqJi1E/mbCP/dJA0kQbvzgTQ0Ki2T7V6AeYGoEPLJmGKPiyzZDwEpYJCHSbQIcbdLvres1zOa13Xbvdu2eTDp9fst329Lnn5XfPPfece7tphmFAmDkuccdDBDIRgUxEIBMRyEQEMhGBTEQgExHIRAQyEYFMRCATEchEBDIRgUxEIBMRyEQEMhGBTEQgExHIxMPNIByNVQBoBUDb7kgo2KTS9wBoUmFNkVCwW6U3A1gP4JJKHwxHY/S+WcW2RkLBVhV7AMAOAIMAGlWstbyOSCh4QMU2Uoy1PBVL+a7IqZu1vOZIKNg20/azBarGvKxebw9HY22RULADwBFLTBcATQnZl4lVEimN4ssteXQrQfstebQpmW1q30xshyqvxRLbofYnYW9ZYgeV8C5LLOWlzbTxM3ouHI7GPgSwWx3Z0syBSBku6IYnlTbM+uQenJQaMnKHDaqAFnDrcCFbl3G1defEjas0a4N/Vz10OybyvapfrSX1sjpo+WIz0ME7QL3djgtHPTAcjb2mepw/b2ZaGh5NL5RnofR8R99dIC5fHusK5JsrCUpm7TSx21XvbcwTNwnbAsPR2GcA3qaG+H0LsHlDPZ7fca/ujZ+cRW9/Em5vCXzlNVhQUjFpf/3OTSRvXkKJz43Xt1bh1S1LUeq/5+njQ9/iVmLIfL1ieRU2b1iFtavztXNu6TrTi8PfnYI67WdPoOp5przV9Y8iuHdb9rOW9uumPI+vDIElddBckztPOqVn5X36Xj1WVQeynx1sOWbK83jc2PviM/dFXIYNax9H55leXLoyYHsfWwI14JCRRx7x5ckBU1oheYQ+1G9u39lVM0Hej7+cR7w/Yb7e9+5LqChfaLvixcK088BwNNZkAOV02ubK6+odwt3RcfOULSSPGEveG48bNj08If3kqXPmdtO6unkpDzYn0u/TLxrzcumJJ80Ut79sygzoFF6/siw75mUYupOEpmnY0/A0pw33FTsCa+hX5oJhZXgkZb5zub2O20CnL7EwkPeCPm+wI7CEBvi5wuOZ36tJW7X3uGXJXAgxk8P4eNpRPEvgskqfuR0Z/BNGejxvDM3/5gs0pboWv+motqybCc+tqUCzz43kaBJ/X+2eMjZ3ClNsjIzo5ioknXZ2b4AlkKYltLJoaY9jOJm/B0KJbtg4c4F/XOmH3+dF9dLKbBo1OD6QQGV56YQ55ODtO0jcHkZ1VSX8/n9nB9S7RkZ1rFy+NG8ZR9s70TeQQKDEh7vJUdt1Y9/OopXFB2/WcbMpyOexE9mlFS21aLlHMmKHfzBl0QT/hV2bzM9oLXv0xG8YGR0zpdLEn6RT2k+/XjDzoLX2G3u3TZBLUyral/Z5qCyAK1f/sl2/or+IWNel1Eji3MWrpjyCZHWqdNrSe6ieSHFERl4mP+q5GehgHGvvRGal5XI5uzU47f3A/R99YTgdF2wXrmkolr9ToZ5NvTjT4yOhoC2T057CJM/r9WDxoqmXa07R9THcuDVcMO8bt4ag6ynULKvkFjWBTLl0ugZKvNlyqLeSQKfYGgOpgXt2b5zVhlzrS+Dr451YvKg0b95txztxvS8xZ+VuXFuLJ5+oNgV+9c3PuHDxGs6cu+w4v//9RJo6x5bN9UgbBo4cPY1U6j+cSD8orFvzGFYuX4KxsRQGbth6FCICc9m5dY05HtN46AQRqPB5PWjY+ZT5RnMwkxGBFh5ZVmle9Z3MrGbjwfqccrC1vajrV7QCaVCfS6qrJj96nQlFK5CujPRT7MgYyEQEMhGBTGwJpAW4kJ9pBbo0zbx70X7y7AOv8HxP3LyB4YTpb2cZBt2iqL3QEwf9zDbX+waLca439QMeC7a+YBmOxugLiM/OTt2yaOoMoO+H6LOcNwf6xusrthsh/7mIh1yFmYhAJiKQiQhkIgKZiEAmIpCJCGQiApmIQCYikIkIZCICmYhAJiKQiQhkIgKZiEAmIpCJCGQiAjkA+AeOwQKMcWZqHgAAAABJRU5ErkJggg==";
/**
 * A list of WeDo 2.0 BLE service UUIDs.
 * @enum
 */

const BLEService = {
  DEVICE_SERVICE: "00001523-1212-efde-1523-785feabcd123",
  IO_SERVICE: "00004f0e-1212-efde-1523-785feabcd123"
};
/**
 * A list of WeDo 2.0 BLE characteristic UUIDs.
 *
 * Characteristics on DEVICE_SERVICE:
 * - ATTACHED_IO
 *
 * Characteristics on IO_SERVICE:
 * - INPUT_VALUES
 * - INPUT_COMMAND
 * - OUTPUT_COMMAND
 *
 * @enum
 */

const BLECharacteristic = {
  ATTACHED_IO: "00001527-1212-efde-1523-785feabcd123",
  LOW_VOLTAGE_ALERT: "00001528-1212-efde-1523-785feabcd123",
  INPUT_VALUES: "00001560-1212-efde-1523-785feabcd123",
  INPUT_COMMAND: "00001563-1212-efde-1523-785feabcd123",
  OUTPUT_COMMAND: "00001565-1212-efde-1523-785feabcd123"
};
/**
 * A time interval to wait (in milliseconds) in between battery check calls.
 * @type {number}
 */

const BLEBatteryCheckInterval = 5000;
/**
 * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
 * @type {number}
 */

const BLESendInterval = 100;
/**
 * A maximum number of BLE message sends per second, to be enforced by the rate limiter.
 * @type {number}
 */

const BLESendRateMax = 20;
/**
 * Enum for WeDo 2.0 sensor and output types.
 * @readonly
 * @enum {number}
 */

const WeDo2Device = {
  MOTOR: 1,
  PIEZO: 22,
  LED: 23,
  TILT: 34,
  DISTANCE: 35
};
/**
 * Enum for connection/port ids assigned to internal WeDo 2.0 output devices.
 * @readonly
 * @enum {number}
 */
// TODO: Check for these more accurately at startup?

const WeDo2ConnectID = {
  LED: 6,
  PIEZO: 5
};
/**
 * Enum for ids for various output commands on the WeDo 2.0.
 * @readonly
 * @enum {number}
 */

const WeDo2Command = {
  MOTOR_POWER: 1,
  PLAY_TONE: 2,
  STOP_TONE: 3,
  WRITE_RGB: 4,
  SET_VOLUME: 255
};
/**
 * Enum for modes for input sensors on the WeDo 2.0.
 * @enum {number}
 */

const WeDo2Mode = {
  TILT: 0,
  // angle
  DISTANCE: 0,
  // detect
  LED: 1 // RGB

};
/**
 * Enum for units for input sensors on the WeDo 2.0.
 *
 * 0 = raw
 * 1 = percent
 *
 * @enum {number}
 */

const WeDo2Unit = {
  TILT: 0,
  DISTANCE: 1,
  LED: 0
};
/**
 * Manage power, direction, and timers for one WeDo 2.0 motor.
 */

class WeDo2Motor {
  /**
   * Construct a WeDo 2.0 Motor instance.
   * @param {WeDo2} parent - the WeDo 2.0 peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   */
  constructor(parent, index) {
    /**
     * The WeDo 2.0 peripheral which owns this motor.
     * @type {WeDo2}
     * @private
     */
    this._parent = parent;
    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */

    this._index = index;
    /**
     * This motor's current direction: 1 for "this way" or -1 for "that way"
     * @type {number}
     * @private
     */

    this._direction = 1;
    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */

    this._power = 100;
    /**
     * Is this motor currently moving?
     * @type {boolean}
     * @private
     */

    this._isOn = false;
    /**
     * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for
     * the end-of-action handler. Cancel this when changing plans.
     * @type {Object}
     * @private
     */

    this._pendingTimeoutId = null;
    /**
     * The starting time for the pending timeout.
     * @type {Object}
     * @private
     */

    this._pendingTimeoutStartTime = null;
    /**
     * The delay/duration of the pending timeout.
     * @type {Object}
     * @private
     */

    this._pendingTimeoutDelay = null;
    this.startBraking = this.startBraking.bind(this);
    this.turnOff = this.turnOff.bind(this);
  }
  /**
   * @return {number} - the duration of active braking after a call to startBraking(). Afterward, turn the motor off.
   * @constructor
   */


  static get BRAKE_TIME_MS() {
    return 1000;
  }
  /**
   * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
   */


  get direction() {
    return this._direction;
  }
  /**
   * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
   */


  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }
  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */


  get power() {
    return this._power;
  }
  /**
   * @param {int} value - this motor's new power level, in the range [0,100].
   */


  set power(value) {
    const p = Math.max(0, Math.min(value, 100)); // Lego Wedo 2.0 hub only turns motors at power range [30 - 100], so
    // map value from [0 - 100] to [30 - 100].

    if (p === 0) {
      this._power = 0;
    } else {
      const delta = 100 / p;
      this._power = 30 + 70 / delta;
    }
  }
  /**
   * @return {boolean} - true if this motor is currently moving, false if this motor is off or braking.
   */


  get isOn() {
    return this._isOn;
  }
  /**
   * @return {boolean} - time, in milliseconds, of when the pending timeout began.
   */


  get pendingTimeoutStartTime() {
    return this._pendingTimeoutStartTime;
  }
  /**
   * @return {boolean} - delay, in milliseconds, of the pending timeout.
   */


  get pendingTimeoutDelay() {
    return this._pendingTimeoutDelay;
  }
  /**
   * Turn this motor on indefinitely.
   */


  turnOn() {
    if (this._power === 0) return;

    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [this._power * this._direction] // power in range 0-100
    );

    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);

    this._isOn = true;

    this._clearTimeout();
  }
  /**
   * Turn this motor on for a specific duration.
   * @param {number} milliseconds - run the motor for this long.
   */


  turnOnFor(milliseconds) {
    if (this._power === 0) return;
    milliseconds = Math.max(0, milliseconds);
    this.turnOn();

    this._setNewTimeout(this.startBraking, milliseconds);
  }
  /**
   * Start active braking on this motor. After a short time, the motor will turn off.
   */


  startBraking() {
    if (this._power === 0) return;

    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [127] // 127 = break
    );

    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);

    this._isOn = false;

    this._setNewTimeout(this.turnOff, WeDo2Motor.BRAKE_TIME_MS);
  }
  /**
   * Turn this motor off.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   */


  turnOff(useLimiter = true) {
    if (this._power === 0) return;

    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [0] // 0 = stop
    );

    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd, useLimiter);

    this._isOn = false;
  }
  /**
   * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.
   * @private
   */


  _clearTimeout() {
    if (this._pendingTimeoutId !== null) {
      clearTimeout(this._pendingTimeoutId);
      this._pendingTimeoutId = null;
      this._pendingTimeoutStartTime = null;
      this._pendingTimeoutDelay = null;
    }
  }
  /**
   * Set a new motor action timeout, after clearing an existing one if necessary.
   * @param {Function} callback - to be called at the end of the timeout.
   * @param {int} delay - wait this many milliseconds before calling the callback.
   * @private
   */


  _setNewTimeout(callback, delay) {
    this._clearTimeout();

    const timeoutID = setTimeout(() => {
      if (this._pendingTimeoutId === timeoutID) {
        this._pendingTimeoutId = null;
        this._pendingTimeoutStartTime = null;
        this._pendingTimeoutDelay = null;
      }

      callback();
    }, delay);
    this._pendingTimeoutId = timeoutID;
    this._pendingTimeoutStartTime = Date.now();
    this._pendingTimeoutDelay = delay;
  }

}
/**
 * Manage communication with a WeDo 2.0 peripheral over a Bluetooth Low Energy client socket.
 */


class WeDo2 {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    this._runtime.on("PROJECT_STOP_ALL", this.stopAll.bind(this));
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * A list of the ids of the motors or sensors in ports 1 and 2.
     * @type {string[]}
     * @private
     */

    this._ports = ["none", "none"];
    /**
     * The motors which this WeDo 2.0 could possibly have.
     * @type {WeDo2Motor[]}
     * @private
     */

    this._motors = [null, null];
    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */

    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      distance: 0
    };
    /**
     * The Bluetooth connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * A rate limiter utility, to help limit the rate at which we send BLE messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */


    this._rateLimiter = new RateLimiter(BLESendRateMax);
    /**
     * An interval id for the battery check interval.
     * @type {number}
     * @private
     */

    this._batteryLevelIntervalId = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._checkBatteryLevel = this._checkBatteryLevel.bind(this);
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */


  get tiltX() {
    return this._sensors.tiltX;
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */


  get tiltY() {
    return this._sensors.tiltY;
  }
  /**
   * @return {number} - the latest value received from the distance sensor.
   */


  get distance() {
    return this._sensors.distance;
  }
  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the zero-based index of the desired motor.
   * @return {WeDo2Motor} - the WeDo2Motor instance, if any, at that index.
   */


  motor(index) {
    return this._motors[index];
  }
  /**
   * Stop all the motors that are currently running.
   */


  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        // Send the motor off command without using the rate limiter.
        // This allows the stop button to stop motors even if we are
        // otherwise flooded with commands.
        motor.turnOff(false);
      }
    });
  }
  /**
   * Set the WeDo 2.0 peripheral's LED to a specific color.
   * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.
   * @return {Promise} - a promise of the completion of the set led send operation.
   */


  setLED(inputRGB) {
    const rgb = [inputRGB >> 16 & 0x000000ff, inputRGB >> 8 & 0x000000ff, inputRGB & 0x000000ff];
    const cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, rgb);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }
  /**
   * Sets the input mode of the LED to RGB.
   * @return {Promise} - a promise returned by the send operation.
   */


  setLEDMode() {
    const cmd = this.generateInputCommand(WeDo2ConnectID.LED, WeDo2Device.LED, WeDo2Mode.LED, 0, WeDo2Unit.LED, false);
    return this.send(BLECharacteristic.INPUT_COMMAND, cmd);
  }
  /**
   * Switch off the LED on the WeDo 2.0.
   * @return {Promise} - a promise of the completion of the stop led send operation.
   */


  stopLED() {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, [0, 0, 0]);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }
  /**
   * Play a tone from the WeDo 2.0 peripheral for a specific amount of time.
   * @param {int} tone - the pitch of the tone, in Hz.
   * @param {int} milliseconds - the duration of the note, in milliseconds.
   * @return {Promise} - a promise of the completion of the play tone send operation.
   */


  playTone(tone, milliseconds) {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.PLAY_TONE, [tone, tone >> 8, milliseconds, milliseconds >> 8]);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }
  /**
   * Stop the tone playing from the WeDo 2.0 peripheral, if any.
   * @return {Promise} - a promise that the command sent.
   */


  stopTone() {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.STOP_TONE); // Send this command without using the rate limiter, because it is
    // only triggered by the stop button.

    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd, false);
  }
  /**
   * Stop the tone playing and motors on the WeDo 2.0 peripheral.
   */


  stopAll() {
    if (!this.isConnected()) return;
    this.stopTone();
    this.stopAllMotors();
  }
  /**
   * Called by the runtime when user wants to scan for a WeDo 2.0 peripheral.
   */


  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BLEService.DEVICE_SERVICE]
      }],
      optionalServices: [BLEService.IO_SERVICE]
    }, this._onConnect, this.reset);
  }
  /**
   * Called by the runtime when user wants to connect to a certain WeDo 2.0 peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }
  /**
   * Disconnects from the current BLE socket.
   */


  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    this._ports = ["none", "none"];
    this._motors = [null, null];
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      distance: 0
    };

    if (this._batteryLevelIntervalId) {
      window.clearInterval(this._batteryLevelIntervalId);
      this._batteryLevelIntervalId = null;
    }
  }
  /**
   * Called by the runtime to detect whether the WeDo 2.0 peripheral is connected.
   * @return {boolean} - the connected state.
   */


  isConnected() {
    let connected = false;

    if (this._ble) {
      connected = this._ble.isConnected();
    }

    return connected;
  }
  /**
   * Write a message to the WeDo 2.0 peripheral BLE socket.
   * @param {number} uuid - the UUID of the characteristic to write to
   * @param {Array} message - the message to write.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the write operation
   */


  send(uuid, message, useLimiter = true) {
    if (!this.isConnected()) return Promise.resolve();

    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }

    return this._ble.write(BLEService.IO_SERVICE, uuid, Utility.uint8ArrayToBase64(message), "base64");
  }
  /**
   * Generate a WeDo 2.0 'Output Command' in the byte array format
   * (CONNECT ID, COMMAND ID, NUMBER OF BYTES, VALUES ...).
   *
   * This sends a command to the WeDo 2.0 to actuate the specified outputs.
   *
   * @param  {number} connectID - the port (Connect ID) to send a command to.
   * @param  {number} commandID - the id of the byte command.
   * @param  {array}  values    - the list of values to write to the command.
   * @return {array}            - a generated output command.
   */


  generateOutputCommand(connectID, commandID, values = null) {
    let command = [connectID, commandID];

    if (values) {
      command = command.concat(values.length).concat(values);
    }

    return command;
  }
  /**
   * Generate a WeDo 2.0 'Input Command' in the byte array format
   * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),
   * UNIT, NOTIFICATIONS ENABLED).
   *
   * This sends a command to the WeDo 2.0 that sets that input format
   * of the specified inputs and sets value change notifications.
   *
   * @param  {number}  connectID           - the port (Connect ID) to send a command to.
   * @param  {number}  type                - the type of input sensor.
   * @param  {number}  mode                - the mode of the input sensor.
   * @param  {number}  delta               - the delta change needed to trigger notification.
   * @param  {array}   units               - the unit of the input sensor value.
   * @param  {boolean} enableNotifications - whether to enable notifications.
   * @return {array}                       - a generated input command.
   */


  generateInputCommand(connectID, type, mode, delta, units, enableNotifications) {
    const command = [1, // Command ID = 1 = "Sensor Format"
    2, // Command Type = 2 = "Write"
    connectID, type, mode, delta, 0, // Delta Interval Byte 2
    0, // Delta Interval Byte 3
    0, // Delta Interval Byte 4
    units, enableNotifications ? 1 : 0];
    return command;
  }
  /**
   * Sets LED mode and initial color and starts reading data from peripheral after BLE has connected.
   * @private
   */


  _onConnect() {
    this.setLEDMode();
    this.setLED(0x0000ff);

    this._ble.startNotifications(BLEService.DEVICE_SERVICE, BLECharacteristic.ATTACHED_IO, this._onMessage);

    this._batteryLevelIntervalId = window.setInterval(this._checkBatteryLevel, BLEBatteryCheckInterval);
  }
  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */


  _onMessage(base64) {
    const data = Utility.base64ToUint8Array(base64); // log.info(data);

    /**
     * If first byte of data is '1' or '2', then either clear the
     * sensor present in ports 1 or 2 or set their format.
     *
     * If first byte of data is anything else, read incoming sensor value.
     */

    switch (data[0]) {
      case 1:
      case 2:
        {
          const connectID = data[0];

          if (data[1] === 0) {
            // clear sensor or motor
            this._clearPort(connectID);
          } else {
            // register sensor or motor
            this._registerSensorOrMotor(connectID, data[3]);
          }

          break;
        }

      default:
        {
          // read incoming sensor value
          const connectID = data[1];
          const type = this._ports[connectID - 1];

          if (type === WeDo2Device.DISTANCE) {
            this._sensors.distance = data[2];
          }

          if (type === WeDo2Device.TILT) {
            this._sensors.tiltX = data[2];
            this._sensors.tiltY = data[3];
          }

          break;
        }
    }
  }
  /**
   * Check the battery level on the WeDo 2.0. If the WeDo 2.0 has disconnected
   * for some reason, the BLE socket will get an error back and automatically
   * close the socket.
   */


  _checkBatteryLevel() {
    this._ble.read(BLEService.DEVICE_SERVICE, BLECharacteristic.LOW_VOLTAGE_ALERT, false);
  }
  /**
   * Register a new sensor or motor connected at a port.  Store the type of
   * sensor or motor internally, and then register for notifications on input
   * values if it is a sensor.
   * @param {number} connectID - the port to register a sensor or motor on.
   * @param {number} type - the type ID of the sensor or motor
   * @private
   */


  _registerSensorOrMotor(connectID, type) {
    // Record which port is connected to what type of device
    this._ports[connectID - 1] = type; // Record motor port

    if (type === WeDo2Device.MOTOR) {
      this._motors[connectID - 1] = new WeDo2Motor(this, connectID - 1);
    } else {
      // Set input format for tilt or distance sensor
      const typeString = type === WeDo2Device.DISTANCE ? "DISTANCE" : "TILT";
      const cmd = this.generateInputCommand(connectID, type, WeDo2Mode[typeString], 1, WeDo2Unit[typeString], true);
      this.send(BLECharacteristic.INPUT_COMMAND, cmd);

      this._ble.startNotifications(BLEService.IO_SERVICE, BLECharacteristic.INPUT_VALUES, this._onMessage);
    }
  }
  /**
   * Clear the sensor or motor present at port 1 or 2.
   * @param {number} connectID - the port to clear.
   * @private
   */


  _clearPort(connectID) {
    const type = this._ports[connectID - 1];

    if (type === WeDo2Device.TILT) {
      this._sensors.tiltX = this._sensors.tiltY = 0;
    }

    if (type === WeDo2Device.DISTANCE) {
      this._sensors.distance = 0;
    }

    this._ports[connectID - 1] = "none";
    this._motors[connectID - 1] = null;
  }

}
/**
 * Enum for motor specification.
 * @readonly
 * @enum {string}
 */


const WeDo2MotorLabel = {
  DEFAULT: "motor",
  A: "motor A",
  B: "motor B",
  ALL: "all motors"
};
/**
 * Enum for motor direction specification.
 * @readonly
 * @enum {string}
 */

const WeDo2MotorDirection = {
  FORWARD: "this way",
  BACKWARD: "that way",
  REVERSE: "reverse"
};
/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */

const WeDo2TiltDirection = {
  UP: "up",
  DOWN: "down",
  LEFT: "left",
  RIGHT: "right",
  ANY: "any"
};
/**
 * Scratch 3.0 blocks to interact with a LEGO WeDo 2.0 peripheral.
 */

class Scratch3WeDo2Blocks {
  /**
   * @return {string} - the ID of this extension.
   */
  static get EXTENSION_ID() {
    return "wedo2";
  }
  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */


  static get TILT_THRESHOLD() {
    return 15;
  }
  /**
   * Construct a set of WeDo 2.0 blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new WeDo 2.0 peripheral instance

    this._peripheral = new WeDo2(this.runtime, Scratch3WeDo2Blocks.EXTENSION_ID);
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: Scratch3WeDo2Blocks.EXTENSION_ID,
      name: "WeDo 2.0",
      blockIconURI: iconURI,
      showStatusButton: true,
      blocks: [{
        opcode: "motorOnFor",
        text: formatMessage({
          id: "wedo2.motorOnFor",
          default: "turn [MOTOR_ID] on for [DURATION] seconds",
          description: "turn a motor on for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: "motorOn",
        text: formatMessage({
          id: "wedo2.motorOn",
          default: "turn [MOTOR_ID] on",
          description: "turn a motor on indefinitely"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: WeDo2MotorLabel.DEFAULT
          }
        }
      }, {
        opcode: "motorOff",
        text: formatMessage({
          id: "wedo2.motorOff",
          default: "turn [MOTOR_ID] off",
          description: "turn a motor off"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: WeDo2MotorLabel.DEFAULT
          }
        }
      }, {
        opcode: "startMotorPower",
        text: formatMessage({
          id: "wedo2.startMotorPower",
          default: "set [MOTOR_ID] power to [POWER]",
          description: "set the motor's power and turn it on"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: "setMotorDirection",
        text: formatMessage({
          id: "wedo2.setMotorDirection",
          default: "set [MOTOR_ID] direction to [MOTOR_DIRECTION]",
          description: "set the motor's turn direction"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: "MOTOR_ID",
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          MOTOR_DIRECTION: {
            type: ArgumentType.STRING,
            menu: "MOTOR_DIRECTION",
            defaultValue: WeDo2MotorDirection.FORWARD
          }
        }
      }, {
        opcode: "setLightHue",
        text: formatMessage({
          id: "wedo2.setLightHue",
          default: "set light color to [HUE]",
          description: "set the LED color"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: "playNoteFor",
        text: formatMessage({
          id: "wedo2.playNoteFor",
          default: "play note [NOTE] for [DURATION] seconds",
          description: "play a certain note for some time"
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          NOTE: {
            type: ArgumentType.NUMBER,
            // TODO: ArgumentType.MIDI_NOTE?
            defaultValue: 60
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.5
          }
        },
        hideFromPalette: true
      }, {
        opcode: "whenDistance",
        text: formatMessage({
          id: "wedo2.whenDistance",
          default: "when distance [OP] [REFERENCE]",
          description: "check for when distance is < or > than reference"
        }),
        blockType: BlockType.HAT,
        arguments: {
          OP: {
            type: ArgumentType.STRING,
            menu: "OP",
            defaultValue: "<"
          },
          REFERENCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: "whenTilted",
        text: formatMessage({
          id: "wedo2.whenTilted",
          default: "when tilted [TILT_DIRECTION_ANY]",
          description: "check when tilted in a certain direction"
        }),
        func: "isTilted",
        blockType: BlockType.HAT,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: "TILT_DIRECTION_ANY",
            defaultValue: WeDo2TiltDirection.ANY
          }
        }
      }, {
        opcode: "getDistance",
        text: formatMessage({
          id: "wedo2.getDistance",
          default: "distance",
          description: "the value returned by the distance sensor"
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: "isTilted",
        text: formatMessage({
          id: "wedo2.isTilted",
          default: "tilted [TILT_DIRECTION_ANY]?",
          description: "whether the tilt sensor is tilted"
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: "TILT_DIRECTION_ANY",
            defaultValue: WeDo2TiltDirection.ANY
          }
        }
      }, {
        opcode: "getTiltAngle",
        text: formatMessage({
          id: "wedo2.getTiltAngle",
          default: "tilt angle [TILT_DIRECTION]",
          description: "the angle returned by the tilt sensor"
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          TILT_DIRECTION: {
            type: ArgumentType.STRING,
            menu: "TILT_DIRECTION",
            defaultValue: WeDo2TiltDirection.UP
          }
        }
      }],
      menus: {
        MOTOR_ID: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "wedo2.motorId.default",
              default: "motor",
              description: "label for motor element in motor menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorLabel.DEFAULT
          }, {
            text: formatMessage({
              id: "wedo2.motorId.a",
              default: "motor A",
              description: "label for motor A element in motor menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorLabel.A
          }, {
            text: formatMessage({
              id: "wedo2.motorId.b",
              default: "motor B",
              description: "label for motor B element in motor menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorLabel.B
          }, {
            text: formatMessage({
              id: "wedo2.motorId.all",
              default: "all motors",
              description: "label for all motors element in motor menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorLabel.ALL
          }]
        },
        MOTOR_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "wedo2.motorDirection.forward",
              default: "this way",
              description: "label for forward element in motor direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorDirection.FORWARD
          }, {
            text: formatMessage({
              id: "wedo2.motorDirection.backward",
              default: "that way",
              description: "label for backward element in motor direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorDirection.BACKWARD
          }, {
            text: formatMessage({
              id: "wedo2.motorDirection.reverse",
              default: "reverse",
              description: "label for reverse element in motor direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2MotorDirection.REVERSE
          }]
        },
        TILT_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "wedo2.tiltDirection.up",
              default: "up",
              description: "label for up element in tilt direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2TiltDirection.UP
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.down",
              default: "down",
              description: "label for down element in tilt direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2TiltDirection.DOWN
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.left",
              default: "left",
              description: "label for left element in tilt direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2TiltDirection.LEFT
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.right",
              default: "right",
              description: "label for right element in tilt direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2TiltDirection.RIGHT
          }]
        },
        TILT_DIRECTION_ANY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: "wedo2.tiltDirection.up",
              default: "up"
            }),
            value: WeDo2TiltDirection.UP
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.down",
              default: "down"
            }),
            value: WeDo2TiltDirection.DOWN
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.left",
              default: "left"
            }),
            value: WeDo2TiltDirection.LEFT
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.right",
              default: "right"
            }),
            value: WeDo2TiltDirection.RIGHT
          }, {
            text: formatMessage({
              id: "wedo2.tiltDirection.any",
              default: "any",
              description: "label for any element in tilt direction menu for LEGO WeDo 2 extension"
            }),
            value: WeDo2TiltDirection.ANY
          }]
        },
        OP: {
          acceptReporters: true,
          items: ["<", ">"]
        }
      }
    };
  }
  /**
   * Turn specified motor(s) on for a specified duration.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} DURATION - the amount of time to run the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  motorOnFor(args) {
    // TODO: cast args.MOTOR_ID?
    let durationMS = Utility.toNumber(args.DURATION) * 1000;
    durationMS = Utility.clamp(durationMS, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(args.MOTOR_ID, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) {
          motor.turnOnFor(durationMS);
        }
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, durationMS);
    });
  }
  /**
   * Turn specified motor(s) on indefinitely.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOn(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.turnOn();
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOff(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.turnOff();
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {int} POWER - the new power level for the motor(s).
   * @return {Promise} - a Promise that resolves after some delay.
   */


  startMotorPower(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.power = Utility.clamp(Utility.toNumber(args.POWER), 0, 100);
        motor.turnOn();
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Set the direction of rotation for specified motor(s).
   * If the direction is 'reverse' the motor(s) will be reversed individually.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).
   * @return {Promise} - a Promise that resolves after some delay.
   */


  setMotorDirection(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        switch (args.MOTOR_DIRECTION) {
          case WeDo2MotorDirection.FORWARD:
            motor.direction = 1;
            break;

          case WeDo2MotorDirection.BACKWARD:
            motor.direction = -1;
            break;

          case WeDo2MotorDirection.REVERSE:
            motor.direction = -motor.direction;
            break;

          default:
            console.warn(`Unknown motor direction in setMotorDirection: ${args.DIRECTION}`);
            break;
        } // keep the motor on if it's running, and update the pending timeout if needed


        if (motor.isOn) {
          if (motor.pendingTimeoutDelay) {
            motor.turnOnFor(motor.pendingTimeoutStartTime + motor.pendingTimeoutDelay - Date.now());
          } else {
            motor.turnOn();
          }
        }
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Set the LED's hue.
   * @param {object} args - the block's arguments.
   * @property {number} HUE - the hue to set, in the range [0,100].
   * @return {Promise} - a Promise that resolves after some delay.
   */


  setLightHue(args) {
    // Convert from [0,100] to [0,360]
    let inputHue = Utility.toNumber(args.HUE);
    inputHue = Utility.wrapClamp(inputHue, 0, 100);
    const hue = inputHue * 360 / 100;
    const rgbObject = Utility.hsvToRgb({
      h: hue,
      s: 1,
      v: 1
    });
    const rgbDecimal = color.rgbToDecimal(rgbObject);

    this._peripheral.setLED(rgbDecimal);

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Make the WeDo 2.0 peripheral play a MIDI note for the specified duration.
   * @param {object} args - the block's arguments.
   * @property {number} NOTE - the MIDI note to play.
   * @property {number} DURATION - the duration of the note, in seconds.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  playNoteFor(args) {
    let durationMS = Utility.toNumber(args.DURATION) * 1000;
    durationMS = Utility.clamp(durationMS, 0, 3000);
    const note = Utility.clamp(Utility.toNumber(args.NOTE), 25, 125); // valid WeDo 2.0 sounds

    if (durationMS === 0) return; // WeDo 2.0 plays duration '0' forever

    return new Promise(resolve => {
      const tone = this._noteToTone(note);

      this._peripheral.playTone(tone, durationMS); // Run for some time even when no piezo is connected


      setTimeout(resolve, durationMS);
    });
  }
  /**
   * Compare the distance sensor's value to a reference.
   * @param {object} args - the block's arguments.
   * @property {string} OP - the comparison operation: '<' or '>'.
   * @property {number} REFERENCE - the value to compare against.
   * @return {boolean} - the result of the comparison, or false on error.
   */


  whenDistance(args) {
    switch (args.OP) {
      case "<":
        return this._peripheral.distance < Utility.toNumber(args.REFERENCE);

      case ">":
        return this._peripheral.distance > Utility.toNumber(args.REFERENCE);

      default:
        console.warn(`Unknown comparison operator in whenDistance: ${args.OP}`);
        return false;
    }
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  whenTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * @return {number} - the distance sensor's value, scaled to the [0,100] range.
   */


  getDistance() {
    return this._peripheral.distance;
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  isTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   */


  getTiltAngle(args) {
    return this._getTiltAngle(args.TILT_DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */


  _isTilted(direction) {
    switch (direction) {
      case WeDo2TiltDirection.ANY:
        return this._getTiltAngle(WeDo2TiltDirection.UP) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.DOWN) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.LEFT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.RIGHT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;

      default:
        return this._getTiltAngle(direction) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;
    }
  }
  /**
   * @param {TiltDirection} direction - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */


  _getTiltAngle(direction) {
    switch (direction) {
      case WeDo2TiltDirection.UP:
        return this._peripheral.tiltY > 45 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;

      case WeDo2TiltDirection.DOWN:
        return this._peripheral.tiltY > 45 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;

      case WeDo2TiltDirection.LEFT:
        return this._peripheral.tiltX > 45 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;

      case WeDo2TiltDirection.RIGHT:
        return this._peripheral.tiltX > 45 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;

      default:
        console.warn(`Unknown tilt direction in _getTiltAngle: ${direction}`);
    }
  }
  /**
   * Call a callback for each motor indexed by the provided motor ID.
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */


  _forEachMotor(motorID, callback) {
    let motors;

    switch (motorID) {
      case WeDo2MotorLabel.A:
        motors = [0];
        break;

      case WeDo2MotorLabel.B:
        motors = [1];
        break;

      case WeDo2MotorLabel.ALL:
      case WeDo2MotorLabel.DEFAULT:
        motors = [0, 1];
        break;

      default:
        console.warn(`Invalid motor ID: ${motorID}`);
        motors = [];
        break;
    }

    for (const index of motors) {
      callback(index);
    }
  }
  /**
   * @param {number} midiNote - the MIDI note value to convert.
   * @return {number} - the frequency, in Hz, corresponding to that MIDI note value.
   * @private
   */


  _noteToTone(midiNote) {
    // Note that MIDI note 69 is A4, 440 Hz
    return 440 * Math.pow(2, (midiNote - 69) / 12);
  }

}

module.exports = Scratch3WeDo2Blocks;

/***/ }),

/***/ "./src/import/load-costume.js":
/*!************************************!*\
  !*** ./src/import/load-costume.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const loadVector_ = function (costume, runtime, rotationCenter, optVersion) {
  return new Promise(resolve => {
    let svgString = costume.asset.decodeText(); // SVG Renderer负载修复了与Scratch 2项目相关的“怪癖”

    if (optVersion && optVersion === 2 && !runtime.v2SvgAdapter) {
      console.error("No V2 SVG adapter present; SVGs may not render correctly.");
    } else if (optVersion && optVersion === 2 && runtime.v2SvgAdapter) {
      runtime.v2SvgAdapter.loadString(svgString, true
      /* fromVersion2 */
      );
      svgString = runtime.v2SvgAdapter.toString(); // 放回仓库

      const storage = runtime.storage;
      costume.asset.encodeTextData(svgString, storage.DataFormat.SVG, true);
      costume.assetId = costume.asset.assetId;
      costume.md5 = `${costume.assetId}.${costume.dataFormat}`;
    } // 如果未提供rotationCenter，createSVGSkin会做正确的事情，因此，如果在此处未定义，则可以


    costume.skinId = runtime.renderer.createSVGSkin(svgString, rotationCenter);
    costume.size = runtime.renderer.getSkinSize(costume.skinId); // 现在我们应该有一个rotationCenter，即使我们以前没有

    if (!rotationCenter) {
      rotationCenter = runtime.renderer.getSkinRotationCenter(costume.skinId);
      costume.rotationCenterX = rotationCenter[0];
      costume.rotationCenterY = rotationCenter[1];
      costume.bitmapResolution = 1;
    }

    resolve(costume);
  });
};

const canvasPool = function () {
  /**
   * 可以重用以减少内存分配的画布对象池.以及花费在这些分配和以后的垃圾收集上的时间.
   */
  class CanvasPool {
    constructor() {
      console.log("load-costume.js class CanvasPool");
      this.pool = [];
      this.clearSoon = null;
    }
    /**
     *短暂的等待后，清除池以让VM收集垃圾.
     */


    clear() {
      if (!this.clearSoon) {
        this.clearSoon = new Promise(resolve => setTimeout(resolve, 1000)).then(() => {
          this.pool.length = 0;
          this.clearSoon = null;
        });
      }
    }
    /**
     * 返回画布。 如果池为空，则创建画布.
     * @returns {HTMLCanvasElement} A canvas element.
     */


    create() {
      return this.pool.pop() || document.createElement("canvas");
    }
    /**
     * 释放画布以重复使用.
     * @param {HTMLCanvasElement} canvas A canvas element.
     */


    release(canvas) {
      this.clear();
      this.pool.push(canvas);
    }

  }

  return new CanvasPool();
}();
/**
 * 以从存储中获取位图并将其作为画布返回
 * 如果造型具有bitmapResolution 1，则它将在此处转换为bitmapResolution 2（Scratch 3的标准）
 * 如果服装具有文本图层资产（这是Scratch 1.4的文本部分），则此功能将合并两个图像资产。
 * @param {!object} costume - 临时服装对象.
 * @param {!Runtime} runtime - 用于访问v2BitmapAdapter
 * @param {?object} rotationCenter - 可选地传递图像旋转中心的坐标. 如果未指定，则服装的旋转中心将在稍后设置为服装的中间.
 * @property {number} costume.bitmapResolution - 位图服装的分辨率比例.
 * @returns {?Promise} - a promise which will resolve to an object {canvas, rotationCenter, assetMatchesBase},
 *     or reject on error.
 *     如果资产与基础层匹配，则assetMatchesBase为true； 如果需要调整，则返回false
 */


const fetchBitmapCanvas_ = function (costume, runtime, rotationCenter) {
  console.log("load-costume.js fetchBitmapCanvas_", costume, runtime, rotationCenter);
  if (!costume || !costume.asset) return Promise.reject("Costume load failed. Assets were missing.");
  if (!runtime.v2BitmapAdapter) return Promise.reject("No V2 Bitmap adapter present.");
  return Promise.all([costume.asset, costume.textLayerAsset].map(asset => {
    if (!asset) return null;
    if (typeof createImageBitmap !== "undefined") return createImageBitmap(new Blob([asset.data], {
      type: asset.assetType.contentType
    }));
    return new Promise((resolve, reject) => {
      const image = new Image();

      image.onload = function () {
        resolve(image);
        image.onload = null;
        image.onerror = null;
      };

      image.onerror = function () {
        reject("Costume load failed. Asset could not be read.");
        image.onload = null;
        image.onerror = null;
      };

      image.src = asset.encodeDataURI();
    });
  })).then(([baseImageElement, textImageElement]) => {
    const mergeCanvas = canvasPool.create();
    const scale = costume.bitmapResolution === 1 ? 2 : 1;
    mergeCanvas.width = baseImageElement.width;
    mergeCanvas.height = baseImageElement.height;
    const ctx = mergeCanvas.getContext("2d");
    ctx.drawImage(baseImageElement, 0, 0);
    if (textImageElement) ctx.drawImage(textImageElement, 0, 0); // Track the canvas we merged the bitmaps onto separately from the
    // canvas that we receive from resize if scale is not 1. We know
    // resize treats mergeCanvas as read only data. We don't know when
    // resize may use or modify the canvas. So we'll only release the
    // mergeCanvas back into the canvas pool. Reusing the canvas from
    // resize may cause errors.

    let canvas = mergeCanvas;
    if (scale !== 1) canvas = runtime.v2BitmapAdapter.resize(mergeCanvas, canvas.width * scale, canvas.height * scale); // By scaling, we've converted it to bitmap resolution 2

    if (rotationCenter) {
      rotationCenter[0] = rotationCenter[0] * scale;
      rotationCenter[1] = rotationCenter[1] * scale;
      costume.rotationCenterX = rotationCenter[0];
      costume.rotationCenterY = rotationCenter[1];
    }

    costume.bitmapResolution = 2; // Clean up the costume object

    delete costume.textLayerMD5;
    delete costume.textLayerAsset;
    return {
      canvas,
      mergeCanvas,
      rotationCenter,
      // True if the asset matches the base layer; false if it required adjustment
      assetMatchesBase: scale === 1 && !textImageElement
    };
  }).catch(() => {
    // Clean up the text layer properties if it fails to load
    delete costume.textLayerMD5;
    delete costume.textLayerAsset;
  });
};

const loadBitmap_ = function (costume, runtime, _rotationCenter) {
  console.log("load-costume.js loadBitmap_", costume, runtime, _rotationCenter);
  return fetchBitmapCanvas_(costume, runtime, _rotationCenter).then(fetched => {
    const updateCostumeAsset = function (dataURI) {
      // 返回拒绝以停止执行updateCostumeAsset.
      if (!runtime.v2BitmapAdapter) return Promise.reject("No V2 Bitmap adapter present.");
      const storage = runtime.storage;
      costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, storage.DataFormat.PNG, runtime.v2BitmapAdapter.convertDataURIToBinary(dataURI), null, true // generate md5
      );
      costume.dataFormat = storage.DataFormat.PNG;
      costume.assetId = costume.asset.assetId;
      costume.md5 = `${costume.assetId}.${costume.dataFormat}`;
    };

    if (!fetched.assetMatchesBase) updateCostumeAsset(fetched.canvas.toDataURL());
    return fetched;
  }).then(({
    canvas,
    mergeCanvas,
    rotationCenter
  }) => {
    // 如果服装。旋转中心未定义，createBitmapSkin会做正确的事情.
    // 如果您上传位图资产或通过拍照创建资产，情况就是如此.
    let center; // fetchBitmapCanvas将确保服装的位图分辨率为2，并且其旋转中心缩放为匹配，因此始终除以2是可以的.

    if (rotationCenter) center = [rotationCenter[0] / 2, rotationCenter[1] / 2]; // TODO: 根据fetchBitmapCanvas_，此时服装.bitmapResolution将始终为2，因此我们无需在此处传递它.

    costume.skinId = runtime.renderer.createBitmapSkin(canvas, costume.bitmapResolution, center);
    canvasPool.release(mergeCanvas);
    const renderSize = runtime.renderer.getSkinSize(costume.skinId);
    costume.size = [renderSize[0] * 2, renderSize[1] * 2]; // 实际大小，因为所有位图均为分辨率2

    if (!rotationCenter) {
      rotationCenter = runtime.renderer.getSkinRotationCenter(costume.skinId); // 实际旋转中心，因为所有位图均为分辨率2

      costume.rotationCenterX = rotationCenter[0] * 2;
      costume.rotationCenterY = rotationCenter[1] * 2;
      costume.bitmapResolution = 2;
    }

    return costume;
  });
};
/**
 * 从资产异步初始化 costume 除非附加了渲染器，否则请勿调用此方法.
 * @param {!object} costume - 代表costume的对象.
 * @property {int} skinId - costume渲染皮肤的ID（安装后）.
 * @property {number} rotationCenterX - 旋转中心YX.
 * @property {number} rotationCenterY - 旋转中心Y.
 * @property {number} [bitmapResolution] - 位图costume的分辨率比例.
 * @property {!Asset} costume.asset - 从存储中加载的costume资产.
 * @param {!Runtime} runtime - 运行时，用于访问存储模块.
 * @param {?int} optVersion - 造型来自哪个版本？2.0or3.0..
 * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.
 */


const loadCostumeFromAsset = function (costume, runtime, optVersion) {
  console.log("vm load-costume.js loadCostumeFromAsset costume ", costume, runtime, optVersion);
  costume.assetId = costume.asset.assetId;
  const renderer = runtime.renderer;

  if (!renderer) {
    console.error("No rendering module present; cannot load costume: ", costume.name);
    return Promise.resolve(costume);
  }

  const AssetType = runtime.storage.AssetType;
  let rotationCenter; // 如果定义了旋转中心和分辨率，请使用它们。 位图分辨率只能为1或2.

  if (typeof costume.rotationCenterX === "number" && !isNaN(costume.rotationCenterX) && typeof costume.rotationCenterY === "number" && !isNaN(costume.rotationCenterY)) {
    rotationCenter = [costume.rotationCenterX, costume.rotationCenterY];
  }

  if (costume.asset.assetType.runtimeFormat === AssetType.ImageVector.runtimeFormat) {
    return loadVector_(costume, runtime, rotationCenter, optVersion).catch(error => {
      console.warn(`Error loading vector image: ${error.name}: ${error.message}`); // Use default asset if original fails to load

      costume.assetId = runtime.storage.defaultAssetId.ImageVector;
      costume.asset = runtime.storage.get(costume.assetId);
      costume.md5 = `${costume.assetId}.${AssetType.ImageVector.runtimeFormat}`;
      return loadVector_(costume, runtime);
    });
  }

  return loadBitmap_(costume, runtime, rotationCenter, optVersion);
};
/**
 * 将服装的资产异步加载到内存中.除非附加了渲染器，否则请勿调用此方法.
 * @param {string} md5ext - MD5和要加载的costume的扩展名.
 * @param {!object} costume - 代表costume的对象.
 * @property {int} skinId - costume渲染皮肤的ID（安装后）.
 * @property {number} rotationCenterX - 旋转中心YX.
 * @property {number} rotationCenterY - 旋转中心Y.
 * @property {number} [bitmapResolution] - 位图costume的分辨率比例.
 * @param {!Runtime} runtime - 运行时，用于访问存储模块.
 * @param {?int} optVersion - 造型来自哪个版本？2.0or3.0.
 * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.
 */


const loadCostume = function (md5ext, costume, runtime, optVersion) {
  console.log("vm load-costume.js loadCostume 将造型资源异步加载到内存中 ", md5ext, costume, runtime, optVersion);
  const idParts = StringUtil.splitFirst(md5ext, ".");
  const md5 = idParts[0];
  const ext = idParts[1].toLowerCase();
  costume.dataFormat = ext; // Costume 附带资产。 它可能来自相机，图像上传，拖放或文件

  if (costume.asset) return loadCostumeFromAsset(costume, runtime, optVersion); // 需要从存储中加载costume。 服务器应对此md5进行引用 .

  if (!runtime.storage) {
    console.error("No storage module present; cannot load costume asset: ", md5ext);
    return Promise.resolve(costume);
  }

  if (!runtime.storage.defaultAssetId) {
    console.error(`No default assets found`);
    return Promise.resolve(costume);
  }

  const AssetType = runtime.storage.AssetType;
  const assetType = ext === "svg" ? AssetType.ImageVector : AssetType.ImageBitmap;
  const costumePromise = runtime.storage.load(assetType, md5, ext);

  if (!costumePromise) {
    console.error(`Couldn't fetch costume asset: ${md5ext}`);
    return;
  }

  let textLayerPromise;

  if (costume.textLayerMD5) {
    textLayerPromise = runtime.storage.load(AssetType.ImageBitmap, costume.textLayerMD5, "png");
  } else {
    textLayerPromise = Promise.resolve(null);
  }

  return Promise.all([costumePromise, textLayerPromise]).then(assetArray => {
    costume.asset = assetArray[0];
    if (assetArray[1]) costume.textLayerAsset = assetArray[1];
    console.log("vm load-costume.js loadCostume Promise.all 将服装的资产异步加载到内存中 ", md5ext, costume, runtime, optVersion);
    return loadCostumeFromAsset(costume, runtime, optVersion);
  });
};

module.exports = {
  loadCostume,
  loadCostumeFromAsset
};

/***/ }),

/***/ "./src/import/load-sound.js":
/*!**********************************!*\
  !*** ./src/import/load-sound.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");
/**
 * Initialize a sound from an asset asynchronously.
 * @param {!object} sound - the Scratch sound object.
 * @property {string} md5 - the MD5 and extension of the sound to be loaded.
 * @property {Buffer} data - sound data will be written here once loaded.
 * @param {!Asset} soundAsset - the asset loaded from storage.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {SoundBank} soundBank - Scratch Audio SoundBank to add sounds to.
 * @returns {!Promise} - a promise which will resolve to the sound when ready.
 */


const loadSoundFromAsset = function (sound, soundAsset, runtime, soundBank) {
  sound.assetId = soundAsset.assetId;

  if (!runtime.audioEngine) {
    console.error("No audio engine present; cannot load sound asset: ", sound.md5);
    return Promise.resolve(sound);
  }

  return runtime.audioEngine.decodeSoundPlayer(Object.assign({}, sound, {
    data: soundAsset.data
  })).then(soundPlayer => {
    sound.soundId = soundPlayer.id; // 由于声音被音频引擎重新采样，因此根据来自音频引擎的音频缓冲区设置声音采样率和采样计数

    const soundBuffer = soundPlayer.buffer;
    sound.rate = soundBuffer.sampleRate;
    sound.sampleCount = soundBuffer.length;

    if (soundBank !== null) {
      soundBank.addSoundPlayer(soundPlayer);
    }

    return sound;
  });
};
/**
 * Load a sound's asset into memory asynchronously.
 * @param {!object} sound - the Scratch sound object.
 * @property {string} md5 - the MD5 and extension of the sound to be loaded.
 * @property {Buffer} data - sound data will be written here once loaded.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {SoundBank} soundBank - Scratch Audio SoundBank to add sounds to.
 * @returns {!Promise} - a promise which will resolve to the sound when ready.
 */


const loadSound = function (sound, runtime, soundBank) {
  if (!runtime.storage) {
    console.error("No storage module present; cannot load sound asset: ", sound.md5);
    return Promise.resolve(sound);
  }

  const idParts = StringUtil.splitFirst(sound.md5, ".");
  const md5 = idParts[0];
  const ext = idParts[1].toLowerCase();
  sound.dataFormat = ext;
  return (sound.asset && Promise.resolve(sound.asset) || runtime.storage.load(runtime.storage.AssetType.Sound, md5, ext)).then(soundAsset => {
    sound.asset = soundAsset;
    return loadSoundFromAsset(sound, soundAsset, runtime, soundBank);
  });
};

module.exports = {
  loadSound,
  loadSoundFromAsset
};

/***/ }),

/***/ "./src/index.js-exposed":
/*!******************************!*\
  !*** ./src/index.js-exposed ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["VirtualMachine"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib!./index.js */ "./node_modules/babel-loader/lib/index.js!./src/index.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/io/ble.js":
/*!***********************!*\
  !*** ./src/io/ble.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const JSONRPC = __webpack_require__(/*! ../util/jsonrpc */ "./src/util/jsonrpc.js");

class BLE extends JSONRPC {
  /**
   * A BLE peripheral socket object.  It handles connecting, over web sockets, to
   * BLE peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this socket.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   */
  constructor(runtime, extensionId, peripheralOptions, connectCallback, resetCallback = null) {
    super();
    this._socket = runtime.getScratchLinkSocket('BLE');

    this._socket.setOnOpen(this.requestPeripheral.bind(this));

    this._socket.setOnClose(this.handleDisconnectError.bind(this));

    this._socket.setOnError(this._handleRequestError.bind(this));

    this._socket.setHandleMessage(this._handleMessage.bind(this));

    this._sendMessage = this._socket.sendMessage.bind(this._socket);
    this._availablePeripherals = {};
    this._connectCallback = connectCallback;
    this._connected = false;
    this._characteristicDidChangeCallback = null;
    this._resetCallback = resetCallback;
    this._discoverTimeoutID = null;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._runtime = runtime;

    this._socket.open();
  }
  /**
   * Request connection to the peripheral.
   * If the web socket is not yet open, request when the socket promise resolves.
   */


  requestPeripheral() {
    this._availablePeripherals = {};

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
    this.sendRemoteRequest('discover', this._peripheralOptions).catch(e => {
      this._handleRequestError(e);
    });
  }
  /**
   * Try connecting to the input peripheral id, and then call the connect
   * callback if connection is successful.
   * @param {number} id - the id of the peripheral to connect to
   */


  connectPeripheral(id) {
    this.sendRemoteRequest('connect', {
      peripheralId: id
    }).then(() => {
      this._connected = true;

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);

      this._connectCallback();
    }).catch(e => {
      this._handleRequestError(e);
    });
  }
  /**
   * Close the websocket.
   */


  disconnect() {
    if (this._connected) {
      this._connected = false;
    }

    if (this._socket.isOpen()) {
      this._socket.close();
    }

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    } // Sets connection status icon to orange


    this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
  }
  /**
   * @return {bool} whether the peripheral is connected.
   */


  isConnected() {
    return this._connected;
  }
  /**
   * Start receiving notifications from the specified ble service.
   * @param {number} serviceId - the ble service to read.
   * @param {number} characteristicId - the ble characteristic to get notifications from.
   * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
   * @return {Promise} - a promise from the remote startNotifications request.
   */


  startNotifications(serviceId, characteristicId, onCharacteristicChanged = null) {
    const params = {
      serviceId,
      characteristicId
    };
    this._characteristicDidChangeCallback = onCharacteristicChanged;
    return this.sendRemoteRequest('startNotifications', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Read from the specified ble service.
   * @param {number} serviceId - the ble service to read.
   * @param {number} characteristicId - the ble characteristic to read.
   * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
   * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
   * @return {Promise} - a promise from the remote read request.
   */


  read(serviceId, characteristicId, optStartNotifications = false, onCharacteristicChanged = null) {
    const params = {
      serviceId,
      characteristicId
    };

    if (optStartNotifications) {
      params.startNotifications = true;
    }

    if (onCharacteristicChanged) {
      this._characteristicDidChangeCallback = onCharacteristicChanged;
    }

    return this.sendRemoteRequest('read', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Write data to the specified ble service.
   * @param {number} serviceId - the ble service to write.
   * @param {number} characteristicId - the ble characteristic to write.
   * @param {string} message - the message to send.
   * @param {string} encoding - the message encoding type.
   * @param {boolean} withResponse - if true, resolve after peripheral's response.
   * @return {Promise} - a promise from the remote send request.
   */


  write(serviceId, characteristicId, message, encoding = null, withResponse = null) {
    const params = {
      serviceId,
      characteristicId,
      message
    };

    if (encoding) {
      params.encoding = encoding;
    }

    if (withResponse !== null) {
      params.withResponse = withResponse;
    }

    return this.sendRemoteRequest('write', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Handle a received call from the socket.
   * @param {string} method - a received method label.
   * @param {object} params - a received list of parameters.
   * @return {object} - optional return value.
   */


  didReceiveCall(method, params) {
    switch (method) {
      case 'didDiscoverPeripheral':
        this._availablePeripherals[params.peripheralId] = params;

        this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);

        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        break;

      case 'characteristicDidChange':
        if (this._characteristicDidChangeCallback) {
          this._characteristicDidChangeCallback(params.message);
        }

        break;

      case 'ping':
        return 42;
    }
  }
  /**
   * Handle an error resulting from losing connection to a peripheral.
   *
   * This could be due to:
   * - battery depletion
   * - going out of bluetooth range
   * - being powered down
   *
   * Disconnect the socket, and if the extension using this socket has a
   * reset callback, call it. Finally, emit an error to the runtime.
   */


  handleDisconnectError()
  /* e */
  {
    // log.error(`BLE error: ${JSON.stringify(e)}`);
    if (!this._connected) return;
    this.disconnect();

    if (this._resetCallback) {
      this._resetCallback();
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
      message: `Scratch lost connection to`,
      extensionId: this._extensionId
    });
  }

  _handleRequestError()
  /* e */
  {
    // log.error(`BLE error: ${JSON.stringify(e)}`);
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
      message: `Scratch lost connection to`,
      extensionId: this._extensionId
    });
  }

  _handleDiscoverTimeout() {
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
  }

}

module.exports = BLE;

/***/ }),

/***/ "./src/io/bt.js":
/*!**********************!*\
  !*** ./src/io/bt.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const JSONRPC = __webpack_require__(/*! ../util/jsonrpc */ "./src/util/jsonrpc.js");

class BT extends JSONRPC {
  /**
   * A BT peripheral socket object.  It handles connecting, over web sockets, to
   * BT peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this socket.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   * @param {object} messageCallback - a callback for message sending.
   */
  constructor(runtime, extensionId, peripheralOptions, connectCallback, resetCallback = null, messageCallback) {
    super();
    this._socket = runtime.getScratchLinkSocket('BT');

    this._socket.setOnOpen(this.requestPeripheral.bind(this));

    this._socket.setOnError(this._handleRequestError.bind(this));

    this._socket.setOnClose(this.handleDisconnectError.bind(this));

    this._socket.setHandleMessage(this._handleMessage.bind(this));

    this._sendMessage = this._socket.sendMessage.bind(this._socket);
    this._availablePeripherals = {};
    this._connectCallback = connectCallback;
    this._connected = false;
    this._characteristicDidChangeCallback = null;
    this._resetCallback = resetCallback;
    this._discoverTimeoutID = null;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._messageCallback = messageCallback;
    this._runtime = runtime;

    this._socket.open();
  }
  /**
   * Request connection to the peripheral.
   * If the web socket is not yet open, request when the socket promise resolves.
   */


  requestPeripheral() {
    this._availablePeripherals = {};

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
    this.sendRemoteRequest('discover', this._peripheralOptions).catch(e => this._handleRequestError(e));
  }
  /**
   * Try connecting to the input peripheral id, and then call the connect
   * callback if connection is successful.
   * @param {number} id - the id of the peripheral to connect to
   * @param {string} pin - an optional pin for pairing
   */


  connectPeripheral(id, pin = null) {
    const params = {
      peripheralId: id
    };

    if (pin) {
      params.pin = pin;
    }

    this.sendRemoteRequest('connect', params).then(() => {
      this._connected = true;

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);

      this._connectCallback();
    }).catch(e => {
      this._handleRequestError(e);
    });
  }
  /**
   * Close the websocket.
   */


  disconnect() {
    if (this._connected) {
      this._connected = false;
    }

    if (this._socket.isOpen()) {
      this._socket.close();
    }

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    } // Sets connection status icon to orange


    this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
  }
  /**
   * @return {bool} whether the peripheral is connected.
   */


  isConnected() {
    return this._connected;
  }

  sendMessage(options) {
    return this.sendRemoteRequest('send', options).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Handle a received call from the socket.
   * @param {string} method - a received method label.
   * @param {object} params - a received list of parameters.
   * @return {object} - optional return value.
   */


  didReceiveCall(method, params) {
    // TODO: Add peripheral 'undiscover' handling
    switch (method) {
      case 'didDiscoverPeripheral':
        this._availablePeripherals[params.peripheralId] = params;

        this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);

        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        break;

      case 'didReceiveMessage':
        this._messageCallback(params); // TODO: refine?


        break;

      default:
        return 'nah';
    }
  }
  /**
   * Handle an error resulting from losing connection to a peripheral.
   *
   * This could be due to:
   * - battery depletion
   * - going out of bluetooth range
   * - being powered down
   *
   * Disconnect the socket, and if the extension using this socket has a
   * reset callback, call it. Finally, emit an error to the runtime.
   */


  handleDisconnectError()
  /* e */
  {
    // log.error(`BT error: ${JSON.stringify(e)}`);
    if (!this._connected) return;
    this.disconnect();

    if (this._resetCallback) {
      this._resetCallback();
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
      message: `Scratch lost connection to`,
      extensionId: this._extensionId
    });
  }

  _handleRequestError()
  /* e */
  {
    // log.error(`BT error: ${JSON.stringify(e)}`);
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
      message: `Scratch lost connection to`,
      extensionId: this._extensionId
    });
  }

  _handleDiscoverTimeout() {
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
  }

}

module.exports = BT;

/***/ }),

/***/ "./src/io/clock.js":
/*!*************************!*\
  !*** ./src/io/clock.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

class Clock {
  constructor(runtime) {
    this._projectTimer = new Timer({
      now: () => runtime.currentMSecs
    });

    this._projectTimer.start();

    this._pausedTime = null;
    this._paused = false;
    /**
     * Reference to the owning Runtime.
     * @type{!Runtime}
     */

    this.runtime = runtime;
  }

  projectTimer() {
    if (this._paused) {
      return this._pausedTime / 1000;
    }

    return this._projectTimer.timeElapsed() / 1000;
  }

  pause() {
    this._paused = true;
    this._pausedTime = this._projectTimer.timeElapsed();
  }

  resume() {
    this._paused = false;

    const dt = this._projectTimer.timeElapsed() - this._pausedTime;

    this._projectTimer.startTime += dt;
  }

  resetProjectTimer() {
    this._projectTimer.start();
  }

}

module.exports = Clock;

/***/ }),

/***/ "./src/io/cloud.js":
/*!*************************!*\
  !*** ./src/io/cloud.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

class Cloud {
  /**
   * @typedef updateVariable
   * @param {string} name The name of the cloud variable to update on the server
   * @param {(string | number)} value The value to update the cloud variable with.
   */

  /**
   * A cloud data provider, responsible for managing the connection to the
   * cloud data server and for posting data about cloud data activity to
   * this IO device.
   * @typedef {object} CloudProvider
   * @property {updateVariable} updateVariable A function which sends a cloud variable
   * update to the cloud data server.
   * @property {Function} requestCloseConnection A function which closes
   * the connection to the cloud data server.
   */

  /**
   * Part of a cloud io data post indicating a cloud variable update.
   * @typedef {object} VarUpdateData
   * @property {string} name The name of the variable to update
   * @property {(number | string)} value The scalar value to update the variable with
   */

  /**
   * A cloud io data post message.
   * @typedef {object} CloudIOData
   * @property {VarUpdateData} varUpdate A {@link VarUpdateData} message indicating
   * a cloud variable update
   */

  /**
   * Cloud IO Device responsible for sending and receiving messages from
   * cloud provider (mananging the cloud server connection) and interacting
   * with cloud variables in the current project.
   * @param {Runtime} runtime The runtime context for this cloud io device.
   */
  constructor(runtime) {
    /**
     * Reference to the cloud data provider, responsible for mananging
     * the web socket connection to the cloud data server.
     * @type {?CloudProvider}
     */
    this.provider = null;
    /**
     * Reference to the runtime that owns this cloud io device.
     * @type {!Runtime}
     */

    this.runtime = runtime;
    /**
     * Reference to the stage target which owns the cloud variables
     * in the project.
     * @type {?Target}
     */

    this.stage = null;
  }
  /**
   * Set a reference to the cloud data provider.
   * @param {CloudProvider} provider The cloud data provider
   */


  setProvider(provider) {
    this.provider = provider;
  }
  /**
   * Set a reference to the stage target which owns the
   * cloud variables in the project.
   * @param {Target} stage The stage target
   */


  setStage(stage) {
    this.stage = stage;
  }
  /**
   * Handle incoming data to this io device.
   * @param {CloudIOData} data The {@link CloudIOData} object to process
   */


  postData(data) {
    if (data.varUpdate) {
      this.updateCloudVariable(data.varUpdate);
    }
  }

  requestCreateVariable(variable) {
    if (this.runtime.canAddCloudVariable()) {
      if (this.provider) {
        this.provider.createVariable(variable.name, variable.value); // We'll set the cloud flag and update the
        // cloud variable limit when we actually
        // get a confirmation from the cloud data server
      }
    } // TODO else track creation for later

  }
  /**
   * Request the cloud data provider to update the given variable with
   * the given value. Does nothing if this io device does not have a provider set.
   * @param {string} name The name of the variable to update
   * @param {string | number} value The value to update the variable with
   */


  requestUpdateVariable(name, value) {
    if (this.provider) {
      this.provider.updateVariable(name, value);
    }
  }
  /**
   * Request the cloud data provider to rename the variable with the given name
   * to the given new name. Does nothing if this io device does not have a provider set.
   * @param {string} oldName The name of the variable to rename
   * @param {string | number} newName The new name for the variable
   */


  requestRenameVariable(oldName, newName) {
    if (this.provider) {
      this.provider.renameVariable(oldName, newName);
    }
  }
  /**
   * Request the cloud data provider to delete the variable with the given name
   * Does nothing if this io device does not have a provider set.
   * @param {string} name The name of the variable to delete
   */


  requestDeleteVariable(name) {
    if (this.provider) {
      this.provider.deleteVariable(name);
    }
  }
  /**
   * Update a cloud variable in the runtime based on the message received
   * from the cloud provider.
   * @param {VarData} varUpdate A {@link VarData} object describing
   * a cloud variable update received from the cloud data provider.
   */


  updateCloudVariable(varUpdate) {
    const varName = varUpdate.name;
    const variable = this.stage.lookupVariableByNameAndType(varName, Variable.SCALAR_TYPE);

    if (!variable || !variable.isCloud) {
      console.warn(`Received an update for a cloud variable that does not exist: ${varName}`);
      return;
    }

    variable.value = varUpdate.value;
  }
  /**
   * Request the cloud data provider to close the web socket connection and
   * clear this io device of references to the cloud data provider and the
   * stage.
   */


  clear() {
    if (!this.provider) return;
    this.provider.requestCloseConnection();
    this.provider = null;
    this.stage = null;
  }

}

module.exports = Cloud;

/***/ }),

/***/ "./src/io/keyboard.js":
/*!****************************!*\
  !*** ./src/io/keyboard.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Names used internally for keys used in scratch, also known as "scratch keys".
 * @enum {string}
 */
const KEY_NAME = {
  SPACE: "space",
  LEFT: "left arrow",
  UP: "up arrow",
  RIGHT: "right arrow",
  DOWN: "down arrow",
  ENTER: "enter"
};
/**
 * An array of the names of scratch keys.
 * @type {Array<string>}
 */

const KEY_NAME_LIST = Object.keys(KEY_NAME).map(name => KEY_NAME[name]);

class Keyboard {
  constructor(runtime) {
    /**
     * List of currently pressed scratch keys.
     * A scratch key is:
     * A key you can press on a keyboard, excluding modifier keys.
     * An uppercase string of length one;
     *     except for special key names for arrow keys and space (e.g. 'left arrow').
     * Can be a non-english unicode letter like: æ ø ש נ 手 廿.
     * @type{Array.<string>}
     */
    this._keysPressed = [];
    /**
     * Reference to the owning Runtime.
     * Can be used, for example, to activate hats.
     * @type{!Runtime}
     */

    this.runtime = runtime;
  }
  /**
   * Convert from a keyboard event key name to a Scratch key name.
   * @param  {string} keyString the input key string.
   * @return {string} the corresponding Scratch key, or an empty string.
   */


  _keyStringToScratchKey(keyString) {
    keyString = String(keyString); // Convert space and arrow keys to their Scratch key names.

    switch (keyString) {
      case " ":
        return KEY_NAME.SPACE;

      case "ArrowLeft":
      case "Left":
        return KEY_NAME.LEFT;

      case "ArrowUp":
      case "Up":
        return KEY_NAME.UP;

      case "Right":
      case "ArrowRight":
        return KEY_NAME.RIGHT;

      case "Down":
      case "ArrowDown":
        return KEY_NAME.DOWN;

      case "Enter":
        return KEY_NAME.ENTER;
    } // Ignore modifier keys


    if (keyString.length > 1) {
      return "";
    }

    return keyString.toUpperCase();
  }
  /**
   * Convert from a block argument to a Scratch key name.
   * @param  {string} keyArg the input arg.
   * @return {string} the corresponding Scratch key.
   */


  _keyArgToScratchKey(keyArg) {
    // If a number was dropped in, try to convert from ASCII to Scratch key.
    if (typeof keyArg === "number") {
      // Check for the ASCII range containing numbers, some punctuation,
      // and uppercase letters.
      if (keyArg >= 48 && keyArg <= 90) {
        return String.fromCharCode(keyArg);
      }

      switch (keyArg) {
        case 32:
          return KEY_NAME.SPACE;

        case 37:
          return KEY_NAME.LEFT;

        case 38:
          return KEY_NAME.UP;

        case 39:
          return KEY_NAME.RIGHT;

        case 40:
          return KEY_NAME.DOWN;
      }
    }

    keyArg = String(keyArg); // If the arg matches a special key name, return it.

    if (KEY_NAME_LIST.includes(keyArg)) {
      return keyArg;
    } // Use only the first character.


    if (keyArg.length > 1) {
      keyArg = keyArg[0];
    } // Check for the space character.


    if (keyArg === " ") {
      return KEY_NAME.SPACE;
    }

    return keyArg.toUpperCase();
  }
  /**
   * Keyboard DOM event handler.
   * @param  {object} data Data from DOM event.
   */


  postData(data) {
    if (!data.key) return;

    const scratchKey = this._keyStringToScratchKey(data.key);

    if (scratchKey === "") return;

    const index = this._keysPressed.indexOf(scratchKey);

    if (data.isDown) {
      this.runtime.emit("KEY_PRESSED", scratchKey); // If not already present, add to the list.

      if (index < 0) {
        this._keysPressed.push(scratchKey);
      }
    } else if (index > -1) {
      // If already present, remove from the list.
      this._keysPressed.splice(index, 1);
    }
  }
  /**
   * Get key down state for a specified key.
   * @param  {Any} keyArg key argument.
   * @return {boolean} Is the specified key down?
   */


  getKeyIsDown(keyArg) {
    if (keyArg === "any") {
      return this._keysPressed.length > 0;
    }

    const scratchKey = this._keyArgToScratchKey(keyArg);

    return this._keysPressed.indexOf(scratchKey) > -1;
  }

}

module.exports = Keyboard;

/***/ }),

/***/ "./src/io/mouse.js":
/*!*************************!*\
  !*** ./src/io/mouse.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

class Mouse {
  constructor(runtime) {
    this._x = 0;
    this._y = 0;
    this._isDown = false;
    /**
     * Reference to the owning Runtime.
     * Can be used, for example, to activate hats.
     * @type{!Runtime}
     */

    this.runtime = runtime;
  }
  /**
   * Activate "event_whenthisspriteclicked" hats.
   * @param  {Target} target to trigger hats on.
   * @private
   */


  _activateClickHats(target) {
    // Activate both "this sprite clicked" and "stage clicked"
    // They were separated into two opcodes for labeling,
    // but should act the same way.
    // Intentionally not checking isStage to make it work when sharing blocks.
    // @todo the blocks should be converted from one to another when shared
    this.runtime.startHats("event_whenthisspriteclicked", null, target);
    this.runtime.startHats("event_whenstageclicked", null, target);
  }
  /**
   * Find a target by XY location
   * @param  {number} x X position to be sent to the renderer.
   * @param  {number} y Y position to be sent to the renderer.
   * @return {Target} the target at that location
   * @private
   */


  _pickTarget(x, y) {
    if (this.runtime.renderer) {
      const drawableID = this.runtime.renderer.pick(x, y);

      for (let i = 0; i < this.runtime.targets.length; i++) {
        const target = this.runtime.targets[i];

        if (target.hasOwnProperty("drawableID") && target.drawableID === drawableID) {
          return target;
        }
      }
    } // Return the stage if no target was found


    return this.runtime.getTargetForStage();
  }
  /**
   * Mouse DOM event handler.
   * @param  {object} data Data from DOM event.
   */


  postData(data) {
    if (data.x) {
      this._clientX = data.x;
      this._scratchX = Math.round(Utility.clamp(480 * (data.x / data.canvasWidth - 0.5), -240, 240));
    }

    if (data.y) {
      this._clientY = data.y;
      this._scratchY = Math.round(Utility.clamp(-360 * (data.y / data.canvasHeight - 0.5), -180, 180));
    }

    if (typeof data.isDown !== "undefined") {
      const previousDownState = this._isDown;
      this._isDown = data.isDown; // Do not trigger if down state has not changed

      if (previousDownState === this._isDown) return; // Never trigger click hats at the end of a drag

      if (data.wasDragged) return; // Do not activate click hats for clicks outside canvas bounds

      if (!(data.x > 0 && data.x < data.canvasWidth && data.y > 0 && data.y < data.canvasHeight)) return;

      const target = this._pickTarget(data.x, data.y);

      const isNewMouseDown = !previousDownState && this._isDown;
      const isNewMouseUp = previousDownState && !this._isDown; // Draggable targets start click hats on mouse up.
      // Non-draggable targets start click hats on mouse down.

      if (target.draggable && isNewMouseUp) {
        this._activateClickHats(target);
      } else if (!target.draggable && isNewMouseDown) {
        this._activateClickHats(target);
      }
    }
  }
  /**
   * Get the X position of the mouse in client coordinates.
   * @return {number} Non-clamped X position of the mouse cursor.
   */


  getClientX() {
    return this._clientX;
  }
  /**
   * Get the Y position of the mouse in client coordinates.
   * @return {number} Non-clamped Y position of the mouse cursor.
   */


  getClientY() {
    return this._clientY;
  }
  /**
   * Get the X position of the mouse in scratch coordinates.
   * @return {number} Clamped and integer rounded X position of the mouse cursor.
   */


  getScratchX() {
    return this._scratchX;
  }
  /**
   * Get the Y position of the mouse in scratch coordinates.
   * @return {number} Clamped and integer rounded Y position of the mouse cursor.
   */


  getScratchY() {
    return this._scratchY;
  }
  /**
   * Get the down state of the mouse.
   * @return {boolean} Is the mouse down?
   */


  getIsDown() {
    return this._isDown;
  }

}

module.exports = Mouse;

/***/ }),

/***/ "./src/io/mouseWheel.js":
/*!******************************!*\
  !*** ./src/io/mouseWheel.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

class MouseWheel {
  constructor(runtime) {
    /**
     * Reference to the owning Runtime.
     * @type{!Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Mouse wheel DOM event handler.
   * @param  {object} data Data from DOM event.
   */


  postData(data) {
    const matchFields = {};

    if (data.deltaY < 0) {
      matchFields.KEY_OPTION = 'up arrow';
    } else if (data.deltaY > 0) {
      matchFields.KEY_OPTION = 'down arrow';
    } else {
      return;
    }

    this.runtime.startHats('event_whenkeypressed', matchFields);
  }

}

module.exports = MouseWheel;

/***/ }),

/***/ "./src/io/userData.js":
/*!****************************!*\
  !*** ./src/io/userData.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

class UserData {
  constructor() {
    this._username = "";
  }
  /**
   * 用于更新用户名的处理程序
   * @param {object} data 数据发布到此ioDevice.
   * @property {!string} username 新的用户名.
   */


  postData(data) {
    this._username = data.username;
  }
  /**
   * 用户名的获取器。 最初为空字符串，直到通过postData设置.
   * @returns {!string} 当前的用户名
   */


  getUsername() {
    return this._username;
  }

}

module.exports = UserData;

/***/ }),

/***/ "./src/io/video.js":
/*!*************************!*\
  !*** ./src/io/video.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

class Video {
  constructor(runtime) {
    this.runtime = runtime;
    /**
     * @typedef VideoProvider
     * @property {Function} enableVideo - Requests camera access from the user, and upon success,
     * enables the video feed
     * @property {Function} disableVideo - Turns off the video feed
     * @property {Function} getFrame - Return frame data from the video feed in
     * specified dimensions, format, and mirroring.
     */

    this.provider = null;
    /**
     * Id representing a Scratch Renderer skin the video is rendered to for
     * previewing.
     * @type {number}
     */

    this._skinId = -1;
    /**
     * Id for a drawable using the video's skin that will render as a video
     * preview.
     * @type {Drawable}
     */

    this._drawable = -1;
    /**
     * Store the last state of the video transparency ghost effect
     * @type {number}
     */

    this._ghost = 0;
    /**
     * Store a flag that allows the preview to be forced transparent.
     * @type {number}
     */

    this._forceTransparentPreview = false;
  }

  static get FORMAT_IMAGE_DATA() {
    return 'image-data';
  }

  static get FORMAT_CANVAS() {
    return 'canvas';
  }
  /**
   * Dimensions the video stream is analyzed at after its rendered to the
   * sample canvas.
   * @type {Array.<number>}
   */


  static get DIMENSIONS() {
    return [480, 360];
  }
  /**
   * Order preview drawable is inserted at in the renderer.
   * @type {number}
   */


  static get ORDER() {
    return 1;
  }
  /**
   * Set a video provider for this device. A default implementation of
   * a video provider can be found in scratch-gui/src/lib/video/video-provider
   * @param {VideoProvider} provider - Video provider to use
   */


  setProvider(provider) {
    this.provider = provider;
  }
  /**
   * Request video be enabled.  Sets up video, creates video skin and enables preview.
   *
   * ioDevices.video.requestVideo()
   *
   * @return {Promise.<Video>} resolves a promise to this IO device when video is ready.
   */


  enableVideo() {
    if (!this.provider) return null;
    return this.provider.enableVideo().then(() => this._setupPreview());
  }
  /**
   * Disable video stream (turn video off)
   * @return {void}
   */


  disableVideo() {
    this._disablePreview();

    if (!this.provider) return null;
    this.provider.disableVideo();
  }
  /**
   * Return frame data from the video feed in a specified dimensions, format, and mirroring.
   *
   * @param {object} frameInfo A descriptor of the frame you would like to receive.
   * @param {Array.<number>} frameInfo.dimensions [width, height] array of numbers.  Defaults to [480,360]
   * @param {boolean} frameInfo.mirror If you specificly want a mirror/non-mirror frame, defaults to the global
   *                                   mirror state (ioDevices.video.mirror)
   * @param {string} frameInfo.format Requested video format, available formats are 'image-data' and 'canvas'.
   * @param {number} frameInfo.cacheTimeout Will reuse previous image data if the time since capture is less than
   *                                        the cacheTimeout.  Defaults to 16ms.
   *
   * @return {ArrayBuffer|Canvas|string|null} Frame data in requested format, null when errors.
   */


  getFrame({
    dimensions = Video.DIMENSIONS,
    mirror = this.mirror,
    format = Video.FORMAT_IMAGE_DATA,
    cacheTimeout = this._frameCacheTimeout
  }) {
    if (this.provider) return this.provider.getFrame({
      dimensions,
      mirror,
      format,
      cacheTimeout
    });
    return null;
  }
  /**
   * Set the preview ghost effect
   * @param {number} ghost from 0 (visible) to 100 (invisible) - ghost effect
   */


  setPreviewGhost(ghost) {
    this._ghost = ghost; // Confirm that the default value has been changed to a valid id for the drawable

    if (this._drawable !== -1) {
      this.runtime.renderer.updateDrawableProperties(this._drawable, {
        ghost: this._forceTransparentPreview ? 100 : ghost
      });
    }
  }

  _disablePreview() {
    if (this._skinId !== -1) {
      this.runtime.renderer.updateBitmapSkin(this._skinId, new ImageData(...Video.DIMENSIONS), 1);
      this.runtime.renderer.updateDrawableProperties(this._drawable, {
        visible: false
      });
    }

    this._renderPreviewFrame = null;
  }

  _setupPreview() {
    const {
      renderer
    } = this.runtime;
    if (!renderer) return;

    if (this._skinId === -1 && this._drawable === -1) {
      this._skinId = renderer.createBitmapSkin(new ImageData(...Video.DIMENSIONS), 1);
      this._drawable = renderer.createDrawable(StageLayering.VIDEO_LAYER);
      renderer.updateDrawableProperties(this._drawable, {
        skinId: this._skinId
      });
    } // if we haven't already created and started a preview frame render loop, do so


    if (!this._renderPreviewFrame) {
      renderer.updateDrawableProperties(this._drawable, {
        ghost: this._forceTransparentPreview ? 100 : this._ghost,
        visible: true
      });

      this._renderPreviewFrame = () => {
        clearTimeout(this._renderPreviewTimeout);

        if (!this._renderPreviewFrame) {
          return;
        }

        this._renderPreviewTimeout = setTimeout(this._renderPreviewFrame, this.runtime.currentStepTime);
        const imageData = this.getFrame({
          format: Video.FORMAT_IMAGE_DATA,
          cacheTimeout: this.runtime.currentStepTime
        });

        if (!imageData) {
          renderer.updateBitmapSkin(this._skinId, new ImageData(...Video.DIMENSIONS), 1);
          return;
        }

        renderer.updateBitmapSkin(this._skinId, imageData, 1);
        this.runtime.requestRedraw();
      };

      this._renderPreviewFrame();
    }
  }

  get videoReady() {
    if (this.provider) return this.provider.videoReady;
    return false;
  }
  /**
   * Method implemented by all IO devices to allow external changes.
   * The only change available externally is hiding the preview, used e.g. to
   * prevent drawing the preview into project thumbnails.
   * @param {object} - data passed to this IO device.
   * @property {boolean} forceTransparentPreview - whether the preview should be forced transparent.
   */


  postData({
    forceTransparentPreview
  }) {
    this._forceTransparentPreview = forceTransparentPreview; // Setting the ghost to the current value will pick up the forceTransparentPreview
    // flag and override the current ghost. The complexity is to prevent blocks
    // from overriding forceTransparentPreview

    this.setPreviewGhost(this._ghost);
  }

}

module.exports = Video;

/***/ }),

/***/ "./src/parser/index.js":
/*!*****************************!*\
  !*** ./src/parser/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {const JSZip = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");
/** 该函数尚未重写 2020.12.20 */


const unzip = function (input, isSprite) {
  console.warn("尚未重写的unzip:", input, isSprite);
  return JSZip.loadAsync(input).then(function (zip) {
    // 在文件列表或子目录中查找json，假定zipfile中只有一个sprite或project json
    const file = isSprite ? zip.file(/^([^/]*\/)?sprite\.json$/)[0] : zip.file(/^([^/]*\/)?project\.json$/)[0];

    if (file) {
      return file.async("string").then(function (project) {
        return callback(null, [project, zip]);
      });
    }

    return callback("无法解压缩和提取project.json，出现错误: 缺少项目或精灵json");
  }).catch(function (err) {
    return callback(`无法解压缩和提取project.json，出现错误: ${JSON.stringify(err)}`);
  });
};
/**
 * @function 对传入的数据进行解包
 * @param {*} data 传入的数据(项目JSON或元素数据)
 * @param {*} isMaterial 传入当前是否为元素
 */


const unpack = function (data, isMaterial) {
  //   console.warn("重写unpack", data, isMaterial);
  return new Promise((resolve, reject) => {
    // 如果data是字符串类型，将字符串传递到回调函数中
    if (typeof data === "string") return resolve([data, null]); // 如果非字符串，再验证是否为buffer类型，不是就将其转为buffer

    if (!Buffer.isBuffer(data)) data = new Buffer(data); // 由buffer的某些字节(签名)确定格式

    let signature = data.slice(0, 3).join(" ");
    let isLegacy = false;
    let isZip = false;
    if (signature.indexOf("83 99 114") === 0) isLegacy = true;
    if (signature.indexOf("80 75") === 0) isZip = true;
    if (isLegacy) return reject([null, "解析器只支持2.x及更高版本"]);
    if (!isZip && !isLegacy) return resolve([data.toString("utf-8"), null]);

    if (isZip) {
      console.warn("需要处理压缩包类型,以下是解包函数"); // 如果是zip，调用解压缩

      unzip(data, isMaterial);
    }
  });
};
/**
 * @function 解析传入的数据
 * @param data 值为项目的JSON对象
 */


const parse = function (data) {
  //   console.warn("重写parse", data);
  return new Promise((resolve, reject) => {
    // 输入是JSON字符串，其中可能包含应删除的控制字符
    try {
      resolve(JSON.parse(data.replace(/\\b|\\u0008/g, "")));
    } catch (e) {
      reject(e.toString());
    }
  });
};
/**
 * @function 校验
 * @param {*} data 传入待校验数据
 */


const validate = function (data) {
  //   console.warn("重写validate", data, isMaterial);
  return new Promise((resolve, reject) => {
    // 此处暂时使用data.meta.semver判断，遇到2代项目，再看具体使用哪个值
    if (data.meta.semver && data.meta.semver.indexOf("2") > -1) {
      data.projectVersion = 2;
      return resolve(data, null);
    }

    if (data.meta.semver && data.meta.semver.indexOf("3") > -1) {
      data.projectVersion = 3;
      return resolve(data, null);
    }

    reject({
      validationError: "无法解析为有效的SB2或SB3项目."
    });
  });
};
/**
 * 解压，解析，验证和分析Scratch项目。 如果成功，将返回带有附加元数据的有效Scratch项目对象.
 * @param {Buffer | string} data 代表项目的缓冲区或字符串
 * @param {boolean} isMaterial false表示项目数据;true表示单个元素数据
 */


module.exports = function (data, isMaterial) {
  //   console.warn("index.js", data, isMaterial);
  return unpack(data, isMaterial).then(unpackedProject => {
    console.warn("解包:", unpackedProject);
    return parse(unpackedProject[0]).then(res => validate(res).then(ress => ress));
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/serialization/deserialize-assets.js":
/*!*************************************************!*\
  !*** ./src/serialization/deserialize-assets.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const JSZip = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");
/**
 * 将声音从文件反序列化到存储缓存中，以便可以将其加载到运行时中.
 * @param {object} sound sb3文件中声音的描述符
 * @param {Runtime} runtime T运行时包含用于缓存声音的存储
 * @param {JSZip} zip 包含声音文件的zip文件，由`sound`描述
 * @param {string} assetFileName 给定资产的可选文件名
 * (sb2 files have filenames of the form [int].[ext],
 * sb3 files have filenames of the form [md5].[ext])
 * @return {Promise} 在将描述的声音存储到运行时存储高速缓存，声音已经存储或发生错误之后解决的承诺.
 */


const deserializeSound = function (sound, runtime, zip, assetFileName) {
  const fileName = assetFileName ? assetFileName : sound.md5;
  const storage = runtime.storage;

  if (!storage) {
    console.error("No storage module present; cannot load sound asset: ", fileName);
    return Promise.resolve(null);
  }

  if (!zip) {
    // Zip will not be provided if loading project json from server
    return Promise.resolve(null);
  }

  let soundFile = zip.file(fileName);

  if (!soundFile) {
    // look for assetfile in a flat list of files, or in a folder
    const fileMatch = new RegExp(`^([^/]*/)?${fileName}$`);
    soundFile = zip.file(fileMatch)[0]; // use first matching file
  }

  if (!soundFile) {
    console.error(`Could not find sound file associated with the ${sound.name} sound.`);
    return Promise.resolve(null);
  }

  if (!JSZip.support.uint8array) {
    console.error("JSZip uint8array is not supported in this browser.");
    return Promise.resolve(null);
  }

  const dataFormat = sound.dataFormat.toLowerCase() === "mp3" ? storage.DataFormat.MP3 : storage.DataFormat.WAV;
  return soundFile.async("uint8array").then(data => storage.createAsset(storage.AssetType.Sound, dataFormat, data, null, true)).then(asset => {
    sound.asset = asset;
    sound.assetId = asset.assetId;
    sound.md5 = `${asset.assetId}.${asset.dataFormat}`;
  });
};
/**
 * 将服装从文件反序列化到存储缓存中，以便可以将其加载到运行时中.
 * @param {object} costume sb3文件中服装的描述符
 * @param {Runtime} runtime 运行时包含用于存储服装的存储空间
 * @param {JSZip} zip 包含服装文件的zip由`costume`描述
 * @param {string} assetFileName Optional file name for the given asset
 * (sb2 files have filenames of the form [int].[ext],
 * sb3 files have filenames of the form [md5].[ext])
 * @param {string} textLayerFileName Optional file name for the given asset's text layer (sb2 only; files have filenames of the form [int].png)
 * @return {Promise} Promise that resolves after the described costume has been stored into the runtime storage cache, the costume was already stored, or an error has occurred.
 */


const deserializeCostume = function (costume, runtime, zip, assetFileName, textLayerFileName) {
  console.log("反序列化资源.js");
  const storage = runtime.storage;
  const assetId = costume.assetId;
  const fileName = assetFileName ? assetFileName : `${assetId}.${costume.dataFormat}`;

  if (!storage) {
    console.error("No storage module present; cannot load costume asset: ", fileName);
    return Promise.resolve(null);
  }

  if (costume.asset) {
    // 从图像文件上传精灵时，将提供资产数据
    // @todo 将资产数据缓存到某处并在此处拉出
    return Promise.resolve(storage.createAsset(costume.asset.assetType, costume.asset.dataFormat, new Uint8Array(Object.keys(costume.asset.data).map(key => costume.asset.data[key])), null, true)).then(asset => {
      costume.asset = asset;
      costume.assetId = asset.assetId;
      costume.md5 = `${asset.assetId}.${asset.dataFormat}`;
    });
  } // 如果从服务器加载项目json


  if (!zip) return Promise.resolve(null);
  let costumeFile = zip.file(fileName);

  if (!costumeFile) {
    // 在平面文件列表或文件夹中查找资产文件
    const fileMatch = new RegExp(`^([^/]*/)?${fileName}$`);
    costumeFile = zip.file(fileMatch)[0]; // use the first matched file
  }

  if (!costumeFile) {
    console.error(`Could not find costume file associated with the ${costume.name} costume.`);
    return Promise.resolve(null);
  }

  let assetType = null;
  const costumeFormat = costume.dataFormat.toLowerCase();

  if (costumeFormat === "svg") {
    assetType = storage.AssetType.ImageVector;
  } else if (["png", "bmp", "jpeg", "jpg", "gif"].indexOf(costumeFormat) >= 0) {
    assetType = storage.AssetType.ImageBitmap;
  } else {
    console.error(`Unexpected file format for costume: ${costumeFormat}`);
  }

  if (!JSZip.support.uint8array) {
    console.error("JSZip uint8array is not supported in this browser.");
    return Promise.resolve(null);
  } // textLayerMD5 exists if there is a text layer, which is a png of text from Scratch 1.4
  // that was opened in Scratch 2.0. In this case, set costume.textLayerAsset.


  let textLayerFilePromise;

  if (costume.textLayerMD5) {
    const textLayerFile = zip.file(textLayerFileName);

    if (!textLayerFile) {
      console.error(`Could not find text layer file associated with the ${costume.name} costume.`);
      return Promise.resolve(null);
    }

    textLayerFilePromise = textLayerFile.async("uint8array").then(data => storage.createAsset(storage.AssetType.ImageBitmap, "png", data, costume.textLayerMD5)).then(asset => {
      costume.textLayerAsset = asset;
    });
  } else {
    textLayerFilePromise = Promise.resolve(null);
  }

  return Promise.all([textLayerFilePromise, costumeFile.async("uint8array").then(data => storage.createAsset(assetType, // TODO eventually we want to map non-png's to their actual file types?
  costumeFormat, data, null, true)).then(asset => {
    costume.asset = asset;
    costume.assetId = asset.assetId;
    costume.md5 = `${asset.assetId}.${asset.dataFormat}`;
  })]);
};

module.exports = {
  deserializeSound,
  deserializeCostume
};

/***/ }),

/***/ "./src/serialization/sb2.js":
/*!**********************************!*\
  !*** ./src/serialization/sb2.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * Partial implementation of an SB2 JSON importer.
 * Parses provided JSON and then generates all needed
 * scratch-vm runtime structures.
 */
const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");

const RenderedTarget = __webpack_require__(/*! ../sprites/rendered-target */ "./src/sprites/rendered-target.js");

const Sprite = __webpack_require__(/*! ../sprites/sprite */ "./src/sprites/sprite.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const specMap = __webpack_require__(/*! ./sb2_specmap */ "./src/serialization/sb2_specmap.js");

const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const MonitorRecord = __webpack_require__(/*! ../engine/monitor-record */ "./src/engine/monitor-record.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

const {
  loadCostume
} = __webpack_require__(/*! ../import/load-costume.js */ "./src/import/load-costume.js");

const {
  loadSound
} = __webpack_require__(/*! ../import/load-sound.js */ "./src/import/load-sound.js");

const {
  deserializeCostume,
  deserializeSound
} = __webpack_require__(/*! ./deserialize-assets.js */ "./src/serialization/deserialize-assets.js"); // Constants used during deserialization of an SB2 file


const CORE_EXTENSIONS = ["argument", "control", "data", "event", "looks", "math", "motion", "operator", "procedures", "sensing", "sound"]; // Adjust script coordinates to account for
// larger block size in scratch-blocks.
// @todo: Determine more precisely the right formulas here.

const WORKSPACE_X_SCALE = 1.5;
const WORKSPACE_Y_SCALE = 2.2;
/**
 * Convert a Scratch 2.0 procedure string (e.g., "my_procedure %s %b %n")
 * into an argument map. This allows us to provide the expected inputs
 * to a mutated procedure call.
 * @param {string} procCode Scratch 2.0 procedure string.
 * @return {object} Argument map compatible with those in sb2specmap.
 */

const parseProcedureArgMap = function (procCode) {
  const argMap = [{} // First item in list is op string.
  ];
  const INPUT_PREFIX = "input";
  let inputCount = 0; // Split by %n, %b, %s.

  const parts = procCode.split(/(?=[^\\]%[nbs])/);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].trim();

    if (part.substring(0, 1) === "%") {
      const argType = part.substring(1, 2);
      const arg = {
        type: "input",
        inputName: INPUT_PREFIX + inputCount++
      };

      if (argType === "n") {
        arg.inputOp = "math_number";
      } else if (argType === "s") {
        arg.inputOp = "text";
      } else if (argType === "b") {
        arg.inputOp = "boolean";
      }

      argMap.push(arg);
    }
  }

  return argMap;
};
/**
 * Generate a list of "argument IDs" for procdefs and caller mutations.
 * IDs just end up being `input0`, `input1`, ... which is good enough.
 * @param {string} procCode Scratch 2.0 procedure string.
 * @return {Array.<string>} Array of argument id strings.
 */


const parseProcedureArgIds = function (procCode) {
  return parseProcedureArgMap(procCode).map(arg => arg.inputName).filter(name => name); // Filter out unnamed inputs which are labels
};
/**
 * Flatten a block tree into a block list.
 * Children are temporarily stored on the `block.children` property.
 * @param {Array.<object>} blocks list generated by `parseBlockList`.
 * @return {Array.<object>} Flattened list to be passed to `blocks.createBlock`.
 */


const flatten = function (blocks) {
  let finalBlocks = [];

  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    finalBlocks.push(block);

    if (block.children) {
      finalBlocks = finalBlocks.concat(flatten(block.children));
    }

    delete block.children;
  }

  return finalBlocks;
};
/**
 * Parse any list of blocks from SB2 JSON into a list of VM-format blocks.
 * Could be used to parse a top-level script,
 * a list of blocks in a branch (e.g., in forever),
 * or a list of blocks in an argument (e.g., move [pick random...]).
 * @param {Array.<object>} blockList SB2 JSON-format block list.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retreive a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {ParseState} parseState - info on the state of parsing beyond the current block.
 * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.
 * They are indexed in this object by the sb2 flattened block list index indicating
 * which block they should attach to.
 * @param {int} commentIndex The current index of the top block in this list if it were in a flattened
 * list of all blocks for the target
 * @return {Array<Array.<object>|int>} Tuple where first item is the Scratch VM-format block list, and
 * second item is the updated comment index
 */


const parseBlockList = function (blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {
  const resultingList = [];
  let previousBlock = null; // For setting next.

  for (let i = 0; i < blockList.length; i++) {
    const block = blockList[i]; // eslint-disable-next-line no-use-before-define

    const parsedBlockAndComments = parseBlock(block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
    const parsedBlock = parsedBlockAndComments[0]; // Update commentIndex

    commentIndex = parsedBlockAndComments[1];
    if (!parsedBlock) continue;

    if (previousBlock) {
      parsedBlock.parent = previousBlock.id;
      previousBlock.next = parsedBlock.id;
    }

    previousBlock = parsedBlock;
    resultingList.push(parsedBlock);
  }

  return [resultingList, commentIndex];
};
/**
 * Parse a Scratch object's scripts into VM blocks.
 * This should only handle top-level scripts that include X, Y coordinates.
 * @param {!object} scripts Scripts object from SB2 JSON.
 * @param {!Blocks} blocks Blocks object to load parsed blocks into.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retreive a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {object} comments Comments that need to be attached to the blocks that need to be parsed
 */


const parseScripts = function (scripts, blocks, addBroadcastMsg, getVariableId, extensions, comments) {
  // Keep track of the index of the current script being
  // parsed in order to attach block comments correctly
  let scriptIndexForComment = 0;

  for (let i = 0; i < scripts.length; i++) {
    const script = scripts[i];
    const scriptX = script[0];
    const scriptY = script[1];
    const blockList = script[2];
    const parseState = {};
    const [parsedBlockList, newCommentIndex] = parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, scriptIndexForComment);
    scriptIndexForComment = newCommentIndex;

    if (parsedBlockList[0]) {
      parsedBlockList[0].x = scriptX * WORKSPACE_X_SCALE;
      parsedBlockList[0].y = scriptY * WORKSPACE_Y_SCALE;
      parsedBlockList[0].topLevel = true;
      parsedBlockList[0].parent = null;
    } // Flatten children and create add the blocks.


    const convertedBlocks = flatten(parsedBlockList);

    for (let j = 0; j < convertedBlocks.length; j++) {
      blocks.createBlock(convertedBlocks[j]);
    }
  }
};
/**
 * Create a callback for assigning fixed IDs to imported variables
 * Generator stores the global variable mapping in a closure
 * @param {!string} targetId the id of the target to scope the variable to
 * @return {string} variable ID
 */


const generateVariableIdGetter = function () {
  let globalVariableNameMap = {};

  const namer = (targetId, name, type) => `${targetId}-${StringUtil.replaceUnsafeChars(name)}-${type}`;

  return function (targetId, topLevel) {
    // Reset the global variable map if topLevel
    if (topLevel) globalVariableNameMap = {};
    return function (name, type) {
      if (topLevel) {
        // Store the name/id pair in the globalVariableNameMap
        globalVariableNameMap[`${name}-${type}`] = namer(targetId, name, type);
        return globalVariableNameMap[`${name}-${type}`];
      } // Not top-level, so first check the global name map


      if (globalVariableNameMap[`${name}-${type}`]) return globalVariableNameMap[`${name}-${type}`];
      return namer(targetId, name, type);
    };
  };
}();

const globalBroadcastMsgStateGenerator = function () {
  let broadcastMsgNameMap = {};
  const allBroadcastFields = [];
  console.warn("sb2:", Utility.uid());
  const emptyStringName = Utility.uid();
  return function (topLevel) {
    if (topLevel) broadcastMsgNameMap = {};
    return {
      broadcastMsgMapUpdater: function (name, field) {
        name = name.toLowerCase();

        if (name === "") {
          name = emptyStringName;
        }

        broadcastMsgNameMap[name] = `broadcastMsgId-${StringUtil.replaceUnsafeChars(name)}`;
        allBroadcastFields.push(field);
        return broadcastMsgNameMap[name];
      },
      globalBroadcastMsgs: broadcastMsgNameMap,
      allBroadcastFields: allBroadcastFields,
      emptyMsgName: emptyStringName
    };
  };
}();
/**
 * Parse a single monitor object and create all its in-memory VM objects.
 *
 * It is important that monitors are parsed last,
 * - after all sprite targets have finished parsing, and
 * - after the rest of the stage has finished parsing.
 *
 * It is specifically important that all the scripts in the project
 * have been parsed and all the relevant targets exist, have uids,
 * and have their variables initialized.
 * Calling this function before these things are true, will result in
 * undefined behavior.
 * @param {!object} object - From-JSON "Monitor object"
 * @param {!Runtime} runtime - (in/out) Runtime object to load monitor info into.
 * @param {!Array.<Target>} targets - Targets have already been parsed.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 */


const parseMonitorObject = (object, runtime, targets, extensions) => {
  // If we can't find the block in the spec map, ignore it.
  // This happens for things like Lego Wedo 1.0 monitors.
  const mapped = specMap[object.cmd];

  if (!mapped) {
    console.warn(`Could not find monitor block with opcode: ${object.cmd}`);
    return;
  } // In scratch 2.0, there are two monitors that now correspond to extension
  // blocks (tempo and video motion/direction). In the case of the
  // video motion/direction block, this reporter is not monitorable in Scratch 3.0.
  // In the case of the tempo block, we should import it and load the music extension
  // only when the monitor is actually visible.


  const opcode = specMap[object.cmd].opcode;
  const extIndex = opcode.indexOf("_");
  const extID = opcode.substring(0, extIndex);

  if (extID === "videoSensing") {
    return;
  } else if (CORE_EXTENSIONS.indexOf(extID) === -1 && extID !== "" && !extensions.extensionIDs.has(extID) && !object.visible) {
    // Don't import this monitor if it refers to a non-core extension that
    // doesn't exist anywhere else in the project and it isn't visible.
    // This should only apply to the tempo block at this point since
    // there are no other sb2 blocks that are now extension monitors.
    return;
  }

  let target = null; // List blocks don't come in with their target name set.
  // Find the target by searching for a target with matching variable name/type.

  if (!object.hasOwnProperty("target")) {
    for (let i = 0; i < targets.length; i++) {
      const currTarget = targets[i];
      const listVariables = Object.keys(currTarget.variables).filter(key => {
        const variable = currTarget.variables[key];
        return variable.type === Variable.LIST_TYPE && variable.name === object.listName;
      });

      if (listVariables.length > 0) {
        target = currTarget; // Keep this target for later use

        object.target = currTarget.getName(); // Set target name to normalize with other monitors
      }
    }
  } // Get the target for this monitor, if not gotten above.


  target = target || targets.filter(t => t.getName() === object.target)[0];
  if (!target) throw new Error("Cannot create monitor for target that cannot be found by name"); // Create var id getter to make block naming/parsing easier, variables already created.

  const getVariableId = generateVariableIdGetter(target.id, false); // eslint-disable-next-line no-use-before-define

  const [block, _] = parseBlock([object.cmd, object.param], // Scratch 2 monitor blocks only have one param.
  null, // `addBroadcastMsg`, not needed for monitor blocks.
  getVariableId, extensions, {}, null, // `comments`, not needed for monitor blocks
  null // `commentIndex`, not needed for monitor blocks
  ); // Monitor blocks have special IDs to match the toolbox obtained from the getId
  // function in the runtime.monitorBlocksInfo. Variable monitors, however,
  // get their IDs from the variable id they reference.

  if (object.cmd === "getVar:") {
    block.id = getVariableId(object.param, Variable.SCALAR_TYPE);
  } else if (object.cmd === "contentsOfList:") {
    block.id = getVariableId(object.param, Variable.LIST_TYPE);
  } else if (runtime.monitorBlockInfo.hasOwnProperty(block.opcode)) {
    block.id = runtime.monitorBlockInfo[block.opcode].getId(target.id, block.fields);
  } else {
    // If the opcode can't be found in the runtime monitorBlockInfo,
    // then default to using the block opcode as the id instead.
    // This is for extension monitors, and assumes that extension monitors
    // cannot be sprite specific.
    block.id = block.opcode;
  } // Block needs a targetId if it is targetting something other than the stage


  block.targetId = target.isStage ? null : target.id; // Property required for running monitored blocks.

  block.isMonitored = object.visible;
  const existingMonitorBlock = runtime.monitorBlocks._blocks[block.id];

  if (existingMonitorBlock) {
    // A monitor block already exists if the toolbox has been loaded and
    // the monitor block is not target specific (because the block gets recycled).
    // Update the existing block with the relevant monitor information.
    existingMonitorBlock.isMonitored = object.visible;
    existingMonitorBlock.targetId = block.targetId;
  } else {
    // Blocks can be created with children, flatten and add to monitorBlocks.
    const newBlocks = flatten([block]);

    for (let i = 0; i < newBlocks.length; i++) {
      runtime.monitorBlocks.createBlock(newBlocks[i]);
    }
  } // Convert numbered mode into strings for better understandability.


  switch (object.mode) {
    case 1:
      object.mode = "default";
      break;

    case 2:
      object.mode = "large";
      break;

    case 3:
      object.mode = "slider";
      break;
  } // Create a monitor record for the runtime's monitorState


  runtime.requestAddMonitor(MonitorRecord({
    id: block.id,
    targetId: block.targetId,
    spriteName: block.targetId ? object.target : null,
    opcode: block.opcode,
    params: runtime.monitorBlocks._getBlockParams(block),
    value: "",
    mode: object.mode,
    sliderMin: object.sliderMin,
    sliderMax: object.sliderMax,
    isDiscrete: object.isDiscrete,
    x: object.x,
    y: object.y,
    width: object.width,
    height: object.height,
    visible: object.visible
  }));
};
/**
 * Parse the assets of a single "Scratch object" and load them. This
 * preprocesses objects to support loading the data for those assets over a
 * network while the objects are further processed into Blocks, Sprites, and a
 * list of needed Extensions.
 * @param {!object} object - From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime - Runtime object to load all structures into.
 * @param {boolean} topLevel - Whether this is the top-level object (stage).
 * @param {?object} zip - Optional zipped assets for local file import
 * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank,children:object}}
 *   Object of arrays of promises and child objects for asset objects used in
 *   Sprites. As well as a SoundBank for the sound assets. null for unsupported
 *   objects.
 */


const parseScratchAssets = function (object, runtime, topLevel, zip) {
  if (!object.hasOwnProperty("objName")) {
    // Skip parsing monitors. Or any other objects missing objName.
    return null;
  }

  const assets = {
    costumePromises: [],
    soundPromises: [],
    soundBank: runtime.audioEngine && runtime.audioEngine.createBank(),
    children: []
  }; // Costumes from JSON.

  const costumePromises = assets.costumePromises;

  if (object.hasOwnProperty("costumes")) {
    for (let i = 0; i < object.costumes.length; i++) {
      const costumeSource = object.costumes[i];
      const bitmapResolution = costumeSource.bitmapResolution || 1;
      const costume = {
        name: costumeSource.costumeName,
        bitmapResolution: bitmapResolution,
        rotationCenterX: topLevel ? 240 * bitmapResolution : costumeSource.rotationCenterX,
        rotationCenterY: topLevel ? 180 * bitmapResolution : costumeSource.rotationCenterY,
        // TODO we eventually want this next property to be called
        // md5ext to reflect what it actually contains, however this
        // will be a very extensive change across many repositories
        // and should be done carefully and altogether
        md5: costumeSource.baseLayerMD5,
        skinId: null
      };
      const md5ext = costumeSource.baseLayerMD5;
      const idParts = StringUtil.splitFirst(md5ext, ".");
      const md5 = idParts[0];
      let ext;

      if (idParts.length === 2 && idParts[1]) {
        ext = idParts[1];
      } else {
        // Default to 'png' if baseLayerMD5 is not formatted correctly
        ext = "png"; // Fix costume md5 for later

        costume.md5 = `${costume.md5}.${ext}`;
      }

      costume.dataFormat = ext;
      costume.assetId = md5;

      if (costumeSource.textLayerMD5) {
        costume.textLayerMD5 = StringUtil.splitFirst(costumeSource.textLayerMD5, ".")[0];
      } // If there is no internet connection, or if the asset is not in storage
      // for some reason, and we are doing a local .sb2 import, (e.g. zip is provided)
      // the file name of the costume should be the baseLayerID followed by the file ext


      const assetFileName = `${costumeSource.baseLayerID}.${ext}`;
      const textLayerFileName = costumeSource.textLayerID ? `${costumeSource.textLayerID}.png` : null;
      costumePromises.push(deserializeCostume(costume, runtime, zip, assetFileName, textLayerFileName).then(() => loadCostume(costume.md5, costume, runtime, 2
      /* optVersion */
      )));
    }
  } // Sounds from JSON


  const {
    soundBank,
    soundPromises
  } = assets;

  if (object.hasOwnProperty("sounds")) {
    for (let s = 0; s < object.sounds.length; s++) {
      const soundSource = object.sounds[s];
      const sound = {
        name: soundSource.soundName,
        format: soundSource.format,
        rate: soundSource.rate,
        sampleCount: soundSource.sampleCount,
        // TODO we eventually want this next property to be called
        // md5ext to reflect what it actually contains, however this
        // will be a very extensive change across many repositories
        // and should be done carefully and altogether
        // (for example, the audio engine currently relies on this
        // property to be named 'md5')
        md5: soundSource.md5,
        data: null
      };
      const md5ext = soundSource.md5;
      const idParts = StringUtil.splitFirst(md5ext, ".");
      const md5 = idParts[0];
      const ext = idParts[1].toLowerCase();
      sound.dataFormat = ext;
      sound.assetId = md5; // If there is no internet connection, or if the asset is not in storage
      // for some reason, and we are doing a local .sb2 import, (e.g. zip is provided)
      // the file name of the sound should be the soundID (provided from the project.json)
      // followed by the file ext

      const assetFileName = `${soundSource.soundID}.${ext}`;
      soundPromises.push(deserializeSound(sound, runtime, zip, assetFileName).then(() => loadSound(sound, runtime, soundBank)));
    }
  } // The stage will have child objects; recursively process them.


  const childrenAssets = assets.children;

  if (object.children) {
    for (let m = 0; m < object.children.length; m++) {
      childrenAssets.push(parseScratchAssets(object.children[m], runtime, false, zip));
    }
  }

  return assets;
};
/**
 * Parse a single "Scratch object" and create all its in-memory VM objects.
 * TODO: parse the "info" section, especially "savedExtensions"
 * @param {!object} object - From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime - Runtime object to load all structures into.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {boolean} topLevel - Whether this is the top-level object (stage).
 * @param {?object} zip - Optional zipped assets for local file import
 * @param {object} assets - Promises for assets of this scratch object grouped
 *   into costumes and sounds
 * @return {!Promise.<Array.<Target>>} Promise for the loaded targets when ready, or null for unsupported objects.
 */


const parseScratchObject = function (object, runtime, extensions, topLevel, zip, assets) {
  if (!object.hasOwnProperty("objName")) {
    if (object.hasOwnProperty("listName")) {
      // Shim these objects so they can be processed as monitors
      object.cmd = "contentsOfList:";
      object.param = object.listName;
      object.mode = "list";
    } // Defer parsing monitors until targets are all parsed


    object.deferredMonitor = true;
    return Promise.resolve(object);
  } // Blocks container for this object.


  const blocks = new Blocks(runtime); // @todo: For now, load all Scratch objects (stage/sprites) as a Sprite.

  const sprite = new Sprite(blocks, runtime); // Sprite/stage name from JSON.

  if (object.hasOwnProperty("objName")) {
    if (topLevel && object.objName !== "Stage") {
      for (const child of object.children) {
        if (!child.hasOwnProperty("objName") && child.target === object.objName) {
          child.target = "Stage";
        }
      }

      object.objName = "Stage";
    }

    sprite.name = object.objName;
  } // Costumes from JSON.


  const costumePromises = assets.costumePromises; // Sounds from JSON

  const {
    soundBank,
    soundPromises
  } = assets; // Create the first clone, and load its run-state from JSON.

  const target = sprite.createClone(topLevel ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);
  const getVariableId = generateVariableIdGetter(target.id, topLevel);
  const globalBroadcastMsgObj = globalBroadcastMsgStateGenerator(topLevel);
  const addBroadcastMsg = globalBroadcastMsgObj.broadcastMsgMapUpdater; // Load target properties from JSON.

  if (object.hasOwnProperty("variables")) {
    for (let j = 0; j < object.variables.length; j++) {
      const variable = object.variables[j]; // A variable is a cloud variable if:
      // - the project says it's a cloud variable, and
      // - it's a stage variable, and
      // - the runtime can support another cloud variable

      const isCloud = variable.isPersistent && topLevel && runtime.canAddCloudVariable();
      const newVariable = new Variable(getVariableId(variable.name, Variable.SCALAR_TYPE), variable.name, Variable.SCALAR_TYPE, isCloud);
      if (isCloud) runtime.addCloudVariable();
      newVariable.value = variable.value;
      target.variables[newVariable.id] = newVariable;
    }
  } // If included, parse any and all comments on the object (this includes top-level
  // workspace comments as well as comments attached to specific blocks)


  const blockComments = {};

  if (object.hasOwnProperty("scriptComments")) {
    const comments = object.scriptComments.map(commentDesc => {
      const [commentX, commentY, commentWidth, commentHeight, commentFullSize, flattenedBlockIndex, commentText] = commentDesc;
      const isBlockComment = commentDesc[5] >= 0;
      const newComment = new Comment(null, // generate a new id for this comment
      commentText, // text content of sb2 comment
      // Only serialize x & y position of comment if it's a workspace comment
      // If it's a block comment, we'll let scratch-blocks handle positioning
      isBlockComment ? null : commentX * WORKSPACE_X_SCALE, isBlockComment ? null : commentY * WORKSPACE_Y_SCALE, commentWidth * WORKSPACE_X_SCALE, commentHeight * WORKSPACE_Y_SCALE, !commentFullSize);

      if (isBlockComment) {
        // commentDesc[5] refers to the index of the block that this
        // comment is attached to --  in a flattened version of the
        // scripts array.
        // If commentDesc[5] is -1, this is a workspace comment (we don't need to do anything
        // extra at this point), otherwise temporarily save the flattened script array
        // index as the blockId property of the new comment. We will
        // change this to refer to the actual block id of the corresponding
        // block when that block gets created
        newComment.blockId = flattenedBlockIndex; // Add this comment to the block comments object with its script index
        // as the key

        if (blockComments.hasOwnProperty(flattenedBlockIndex)) {
          blockComments[flattenedBlockIndex].push(newComment);
        } else {
          blockComments[flattenedBlockIndex] = [newComment];
        }
      }

      return newComment;
    }); // Add all the comments that were just created to the target.comments,
    // referenced by id

    comments.forEach(comment => {
      target.comments[comment.id] = comment;
    });
  } // If included, parse any and all scripts/blocks on the object.


  if (object.hasOwnProperty("scripts")) {
    parseScripts(object.scripts, blocks, addBroadcastMsg, getVariableId, extensions, blockComments);
  } // If there are any comments referring to a numerical block ID, make them
  // workspace comments. These are comments that were originally created as
  // block comments, detached from the block, and then had the associated
  // block deleted.
  // These comments should be imported as workspace comments
  // by making their blockIDs (which currently refer to non-existing blocks)
  // null (See #1452).


  for (const commentIndex in blockComments) {
    const currBlockComments = blockComments[commentIndex];
    currBlockComments.forEach(c => {
      if (typeof c.blockId === "number") {
        c.blockId = null;
      }
    });
  } // Update stage specific blocks (e.g. sprite clicked <=> stage clicked)


  blocks.updateTargetSpecificBlocks(topLevel); // topLevel = isStage

  if (object.hasOwnProperty("lists")) {
    for (let k = 0; k < object.lists.length; k++) {
      const list = object.lists[k];
      const newVariable = new Variable(getVariableId(list.listName, Variable.LIST_TYPE), list.listName, Variable.LIST_TYPE, false);
      newVariable.value = list.contents;
      target.variables[newVariable.id] = newVariable;
    }
  }

  if (object.hasOwnProperty("scratchX")) {
    target.x = object.scratchX;
  }

  if (object.hasOwnProperty("scratchY")) {
    target.y = object.scratchY;
  }

  if (object.hasOwnProperty("direction")) {
    target.direction = object.direction;
  }

  if (object.hasOwnProperty("isDraggable")) {
    target.draggable = object.isDraggable;
  }

  if (object.hasOwnProperty("scale")) {
    // SB2 stores as 1.0 = 100%; we use % in the VM.
    target.size = object.scale * 100;
  }

  if (object.hasOwnProperty("visible")) {
    target.visible = object.visible;
  }

  if (object.hasOwnProperty("currentCostumeIndex")) {
    // Current costume index can sometimes be a floating
    // point number, use Math.floor to come up with an appropriate index
    // and clamp it to the actual number of costumes the object has for good measure.
    target.currentCostume = Utility.clamp(Math.floor(object.currentCostumeIndex), 0, object.costumes.length - 1);
  }

  if (object.hasOwnProperty("rotationStyle")) {
    if (object.rotationStyle === "none") {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
    } else if (object.rotationStyle === "leftRight") {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
    } else if (object.rotationStyle === "normal") {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    }
  }

  if (object.hasOwnProperty("tempoBPM")) {
    target.tempo = object.tempoBPM;
  }

  if (object.hasOwnProperty("videoAlpha")) {
    // SB2 stores alpha as opacity, where 1.0 is opaque.
    // We convert to a percentage, and invert it so 100% is full transparency.
    target.videoTransparency = 100 - 100 * object.videoAlpha;
  }

  if (object.hasOwnProperty("info")) {
    if (object.info.hasOwnProperty("videoOn")) {
      if (object.info.videoOn) {
        target.videoState = RenderedTarget.VIDEO_STATE.ON;
      } else {
        target.videoState = RenderedTarget.VIDEO_STATE.OFF;
      }
    }
  }

  if (object.hasOwnProperty("indexInLibrary")) {
    // Temporarily store the 'indexInLibrary' property from the sb2 file
    // so that we can correctly order sprites in the target pane.
    // This will be deleted after we are done parsing and ordering the targets list.
    target.targetPaneOrder = object.indexInLibrary;
  }

  target.isStage = topLevel;
  Promise.all(costumePromises).then(costumes => {
    sprite.costumes = costumes;
  });
  Promise.all(soundPromises).then(sounds => {
    sprite.sounds = sounds; // Make sure if soundBank is undefined, sprite.soundBank is then null.

    sprite.soundBank = soundBank || null;
  }); // The stage will have child objects; recursively process them.

  const childrenPromises = [];

  if (object.children) {
    for (let m = 0; m < object.children.length; m++) {
      childrenPromises.push(parseScratchObject(object.children[m], runtime, extensions, false, zip, assets.children[m]));
    }
  }

  return Promise.all(costumePromises.concat(soundPromises)).then(() => Promise.all(childrenPromises).then(children => {
    // Need create broadcast msgs as variables after
    // all other targets have finished processing.
    if (target.isStage) {
      const allBroadcastMsgs = globalBroadcastMsgObj.globalBroadcastMsgs;
      const allBroadcastMsgFields = globalBroadcastMsgObj.allBroadcastFields;
      const oldEmptyMsgName = globalBroadcastMsgObj.emptyMsgName;

      if (allBroadcastMsgs[oldEmptyMsgName]) {
        // Find a fresh 'messageN'
        let currIndex = 1;

        while (allBroadcastMsgs[`message${currIndex}`]) {
          currIndex += 1;
        }

        const newEmptyMsgName = `message${currIndex}`; // Add the new empty message name to the broadcast message
        // name map, and assign it the old id.
        // Then, delete the old entry in map.

        allBroadcastMsgs[newEmptyMsgName] = allBroadcastMsgs[oldEmptyMsgName];
        delete allBroadcastMsgs[oldEmptyMsgName]; // Now update all the broadcast message fields with
        // the new empty message name.

        for (let i = 0; i < allBroadcastMsgFields.length; i++) {
          if (allBroadcastMsgFields[i].value === "") {
            allBroadcastMsgFields[i].value = newEmptyMsgName;
          }
        }
      } // Traverse the broadcast message name map and create
      // broadcast messages as variables on the stage (which is this
      // target).


      for (const msgName in allBroadcastMsgs) {
        const msgId = allBroadcastMsgs[msgName];
        const newMsg = new Variable(msgId, msgName, Variable.BROADCAST_MESSAGE_TYPE, false);
        target.variables[newMsg.id] = newMsg;
      }
    }

    let targets = [target];
    const deferredMonitors = [];

    for (let n = 0; n < children.length; n++) {
      if (children[n]) {
        if (children[n].deferredMonitor) {
          deferredMonitors.push(children[n]);
        } else {
          targets = targets.concat(children[n]);
        }
      }
    } // It is important that monitors are parsed last
    // - after all sprite targets have finished parsing
    // - and this is the last thing that happens in the stage parsing
    // It is specifically important that all the scripts in the project
    // have been parsed and all the relevant targets exist, have uids,
    // and have their variables initialized.


    for (let n = 0; n < deferredMonitors.length; n++) {
      parseMonitorObject(deferredMonitors[n], runtime, targets, extensions);
    }

    return targets;
  }));
};

const reorderParsedTargets = function (targets) {
  // Reorder parsed targets based on the temporary targetPaneOrder property
  // and then delete it.
  const reordered = targets.map((t, index) => {
    t.layerOrder = index;
    return t;
  }).sort((a, b) => a.targetPaneOrder - b.targetPaneOrder); // Delete the temporary target pane ordering since we shouldn't need it anymore.

  reordered.forEach(t => {
    delete t.targetPaneOrder;
  });
  return reordered;
};
/**
 * Top-level handler. Parse provided JSON,
 * and process the top-level object (the stage object).
 * @param {!object} json SB2-format JSON to load.
 * @param {!Runtime} runtime Runtime object to load all structures into.
 * @param {boolean=} optForceSprite If set, treat as sprite (Sprite2).
 * @param {?object} zip Optional zipped assets for local file import
 * @return {Promise.<ImportedProject>} Promise that resolves to the loaded targets when ready.
 */


const sb2import = function (json, runtime, optForceSprite, zip) {
  const extensions = {
    extensionIDs: new Set(),
    extensionURLs: new Map()
  };
  return Promise.resolve(parseScratchAssets(json, runtime, !optForceSprite, zip)) // Force this promise to wait for the next loop in the js tick. Let
  // storage have some time to send off asset requests.
  .then(assets => Promise.resolve(assets)).then(assets => parseScratchObject(json, runtime, extensions, !optForceSprite, zip, assets)).then(reorderParsedTargets).then(targets => ({
    targets,
    extensions
  }));
};
/**
 * Given the sb2 block, inspect the specmap for a translation method or object.
 * @param {!object} block a sb2 formatted block
 * @return {object} specmap block to parse this opcode
 */


const specMapBlock = function (block) {
  const opcode = block[0];
  const mapped = opcode && specMap[opcode];

  if (!mapped) {
    console.warn(`Couldn't find SB2 block: ${opcode}`);
    return null;
  }

  if (typeof mapped === "function") {
    return mapped(block);
  }

  return mapped;
};
/**
 * Parse a single SB2 JSON-formatted block and its children.
 * @param {!object} sb2block SB2 JSON-formatted block.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retrieve a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {ParseState} parseState - info on the state of parsing beyond the current block.
 * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.
 * They are indexed in this object by the sb2 flattened block list index indicating
 * which block they should attach to.
 * @param {int} commentIndex The comment index for the block to be parsed if it were in a flattened
 * list of all blocks for the target
 * @return {Array.<object|int>} Tuple where first item is the Scratch VM-format block (or null if unsupported object),
 * and second item is the updated comment index (after this block and its children are parsed)
 */


const parseBlock = function (sb2block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {
  const commentsForParsedBlock = comments && typeof commentIndex === "number" && !isNaN(commentIndex) ? comments[commentIndex] : null;
  const blockMetadata = specMapBlock(sb2block);

  if (!blockMetadata) {
    // No block opcode found, exclude this block, increment the commentIndex,
    // make all block comments into workspace comments and send them to zero/zero
    // to prevent serialization issues.
    if (commentsForParsedBlock) {
      commentsForParsedBlock.forEach(comment => {
        comment.blockId = null;
        comment.x = comment.y = 0;
      });
    }

    return [null, commentIndex + 1];
  }

  const oldOpcode = sb2block[0]; // If the block is from an extension, record it.

  const index = blockMetadata.opcode.indexOf("_");
  const prefix = blockMetadata.opcode.substring(0, index);

  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {
    if (prefix !== "") extensions.extensionIDs.add(prefix);
  } // Block skeleton.


  const activeBlock = {
    id: Utility.uid(),
    // Generate a new block unique ID.
    opcode: blockMetadata.opcode,
    // Converted, e.g. "motion_movesteps".
    inputs: {},
    // Inputs to this block and the blocks they point to.
    fields: {},
    // Fields on this block and their values.
    next: null,
    // Next block.
    shadow: false,
    // No shadow blocks in an SB2 by default.
    children: [] // Store any generated children, flattened in `flatten`.

  }; // Attach any comments to this block..

  if (commentsForParsedBlock) {
    // Attach only the last comment to the block, make all others workspace comments
    activeBlock.comment = commentsForParsedBlock[commentsForParsedBlock.length - 1].id;
    commentsForParsedBlock.forEach(comment => {
      if (comment.id === activeBlock.comment) {
        comment.blockId = activeBlock.id;
      } else {
        // All other comments don't get a block ID and are sent back to zero.
        // This is important, because if they have `null` x/y, serialization breaks.
        comment.blockId = null;
        comment.x = comment.y = 0;
      }
    });
  }

  commentIndex++;
  const parentExpectedArg = parseState.expectedArg; // For a procedure call, generate argument map from proc string.

  if (oldOpcode === "call") {
    blockMetadata.argMap = parseProcedureArgMap(sb2block[1]);
  } // Look at the expected arguments in `blockMetadata.argMap.`
  // The basic problem here is to turn positional SB2 arguments into
  // non-positional named Scratch VM arguments.


  for (let i = 0; i < blockMetadata.argMap.length; i++) {
    const expectedArg = blockMetadata.argMap[i];
    const providedArg = sb2block[i + 1]; // (i = 0 is opcode)
    // Whether the input is obscuring a shadow.

    let shadowObscured = false; // Positional argument is an input.

    if (expectedArg.type === "input") {
      // Create a new block and input metadata.
      const inputUid = Utility.uid();
      activeBlock.inputs[expectedArg.inputName] = {
        name: expectedArg.inputName,
        block: null,
        shadow: null
      };

      if (typeof providedArg === "object" && providedArg) {
        // Block or block list occupies the input.
        let innerBlocks;
        parseState.expectedArg = expectedArg;

        if (typeof providedArg[0] === "object" && providedArg[0]) {
          // Block list occupies the input.
          [innerBlocks, commentIndex] = parseBlockList(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
        } else {
          // Single block occupies the input.
          const parsedBlockDesc = parseBlock(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
          innerBlocks = parsedBlockDesc[0] ? [parsedBlockDesc[0]] : []; // Update commentIndex

          commentIndex = parsedBlockDesc[1];
        }

        parseState.expectedArg = parentExpectedArg; // Check if innerBlocks is not an empty list.
        // An empty list indicates that all the inner blocks from the sb2 have
        // unknown opcodes and have been skipped.

        if (innerBlocks.length > 0) {
          let previousBlock = null;

          for (let j = 0; j < innerBlocks.length; j++) {
            if (j === 0) {
              innerBlocks[j].parent = activeBlock.id;
            } else {
              innerBlocks[j].parent = previousBlock;
            }

            previousBlock = innerBlocks[j].id;
          }

          activeBlock.inputs[expectedArg.inputName].block = innerBlocks[0].id;
          activeBlock.children = activeBlock.children.concat(innerBlocks);
        } // Obscures any shadow.


        shadowObscured = true;
      } // Generate a shadow block to occupy the input.


      if (!expectedArg.inputOp) {
        // Undefined inputOp. inputOp should always be defined for inputs.
        console.warn(`Unknown input operation for input ${expectedArg.inputName} of opcode ${activeBlock.opcode}.`);
        continue;
      }

      if (expectedArg.inputOp === "boolean" || expectedArg.inputOp === "substack") {
        // No editable shadow input; e.g., for a boolean.
        continue;
      } // Each shadow has a field generated for it automatically.
      // Value to be filled in the field.


      let fieldValue = providedArg; // Shadows' field names match the input name, except for these:

      let fieldName = expectedArg.inputName;

      if (expectedArg.inputOp === "math_number" || expectedArg.inputOp === "math_whole_number" || expectedArg.inputOp === "math_positive_number" || expectedArg.inputOp === "math_integer" || expectedArg.inputOp === "math_angle") {
        fieldName = "NUM"; // Fields are given Scratch 2.0 default values if obscured.

        if (shadowObscured) {
          fieldValue = 10;
        }
      } else if (expectedArg.inputOp === "text") {
        fieldName = "TEXT";

        if (shadowObscured) {
          fieldValue = "";
        }
      } else if (expectedArg.inputOp === "colour_picker") {
        // Convert SB2 color to hex.
        fieldValue = Utility.decimalToHex(providedArg);
        fieldName = "COLOUR";

        if (shadowObscured) {
          fieldValue = "#990000";
        }
      } else if (expectedArg.inputOp === "event_broadcast_menu") {
        fieldName = "BROADCAST_OPTION";

        if (shadowObscured) {
          fieldValue = "";
        }
      } else if (expectedArg.inputOp === "sensing_of_object_menu") {
        if (shadowObscured) {
          fieldValue = "_stage_";
        } else if (fieldValue === "Stage") {
          fieldValue = "_stage_";
        }
      } else if (expectedArg.inputOp === "note") {
        if (shadowObscured) {
          fieldValue = 60;
        }
      } else if (expectedArg.inputOp === "music.menu.DRUM") {
        if (shadowObscured) {
          fieldValue = 1;
        }
      } else if (expectedArg.inputOp === "music.menu.INSTRUMENT") {
        if (shadowObscured) {
          fieldValue = 1;
        }
      } else if (expectedArg.inputOp === "videoSensing.menu.ATTRIBUTE") {
        if (shadowObscured) {
          fieldValue = "motion";
        }
      } else if (expectedArg.inputOp === "videoSensing.menu.SUBJECT") {
        if (shadowObscured) {
          fieldValue = "this sprite";
        }
      } else if (expectedArg.inputOp === "videoSensing.menu.VIDEO_STATE") {
        if (shadowObscured) {
          fieldValue = "on";
        }
      } else if (shadowObscured) {
        // Filled drop-down menu.
        fieldValue = "";
      }

      const fields = {};
      fields[fieldName] = {
        name: fieldName,
        value: fieldValue
      }; // event_broadcast_menus have some extra properties to add to the
      // field and a different value than the rest

      if (expectedArg.inputOp === "event_broadcast_menu") {
        // Need to update the broadcast message name map with
        // the value of this field.
        // Also need to provide the fields[fieldName] object,
        // so that we can later update its value property, e.g.
        // if sb2 message name is empty string, we will later
        // replace this field's value with messageN
        // once we can traverse through all the existing message names
        // and come up with a fresh messageN.
        const broadcastId = addBroadcastMsg(fieldValue, fields[fieldName]);
        fields[fieldName].id = broadcastId;
        fields[fieldName].variableType = expectedArg.variableType;
      }

      activeBlock.children.push({
        id: inputUid,
        opcode: expectedArg.inputOp,
        inputs: {},
        fields: fields,
        next: null,
        topLevel: false,
        parent: activeBlock.id,
        shadow: true
      });
      activeBlock.inputs[expectedArg.inputName].shadow = inputUid; // If no block occupying the input, alias to the shadow.

      if (!activeBlock.inputs[expectedArg.inputName].block) {
        activeBlock.inputs[expectedArg.inputName].block = inputUid;
      }
    } else if (expectedArg.type === "field") {
      // Add as a field on this block.
      activeBlock.fields[expectedArg.fieldName] = {
        name: expectedArg.fieldName,
        value: providedArg
      };

      if (expectedArg.fieldName === "CURRENTMENU") {
        // In 3.0, the field value of the `sensing_current` block
        // is in all caps.
        activeBlock.fields[expectedArg.fieldName].value = providedArg.toUpperCase();

        if (providedArg === "day of week") {
          activeBlock.fields[expectedArg.fieldName].value = "DAYOFWEEK";
        }
      }

      if (expectedArg.fieldName === "VARIABLE") {
        // Add `id` property to variable fields
        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.SCALAR_TYPE);
      } else if (expectedArg.fieldName === "LIST") {
        // Add `id` property to variable fields
        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.LIST_TYPE);
      } else if (expectedArg.fieldName === "BROADCAST_OPTION") {
        // Add the name in this field to the broadcast msg name map.
        // Also need to provide the fields[fieldName] object,
        // so that we can later update its value property, e.g.
        // if sb2 message name is empty string, we will later
        // replace this field's value with messageN
        // once we can traverse through all the existing message names
        // and come up with a fresh messageN.
        const broadcastId = addBroadcastMsg(providedArg, activeBlock.fields[expectedArg.fieldName]);
        activeBlock.fields[expectedArg.fieldName].id = broadcastId;
      }

      const varType = expectedArg.variableType;

      if (typeof varType === "string") {
        activeBlock.fields[expectedArg.fieldName].variableType = varType;
      }
    }
  } // Updates for blocks that have new menus (e.g. in Looks)


  switch (oldOpcode) {
    case "comeToFront":
      activeBlock.fields.FRONT_BACK = {
        name: "FRONT_BACK",
        value: "front"
      };
      break;

    case "goBackByLayers:":
      activeBlock.fields.FORWARD_BACKWARD = {
        name: "FORWARD_BACKWARD",
        value: "backward"
      };
      break;

    case "backgroundIndex":
      activeBlock.fields.NUMBER_NAME = {
        name: "NUMBER_NAME",
        value: "number"
      };
      break;

    case "sceneName":
      activeBlock.fields.NUMBER_NAME = {
        name: "NUMBER_NAME",
        value: "name"
      };
      break;

    case "costumeIndex":
      activeBlock.fields.NUMBER_NAME = {
        name: "NUMBER_NAME",
        value: "number"
      };
      break;

    case "costumeName":
      activeBlock.fields.NUMBER_NAME = {
        name: "NUMBER_NAME",
        value: "name"
      };
      break;
  } // Special cases to generate mutations.


  if (oldOpcode === "stopScripts") {
    // Mutation for stop block: if the argument is 'other scripts',
    // the block needs a next connection.
    if (sb2block[1] === "other scripts in sprite" || sb2block[1] === "other scripts in stage") {
      activeBlock.mutation = {
        tagName: "mutation",
        hasnext: "true",
        children: []
      };
    }
  } else if (oldOpcode === "procDef") {
    // Mutation for procedure definition:
    // store all 2.0 proc data.
    const procData = sb2block.slice(1); // Create a new block and input metadata.

    const inputUid = Utility.uid();
    const inputName = "custom_block";
    activeBlock.inputs[inputName] = {
      name: inputName,
      block: inputUid,
      shadow: inputUid
    };
    activeBlock.children = [{
      id: inputUid,
      opcode: "procedures_prototype",
      inputs: {},
      fields: {},
      next: null,
      shadow: true,
      children: [],
      mutation: {
        tagName: "mutation",
        proccode: procData[0],
        // e.g., "abc %n %b %s"
        argumentnames: JSON.stringify(procData[1]),
        // e.g. ['arg1', 'arg2']
        argumentids: JSON.stringify(parseProcedureArgIds(procData[0])),
        argumentdefaults: JSON.stringify(procData[2]),
        // e.g., [1, 'abc']
        warp: procData[3],
        // Warp mode, e.g., true/false.
        children: []
      }
    }];
  } else if (oldOpcode === "call") {
    // Mutation for procedure call:
    // string for proc code (e.g., "abc %n %b %s").
    activeBlock.mutation = {
      tagName: "mutation",
      children: [],
      proccode: sb2block[1],
      argumentids: JSON.stringify(parseProcedureArgIds(sb2block[1]))
    };
  } else if (oldOpcode === "getParam") {
    let returnCode = sb2block[2]; // Ensure the returnCode is "b" if used in a boolean input.

    if (parentExpectedArg && parentExpectedArg.inputOp === "boolean" && returnCode !== "b") {
      returnCode = "b";
    } // Assign correct opcode based on the block shape.


    switch (returnCode) {
      case "r":
        activeBlock.opcode = "argument_reporter_string_number";
        break;

      case "b":
        activeBlock.opcode = "argument_reporter_boolean";
        break;
    }
  }

  return [activeBlock, commentIndex];
};

module.exports = {
  deserialize: sb2import
};

/***/ }),

/***/ "./src/serialization/sb2_specmap.js":
/*!******************************************!*\
  !*** ./src/serialization/sb2_specmap.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * The specMap below handles a few pieces of "translation" work between
 * the SB2 JSON format and the data we need to run a project
 * in the Scratch 3.0 VM.
 * Notably:
 *  - Map 2.0 and 1.4 opcodes (forward:) into 3.0-format (motion_movesteps).
 *  - Map ordered, unnamed args to unordered, named inputs and fields.
 * Keep this up-to-date as 3.0 blocks are renamed, changed, etc.
 * Originally this was generated largely by a hand-guided scripting process.
 * The relevant data lives here:
 * https://github.com/LLK/scratch-flash/blob/master/src/Specs.as
 * (for the old opcode and argument order).
 * and here:
 * https://github.com/LLK/scratch-blocks/tree/develop/blocks_vertical
 * (for the new opcodes and argument names).
 * and here:
 * https://github.com/LLK/scratch-blocks/blob/develop/tests/
 * (for the shadow blocks created for each block).
 * I started with the `commands` array in Specs.as, and discarded irrelevant
 * properties. By hand, I matched the opcode name to the 3.0 opcode.
 * Finally, I filled in the expected arguments as below.
 */
const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");
/**
 * @typedef {object} SB2SpecMap_blockInfo
 * @property {string} opcode - the Scratch 3.0 block opcode. Use 'extensionID.opcode' for extension opcodes.
 * @property {Array.<SB2SpecMap_argInfo>} argMap - metadata for this block's arguments.
 */

/**
 * @typedef {object} SB2SpecMap_argInfo
 * @property {string} type - the type of this arg (such as 'input' or 'field')
 * @property {string} inputOp - the scratch-blocks shadow type for this arg
 * @property {string} inputName - the name this argument will take when provided to the block implementation
 */

/**
 * Mapping of Scratch 2.0 opcode to Scratch 3.0 block metadata.
 * @type {object.<SB2SpecMap_blockInfo>}
 */


const specMap = {
  'forward:': {
    opcode: 'motion_movesteps',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'STEPS'
    }]
  },
  'turnRight:': {
    opcode: 'motion_turnright',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DEGREES'
    }]
  },
  'turnLeft:': {
    opcode: 'motion_turnleft',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DEGREES'
    }]
  },
  'heading:': {
    opcode: 'motion_pointindirection',
    argMap: [{
      type: 'input',
      inputOp: 'math_angle',
      inputName: 'DIRECTION'
    }]
  },
  'pointTowards:': {
    opcode: 'motion_pointtowards',
    argMap: [{
      type: 'input',
      inputOp: 'motion_pointtowards_menu',
      inputName: 'TOWARDS'
    }]
  },
  'gotoX:y:': {
    opcode: 'motion_gotoxy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'gotoSpriteOrMouse:': {
    opcode: 'motion_goto',
    argMap: [{
      type: 'input',
      inputOp: 'motion_goto_menu',
      inputName: 'TO'
    }]
  },
  'glideSecs:toX:y:elapsed:from:': {
    opcode: 'motion_glidesecstoxy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'changeXposBy:': {
    opcode: 'motion_changexby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DX'
    }]
  },
  'xpos:': {
    opcode: 'motion_setx',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }]
  },
  'changeYposBy:': {
    opcode: 'motion_changeyby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DY'
    }]
  },
  'ypos:': {
    opcode: 'motion_sety',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'bounceOffEdge': {
    opcode: 'motion_ifonedgebounce',
    argMap: []
  },
  'setRotationStyle': {
    opcode: 'motion_setrotationstyle',
    argMap: [{
      type: 'field',
      fieldName: 'STYLE'
    }]
  },
  'xpos': {
    opcode: 'motion_xposition',
    argMap: []
  },
  'ypos': {
    opcode: 'motion_yposition',
    argMap: []
  },
  'heading': {
    opcode: 'motion_direction',
    argMap: []
  },
  'scrollRight': {
    opcode: 'motion_scroll_right',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DISTANCE'
    }]
  },
  'scrollUp': {
    opcode: 'motion_scroll_up',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DISTANCE'
    }]
  },
  'scrollAlign': {
    opcode: 'motion_align_scene',
    argMap: [{
      type: 'field',
      fieldName: 'ALIGNMENT'
    }]
  },
  'xScroll': {
    opcode: 'motion_xscroll',
    argMap: []
  },
  'yScroll': {
    opcode: 'motion_yscroll',
    argMap: []
  },
  'say:duration:elapsed:from:': {
    opcode: 'looks_sayforsecs',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }]
  },
  'say:': {
    opcode: 'looks_say',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }]
  },
  'think:duration:elapsed:from:': {
    opcode: 'looks_thinkforsecs',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }]
  },
  'think:': {
    opcode: 'looks_think',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }]
  },
  'show': {
    opcode: 'looks_show',
    argMap: []
  },
  'hide': {
    opcode: 'looks_hide',
    argMap: []
  },
  'hideAll': {
    opcode: 'looks_hideallsprites',
    argMap: []
  },
  'lookLike:': {
    opcode: 'looks_switchcostumeto',
    argMap: [{
      type: 'input',
      inputOp: 'looks_costume',
      inputName: 'COSTUME'
    }]
  },
  'nextCostume': {
    opcode: 'looks_nextcostume',
    argMap: []
  },
  'startScene': {
    opcode: 'looks_switchbackdropto',
    argMap: [{
      type: 'input',
      inputOp: 'looks_backdrops',
      inputName: 'BACKDROP'
    }]
  },
  'changeGraphicEffect:by:': {
    opcode: 'looks_changeeffectby',
    argMap: [{
      type: 'field',
      fieldName: 'EFFECT'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setGraphicEffect:to:': {
    opcode: 'looks_seteffectto',
    argMap: [{
      type: 'field',
      fieldName: 'EFFECT'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VALUE'
    }]
  },
  'filterReset': {
    opcode: 'looks_cleargraphiceffects',
    argMap: []
  },
  'changeSizeBy:': {
    opcode: 'looks_changesizeby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setSizeTo:': {
    opcode: 'looks_setsizeto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'changeStretchBy:': {
    opcode: 'looks_changestretchby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setStretchTo:': {
    opcode: 'looks_setstretchto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'STRETCH'
    }]
  },
  'comeToFront': {
    opcode: 'looks_gotofrontback',
    argMap: []
  },
  'goBackByLayers:': {
    opcode: 'looks_goforwardbackwardlayers',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'NUM'
    }]
  },
  'costumeIndex': {
    opcode: 'looks_costumenumbername',
    argMap: []
  },
  'costumeName': {
    opcode: 'looks_costumenumbername',
    argMap: []
  },
  'sceneName': {
    opcode: 'looks_backdropnumbername',
    argMap: []
  },
  'scale': {
    opcode: 'looks_size',
    argMap: []
  },
  'startSceneAndWait': {
    opcode: 'looks_switchbackdroptoandwait',
    argMap: [{
      type: 'input',
      inputOp: 'looks_backdrops',
      inputName: 'BACKDROP'
    }]
  },
  'nextScene': {
    opcode: 'looks_nextbackdrop',
    argMap: []
  },
  'backgroundIndex': {
    opcode: 'looks_backdropnumbername',
    argMap: []
  },
  'playSound:': {
    opcode: 'sound_play',
    argMap: [{
      type: 'input',
      inputOp: 'sound_sounds_menu',
      inputName: 'SOUND_MENU'
    }]
  },
  'doPlaySoundAndWait': {
    opcode: 'sound_playuntildone',
    argMap: [{
      type: 'input',
      inputOp: 'sound_sounds_menu',
      inputName: 'SOUND_MENU'
    }]
  },
  'stopAllSounds': {
    opcode: 'sound_stopallsounds',
    argMap: []
  },
  'playDrum': {
    opcode: 'music_playDrumForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'music_menu_DRUM',
      inputName: 'DRUM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'drum:duration:elapsed:from:': {
    opcode: 'music_midiPlayDrumForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DRUM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'rest:elapsed:from:': {
    opcode: 'music_restForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'noteOn:duration:elapsed:from:': {
    opcode: 'music_playNoteForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'note',
      inputName: 'NOTE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'instrument:': {
    opcode: 'music_setInstrument',
    argMap: [{
      type: 'input',
      inputOp: 'music_menu_INSTRUMENT',
      inputName: 'INSTRUMENT'
    }]
  },
  'midiInstrument:': {
    opcode: 'music_midiSetInstrument',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'INSTRUMENT'
    }]
  },
  'changeVolumeBy:': {
    opcode: 'sound_changevolumeby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VOLUME'
    }]
  },
  'setVolumeTo:': {
    opcode: 'sound_setvolumeto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VOLUME'
    }]
  },
  'volume': {
    opcode: 'sound_volume',
    argMap: []
  },
  'changeTempoBy:': {
    opcode: 'music_changeTempo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TEMPO'
    }]
  },
  'setTempoTo:': {
    opcode: 'music_setTempo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TEMPO'
    }]
  },
  'tempo': {
    opcode: 'music_getTempo',
    argMap: []
  },
  'clearPenTrails': {
    opcode: 'pen_clear',
    argMap: []
  },
  'stampCostume': {
    opcode: 'pen_stamp',
    argMap: []
  },
  'putPenDown': {
    opcode: 'pen_penDown',
    argMap: []
  },
  'putPenUp': {
    opcode: 'pen_penUp',
    argMap: []
  },
  'penColor:': {
    opcode: 'pen_setPenColorToColor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }]
  },
  'changePenHueBy:': {
    opcode: 'pen_changePenHueBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'HUE'
    }]
  },
  'setPenHueTo:': {
    opcode: 'pen_setPenHueToNumber',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'HUE'
    }]
  },
  'changePenShadeBy:': {
    opcode: 'pen_changePenShadeBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SHADE'
    }]
  },
  'setPenShadeTo:': {
    opcode: 'pen_setPenShadeToNumber',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SHADE'
    }]
  },
  'changePenSizeBy:': {
    opcode: 'pen_changePenSizeBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'penSize:': {
    opcode: 'pen_setPenSizeTo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'senseVideoMotion': {
    opcode: 'videoSensing_videoOn',
    argMap: [{
      type: 'input',
      inputOp: 'videoSensing_menu_ATTRIBUTE',
      inputName: 'ATTRIBUTE'
    }, {
      type: 'input',
      inputOp: 'videoSensing_menu_SUBJECT',
      inputName: 'SUBJECT'
    }]
  },
  'whenGreenFlag': {
    opcode: 'event_whenflagclicked',
    argMap: []
  },
  'whenKeyPressed': {
    opcode: 'event_whenkeypressed',
    argMap: [{
      type: 'field',
      fieldName: 'KEY_OPTION'
    }]
  },
  'whenClicked': {
    opcode: 'event_whenthisspriteclicked',
    argMap: []
  },
  'whenSceneStarts': {
    opcode: 'event_whenbackdropswitchesto',
    argMap: [{
      type: 'field',
      fieldName: 'BACKDROP'
    }]
  },
  'whenSensorGreaterThan': ([, sensor]) => {
    if (sensor === 'video motion') {
      return {
        opcode: 'videoSensing_whenMotionGreaterThan',
        argMap: [// skip the first arg, since we converted to a video specific sensing block
        {}, {
          type: 'input',
          inputOp: 'math_number',
          inputName: 'REFERENCE'
        }]
      };
    }

    return {
      opcode: 'event_whengreaterthan',
      argMap: [{
        type: 'field',
        fieldName: 'WHENGREATERTHANMENU'
      }, {
        type: 'input',
        inputOp: 'math_number',
        inputName: 'VALUE'
      }]
    };
  },
  'whenIReceive': {
    opcode: 'event_whenbroadcastreceived',
    argMap: [{
      type: 'field',
      fieldName: 'BROADCAST_OPTION',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'broadcast:': {
    opcode: 'event_broadcast',
    argMap: [{
      type: 'input',
      inputOp: 'event_broadcast_menu',
      inputName: 'BROADCAST_INPUT',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'doBroadcastAndWait': {
    opcode: 'event_broadcastandwait',
    argMap: [{
      type: 'input',
      inputOp: 'event_broadcast_menu',
      inputName: 'BROADCAST_INPUT',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'wait:elapsed:from:': {
    opcode: 'control_wait',
    argMap: [{
      type: 'input',
      inputOp: 'math_positive_number',
      inputName: 'DURATION'
    }]
  },
  'doRepeat': {
    opcode: 'control_repeat',
    argMap: [{
      type: 'input',
      inputOp: 'math_whole_number',
      inputName: 'TIMES'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doForever': {
    opcode: 'control_forever',
    argMap: [{
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doIf': {
    opcode: 'control_if',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doIfElse': {
    opcode: 'control_if_else',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK2'
    }]
  },
  'doWaitUntil': {
    opcode: 'control_wait_until',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }]
  },
  'doUntil': {
    opcode: 'control_repeat_until',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doWhile': {
    opcode: 'control_while',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doForLoop': {
    opcode: 'control_for_each',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'VALUE'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'stopScripts': {
    opcode: 'control_stop',
    argMap: [{
      type: 'field',
      fieldName: 'STOP_OPTION'
    }]
  },
  'whenCloned': {
    opcode: 'control_start_as_clone',
    argMap: []
  },
  'createCloneOf': {
    opcode: 'control_create_clone_of',
    argMap: [{
      type: 'input',
      inputOp: 'control_create_clone_of_menu',
      inputName: 'CLONE_OPTION'
    }]
  },
  'deleteClone': {
    opcode: 'control_delete_this_clone',
    argMap: []
  },
  'COUNT': {
    opcode: 'control_get_counter',
    argMap: []
  },
  'INCR_COUNT': {
    opcode: 'control_incr_counter',
    argMap: []
  },
  'CLR_COUNT': {
    opcode: 'control_clear_counter',
    argMap: []
  },
  'warpSpeed': {
    opcode: 'control_all_at_once',
    argMap: [{
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'touching:': {
    opcode: 'sensing_touchingobject',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_touchingobjectmenu',
      inputName: 'TOUCHINGOBJECTMENU'
    }]
  },
  'touchingColor:': {
    opcode: 'sensing_touchingcolor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }]
  },
  'color:sees:': {
    opcode: 'sensing_coloristouchingcolor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }, {
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR2'
    }]
  },
  'distanceTo:': {
    opcode: 'sensing_distanceto',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_distancetomenu',
      inputName: 'DISTANCETOMENU'
    }]
  },
  'doAsk': {
    opcode: 'sensing_askandwait',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'QUESTION'
    }]
  },
  'answer': {
    opcode: 'sensing_answer',
    argMap: []
  },
  'keyPressed:': {
    opcode: 'sensing_keypressed',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_keyoptions',
      inputName: 'KEY_OPTION'
    }]
  },
  'mousePressed': {
    opcode: 'sensing_mousedown',
    argMap: []
  },
  'mouseX': {
    opcode: 'sensing_mousex',
    argMap: []
  },
  'mouseY': {
    opcode: 'sensing_mousey',
    argMap: []
  },
  'soundLevel': {
    opcode: 'sensing_loudness',
    argMap: []
  },
  'isLoud': {
    opcode: 'sensing_loud',
    argMap: []
  },
  // 'senseVideoMotion': {
  //     opcode: 'sensing_videoon',
  //     argMap: [
  //         {
  //             type: 'input',
  //             inputOp: 'sensing_videoonmenuone',
  //             inputName: 'VIDEOONMENU1'
  //         },
  //         {
  //             type: 'input',
  //             inputOp: 'sensing_videoonmenutwo',
  //             inputName: 'VIDEOONMENU2'
  //         }
  //     ]
  // },
  'setVideoState': {
    opcode: 'videoSensing_videoToggle',
    argMap: [{
      type: 'input',
      inputOp: 'videoSensing_menu_VIDEO_STATE',
      inputName: 'VIDEO_STATE'
    }]
  },
  'setVideoTransparency': {
    opcode: 'videoSensing_setVideoTransparency',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TRANSPARENCY'
    }]
  },
  'timer': {
    opcode: 'sensing_timer',
    argMap: []
  },
  'timerReset': {
    opcode: 'sensing_resettimer',
    argMap: []
  },
  'getAttribute:of:': {
    opcode: 'sensing_of',
    argMap: [{
      type: 'field',
      fieldName: 'PROPERTY'
    }, {
      type: 'input',
      inputOp: 'sensing_of_object_menu',
      inputName: 'OBJECT'
    }]
  },
  'timeAndDate': {
    opcode: 'sensing_current',
    argMap: [{
      type: 'field',
      fieldName: 'CURRENTMENU'
    }]
  },
  'timestamp': {
    opcode: 'sensing_dayssince2000',
    argMap: []
  },
  'getUserName': {
    opcode: 'sensing_username',
    argMap: []
  },
  'getUserId': {
    opcode: 'sensing_userid',
    argMap: []
  },
  '+': {
    opcode: 'operator_add',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '-': {
    opcode: 'operator_subtract',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '*': {
    opcode: 'operator_multiply',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '/': {
    opcode: 'operator_divide',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  'randomFrom:to:': {
    opcode: 'operator_random',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'FROM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TO'
    }]
  },
  '<': {
    opcode: 'operator_lt',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '=': {
    opcode: 'operator_equals',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '>': {
    opcode: 'operator_gt',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '&': {
    opcode: 'operator_and',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND2'
    }]
  },
  '|': {
    opcode: 'operator_or',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND2'
    }]
  },
  'not': {
    opcode: 'operator_not',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND'
    }]
  },
  'concatenate:with:': {
    opcode: 'operator_join',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING2'
    }]
  },
  'letter:of:': {
    opcode: 'operator_letter_of',
    argMap: [{
      type: 'input',
      inputOp: 'math_whole_number',
      inputName: 'LETTER'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING'
    }]
  },
  'stringLength:': {
    opcode: 'operator_length',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING'
    }]
  },
  '%': {
    opcode: 'operator_mod',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  'rounded': {
    opcode: 'operator_round',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM'
    }]
  },
  'computeFunction:of:': {
    opcode: 'operator_mathop',
    argMap: [{
      type: 'field',
      fieldName: 'OPERATOR'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM'
    }]
  },
  'readVariable': {
    opcode: 'data_variable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  // Scratch 2 uses this alternative variable getter opcode only in monitors,
  // blocks use the `readVariable` opcode above.
  'getVar:': {
    opcode: 'data_variable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'setVar:to:': {
    opcode: 'data_setvariableto',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'VALUE'
    }]
  },
  'changeVar:by:': {
    opcode: 'data_changevariableby',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VALUE'
    }]
  },
  'showVariable:': {
    opcode: 'data_showvariable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'hideVariable:': {
    opcode: 'data_hidevariable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'contentsOfList:': {
    opcode: 'data_listcontents',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'append:toList:': {
    opcode: 'data_addtolist',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'deleteLine:ofList:': {
    opcode: 'data_deleteoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'insert:at:ofList:': {
    opcode: 'data_insertatlist',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }, {
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'setLine:ofList:to:': {
    opcode: 'data_replaceitemoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }]
  },
  'getLine:ofList:': {
    opcode: 'data_itemoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'lineCountOfList:': {
    opcode: 'data_lengthoflist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'list:contains:': {
    opcode: 'data_listcontainsitem',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }]
  },
  'showList:': {
    opcode: 'data_showlist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'hideList:': {
    opcode: 'data_hidelist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'procDef': {
    opcode: 'procedures_definition',
    argMap: []
  },
  'getParam': {
    // Doesn't map to single opcode. Import step assigns final correct opcode.
    opcode: 'argument_reporter_string_number',
    argMap: [{
      type: 'field',
      fieldName: 'VALUE'
    }]
  },
  'call': {
    opcode: 'procedures_call',
    argMap: []
  }
};
/**
 * Add to the specMap entries for an opcode from a Scratch 2.0 extension. Two entries will be made with the same
 * metadata; this is done to support projects saved by both older and newer versions of the Scratch 2.0 editor.
 * @param {string} sb2Extension - the Scratch 2.0 name of the extension
 * @param {string} sb2Opcode - the Scratch 2.0 opcode
 * @param {SB2SpecMap_blockInfo} blockInfo - the Scratch 3.0 block info
 */

const addExtensionOp = function (sb2Extension, sb2Opcode, blockInfo) {
  /**
   * This string separates the name of an extension and the name of an opcode in more recent Scratch 2.0 projects.
   * Earlier projects used '.' as a separator, up until we added the 'LEGO WeDo 2.0' extension...
   * @type {string}
   */
  const sep = '\u001F'; // Unicode Unit Separator
  // make one entry for projects saved by recent versions of the Scratch 2.0 editor

  specMap[`${sb2Extension}${sep}${sb2Opcode}`] = blockInfo; // make a second for projects saved by older versions of the Scratch 2.0 editor

  specMap[`${sb2Extension}.${sb2Opcode}`] = blockInfo;
};

const weDo2 = 'LEGO WeDo 2.0';
addExtensionOp(weDo2, 'motorOnFor', {
  opcode: 'wedo2_motorOnFor',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'DURATION'
  }]
});
addExtensionOp(weDo2, 'motorOn', {
  opcode: 'wedo2_motorOn',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }]
});
addExtensionOp(weDo2, 'motorOff', {
  opcode: 'wedo2_motorOff',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }]
});
addExtensionOp(weDo2, 'startMotorPower', {
  opcode: 'wedo2_startMotorPower',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'POWER'
  }]
});
addExtensionOp(weDo2, 'setMotorDirection', {
  opcode: 'wedo2_setMotorDirection',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_DIRECTION',
    inputName: 'MOTOR_DIRECTION'
  }]
});
addExtensionOp(weDo2, 'setLED', {
  opcode: 'wedo2_setLightHue',
  argMap: [{
    type: 'input',
    inputOp: 'math_number',
    inputName: 'HUE'
  }]
});
addExtensionOp(weDo2, 'playNote', {
  opcode: 'wedo2_playNoteFor',
  argMap: [{
    type: 'input',
    inputOp: 'math_number',
    inputName: 'NOTE'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'DURATION'
  }]
});
addExtensionOp(weDo2, 'whenDistance', {
  opcode: 'wedo2_whenDistance',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_OP',
    inputName: 'OP'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'REFERENCE'
  }]
});
addExtensionOp(weDo2, 'whenTilted', {
  opcode: 'wedo2_whenTilted',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION_ANY',
    inputName: 'TILT_DIRECTION_ANY'
  }]
});
addExtensionOp(weDo2, 'getDistance', {
  opcode: 'wedo2_getDistance',
  argMap: []
});
addExtensionOp(weDo2, 'isTilted', {
  opcode: 'wedo2_isTilted',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION_ANY',
    inputName: 'TILT_DIRECTION_ANY'
  }]
});
addExtensionOp(weDo2, 'getTilt', {
  opcode: 'wedo2_getTiltAngle',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION',
    inputName: 'TILT_DIRECTION'
  }]
});
module.exports = specMap;

/***/ }),

/***/ "./src/serialization/sb3.js":
/*!**********************************!*\
  !*** ./src/serialization/sb3.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview SB3串行器和解串器。 解析提供的SON，然后生成所有需要的vm运行时结构.
 */
const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");

const Sprite = __webpack_require__(/*! ../sprites/sprite */ "./src/sprites/sprite.js");

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");

const MonitorRecord = __webpack_require__(/*! ../engine/monitor-record */ "./src/engine/monitor-record.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const VariableUtil = __webpack_require__(/*! ../util/variable-util */ "./src/util/variable-util.js");

const {
  loadCostume
} = __webpack_require__(/*! ../import/load-costume.js */ "./src/import/load-costume.js");

const {
  loadSound
} = __webpack_require__(/*! ../import/load-sound.js */ "./src/import/load-sound.js");

const {
  deserializeCostume,
  deserializeSound
} = __webpack_require__(/*! ./deserialize-assets.js */ "./src/serialization/deserialize-assets.js");

const hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * @typedef {object} ImportedProject
 * @property {Array.<Target>} targets - the imported Scratch 3.0 target objects.
 * @property {ImportedExtensionsInfo} extensionsInfo - the ID of each extension actually used by this project.
 */

/**
 * @typedef {object} ImportedExtensionsInfo
 * @property {Set.<string>} extensionIDs - the ID of each extension actually in use by blocks in this project.
 * @property {Map.<string, string>} extensionURLs - map of ID => URL from project metadata. May not match extensionIDs.
 */
// Constants used during serialization and deserialization

const INPUT_SAME_BLOCK_SHADOW = 1; // unobscured shadow

const INPUT_BLOCK_NO_SHADOW = 2; // no shadow

const INPUT_DIFF_BLOCK_SHADOW = 3; // obscured shadow
// There shouldn't be a case where block is null, but shadow is present...
// Constants used during deserialization of an SB3 file

const CORE_EXTENSIONS = ["argument", "colour", "control", "data", "event", "looks", "math", "motion", "operator", "procedures", "sensing", "sound"]; // Constants referring to 'primitive' blocks that are usually shadows,
// or in the case of variables and lists, appear quite often in projects
// math_number

const MATH_NUM_PRIMITIVE = 4; // there's no reason these constants can't collide
// math_positive_number

const POSITIVE_NUM_PRIMITIVE = 5; // with the above, but removing duplication for clarity
// math_whole_number

const WHOLE_NUM_PRIMITIVE = 6; // math_integer

const INTEGER_NUM_PRIMITIVE = 7; // math_angle

const ANGLE_NUM_PRIMITIVE = 8; // colour_picker

const COLOR_PICKER_PRIMITIVE = 9; // text

const TEXT_PRIMITIVE = 10; // event_broadcast_menu

const BROADCAST_PRIMITIVE = 11; // data_variable

const VAR_PRIMITIVE = 12; // data_listcontents

const LIST_PRIMITIVE = 13; // Map block opcodes to the above primitives and the name of the field we can use
// to find the value of the field

const primitiveOpcodeInfoMap = {
  math_number: [MATH_NUM_PRIMITIVE, "NUM"],
  math_positive_number: [POSITIVE_NUM_PRIMITIVE, "NUM"],
  math_whole_number: [WHOLE_NUM_PRIMITIVE, "NUM"],
  math_integer: [INTEGER_NUM_PRIMITIVE, "NUM"],
  math_angle: [ANGLE_NUM_PRIMITIVE, "NUM"],
  colour_picker: [COLOR_PICKER_PRIMITIVE, "COLOUR"],
  text: [TEXT_PRIMITIVE, "TEXT"],
  event_broadcast_menu: [BROADCAST_PRIMITIVE, "BROADCAST_OPTION"],
  data_variable: [VAR_PRIMITIVE, "VARIABLE"],
  data_listcontents: [LIST_PRIMITIVE, "LIST"]
};
/**
 * Serializes primitives described above into a more compact format
 * @param {object} block the block to serialize
 * @return {array} An array representing the information in the block,
 * or null if the given block is not one of the primitives described above.
 */

const serializePrimitiveBlock = function (block) {
  // Returns an array represeting a primitive block or null if not one of
  // the primitive types above
  if (hasOwnProperty.call(primitiveOpcodeInfoMap, block.opcode)) {
    const primitiveInfo = primitiveOpcodeInfoMap[block.opcode];
    const primitiveConstant = primitiveInfo[0];
    const fieldName = primitiveInfo[1];
    const field = block.fields[fieldName];
    const primitiveDesc = [primitiveConstant, field.value];

    if (block.opcode === "event_broadcast_menu") {
      primitiveDesc.push(field.id);
    } else if (block.opcode === "data_variable" || block.opcode === "data_listcontents") {
      primitiveDesc.push(field.id);

      if (block.topLevel) {
        primitiveDesc.push(block.x ? Math.round(block.x) : 0);
        primitiveDesc.push(block.y ? Math.round(block.y) : 0);
      }
    }

    return primitiveDesc;
  }

  return null;
};
/**
 * Serializes the inputs field of a block in a compact form using
 * constants described above to represent the relationship between the
 * inputs of this block (e.g. if there is an unobscured shadow, an obscured shadow
 * -- a block plugged into a droppable input -- or, if there is just a block).
 * Based on this relationship, serializes the ids of the block and shadow (if present)
 *
 * @param {object} inputs The inputs to serialize
 * @return {object} An object representing the serialized inputs
 */


const serializeInputs = function (inputs) {
  const obj = Object.create(null);

  for (const inputName in inputs) {
    if (!hasOwnProperty.call(inputs, inputName)) continue; // if block and shadow refer to the same block, only serialize one

    if (inputs[inputName].block === inputs[inputName].shadow) {
      // has block and shadow, and they are the same
      obj[inputName] = [INPUT_SAME_BLOCK_SHADOW, inputs[inputName].block];
    } else if (inputs[inputName].shadow === null) {
      // does not have shadow
      obj[inputName] = [INPUT_BLOCK_NO_SHADOW, inputs[inputName].block];
    } else {
      // block and shadow are both present and are different
      obj[inputName] = [INPUT_DIFF_BLOCK_SHADOW, inputs[inputName].block, inputs[inputName].shadow];
    }
  }

  return obj;
};
/**
 * Serialize the fields of a block in a more compact form.
 * @param {object} fields The fields object to serialize
 * @return {object} An object representing the serialized fields
 */


const serializeFields = function (fields) {
  const obj = Object.create(null);

  for (const fieldName in fields) {
    if (!hasOwnProperty.call(fields, fieldName)) continue;
    obj[fieldName] = [fields[fieldName].value];

    if (fields[fieldName].hasOwnProperty("id")) {
      obj[fieldName].push(fields[fieldName].id);
    }
  }

  return obj;
};
/**
 * Serialize the given block in the SB3 format with some compression of inputs,
 * fields, and primitives.
 * @param {object} block The block to serialize
 * @return {object | array} A serialized representation of the block. This is an
 * array if the block is one of the primitive types described above or an object,
 * if not.
 */


const serializeBlock = function (block) {
  const serializedPrimitive = serializePrimitiveBlock(block);
  if (serializedPrimitive) return serializedPrimitive; // If serializedPrimitive is null, proceed with serializing a non-primitive block

  const obj = Object.create(null);
  obj.opcode = block.opcode; // NOTE: this is extremely important to serialize even if null;
  // not serializing `next: null` results in strange behavior with block
  // execution

  obj.next = block.next;
  obj.parent = block.parent;
  obj.inputs = serializeInputs(block.inputs);
  obj.fields = serializeFields(block.fields);
  obj.shadow = block.shadow;

  if (block.topLevel) {
    obj.topLevel = true;
    obj.x = block.x ? Math.round(block.x) : 0;
    obj.y = block.y ? Math.round(block.y) : 0;
  } else {
    obj.topLevel = false;
  }

  if (block.mutation) {
    obj.mutation = block.mutation;
  }

  if (block.comment) {
    obj.comment = block.comment;
  }

  return obj;
};
/**
 * Compresses the serialized inputs replacing block/shadow ids that refer to
 * one of the primitives with the primitive itself. E.g.
 *
 * blocks: {
 *      aUidForMyBlock: {
 *          inputs: {
 *               MYINPUT: [1, 'aUidForAnUnobscuredShadowPrimitive']
 *          }
 *      },
 *      aUidForAnUnobscuredShadowPrimitive: [4, 10]
 *      // the above is a primitive representing a 'math_number' with value 10
 * }
 *
 * becomes:
 *
 * blocks: {
 *      aUidForMyBlock: {
 *          inputs: {
 *               MYINPUT: [1, [4, 10]]
 *          }
 *      }
 * }
 * Note: this function modifies the given blocks object in place
 * @param {object} block The block with inputs to compress
 * @param {objec} blocks The object containing all the blocks currently getting serialized
 * @return {object} The serialized block with compressed inputs
 */


const compressInputTree = function (block, blocks) {
  // This is the second pass on the block
  // so the inputs field should be an object of key - array pairs
  const serializedInputs = block.inputs;

  for (const inputName in serializedInputs) {
    // don't need to check for hasOwnProperty because of how we constructed
    // inputs
    const currInput = serializedInputs[inputName]; // traverse currInput skipping the first element, which describes whether the block
    // and shadow are the same

    for (let i = 1; i < currInput.length; i++) {
      if (!currInput[i]) continue; // need this check b/c block/shadow can be null

      const blockOrShadowID = currInput[i]; // replace element of currInput directly
      // (modifying input block directly)

      const blockOrShadow = blocks[blockOrShadowID];

      if (Array.isArray(blockOrShadow)) {
        currInput[i] = blockOrShadow; // Modifying blocks in place!

        delete blocks[blockOrShadowID];
      }
    }
  }

  return block;
};
/**
 * Get non-core extension ID for a given sb3 opcode.
 * @param {!string} opcode The opcode to examine for extension.
 * @return {?string} The extension ID, if it exists and is not a core extension.
 */


const getExtensionIdForOpcode = function (opcode) {
  const index = opcode.indexOf("_");
  const prefix = opcode.substring(0, index);

  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {
    if (prefix !== "") return prefix;
  }
};
/**
 * Serialize the given blocks object (representing all the blocks for the target
 * currently being serialized.)
 * @param {object} blocks The blocks to be serialized
 * @return {Array} An array of the serialized blocks with compressed inputs and
 * compressed primitives and the list of all extension IDs present
 * in the serialized blocks.
 */


const serializeBlocks = function (blocks) {
  const obj = Object.create(null);
  const extensionIDs = new Set();

  for (const blockID in blocks) {
    if (!blocks.hasOwnProperty(blockID)) continue;
    obj[blockID] = serializeBlock(blocks[blockID], blocks);
    const extensionID = getExtensionIdForOpcode(blocks[blockID].opcode);

    if (extensionID) {
      extensionIDs.add(extensionID);
    }
  } // once we have completed a first pass, do a second pass on block inputs


  for (const blockID in obj) {
    // don't need to do the hasOwnProperty check here since we
    // created an object that doesn't get extra properties/functions
    const serializedBlock = obj[blockID]; // caution, this function deletes parts of this object in place as
    // it's traversing it

    obj[blockID] = compressInputTree(serializedBlock, obj); // second pass on connecting primitives to serialized inputs directly
  } // Do one last pass and remove any top level shadows (these are caused by
  // a bug: LLK/scratch-vm#1011, and this pass should be removed once that is
  // completely fixed)


  for (const blockID in obj) {
    const serializedBlock = obj[blockID]; // If the current block is serialized as a primitive (e.g. it's an array
    // instead of an object), AND it is not one of the top level primitives
    // e.g. variable getter or list getter, then it should be deleted as it's
    // a shadow block, and there are no blocks that reference it, otherwise
    // they would have been compressed in the last pass)

    if (Array.isArray(serializedBlock) && [VAR_PRIMITIVE, LIST_PRIMITIVE].indexOf(serializedBlock[0]) < 0) {
      console.warn(`Found an unexpected top level primitive with block ID: ${blockID}; deleting it from serialized blocks.`);
      delete obj[blockID];
    }
  }

  return [obj, Array.from(extensionIDs)];
};
/**
 * Serialize the given costume.
 * @param {object} costume The costume to be serialized.
 * @return {object} A serialized representation of the costume.
 */


const serializeCostume = function (costume) {
  const obj = Object.create(null);
  obj.assetId = costume.assetId;
  obj.name = costume.name;
  obj.bitmapResolution = costume.bitmapResolution; // serialize this property with the name 'md5ext' because that's
  // what it's actually referring to. TODO runtime objects need to be
  // updated to actually refer to this as 'md5ext' instead of 'md5'
  // but that change should be made carefully since it is very
  // pervasive

  obj.md5ext = costume.md5;
  obj.dataFormat = costume.dataFormat.toLowerCase();
  obj.rotationCenterX = costume.rotationCenterX;
  obj.rotationCenterY = costume.rotationCenterY;
  return obj;
};
/**
 * Serialize the given sound.
 * @param {object} sound The sound to be serialized.
 * @return {object} A serialized representation of the sound.
 */


const serializeSound = function (sound) {
  const obj = Object.create(null);
  obj.assetId = sound.assetId;
  obj.name = sound.name;
  obj.dataFormat = sound.dataFormat.toLowerCase();
  obj.format = sound.format;
  obj.rate = sound.rate;
  obj.sampleCount = sound.sampleCount; // serialize this property with the name 'md5ext' because that's
  // what it's actually referring to. TODO runtime objects need to be
  // updated to actually refer to this as 'md5ext' instead of 'md5'
  // but that change should be made carefully since it is very
  // pervasive

  obj.md5ext = sound.md5;
  return obj;
};
/**
 * Serialize the given variables object.
 * @param {object} variables The variables to be serialized.
 * @return {object} A serialized representation of the variables. They get
 * separated by type to compress the representation of each given variable and
 * reduce duplicate information.
 */


const serializeVariables = function (variables) {
  const obj = Object.create(null); // separate out variables into types at the top level so we don't have
  // keep track of a type for each

  obj.variables = Object.create(null);
  obj.lists = Object.create(null);
  obj.broadcasts = Object.create(null);

  for (const varId in variables) {
    const v = variables[varId];

    if (v.type === Variable.BROADCAST_MESSAGE_TYPE) {
      obj.broadcasts[varId] = v.value; // name and value is the same for broadcast msgs

      continue;
    }

    if (v.type === Variable.LIST_TYPE) {
      obj.lists[varId] = [v.name, v.value];
      continue;
    } // otherwise should be a scalar type


    obj.variables[varId] = [v.name, v.value]; // only scalar vars have the potential to be cloud vars

    if (v.isCloud) obj.variables[varId].push(true);
  }

  return obj;
};

const serializeComments = function (comments) {
  const obj = Object.create(null);

  for (const commentId in comments) {
    if (!comments.hasOwnProperty(commentId)) continue;
    const comment = comments[commentId];
    const serializedComment = Object.create(null);
    serializedComment.blockId = comment.blockId;
    serializedComment.x = comment.x;
    serializedComment.y = comment.y;
    serializedComment.width = comment.width;
    serializedComment.height = comment.height;
    serializedComment.minimized = comment.minimized;
    serializedComment.text = comment.text;
    obj[commentId] = serializedComment;
  }

  return obj;
};
/**
 * Serialize the given target. Only serialize properties that are necessary
 * for saving and loading this target.
 * @param {object} target The target to be serialized.
 * @param {Set} extensions A set of extensions to add extension IDs to
 * @return {object} A serialized representation of the given target.
 */


const serializeTarget = function (target, extensions) {
  const obj = Object.create(null);
  let targetExtensions = [];
  obj.isStage = target.isStage;
  obj.name = obj.isStage ? "Stage" : target.name;
  const vars = serializeVariables(target.variables);
  obj.variables = vars.variables;
  obj.lists = vars.lists;
  obj.broadcasts = vars.broadcasts;
  [obj.blocks, targetExtensions] = serializeBlocks(target.blocks);
  obj.comments = serializeComments(target.comments); // TODO remove this check/patch when (#1901) is fixed

  if (target.currentCostume < 0 || target.currentCostume >= target.costumes.length) {
    console.warn(`currentCostume property for target ${target.name} is out of range`);
    target.currentCostume = Utility.clamp(target.currentCostume, 0, target.costumes.length - 1);
  }

  obj.currentCostume = target.currentCostume;
  obj.costumes = target.costumes.map(serializeCostume);
  obj.sounds = target.sounds.map(serializeSound);
  if (target.hasOwnProperty("volume")) obj.volume = target.volume;
  if (target.hasOwnProperty("layerOrder")) obj.layerOrder = target.layerOrder;

  if (obj.isStage) {
    // Only the stage should have these properties
    if (target.hasOwnProperty("tempo")) obj.tempo = target.tempo;
    if (target.hasOwnProperty("videoTransparency")) obj.videoTransparency = target.videoTransparency;
    if (target.hasOwnProperty("videoState")) obj.videoState = target.videoState;
    if (target.hasOwnProperty("textToSpeechLanguage")) obj.textToSpeechLanguage = target.textToSpeechLanguage;
  } else {
    // The stage does not need the following properties, but sprites should
    obj.visible = target.visible;
    obj.x = target.x;
    obj.y = target.y;
    obj.size = target.size;
    obj.direction = target.direction;
    obj.draggable = target.draggable;
    obj.rotationStyle = target.rotationStyle;
  } // Add found extensions to the extensions object


  targetExtensions.forEach(extensionId => {
    extensions.add(extensionId);
  });
  return obj;
};

const getSimplifiedLayerOrdering = function (targets) {
  const layerOrders = targets.map(t => t.getLayerOrder());
  return Utility.reducedSortOrdering(layerOrders);
};

const serializeMonitors = function (monitors) {
  return monitors.valueSeq().map(monitorData => {
    const serializedMonitor = {
      id: monitorData.id,
      mode: monitorData.mode,
      opcode: monitorData.opcode,
      params: monitorData.params,
      spriteName: monitorData.spriteName,
      value: monitorData.value,
      width: monitorData.width,
      height: monitorData.height,
      x: monitorData.x,
      y: monitorData.y,
      visible: monitorData.visible
    };

    if (monitorData.mode !== "list") {
      serializedMonitor.sliderMin = monitorData.sliderMin;
      serializedMonitor.sliderMax = monitorData.sliderMax;
      serializedMonitor.isDiscrete = monitorData.isDiscrete;
    }

    return serializedMonitor;
  });
};
/**
 * Serializes the specified VM runtime.
 * @param {!Runtime} runtime VM runtime instance to be serialized.
 * @param {string=} targetId Optional target id if serializing only a single target
 * @return {object} Serialized runtime instance.
 */


const serialize = function (runtime, targetId) {
  // Fetch targets
  const obj = Object.create(null); // Create extension set to hold extension ids found while serializing targets

  const extensions = new Set();
  const originalTargetsToSerialize = targetId ? [runtime.getTargetById(targetId)] : runtime.targets.filter(target => target.isOriginal);
  const layerOrdering = getSimplifiedLayerOrdering(originalTargetsToSerialize);
  const flattenedOriginalTargets = originalTargetsToSerialize.map(t => t.toJSON()); // If the renderer is attached, and we're serializing a whole project (not a sprite)
  // add a temporary layerOrder property to each target.

  if (runtime.renderer && !targetId) {
    flattenedOriginalTargets.forEach((t, index) => {
      t.layerOrder = layerOrdering[index];
    });
  }

  const serializedTargets = flattenedOriginalTargets.map(t => serializeTarget(t, extensions));

  if (targetId) {
    return serializedTargets[0];
  }

  obj.targets = serializedTargets;
  obj.monitors = serializeMonitors(runtime.getMonitorState()); // Assemble extension list

  obj.extensions = Array.from(extensions); // Assemble metadata

  const meta = Object.create(null);
  meta.semver = "3.0.0";
  meta.vm = "0.2.0"; // Attach full user agent string to metadata if available

  meta.agent = "none";
  if (typeof navigator !== "undefined") meta.agent = navigator.userAgent; // Assemble payload and return

  obj.meta = meta;
  return obj;
};
/**
 * Deserialize a block input descriptors. This is either a
 * block id or a serialized primitive, e.g. an array
 * (see serializePrimitiveBlock function).
 * @param {string | array} inputDescOrId The block input descriptor to be serialized.
 * @param {string} parentId The id of the parent block for this input block.
 * @param {boolean} isShadow Whether or not this input block is a shadow.
 * @param {object} blocks The entire blocks object currently in the process of getting serialized.
 * @return {object} The deserialized input descriptor.
 */


const deserializeInputDesc = function (inputDescOrId, parentId, isShadow, blocks) {
  if (!Array.isArray(inputDescOrId)) return inputDescOrId;
  const primitiveObj = Object.create(null);
  console.warn("sb3:", Utility.uid());
  const newId = Utility.uid();
  primitiveObj.id = newId;
  primitiveObj.next = null;
  primitiveObj.parent = parentId;
  primitiveObj.shadow = isShadow;
  primitiveObj.inputs = Object.create(null); // need a reference to parent id

  switch (inputDescOrId[0]) {
    case MATH_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = "math_number";
        primitiveObj.fields = {
          NUM: {
            name: "NUM",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case POSITIVE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = "math_positive_number";
        primitiveObj.fields = {
          NUM: {
            name: "NUM",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case WHOLE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = "math_whole_number";
        primitiveObj.fields = {
          NUM: {
            name: "NUM",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case INTEGER_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = "math_integer";
        primitiveObj.fields = {
          NUM: {
            name: "NUM",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case ANGLE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = "math_angle";
        primitiveObj.fields = {
          NUM: {
            name: "NUM",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case COLOR_PICKER_PRIMITIVE:
      {
        primitiveObj.opcode = "colour_picker";
        primitiveObj.fields = {
          COLOUR: {
            name: "COLOUR",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case TEXT_PRIMITIVE:
      {
        primitiveObj.opcode = "text";
        primitiveObj.fields = {
          TEXT: {
            name: "TEXT",
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case BROADCAST_PRIMITIVE:
      {
        primitiveObj.opcode = "event_broadcast_menu";
        primitiveObj.fields = {
          BROADCAST_OPTION: {
            name: "BROADCAST_OPTION",
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.BROADCAST_MESSAGE_TYPE
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case VAR_PRIMITIVE:
      {
        primitiveObj.opcode = "data_variable";
        primitiveObj.fields = {
          VARIABLE: {
            name: "VARIABLE",
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.SCALAR_TYPE
          }
        };

        if (inputDescOrId.length > 3) {
          primitiveObj.topLevel = true;
          primitiveObj.x = inputDescOrId[3];
          primitiveObj.y = inputDescOrId[4];
        }

        break;
      }

    case LIST_PRIMITIVE:
      {
        primitiveObj.opcode = "data_listcontents";
        primitiveObj.fields = {
          LIST: {
            name: "LIST",
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.LIST_TYPE
          }
        };

        if (inputDescOrId.length > 3) {
          primitiveObj.topLevel = true;
          primitiveObj.x = inputDescOrId[3];
          primitiveObj.y = inputDescOrId[4];
        }

        break;
      }

    default:
      {
        console.error(`Found unknown primitive type during deserialization: ${JSON.stringify(inputDescOrId)}`);
        return null;
      }
  }

  blocks[newId] = primitiveObj;
  return newId;
};
/**
 * Deserialize the given block inputs.
 * @param {object} inputs The inputs to deserialize.
 * @param {string} parentId The block id of the parent block
 * @param {object} blocks The object representing the entire set of blocks currently
 * in the process of getting deserialized.
 * @return {object} The deserialized and uncompressed inputs.
 */


const deserializeInputs = function (inputs, parentId, blocks) {
  // Explicitly not using Object.create(null) here
  // because we call prototype functions later in the vm
  const obj = {};

  for (const inputName in inputs) {
    if (!hasOwnProperty.call(inputs, inputName)) continue;
    const inputDescArr = inputs[inputName]; // If this block has already been deserialized (it's not an array) skip it

    if (!Array.isArray(inputDescArr)) continue;
    let block = null;
    let shadow = null;
    const blockShadowInfo = inputDescArr[0];

    if (blockShadowInfo === INPUT_SAME_BLOCK_SHADOW) {
      // block and shadow are the same id, and only one is provided
      block = shadow = deserializeInputDesc(inputDescArr[1], parentId, true, blocks);
    } else if (blockShadowInfo === INPUT_BLOCK_NO_SHADOW) {
      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);
    } else {
      // assume INPUT_DIFF_BLOCK_SHADOW
      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);
      shadow = deserializeInputDesc(inputDescArr[2], parentId, true, blocks);
    }

    obj[inputName] = {
      name: inputName,
      block: block,
      shadow: shadow
    };
  }

  return obj;
};
/**
 * Deserialize the given block fields.
 * @param {object} fields The fields to be deserialized
 * @return {object} The deserialized and uncompressed block fields.
 */


const deserializeFields = function (fields) {
  // Explicitly not using Object.create(null) here
  // because we call prototype functions later in the vm
  const obj = {};

  for (const fieldName in fields) {
    if (!hasOwnProperty.call(fields, fieldName)) continue;
    const fieldDescArr = fields[fieldName]; // If this block has already been deserialized (it's not an array) skip it

    if (!Array.isArray(fieldDescArr)) continue;
    obj[fieldName] = {
      name: fieldName,
      value: fieldDescArr[0]
    };

    if (fieldDescArr.length > 1) {
      obj[fieldName].id = fieldDescArr[1];
    }

    if (fieldName === "BROADCAST_OPTION") {
      obj[fieldName].variableType = Variable.BROADCAST_MESSAGE_TYPE;
    } else if (fieldName === "VARIABLE") {
      obj[fieldName].variableType = Variable.SCALAR_TYPE;
    } else if (fieldName === "LIST") {
      obj[fieldName].variableType = Variable.LIST_TYPE;
    }
  }

  return obj;
};
/**
 * Covnert serialized INPUT and FIELD primitives back to hydrated block templates.
 * Should be able to deserialize a format that has already been deserialized.  The only
 * "east" path to adding new targets/code requires going through deserialize, so it should
 * work with pre-parsed deserialized blocks.
 *
 * @param {object} blocks Serialized SB3 "blocks" property of a target. Will be mutated.
 * @return {object} input is modified and returned
 */


const deserializeBlocks = function (blocks) {
  for (const blockId in blocks) {
    if (!Object.prototype.hasOwnProperty.call(blocks, blockId)) {
      continue;
    }

    const block = blocks[blockId];

    if (Array.isArray(block)) {
      // this is one of the primitives
      // delete the old entry in object.blocks and replace it w/the
      // deserialized object
      delete blocks[blockId];
      deserializeInputDesc(block, null, false, blocks);
      continue;
    }

    block.id = blockId; // add id back to block since it wasn't serialized

    block.inputs = deserializeInputs(block.inputs, blockId, blocks);
    block.fields = deserializeFields(block.fields);
  }

  return blocks;
};
/**
 * 解析单个“对象”的资产并加载它们. 这将对对象进行预处理，以支持通过网络为这些资产加载数据，同时将对象进一步处理为“块”，“子画面”和所需的扩展列表。.
 * @param {!object} object 来自JSON的“对象：”精灵，舞台，观察者.
 * @param {!Runtime} runtime 运行时对象，将所有结构加载到.
 * @param {JSZip} zip 描述此项目的SB3文件（从中加载资产）
 * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank}}
 * Sprites中使用的资产对象的承诺数组对象。 以及用于声音资产的SoundBank。 对于不受支持的对象，为null.
 */


const parseKidAssets = function (object, runtime, zip) {
  console.log("sb3.js 进入 parseKidAssets函数", object, runtime, zip); // 观察者/监视器-跳过此对象，直到在VM中实现.

  if (!object.hasOwnProperty("name")) return Promise.resolve(null);
  const assets = {
    costumePromises: null,
    soundPromises: null,
    soundBank: runtime.audioEngine && runtime.audioEngine.createBank()
  }; // Costumes from JSON.

  assets.costumePromises = (object.costumes || []).map(costumeSource => {
    // @todo: 确保所有相关元数据都已被提取.
    const costume = {
      // costumeSource只有在将图片作为精灵上传时才具有资产
      asset: costumeSource.asset,
      assetId: costumeSource.assetId,
      skinId: null,
      name: costumeSource.name,
      bitmapResolution: costumeSource.bitmapResolution,
      rotationCenterX: costumeSource.rotationCenterX,
      rotationCenterY: costumeSource.rotationCenterY
    };
    const dataFormat = costumeSource.dataFormat || costumeSource.assetType && costumeSource.assetType.runtimeFormat || // older format
    "png"; // 如果所有其他方法都失败了，请猜测可能是PNG

    const costumeMd5Ext = costumeSource.hasOwnProperty("md5ext") ? costumeSource.md5ext : `${costumeSource.assetId}.${dataFormat}`;
    costume.md5 = costumeMd5Ext;
    costume.dataFormat = dataFormat; // 应该在上面创建的造型对象而不是源造型对象上调用deserializeCostume，造型对象转换为sb3格式

    console.log("sb3.js parseKidAssets return前", costume, runtime, zip);
    return deserializeCostume(costume, runtime, zip).then(() => loadCostume(costumeMd5Ext, costume, runtime)); // 仅在反序列化过程完成后尝试加载服装
  }); // Sounds from JSON

  assets.soundPromises = (object.sounds || []).map(soundSource => {
    const sound = {
      assetId: soundSource.assetId,
      format: soundSource.format,
      rate: soundSource.rate,
      sampleCount: soundSource.sampleCount,
      name: soundSource.name,
      // TODO we eventually want this property to be called md5ext,
      // but there are many things relying on this particular name at the
      // moment, so this translation is very important
      md5: soundSource.md5ext,
      dataFormat: soundSource.dataFormat,
      data: null
    }; // deserializeSound should be called on the sound object we're
    // creating above instead of the source sound object, because this way
    // we're always loading the 'sb3' representation of the costume
    // any translation that needs to happen will happen in the process
    // of building up the costume object into an sb3 format

    return deserializeSound(sound, runtime, zip).then(() => loadSound(sound, runtime, assets.soundBank)); // Only attempt to load the sound after the deserialization
    // process has been completed.
  });
  console.warn("parseKidAssets函数的最终输出", assets);
  return assets;
};
/**
 * 解析单个“ Scratch对象”并创建其所有内存VM对象.
 * @param {!object} object From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime 运行时对象，将所有结构加载到.
 * @param {ImportedExtensionsInfo} extensions - (in/out) 解析后的扩展信息将存储在此处.
 * @param {JSZip} zip 描述此项目的SB3文件（从中加载资产）
 * @param {object} assets - Promises for assets of this scratch object grouped
 *   into costumes and sounds
 * @return {!Promise.<Target>} Promise for the target created (stage or sprite), or null for unsupported objects.
 */


const parseKidObject = function (object, runtime, extensions, zip, assets) {
  console.log("parseKidObject 解析单个对象:", object, runtime, extensions, zip, assets);

  if (!object.hasOwnProperty("name")) {
    // Watcher/monitor - 跳过此对象，直到在VM中实现.
    // @todo
    return Promise.resolve(null);
  } // 阻止此对象的容器.


  const blocks = new Blocks(runtime); // @todo: 现在，将所有Kid对象（舞台/精灵）加载为Sprite.

  const sprite = new Sprite(blocks, runtime);
  console.log("vm sb3.js 实例化Sprite", sprite); // Sprite/stage name from JSON.

  if (object.hasOwnProperty("name")) sprite.name = object.name;

  if (object.hasOwnProperty("blocks")) {
    deserializeBlocks(object.blocks); // Take a second pass to create objects and add extensions

    for (const blockId in object.blocks) {
      if (!object.blocks.hasOwnProperty(blockId)) continue;
      const blockJSON = object.blocks[blockId];
      blocks.createBlock(blockJSON); // If the block is from an extension, record it.

      const extensionID = getExtensionIdForOpcode(blockJSON.opcode);

      if (extensionID) {
        extensions.extensionIDs.add(extensionID);
      }
    }
  } // Costumes from JSON.


  const {
    costumePromises
  } = assets; // Sounds from JSON

  const {
    soundBank,
    soundPromises
  } = assets; // 创建第一个克隆，并从JSON加载其运行状态.

  console.log("调用 sprite.创建克隆");
  const target = sprite.createClone(object.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER); // 加载目标属性 from JSON.

  if (object.hasOwnProperty("tempo")) {
    target.tempo = object.tempo;
  }

  if (object.hasOwnProperty("volume")) {
    target.volume = object.volume;
  }

  if (object.hasOwnProperty("videoTransparency")) {
    target.videoTransparency = object.videoTransparency;
  }

  if (object.hasOwnProperty("videoState")) {
    target.videoState = object.videoState;
  }

  if (object.hasOwnProperty("textToSpeechLanguage")) {
    target.textToSpeechLanguage = object.textToSpeechLanguage;
  }

  if (object.hasOwnProperty("variables")) {
    for (const varId in object.variables) {
      const variable = object.variables[varId]; // A variable is a cloud variable if:
      // - the project says it's a cloud variable, and
      // - it's a stage variable, and
      // - the runtime can support another cloud variable

      const isCloud = variable.length === 3 && variable[2] && object.isStage && runtime.canAddCloudVariable();
      const newVariable = new Variable(varId, // var id is the index of the variable desc array in the variables obj
      variable[0], // name of the variable
      Variable.SCALAR_TYPE, // type of the variable
      isCloud);
      if (isCloud) runtime.addCloudVariable();
      newVariable.value = variable[1];
      target.variables[newVariable.id] = newVariable;
    }
  }

  if (object.hasOwnProperty("lists")) {
    for (const listId in object.lists) {
      const list = object.lists[listId];
      const newList = new Variable(listId, list[0], Variable.LIST_TYPE, false);
      newList.value = list[1];
      target.variables[newList.id] = newList;
    }
  }

  if (object.hasOwnProperty("broadcasts")) {
    for (const broadcastId in object.broadcasts) {
      const broadcast = object.broadcasts[broadcastId];
      const newBroadcast = new Variable(broadcastId, broadcast, Variable.BROADCAST_MESSAGE_TYPE, false); // no need to explicitly set the value, variable constructor
      // sets the value to the same as the name for broadcast msgs

      target.variables[newBroadcast.id] = newBroadcast;
    }
  }

  if (object.hasOwnProperty("comments")) {
    for (const commentId in object.comments) {
      const comment = object.comments[commentId];
      const newComment = new Comment(commentId, comment.text, comment.x, comment.y, comment.width, comment.height, comment.minimized);

      if (comment.blockId) {
        newComment.blockId = comment.blockId;
      }

      target.comments[newComment.id] = newComment;
    }
  }

  if (object.hasOwnProperty("x")) {
    target.x = object.x;
  }

  if (object.hasOwnProperty("y")) {
    target.y = object.y;
  }

  if (object.hasOwnProperty("direction")) {
    target.direction = object.direction;
  }

  if (object.hasOwnProperty("size")) {
    target.size = object.size;
  }

  if (object.hasOwnProperty("visible")) {
    target.visible = object.visible;
  }

  if (object.hasOwnProperty("currentCostume")) {
    target.currentCostume = Utility.clamp(object.currentCostume, 0, object.costumes.length - 1);
  }

  if (object.hasOwnProperty("rotationStyle")) {
    target.rotationStyle = object.rotationStyle;
  }

  if (object.hasOwnProperty("isStage")) {
    target.isStage = object.isStage;
  }

  if (object.hasOwnProperty("targetPaneOrder")) {
    // Temporarily store the 'targetPaneOrder' property
    // so that we can correctly order sprites in the target pane.
    // This will be deleted after we are done parsing and ordering the targets list.
    target.targetPaneOrder = object.targetPaneOrder;
  }

  if (object.hasOwnProperty("draggable")) {
    target.draggable = object.draggable;
  }

  Promise.all(costumePromises).then(costumes => {
    console.log("vm sb3.js Promise.all ", costumes);
    sprite.costumes = costumes;
  });
  Promise.all(soundPromises).then(sounds => {
    sprite.sounds = sounds; // Make sure if soundBank is undefined, sprite.soundBank is then null.

    sprite.soundBank = soundBank || null;
  });
  return Promise.all(costumePromises.concat(soundPromises)).then(() => target);
};

const deserializeMonitor = function (monitorData, runtime, targets, extensions) {
  // 如果已序列化的监视器定义了spriteName，请在给定的目标列表中按名称查找该sprite，并更新监视器的targetId以匹配该sprite的ID.
  if (monitorData.spriteName) {
    const filteredTargets = targets.filter(t => t.sprite.name === monitorData.spriteName);

    if (filteredTargets && filteredTargets.length > 0) {
      monitorData.targetId = filteredTargets[0].id;
    } else {
      console.warn(`Tried to deserialize sprite specific monitor ${monitorData.opcode} but could not find sprite ${monitorData.spriteName}.`);
    }
  } // Get information about this monitor, if it exists, given the monitor's opcode.
  // This will be undefined for extension blocks


  const monitorBlockInfo = runtime.monitorBlockInfo[monitorData.opcode]; // Due to a bug (see https://github.com/LLK/scratch-vm/pull/2322), renamed list monitors may have been serialized
  // with an outdated/incorrect LIST parameter. Fix it up to use the current name of the actual corresponding list.

  if (monitorData.opcode === "data_listcontents") {
    const listTarget = monitorData.targetId ? targets.find(t => t.id === monitorData.targetId) : targets.find(t => t.isStage);

    if (listTarget && Object.prototype.hasOwnProperty.call(listTarget.variables, monitorData.id)) {
      monitorData.params.LIST = listTarget.variables[monitorData.id].name;
    }
  } // Convert the serialized monitorData params into the block fields structure


  const fields = {};

  for (const paramKey in monitorData.params) {
    const field = {
      name: paramKey,
      value: monitorData.params[paramKey]
    };
    fields[paramKey] = field;
  } // Variables, lists, and non-sprite-specific monitors, including any extension
  // monitors should already have the correct monitor ID serialized in the monitorData,
  // find the correct id for all other monitors.


  if (monitorData.opcode !== "data_variable" && monitorData.opcode !== "data_listcontents" && monitorBlockInfo && monitorBlockInfo.isSpriteSpecific) {
    monitorData.id = monitorBlockInfo.getId(monitorData.targetId, fields);
  } else {
    // Replace unsafe characters in monitor ID, if there are any.
    // These would have come from projects that were originally 2.0 projects
    // that had unsafe characters in the variable name (and then the name was
    // used as part of the variable ID when importing the project).
    monitorData.id = StringUtil.replaceUnsafeChars(monitorData.id);
  } // If the runtime already has a monitor block for this monitor's id,
  // update the existing block with the relevant monitor information.


  const existingMonitorBlock = runtime.monitorBlocks._blocks[monitorData.id];

  if (existingMonitorBlock) {
    // A monitor block already exists if the toolbox has been loaded and
    // the monitor block is not target specific (because the block gets recycled).
    existingMonitorBlock.isMonitored = monitorData.visible;
    existingMonitorBlock.targetId = monitorData.targetId;
  } else {
    // If a monitor block doesn't already exist for this monitor,
    // construct a monitor block to add to the monitor blocks container
    const monitorBlock = {
      id: monitorData.id,
      opcode: monitorData.opcode,
      inputs: {},
      // Assuming that monitor blocks don't have droppable fields
      fields: fields,
      topLevel: true,
      next: null,
      parent: null,
      shadow: false,
      x: 0,
      y: 0,
      isMonitored: monitorData.visible,
      targetId: monitorData.targetId
    }; // Variables and lists have additional properties
    // stored in their fields, update this info in the
    // monitor block fields

    if (monitorData.opcode === "data_variable") {
      const field = monitorBlock.fields.VARIABLE;
      field.id = monitorData.id;
      field.variableType = Variable.SCALAR_TYPE;
    } else if (monitorData.opcode === "data_listcontents") {
      const field = monitorBlock.fields.LIST;
      field.id = monitorData.id;
      field.variableType = Variable.LIST_TYPE;
    }

    runtime.monitorBlocks.createBlock(monitorBlock); // If the block is from an extension, record it.

    const extensionID = getExtensionIdForOpcode(monitorBlock.opcode);

    if (extensionID) {
      extensions.extensionIDs.add(extensionID);
    }
  }

  runtime.requestAddMonitor(MonitorRecord(monitorData));
}; // Replace variable IDs throughout the project with
// xml-safe versions.
// This is to fix up projects imported from 2.0 where xml-unsafe names
// were getting added to the variable ids.


const replaceUnsafeCharsInVariableIds = function (targets) {
  const allVarRefs = VariableUtil.getAllVarRefsForTargets(targets, true); // Re-id the variables in the actual targets

  targets.forEach(t => {
    Object.keys(t.variables).forEach(id => {
      const newId = StringUtil.replaceUnsafeChars(id);
      if (newId === id) return;
      t.variables[id].id = newId;
      t.variables[newId] = t.variables[id];
      delete t.variables[id];
    });
  }); // Replace the IDs in the blocks refrencing variables or lists

  for (const id in allVarRefs) {
    const newId = StringUtil.replaceUnsafeChars(id);
    if (id === newId) continue; // ID was already safe, skip
    // We're calling this on the stage target because we need a
    // target to call on but this shouldn't matter because we're passing
    // in all the varRefs we want to operate on

    VariableUtil.updateVariableIdentifiers(allVarRefs[id], newId);
  }

  return targets;
};
/**
 * 反序列化VM运行时的指定表示并将其加载到提供的运行时实例中.
 * @param  {object} json - VM运行时的JSON表示形式.
 * @param  {Runtime} runtime - Runtime instance
 * @param {JSZip} zip - 描述此项目的SB3文件（从中加载资产）
 * @param {boolean} isSingleSprite - 如果为true，则视为单一子项目，否则视为整个项目
 * @returns {Promise.<ImportedProject>} 反序列化项目后解析为目标列表的承诺
 */


const deserialize = function (json, runtime, zip, isSingleSprite) {
  console.log("sb3.js 反序列化VM运行时", json, runtime, zip, isSingleSprite);
  const extensions = {
    extensionIDs: new Set(),
    extensionURLs: new Map()
  }; // 首先在json中跟踪当前目标订单, 然后在解析目标之前按图层顺序属性进行排序，以便可以按其图层顺序创建其对应的渲染可绘制对象（例如，从后到前）

  const targetObjects = ((isSingleSprite ? [json] : json.targets) || []).map((t, i) => Object.assign(t, {
    targetPaneOrder: i
  })).sort((a, b) => a.layerOrder - b.layerOrder);
  const monitorObjects = json.monitors || [];
  return Promise.resolve(targetObjects.map(target => parseKidAssets(target, runtime, zip))) // 强制此承诺等待js刻度中的下一个循环. 让存储空间有时间发送资产请求.
  .then(assets => Promise.resolve(assets)).then(assets => Promise.all(targetObjects.map((target, index) => parseKidObject(target, runtime, extensions, zip, assets[index])))).then(targets => targets // 将目标重新排序为原始的子画面窗格顺序
  .map((t, i) => {
    // 将层顺序属性添加到反序列化的目标.
    // 此属性用于按正确的顺序初始化可执行目标，并在VM的installTargets函数中删除
    t.layerOrder = i;
    return t;
  }).sort((a, b) => a.targetPaneOrder - b.targetPaneOrder).map(t => {
    // 删除用于精灵面板排序和舞台层排序的临时属性
    delete t.targetPaneOrder;
    return t;
  })).then(targets => replaceUnsafeCharsInVariableIds(targets)).then(targets => {
    monitorObjects.map(monitorDesc => deserializeMonitor(monitorDesc, runtime, targets, extensions));
    return targets;
  }).then(targets => ({
    targets,
    extensions
  }));
};

module.exports = {
  serialize: serialize,
  deserialize: deserialize,
  deserializeBlocks: deserializeBlocks,
  serializeBlocks: serializeBlocks,
  getExtensionIdForOpcode: getExtensionIdForOpcode
};

/***/ }),

/***/ "./src/sprites/rendered-target.js":
/*!****************************************!*\
  !*** ./src/sprites/rendered-target.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const Target = __webpack_require__(/*! ../engine/target */ "./src/engine/target.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");
/**
 * 渲染目标: instance of a sprite (clone), or the stage.
 */


class RenderedTarget extends Target {
  /**
   * @param {!Sprite} sprite Reference to the parent sprite.
   * @param {Runtime} runtime Reference to the runtime.
   * @constructor
   */
  constructor(sprite, runtime) {
    super(runtime, sprite.blocks);
    console.log("class RenderedTarget", sprite, runtime);
    /**
     * Reference to the sprite that this is a render of.
     * @type {!Sprite}
     */

    this.sprite = sprite;
    /**
     * Reference to the global renderer for this VM, if one exists.
     * @type {?RenderWebGL}
     */

    this.renderer = null;

    if (this.runtime) {
      this.renderer = this.runtime.renderer;
    }
    /**
     * ID of the drawable for this rendered target,
     * returned by the renderer, if rendered.
     * @type {?Number}
     */


    this.drawableID = null;
    /**
     * Drag state of this rendered target. If true, x/y position can't be
     * changed by blocks.
     * @type {boolean}
     */

    this.dragging = false;
    /**
     * Map of current graphic effect values.
     * @type {!Object.<string, number>}
     */

    this.effects = {
      color: 0,
      fisheye: 0,
      whirl: 0,
      pixelate: 0,
      mosaic: 0,
      brightness: 0,
      ghost: 0
    };
    /**
     * Whether this represents an "original" non-clone rendered-target for a sprite,
     * i.e., created by the editor and not clone blocks.
     * @type {boolean}
     */

    this.isOriginal = true;
    /**
     * Whether this rendered target represents the Scratch stage.
     * @type {boolean}
     */

    this.isStage = false;
    /**
     * Scratch X coordinate. Currently should range from -240 to 240.
     * @type {Number}
     */

    this.x = 0;
    /**
     * Scratch Y coordinate. Currently should range from -180 to 180.
     * @type {number}
     */

    this.y = 0;
    /**
     * Scratch direction. Currently should range from -179 to 180.
     * @type {number}
     */

    this.direction = 90;
    /**
     * Whether the rendered target is draggable on the stage
     * @type {boolean}
     */

    this.draggable = false;
    /**
     * Whether the rendered target is currently visible.
     * @type {boolean}
     */

    this.visible = true;
    /**
     * Size of rendered target as a percent of costume size.
     * @type {number}
     */

    this.size = 100;
    /**
     * Currently selected costume index.
     * @type {number}
     */

    this.currentCostume = 0;
    /**
     * Current rotation style.
     * @type {!string}
     */

    this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    /**
     * Loudness for sound playback for this target, as a percentage.
     * @type {number}
     */

    this.volume = 100;
    /**
     * Current tempo (used by the music extension).
     * This property is global to the project and stored in the stage.
     * @type {number}
     */

    this.tempo = 60;
    /**
     * The transparency of the video (used by extensions with camera input).
     * This property is global to the project and stored in the stage.
     * @type {number}
     */

    this.videoTransparency = 50;
    /**
     * The state of the video input (used by extensions with camera input).
     * This property is global to the project and stored in the stage.
     *
     * Defaults to ON. This setting does not turn the video by itself. A
     * video extension once loaded will set the video device to this
     * setting. Set to ON when a video extension is added in the editor the
     * video will start ON. If the extension is loaded as part of loading a
     * saved project the extension will see the value set when the stage
     * was loaded from the saved values including the video state.
     *
     * @type {string}
     */

    this.videoState = RenderedTarget.VIDEO_STATE.ON;
    /**
     * The language to use for speech synthesis, in the text2speech extension.
     * It is initialized to null so that on extension load, we can check for
     * this and try setting it using the editor locale.
     * @type {string}
     */

    this.textToSpeechLanguage = null;
  }
  /**
   * Create a drawable with the this.renderer.
   * @param {boolean} layerGroup The layer group this drawable should be added to
   */


  initDrawable(layerGroup) {
    if (this.renderer) {
      this.drawableID = this.renderer.createDrawable(layerGroup);
    } // If we're a clone, start the hats.


    if (!this.isOriginal) {
      this.runtime.startHats("control_start_as_clone", null, this);
    }
  }

  get audioPlayer() {
    /* eslint-disable no-console */
    console.warn("get audioPlayer deprecated, please update to use .sprite.soundBank methods");
    console.warn(new Error("stack for debug").stack);
    /* eslint-enable no-console */

    const bank = this.sprite.soundBank;
    const audioPlayerProxy = {
      playSound: soundId => bank.play(this, soundId)
    };
    Object.defineProperty(this, "audioPlayer", {
      configurable: false,
      enumerable: true,
      writable: false,
      value: audioPlayerProxy
    });
    return audioPlayerProxy;
  }
  /**
   * Initialize the audio player for this sprite or clone.
   */


  initAudio() {}
  /**
   * Event which fires when a target moves.
   * @type {string}
   */


  static get EVENT_TARGET_MOVED() {
    return "TARGET_MOVED";
  }
  /**
   * Event which fires when a target changes visually, for updating say bubbles.
   * @type {string}
   */


  static get EVENT_TARGET_VISUAL_CHANGE() {
    return "EVENT_TARGET_VISUAL_CHANGE";
  }
  /**
   * Rotation style for "all around"/spinning.
   * @type {string}
   */


  static get ROTATION_STYLE_ALL_AROUND() {
    return "all around";
  }
  /**
   * Rotation style for "left-right"/flipping.
   * @type {string}
   */


  static get ROTATION_STYLE_LEFT_RIGHT() {
    return "left-right";
  }
  /**
   * Rotation style for "no rotation."
   * @type {string}
   */


  static get ROTATION_STYLE_NONE() {
    return "don't rotate";
  }
  /**
   * Available states for video input.
   * @enum {string}
   */


  static get VIDEO_STATE() {
    return {
      OFF: "off",
      ON: "on",
      ON_FLIPPED: "on-flipped"
    };
  }
  /**
   * Set the X and Y coordinates.
   * @param {!number} x New X coordinate, in Scratch coordinates.
   * @param {!number} y New Y coordinate, in Scratch coordinates.
   * @param {?boolean} force Force setting X/Y, in case of dragging
   */


  setXY(x, y, force) {
    if (this.isStage) return;
    if (this.dragging && !force) return;
    const oldX = this.x;
    const oldY = this.y;

    if (this.renderer) {
      const position = this.renderer.getFencedPositionOfDrawable(this.drawableID, [x, y]);
      this.x = position[0];
      this.y = position[1];
      this.renderer.updateDrawablePosition(this.drawableID, position);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    } else {
      this.x = x;
      this.y = y;
    }

    this.emit(RenderedTarget.EVENT_TARGET_MOVED, this, oldX, oldY, force);
    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * 应用旋转样式后，获取渲染的方向和比例.
   * @return {object<string, number>} 方向和缩放比例.
   */


  _getRenderedDirectionAndScale() {
    // 默认值：不更改“ this.direction”或“ this.scale”
    let finalDirection = this.direction;
    let finalScale = [this.size, this.size];

    if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
      // 强制渲染方向为90.
      finalDirection = 90;
    } else if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
      // 强制渲染方向为90，并在需要时翻转可绘制.
      finalDirection = 90;
      const scaleFlip = this.direction < 0 ? -1 : 1;
      finalScale = [scaleFlip * this.size, this.size];
    }

    return {
      direction: finalDirection,
      scale: finalScale
    };
  }
  /**
   * 设定方向.
   * @param {!number} direction New direction.
   */


  setDirection(direction) {
    console.log("设置方向:", direction);

    if (this.isStage) {
      return;
    }

    if (!isFinite(direction)) {
      return;
    } // 将方向保持在-179至+180之间.


    this.direction = Utility.wrapClamp(direction, -179, 180);

    if (this.renderer) {
      // 返回方向和缩放比
      const {
        direction: renderedDirection,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawableDirectionScale(this.drawableID, renderedDirection, scale);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set draggability; i.e., whether it's able to be dragged in the player
   * @param {!boolean} draggable True if should be draggable.
   */


  setDraggable(draggable) {
    if (this.isStage) return;
    this.draggable = !!draggable;
    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set visibility; i.e., whether it's shown or hidden.
   * @param {!boolean} visible True if should be shown.
   */


  setVisible(visible) {
    if (this.isStage) {
      return;
    }

    this.visible = !!visible;

    if (this.renderer) {
      this.renderer.updateDrawableVisible(this.drawableID, this.visible);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set size, as a percentage of the costume size.
   * @param {!number} size Size of rendered target, as % of costume size.
   */


  setSize(size) {
    if (this.isStage) {
      return;
    }

    if (this.renderer) {
      // Clamp to scales relative to costume and stage size.
      // See original ScratchSprite.as:setSize.
      const costumeSize = this.renderer.getCurrentSkinSize(this.drawableID);
      const origW = costumeSize[0];
      const origH = costumeSize[1];
      const minScale = Math.min(1, Math.max(5 / origW, 5 / origH));
      const maxScale = Math.min(1.5 * this.runtime.constructor.STAGE_WIDTH / origW, 1.5 * this.runtime.constructor.STAGE_HEIGHT / origH);
      this.size = Utility.clamp(size / 100, minScale, maxScale) * 100;

      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set a particular graphic effect value.
   * @param {!string} effectName Name of effect (see `RenderedTarget.prototype.effects`).
   * @param {!number} value Numerical magnitude of effect.
   */


  setEffect(effectName, value) {
    if (!this.effects.hasOwnProperty(effectName)) return;
    this.effects[effectName] = value;

    if (this.renderer) {
      this.renderer.updateDrawableEffect(this.drawableID, effectName, value);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * Clear all graphic effects on this rendered target.
   */


  clearEffects() {
    for (const effectName in this.effects) {
      if (!this.effects.hasOwnProperty(effectName)) continue;
      this.effects[effectName] = 0;
    }

    if (this.renderer) {
      for (const effectName in this.effects) {
        if (!this.effects.hasOwnProperty(effectName)) continue;
        this.renderer.updateDrawableEffect(this.drawableID, effectName, 0);
      }

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * Set the current costume.
   * @param {number} index New index of costume.
   */


  setCostume(index) {
    // Keep the costume index within possible values.
    index = Math.round(index);
    if ([Infinity, -Infinity, NaN].includes(index)) index = 0;
    this.currentCostume = Utility.wrapClamp(index, 0, this.sprite.costumes.length - 1);

    if (this.renderer) {
      const costume = this.getCostumes()[this.currentCostume];
      this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * 添加服装，注意避免重复的名字.
   * @param {!object} costumeObject Object representing the costume.
   * @param {?int} index Index at which to add costume
   */


  addCostume(costumeObject, index) {
    console.log("render-target.js ()", costumeObject, index);
    typeof index === "number" && !isNaN(index) ? this.sprite.addCostumeAt(costumeObject, index) : this.sprite.addCostumeAt(costumeObject, this.sprite.costumes.length);
  }
  /**
   * Rename a costume, taking care to avoid duplicate names.
   * @param {int} costumeIndex - the index of the costume to be renamed.
   * @param {string} newName - the desired new name of the costume (will be modified if already in use).
   */


  renameCostume(costumeIndex, newName) {
    const usedNames = this.sprite.costumes.filter((costume, index) => costumeIndex !== index).map(costume => costume.name);
    const oldName = this.getCostumes()[costumeIndex].name;
    const newUnusedName = StringUtil.unusedName(newName, usedNames);
    this.getCostumes()[costumeIndex].name = newUnusedName;

    if (this.isStage) {
      // Since this is a backdrop, go through all targets and
      // update any blocks referencing the old backdrop name
      const targets = this.runtime.targets;

      for (let i = 0; i < targets.length; i++) {
        const currTarget = targets[i];
        currTarget.blocks.updateAssetName(oldName, newUnusedName, "backdrop");
      }
    } else {
      this.blocks.updateAssetName(oldName, newUnusedName, "costume");
    }
  }
  /**
   * Delete a costume by index.
   * @param {number} index Costume index to be deleted
   * @return {?object} The costume that was deleted or null
   * if the index was out of bounds of the costumes list or
   * this target only has one costume.
   */


  deleteCostume(index) {
    const originalCostumeCount = this.sprite.costumes.length;
    if (originalCostumeCount === 1) return null;

    if (index < 0 || index >= originalCostumeCount) {
      return null;
    }

    const deletedCostume = this.sprite.deleteCostumeAt(index);

    if (index === this.currentCostume && index === originalCostumeCount - 1) {
      this.setCostume(index - 1);
    } else if (index < this.currentCostume) {
      this.setCostume(this.currentCostume - 1);
    } else {
      this.setCostume(this.currentCostume);
    }

    this.runtime.requestTargetsUpdate(this);
    return deletedCostume;
  }
  /**
   * Add a sound, taking care to avoid duplicate names.
   * @param {!object} soundObject Object representing the sound.
   * @param {?int} index Index at which to add costume
   */


  addSound(soundObject, index) {
    const usedNames = this.sprite.sounds.map(sound => sound.name);
    soundObject.name = StringUtil.unusedName(soundObject.name, usedNames);

    if (typeof index === "number" && !isNaN(index)) {
      this.sprite.sounds.splice(index, 0, soundObject);
    } else {
      this.sprite.sounds.push(soundObject);
    }
  }
  /**
   * Rename a sound, taking care to avoid duplicate names.
   * @param {int} soundIndex - the index of the sound to be renamed.
   * @param {string} newName - the desired new name of the sound (will be modified if already in use).
   */


  renameSound(soundIndex, newName) {
    const usedNames = this.sprite.sounds.filter((sound, index) => soundIndex !== index).map(sound => sound.name);
    const oldName = this.sprite.sounds[soundIndex].name;
    const newUnusedName = StringUtil.unusedName(newName, usedNames);
    this.sprite.sounds[soundIndex].name = newUnusedName;
    this.blocks.updateAssetName(oldName, newUnusedName, "sound");
  }
  /**
   * Delete a sound by index.
   * @param {number} index Sound index to be deleted
   * @return {object} The deleted sound object, or null if no sound was deleted.
   */


  deleteSound(index) {
    // Make sure the sound index is not out of bounds
    if (index < 0 || index >= this.sprite.sounds.length) {
      return null;
    } // Delete the sound at the given index


    const deletedSound = this.sprite.sounds.splice(index, 1)[0];
    this.runtime.requestTargetsUpdate(this);
    return deletedSound;
  }
  /**
   * Update the rotation style.
   * @param {!string} rotationStyle New rotation style.
   */


  setRotationStyle(rotationStyle) {
    if (rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
    } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
    }

    if (this.renderer) {
      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Get a costume index of this rendered target, by name of the costume.
   * @param {?string} costumeName Name of a costume.
   * @return {number} Index of the named costume, or -1 if not present.
   */


  getCostumeIndexByName(costumeName) {
    for (let i = 0; i < this.sprite.costumes.length; i++) {
      if (this.getCostumes()[i].name === costumeName) {
        return i;
      }
    }

    return -1;
  }
  /**
   * Get a costume of this rendered target by id.
   * @return {object} current costume
   */


  getCurrentCostume() {
    return this.getCostumes()[this.currentCostume];
  }
  /**
   * Get full costume list
   * @return {object[]} list of costumes
   */


  getCostumes() {
    return this.sprite.costumes;
  }
  /**
   * Reorder costume list by moving costume at costumeIndex to newIndex.
   * @param {!number} costumeIndex Index of the costume to move.
   * @param {!number} newIndex New index for that costume.
   * @returns {boolean} If a change occurred (i.e. if the indices do not match)
   */


  reorderCostume(costumeIndex, newIndex) {
    newIndex = Utility.clamp(newIndex, 0, this.sprite.costumes.length - 1);
    costumeIndex = Utility.clamp(costumeIndex, 0, this.sprite.costumes.length - 1);
    if (newIndex === costumeIndex) return false;
    const currentCostume = this.getCurrentCostume();
    const costume = this.sprite.costumes[costumeIndex]; // Use the sprite method for deleting costumes because setCostume is handled manually

    this.sprite.deleteCostumeAt(costumeIndex);
    this.addCostume(costume, newIndex);
    this.currentCostume = this.getCostumeIndexByName(currentCostume.name);
    return true;
  }
  /**
   * Reorder sound list by moving sound at soundIndex to newIndex.
   * @param {!number} soundIndex Index of the sound to move.
   * @param {!number} newIndex New index for that sound.
   * @returns {boolean} If a change occurred (i.e. if the indices do not match)
   */


  reorderSound(soundIndex, newIndex) {
    newIndex = Utility.clamp(newIndex, 0, this.sprite.sounds.length - 1);
    soundIndex = Utility.clamp(soundIndex, 0, this.sprite.sounds.length - 1);
    if (newIndex === soundIndex) return false;
    const sound = this.sprite.sounds[soundIndex];
    this.deleteSound(soundIndex);
    this.addSound(sound, newIndex);
    return true;
  }
  /**
   * Get full sound list
   * @return {object[]} list of sounds
   */


  getSounds() {
    return this.sprite.sounds;
  }
  /**
   * Update all drawable properties for this rendered target.
   * Use when a batch has changed, e.g., when the drawable is first created.
   */


  updateAllDrawableProperties() {
    if (this.renderer) {
      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawablePosition(this.drawableID, [this.x, this.y]);
      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);
      this.renderer.updateDrawableVisible(this.drawableID, this.visible);
      const costume = this.getCostumes()[this.currentCostume];
      this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);

      for (const effectName in this.effects) {
        if (!this.effects.hasOwnProperty(effectName)) continue;
        this.renderer.updateDrawableEffect(this.drawableID, effectName, this.effects[effectName]);
      }

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Return the human-readable name for this rendered target, e.g., the sprite's name.
   * @override
   * @returns {string} Human-readable name.
   */


  getName() {
    return this.sprite.name;
  }
  /**
   * Return whether this rendered target is a sprite (not a clone, not the stage).
   * @return {boolean} True if not a clone and not the stage.
   */


  isSprite() {
    return !this.isStage && this.isOriginal;
  }
  /**
   * Return the rendered target's tight bounding box.
   * Includes top, left, bottom, right attributes in Scratch coordinates.
   * @return {?object} Tight bounding box, or null.
   */


  getBounds() {
    if (this.renderer) {
      return this.runtime.renderer.getBounds(this.drawableID);
    }

    return null;
  }
  /**
   * Return the bounding box around a slice of the top 8px of the rendered target.
   * Includes top, left, bottom, right attributes in Scratch coordinates.
   * @return {?object} Tight bounding box, or null.
   */


  getBoundsForBubble() {
    if (this.renderer) {
      return this.runtime.renderer.getBoundsForBubble(this.drawableID);
    }

    return null;
  }
  /**
   * Return whether this target is touching the mouse, an edge, or a sprite.
   * @param {string} requestedObject an id for mouse or edge, or a sprite name.
   * @return {boolean} True if the sprite is touching the object.
   */


  isTouchingObject(requestedObject) {
    if (requestedObject === "_mouse_") {
      if (!this.runtime.ioDevices.mouse) return false;
      const mouseX = this.runtime.ioDevices.mouse.getClientX();
      const mouseY = this.runtime.ioDevices.mouse.getClientY();
      return this.isTouchingPoint(mouseX, mouseY);
    } else if (requestedObject === "_edge_") {
      return this.isTouchingEdge();
    }

    return this.isTouchingSprite(requestedObject);
  }
  /**
   * Return whether touching a point.
   * @param {number} x X coordinate of test point.
   * @param {number} y Y coordinate of test point.
   * @return {boolean} True iff the rendered target is touching the point.
   */


  isTouchingPoint(x, y) {
    if (this.renderer) {
      return this.renderer.drawableTouching(this.drawableID, x, y);
    }

    return false;
  }
  /**
   * Return whether touching a stage edge.
   * @return {boolean} True iff the rendered target is touching the stage edge.
   */


  isTouchingEdge() {
    if (this.renderer) {
      const stageWidth = this.runtime.constructor.STAGE_WIDTH;
      const stageHeight = this.runtime.constructor.STAGE_HEIGHT;
      const bounds = this.getBounds();

      if (bounds.left < -stageWidth / 2 || bounds.right > stageWidth / 2 || bounds.top > stageHeight / 2 || bounds.bottom < -stageHeight / 2) {
        return true;
      }
    }

    return false;
  }
  /**
   * Return whether touching any of a named sprite's clones.
   * @param {string} spriteName Name of the sprite.
   * @return {boolean} True iff touching a clone of the sprite.
   */


  isTouchingSprite(spriteName) {
    spriteName = String(spriteName);
    const firstClone = this.runtime.getSpriteTargetByName(spriteName);

    if (!firstClone || !this.renderer) {
      return false;
    } // Filter out dragging targets. This means a sprite that is being dragged
    // can detect other sprites using touching <sprite>, but cannot be detected
    // by other sprites while it is being dragged. This matches Scratch 2.0 behavior.


    const drawableCandidates = firstClone.sprite.clones.filter(clone => !clone.dragging).map(clone => clone.drawableID);
    return this.renderer.isTouchingDrawables(this.drawableID, drawableCandidates);
  }
  /**
   * Return whether touching a color.
   * @param {Array.<number>} rgb [r,g,b], values between 0-255.
   * @return {Promise.<boolean>} True iff the rendered target is touching the color.
   */


  isTouchingColor(rgb) {
    if (this.renderer) {
      return this.renderer.isTouchingColor(this.drawableID, rgb);
    }

    return false;
  }
  /**
   * Return whether rendered target's color is touching a color.
   * @param {object} targetRgb {Array.<number>} [r,g,b], values between 0-255.
   * @param {object} maskRgb {Array.<number>} [r,g,b], values between 0-255.
   * @return {Promise.<boolean>} True iff the color is touching the color.
   */


  colorIsTouchingColor(targetRgb, maskRgb) {
    if (this.renderer) {
      return this.renderer.isTouchingColor(this.drawableID, targetRgb, maskRgb);
    }

    return false;
  }

  getLayerOrder() {
    if (this.renderer) {
      return this.renderer.getDrawableOrder(this.drawableID);
    }

    return null;
  }
  /**
   * Move to the front layer.
   */


  goToFront() {
    // This should only ever be used for sprites
    if (this.renderer) {
      // Let the renderer re-order the sprite based on its knowledge
      // of what layers are present
      this.renderer.setDrawableOrder(this.drawableID, Infinity, StageLayering.SPRITE_LAYER);
    }

    this.runtime.setExecutablePosition(this, Infinity);
  }
  /**
   * Move to the back layer.
   */


  goToBack() {
    // This should only ever be used for sprites
    if (this.renderer) {
      // Let the renderer re-order the sprite based on its knowledge
      // of what layers are present
      this.renderer.setDrawableOrder(this.drawableID, -Infinity, StageLayering.SPRITE_LAYER, false);
    }

    this.runtime.setExecutablePosition(this, -Infinity);
  }
  /**
   * Move forward a number of layers.
   * @param {number} nLayers How many layers to go forward.
   */


  goForwardLayers(nLayers) {
    if (this.renderer) {
      this.renderer.setDrawableOrder(this.drawableID, nLayers, StageLayering.SPRITE_LAYER, true);
    }

    this.runtime.moveExecutable(this, nLayers);
  }
  /**
   * Move backward a number of layers.
   * @param {number} nLayers How many layers to go backward.
   */


  goBackwardLayers(nLayers) {
    if (this.renderer) {
      this.renderer.setDrawableOrder(this.drawableID, -nLayers, StageLayering.SPRITE_LAYER, true);
    }

    this.runtime.moveExecutable(this, -nLayers);
  }
  /**
   * Move behind some other rendered target.
   * @param {!RenderedTarget} other Other rendered target to move behind.
   */


  goBehindOther(other) {
    if (this.renderer) {
      const otherLayer = this.renderer.setDrawableOrder(other.drawableID, 0, StageLayering.SPRITE_LAYER, true);
      this.renderer.setDrawableOrder(this.drawableID, otherLayer, StageLayering.SPRITE_LAYER);
    }

    const executionPosition = this.runtime.executableTargets.indexOf(other);
    this.runtime.setExecutablePosition(this, executionPosition);
  }
  /**
   * Keep a desired position within a fence.
   * @param {number} newX New desired X position.
   * @param {number} newY New desired Y position.
   * @param {object=} optFence Optional fence with left, right, top bottom.
   * @return {Array.<number>} Fenced X and Y coordinates.
   */


  keepInFence(newX, newY, optFence) {
    let fence = optFence;

    if (!fence) {
      fence = {
        left: -this.runtime.constructor.STAGE_WIDTH / 2,
        right: this.runtime.constructor.STAGE_WIDTH / 2,
        top: this.runtime.constructor.STAGE_HEIGHT / 2,
        bottom: -this.runtime.constructor.STAGE_HEIGHT / 2
      };
    }

    const bounds = this.getBounds();
    if (!bounds) return; // Adjust the known bounds to the target position.

    bounds.left += newX - this.x;
    bounds.right += newX - this.x;
    bounds.top += newY - this.y;
    bounds.bottom += newY - this.y; // Find how far we need to move the target position.

    let dx = 0;
    let dy = 0;

    if (bounds.left < fence.left) {
      dx += fence.left - bounds.left;
    }

    if (bounds.right > fence.right) {
      dx += fence.right - bounds.right;
    }

    if (bounds.top > fence.top) {
      dy += fence.top - bounds.top;
    }

    if (bounds.bottom < fence.bottom) {
      dy += fence.bottom - bounds.bottom;
    }

    return [newX + dx, newY + dy];
  }
  /**
   * Make a clone, copying any run-time properties.
   * If we've hit the global clone limit, returns null.
   * @return {RenderedTarget} New clone.
   */


  makeClone() {
    if (!this.runtime.clonesAvailable() || this.isStage) {
      return null; // Hit max clone limit, or this is the stage.
    }

    this.runtime.changeCloneCounter(1);
    const newClone = this.sprite.createClone(); // Copy all properties.

    newClone.x = this.x;
    newClone.y = this.y;
    newClone.direction = this.direction;
    newClone.draggable = this.draggable;
    newClone.visible = this.visible;
    newClone.size = this.size;
    newClone.currentCostume = this.currentCostume;
    newClone.rotationStyle = this.rotationStyle;
    newClone.effects = Utility.cloneSimple(this.effects);
    newClone.variables = this.duplicateVariables();
    newClone._edgeActivatedHatValues = Utility.cloneSimple(this._edgeActivatedHatValues);
    newClone.initDrawable(StageLayering.SPRITE_LAYER);
    newClone.updateAllDrawableProperties();
    return newClone;
  }
  /**
   * Make a duplicate using a duplicate sprite.
   * @return {RenderedTarget} New clone.
   */


  duplicate() {
    return this.sprite.duplicate().then(newSprite => {
      const newTarget = newSprite.createClone(); // Copy all properties.
      // @todo refactor with clone methods

      newTarget.x = (Math.random() - 0.5) * 400 / 2;
      newTarget.y = (Math.random() - 0.5) * 300 / 2;
      newTarget.direction = this.direction;
      newTarget.draggable = this.draggable;
      newTarget.visible = this.visible;
      newTarget.size = this.size;
      newTarget.currentCostume = this.currentCostume;
      newTarget.rotationStyle = this.rotationStyle;
      newTarget.effects = JSON.parse(JSON.stringify(this.effects));
      newTarget.variables = this.duplicateVariables(newTarget.blocks);
      newTarget.updateAllDrawableProperties();
      return newTarget;
    });
  }
  /**
   * Called when the project receives a "green flag."
   * For a rendered target, this clears graphic effects.
   */


  onGreenFlag() {
    this.clearEffects();
  }
  /**
   * Called when the project receives a "stop all"
   * Stop all sounds and clear graphic effects.
   */


  onStopAll() {
    this.clearEffects();
  }
  /**
   * Post/edit sprite info.
   * @param {object} data An object with sprite info data to set.
   */


  postSpriteInfo(data) {
    const force = data.hasOwnProperty("force") ? data.force : null;
    const isXChanged = data.hasOwnProperty("x");
    const isYChanged = data.hasOwnProperty("y");

    if (isXChanged || isYChanged) {
      this.setXY(isXChanged ? data.x : this.x, isYChanged ? data.y : this.y, force);
    }

    if (data.hasOwnProperty("direction")) {
      this.setDirection(data.direction);
    }

    if (data.hasOwnProperty("draggable")) {
      this.setDraggable(data.draggable);
    }

    if (data.hasOwnProperty("rotationStyle")) {
      this.setRotationStyle(data.rotationStyle);
    }

    if (data.hasOwnProperty("visible")) {
      this.setVisible(data.visible);
    }

    if (data.hasOwnProperty("size")) {
      this.setSize(data.size);
    }
  }
  /**
   * Put the sprite into the drag state. While in effect, setXY must be forced
   */


  startDrag() {
    this.dragging = true;
  }
  /**
   * Remove the sprite from the drag state.
   */


  stopDrag() {
    this.dragging = false;
  }
  /**
   * Serialize sprite info, used when emitting events about the sprite
   * @returns {object} Sprite data as a simple object
   */


  toJSON() {
    const costumes = this.getCostumes();
    return {
      id: this.id,
      name: this.getName(),
      isStage: this.isStage,
      x: this.x,
      y: this.y,
      size: this.size,
      direction: this.direction,
      draggable: this.draggable,
      currentCostume: this.currentCostume,
      costume: costumes[this.currentCostume],
      costumeCount: costumes.length,
      visible: this.visible,
      rotationStyle: this.rotationStyle,
      comments: this.comments,
      blocks: this.blocks._blocks,
      variables: this.variables,
      costumes: costumes,
      sounds: this.getSounds(),
      textToSpeechLanguage: this.textToSpeechLanguage,
      tempo: this.tempo,
      volume: this.volume,
      videoTransparency: this.videoTransparency,
      videoState: this.videoState
    };
  }
  /**
   * Dispose, destroying any run-time properties.
   */


  dispose() {
    this.runtime.changeCloneCounter(-1);
    this.runtime.stopForTarget(this);
    this.runtime.removeExecutable(this);
    this.sprite.removeClone(this);

    if (this.renderer && this.drawableID !== null) {
      this.renderer.destroyDrawable(this.drawableID, this.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);

      if (this.visible) {
        this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
        this.runtime.requestRedraw();
      }
    }
  }

}

module.exports = RenderedTarget;

/***/ }),

/***/ "./src/sprites/sprite.js":
/*!*******************************!*\
  !*** ./src/sprites/sprite.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const RenderedTarget = __webpack_require__(/*! ./rendered-target */ "./src/sprites/rendered-target.js");

const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");

const {
  loadSoundFromAsset
} = __webpack_require__(/*! ../import/load-sound */ "./src/import/load-sound.js");

const {
  loadCostumeFromAsset
} = __webpack_require__(/*! ../import/load-costume */ "./src/import/load-costume.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

class Sprite {
  /**
   * Sprite将在Scratch阶段使用.
   * 所有克隆共有 shared blocks, shared costumes, shared variables, shared sounds, etc.
   * @param {?Blocks} blocks 精灵的所有克隆的共享块对象.
   * @param {Runtime} runtime 引用运行时.
   * @constructor
   */
  constructor(blocks, runtime) {
    console.log("class Sprite", blocks, runtime);
    this.runtime = runtime;

    if (!blocks) {
      // Shared set of blocks for all clones.
      blocks = new Blocks(runtime);
    }

    this.blocks = blocks;
    /**
     * Human-readable name for this sprite (and all clones).
     * @type {string}
     */

    this.name = "";
    /**
     * List of costumes for this sprite.
     * Each entry is an object, e.g.,
     * {
     *      skinId: 1,
     *      name: "Costume Name",
     *      bitmapResolution: 2,
     *      rotationCenterX: 0,
     *      rotationCenterY: 0
     * }
     * @type {Array.<!Object>}
     */

    this.costumes_ = [];
    /**
     * List of sounds for this sprite.
     */

    this.sounds = [];
    /**
     * List of clones for this sprite, including the original.
     * @type {Array.<!RenderedTarget>}
     */

    this.clones = [];
    this.soundBank = null;

    if (this.runtime && this.runtime.audioEngine) {
      this.soundBank = this.runtime.audioEngine.createBank();
    }
  }
  /**
   * 添加一系列服装，注意避免重复的名称.
   * @param {!Array<object>} costumes 代表服装的对象数组.
   */


  set costumes(costumes) {
    this.costumes_ = [];

    for (const costume of costumes) {
      this.addCostumeAt(costume, this.costumes_.length);
    }
  }
  /**
   * 获取完整的服装清单
   * @return {object[]} 服装清单。
   */


  get costumes() {
    return this.costumes_;
  }
  /**
   * 在给定的索引处添加服装，注意避免重复的名称.
   * @param {!object} costumeObject 代表服装的对象.
   * @param {!int} index 服装添加索引
   */


  addCostumeAt(costumeObject, index) {
    console.log("vm sprite.js addCostumeAt()", costumeObject, index);
    if (!costumeObject.name) costumeObject.name = "";
    const usedNames = this.costumes_.map(costume => costume.name);
    costumeObject.name = StringUtil.unusedName(costumeObject.name, usedNames);
    this.costumes_.splice(index, 0, costumeObject);
  }
  /**
   * Delete a costume by index.
   * @param {number} index Costume index to be deleted
   * @return {?object} The deleted costume
   */


  deleteCostumeAt(index) {
    return this.costumes.splice(index, 1)[0];
  }
  /**
   * 创建此精灵的副本.
   * @param {string=} optLayerGroup 克隆的绘制对象应添加到的可选图层组
   * 默认为精灵图层组
   * @returns {!RenderedTarget} 新创建的克隆.
   */


  createClone(optLayerGroup) {
    console.log("createClone 创建副本:", optLayerGroup);
    const newClone = new RenderedTarget(this, this.runtime);
    newClone.isOriginal = this.clones.length === 0;
    this.clones.push(newClone);
    newClone.initAudio();

    if (newClone.isOriginal) {
      // Default to the sprite layer group if optLayerGroup is not provided
      const layerGroup = typeof optLayerGroup === "string" ? optLayerGroup : StageLayering.SPRITE_LAYER;
      newClone.initDrawable(layerGroup);
      this.runtime.fireTargetWasCreated(newClone);
    } else {
      this.runtime.fireTargetWasCreated(newClone, this.clones[0]);
    }

    return newClone;
  }
  /**
   * Disconnect a clone from this sprite. The clone is unmodified.
   * In particular, the clone's dispose() method is not called.
   * @param {!RenderedTarget} clone - the clone to be removed.
   */


  removeClone(clone) {
    this.runtime.fireTargetWasRemoved(clone);
    const cloneIndex = this.clones.indexOf(clone);

    if (cloneIndex >= 0) {
      this.clones.splice(cloneIndex, 1);
    }
  }

  duplicate() {
    const newSprite = new Sprite(null, this.runtime);
    const blocksContainer = this.blocks._blocks;
    const originalBlocks = Object.keys(blocksContainer).map(key => blocksContainer[key]);
    const copiedBlocks = JSON.parse(JSON.stringify(originalBlocks));
    Utility.newBlockIds(copiedBlocks);
    copiedBlocks.forEach(block => {
      newSprite.blocks.createBlock(block);
    });
    const allNames = this.runtime.targets.map(t => t.sprite.name);
    newSprite.name = StringUtil.unusedName(this.name, allNames);
    const assetPromises = [];
    newSprite.costumes = this.costumes_.map(costume => {
      const newCostume = Object.assign({}, costume);
      assetPromises.push(loadCostumeFromAsset(newCostume, this.runtime));
      return newCostume;
    });
    newSprite.sounds = this.sounds.map(sound => {
      const newSound = Object.assign({}, sound);
      const soundAsset = sound.asset;
      assetPromises.push(loadSoundFromAsset(newSound, soundAsset, this.runtime, newSprite.soundBank));
      return newSound;
    });
    return Promise.all(assetPromises).then(() => newSprite);
  }

  dispose() {
    if (this.soundBank) {
      this.soundBank.dispose();
    }
  }

}

module.exports = Sprite;

/***/ }),

/***/ "./src/util/jsonrpc.js":
/*!*****************************!*\
  !*** ./src/util/jsonrpc.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

class JSONRPC {
  constructor() {
    this._requestID = 0;
    this._openRequests = {};
  }
  /**
   * Make an RPC request and retrieve the result.
   * @param {string} method - the remote method to call.
   * @param {object} params - the parameters to pass to the remote method.
   * @returns {Promise} - a promise for the result of the call.
   */


  sendRemoteRequest(method, params) {
    const requestID = this._requestID++;
    const promise = new Promise((resolve, reject) => {
      this._openRequests[requestID] = {
        resolve,
        reject
      };
    });

    this._sendRequest(method, params, requestID);

    return promise;
  }
  /**
   * Make an RPC notification with no expectation of a result or callback.
   * @param {string} method - the remote method to call.
   * @param {object} params - the parameters to pass to the remote method.
   */


  sendRemoteNotification(method, params) {
    this._sendRequest(method, params);
  }
  /**
   * Handle an RPC request from remote, should return a result or Promise for result, if appropriate.
   * @param {string} method - the method requested by the remote caller.
   * @param {object} params - the parameters sent with the remote caller's request.
   */


  didReceiveCall()
  /* method , params */
  {
    throw new Error('Must override didReceiveCall');
  }

  _sendMessage()
  /* jsonMessageObject */
  {
    throw new Error('Must override _sendMessage');
  }

  _sendRequest(method, params, id) {
    const request = {
      jsonrpc: '2.0',
      method,
      params
    };

    if (id !== null) {
      request.id = id;
    }

    this._sendMessage(request);
  }

  _handleMessage(json) {
    if (json.jsonrpc !== '2.0') {
      throw new Error(`Bad or missing JSON-RPC version in message: ${json}`);
    }

    if (json.hasOwnProperty('method')) {
      this._handleRequest(json);
    } else {
      this._handleResponse(json);
    }
  }

  _sendResponse(id, result, error) {
    const response = {
      jsonrpc: '2.0',
      id
    };

    if (error) {
      response.error = error;
    } else {
      response.result = result || null;
    }

    this._sendMessage(response);
  }

  _handleResponse(json) {
    const {
      result,
      error,
      id
    } = json;
    const openRequest = this._openRequests[id];
    delete this._openRequests[id];

    if (openRequest) {
      if (error) {
        openRequest.reject(error);
      } else {
        openRequest.resolve(result);
      }
    }
  }

  _handleRequest(json) {
    const {
      method,
      params,
      id
    } = json;
    const rawResult = this.didReceiveCall(method, params);

    if (id) {
      Promise.resolve(rawResult).then(result => {
        this._sendResponse(id, result);
      }, error => {
        this._sendResponse(id, null, error);
      });
    }
  }

}

module.exports = JSONRPC;

/***/ }),

/***/ "./src/util/maybe-format-message.js":
/*!******************************************!*\
  !*** ./src/util/maybe-format-message.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");
/**
 * 检查“ maybeMessage”是否看起来像消息对象，如果是，则将其传递给“ formatMessage”.
 * 否则，按原样返回`maybeMessage`.
 * @param {*} maybeMessage - 可能是消息描述符对象的东西.
 * @param {object} [args] - 如果被调用传递给formatMessage的参数.
 * @param {string} [locale] - 如果被调用，传递给formatMessage的语言环境.
 * @return {string|*} - 格式化的消息或原始的“ maybeMessage”输入.
 */


const maybeFormatMessage = function (maybeMessage, args, locale) {
  if (maybeMessage && maybeMessage.id && maybeMessage.default) {
    return formatMessage(maybeMessage, args, locale);
  }

  return maybeMessage;
};

module.exports = maybeFormatMessage;

/***/ }),

/***/ "./src/util/rateLimiter.js":
/*!*********************************!*\
  !*** ./src/util/rateLimiter.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

class RateLimiter {
  /**
   * A utility for limiting the rate of repetitive send operations, such as
   * bluetooth messages being sent to hardware devices. It uses the token bucket
   * strategy: a counter accumulates tokens at a steady rate, and each send costs
   * a token. If no tokens remain, it's not okay to send.
   * @param {number} maxRate the maximum number of sends allowed per second
   * @constructor
   */
  constructor(maxRate) {
    /**
     * The maximum number of tokens.
     * @type {number}
     */
    this._maxTokens = maxRate;
    /**
     * The interval in milliseconds for refilling one token. It is calculated
     * so that the tokens will be filled to maximum in one second.
     * @type {number}
     */

    this._refillInterval = 1000 / maxRate;
    /**
     * The current number of tokens in the bucket.
     * @type {number}
     */

    this._count = this._maxTokens;
    this._timer = new Timer();

    this._timer.start();
    /**
     * The last time in milliseconds when the token count was updated.
     * @type {number}
     */


    this._lastUpdateTime = this._timer.timeElapsed();
  }
  /**
   * Check if it is okay to send a message, by updating the token count,
   * taking a token and then checking if we are still under the rate limit.
   * @return {boolean} true if we are under the rate limit
   */


  okayToSend() {
    // Calculate the number of tokens to refill the bucket with, based on the
    // amount of time since the last refill.
    const now = this._timer.timeElapsed();

    const timeSinceRefill = now - this._lastUpdateTime;
    const refillCount = Math.floor(timeSinceRefill / this._refillInterval); // If we're adding at least one token, reset _lastUpdateTime to now.
    // Otherwise, don't reset it so that we can continue measuring time until
    // the next refill.

    if (refillCount > 0) {
      this._lastUpdateTime = now;
    } // Refill the tokens up to the maximum


    this._count = Math.min(this._maxTokens, this._count + refillCount); // If we have at least one token, use one, and it's okay to send.

    if (this._count > 0) {
      this._count--;
      return true;
    }

    return false;
  }

}

module.exports = RateLimiter;

/***/ }),

/***/ "./src/util/scratch-link-websocket.js":
/*!********************************************!*\
  !*** ./src/util/scratch-link-websocket.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This class provides a ScratchLinkSocket implementation using WebSockets,
 * attempting to connect with the locally installed Scratch-Link.
 *
 * To connect with ScratchLink without WebSockets, you must implement all of the
 * public methods in this class.
 * - open()
 * - close()
 * - setOn[Open|Close|Error]
 * - setHandleMessage
 * - sendMessage(msgObj)
 * - isOpen()
 */
class ScratchLinkWebSocket {
  constructor(type) {
    this._type = type;
    this._onOpen = null;
    this._onClose = null;
    this._onError = null;
    this._handleMessage = null;
    this._ws = null;
  }

  open() {
    switch (this._type) {
      case 'BLE':
        this._ws = new WebSocket('wss://device-manager.scratch.mit.edu:20110/scratch/ble');
        break;

      case 'BT':
        this._ws = new WebSocket('wss://device-manager.scratch.mit.edu:20110/scratch/bt');
        break;

      default:
        throw new Error(`Unknown ScratchLink socket Type: ${this._type}`);
    }

    if (this._onOpen && this._onClose && this._onError && this._handleMessage) {
      this._ws.onopen = this._onOpen;
      this._ws.onclose = this._onClose;
      this._ws.onerror = this._onError;
    } else {
      throw new Error('Must set open, close, message and error handlers before calling open on the socket');
    }

    this._ws.onmessage = this._onMessage.bind(this);
  }

  close() {
    this._ws.close();

    this._ws = null;
  }

  sendMessage(message) {
    const messageText = JSON.stringify(message);

    this._ws.send(messageText);
  }

  setOnOpen(fn) {
    this._onOpen = fn;
  }

  setOnClose(fn) {
    this._onClose = fn;
  }

  setOnError(fn) {
    this._onError = fn;
  }

  setHandleMessage(fn) {
    this._handleMessage = fn;
  }

  isOpen() {
    return this._ws && this._ws.readyState === this._ws.OPEN;
  }

  _onMessage(e) {
    const json = JSON.parse(e.data);

    this._handleMessage(json);
  }

}

module.exports = ScratchLinkWebSocket;

/***/ }),

/***/ "./src/util/string-util.js":
/*!*********************************!*\
  !*** ./src/util/string-util.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

class StringUtil {
  static withoutTrailingDigits(s) {
    let i = s.length - 1;

    while (i >= 0 && "0123456789".indexOf(s.charAt(i)) > -1) i--;

    return s.slice(0, i + 1);
  }

  static unusedName(name, existingNames) {
    if (existingNames.indexOf(name) < 0) return name;
    name = StringUtil.withoutTrailingDigits(name);
    let i = 2;

    while (existingNames.indexOf(name + i) >= 0) i++;

    return name + i;
  }
  /**
   * Split a string on the first occurrence of a split character.
   * @param {string} text - the string to split.
   * @param {string} separator - split the text on this character.
   * @returns {string[]} - the two parts of the split string, or [text, null] if no split character found.
   * @example
   * // returns ['foo', 'tar.gz']
   * splitFirst('foo.tar.gz', '.');
   * @example
   * // returns ['foo', null]
   * splitFirst('foo', '.');
   * @example
   * // returns ['foo', '']
   * splitFirst('foo.', '.');
   */


  static splitFirst(text, separator) {
    const index = text.indexOf(separator);

    if (index >= 0) {
      return [text.substring(0, index), text.substring(index + 1)];
    }

    return [text, null];
  }
  /**
   * A customized version of JSON.stringify that sets Infinity/NaN to 0,
   * instead of the default (null).
   * Needed because null is not of type number, but Infinity/NaN are, which
   * can lead to serialization producing JSON that isn't valid based on the parser schema.
   * It is also consistent with the behavior of saving 2.0 projects.
   * This is only needed when stringifying an object for saving.
   *
   * @param {!object} obj - The object to serialize
   * @return {!string} The JSON.stringified string with Infinity/NaN replaced with 0
   */


  static stringify(obj) {
    return JSON.stringify(obj, (_key, value) => {
      if (typeof value === "number" && (value === Infinity || value === -Infinity || isNaN(value))) {
        return 0;
      }

      return value;
    });
  }
  /**
   * A function to replace unsafe characters (not allowed in XML) with safe ones. This is used
   * in cases where we're replacing non-user facing strings (e.g. variable IDs).
   * When replacing user facing strings, the Utility.xmlEscape utility function should be used
   * instead so that the user facing string does not change how it displays.
   * @param {!string | !Array.<string>} unsafe Unsafe string possibly containing unicode control characters.
   * In some cases this argument may be an array (e.g. hacked inputs from 2.0)
   * @return {string} String with control characters replaced.
   */


  static replaceUnsafeChars(unsafe) {
    if (typeof unsafe !== "string") {
      if (Array.isArray(unsafe)) {
        // This happens when we have hacked blocks from 2.0
        // See #1030
        unsafe = String(unsafe);
      } else {
        console.error("Unexpected input recieved in replaceUnsafeChars");
        return unsafe;
      }
    }

    return unsafe.replace(/[<>&'"]/g, c => {
      switch (c) {
        case "<":
          return "lt";

        case ">":
          return "gt";

        case "&":
          return "amp";

        case "'":
          return "apos";

        case '"':
          return "quot";
      }
    });
  }

}

module.exports = StringUtil;

/***/ }),

/***/ "./src/util/timer.js":
/*!***************************!*\
  !*** ./src/util/timer.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * @fileoverview
 * 精确测量时间的实用程序.
 * To use:
 * ---
 * var timer = new Timer();
 * timer.start();
 * ... pass some time ...
 * var timeDifference = timer.timeElapsed();
 * ---
 * Or, you can use the `time` and `relativeTime`
 * to do some measurement yourself.
 */
class Timer {
  constructor(nowObj = Timer.nowObj) {
    /**
     * Used to store the start time of a timer action.
     * Updated when calling `timer.start`.
     */
    this.startTime = 0;
    /**
     * Used to pass custom logic for determining the value for "now",
     * which is sometimes useful for compatibility with Scratch 2
     */

    this.nowObj = nowObj;
  }
  /**
   * Disable use of self.performance for now as it results in lower performance
   * However, instancing it like below (caching the self.performance to a local variable) negates most of the issues.
   * @type {boolean}
   */


  static get USE_PERFORMANCE() {
    return false;
  }
  /**
   * Legacy object to allow for us to call now to get the old style date time (for backwards compatibility)
   * @deprecated This is only called via the nowObj.now() if no other means is possible...
   */


  static get legacyDateCode() {
    return {
      now: function () {
        return new Date().getTime();
      }
    };
  }
  /**
   * Use this object to route all time functions through single access points.
   */


  static get nowObj() {
    if (Timer.USE_PERFORMANCE && typeof self !== "undefined" && self.performance && "now" in self.performance) {
      return self.performance;
    } else if (Date.now) {
      return Date;
    }

    return Timer.legacyDateCode;
  }
  /**
   * Return the currently known absolute time, in ms precision.
   * @returns {number} ms elapsed since 1 January 1970 00:00:00 UTC.
   */


  time() {
    return this.nowObj.now();
  }
  /**
   * Returns a time accurate relative to other times produced by this function.
   * If possible, will use sub-millisecond precision.
   * If not, will use millisecond precision.
   * Not guaranteed to produce the same absolute values per-system.
   * @returns {number} ms-scale accurate time relative to other relative times.
   */


  relativeTime() {
    return this.nowObj.now();
  }
  /**
   * Start a timer for measuring elapsed time,
   * at the most accurate precision possible.
   */


  start() {
    this.startTime = this.nowObj.now();
  }

  timeElapsed() {
    return this.nowObj.now() - this.startTime;
  }
  /**
   * Call a handler function after a specified amount of time has elapsed.
   * @param {function} handler - function to call after the timeout
   * @param {number} timeout - number of milliseconds to delay before calling the handler
   * @returns {number} - the ID of the new timeout
   */


  setTimeout(handler, timeout) {
    return global.setTimeout(handler, timeout);
  }
  /**
   * Clear a timeout from the pending timeout pool.
   * @param {number} timeoutId - the ID returned by `setTimeout()`
   * @memberof Timer
   */


  clearTimeout(timeoutId) {
    global.clearTimeout(timeoutId);
  }

}

module.exports = Timer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/util/variable-util.js":
/*!***********************************!*\
  !*** ./src/util/variable-util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

class VariableUtil {
  static _mergeVarRefObjects(accum, obj2) {
    for (const id in obj2) {
      if (accum[id]) {
        accum[id] = accum[id].concat(obj2[id]);
      } else {
        accum[id] = obj2[id];
      }
    }

    return accum;
  }
  /**
   * Get all variable/list references in the given list of targets
   * in the project.
   * @param {Array.<Target>} targets The list of targets to get the variable
   * and list references from.
   * @param {boolean} shouldIncludeBroadcast Whether to include broadcast message fields.
   * @return {object} An object with variable ids as the keys and a list of block fields referencing
   * the variable.
   */


  static getAllVarRefsForTargets(targets, shouldIncludeBroadcast) {
    return targets.map(t => t.blocks.getAllVariableAndListReferences(null, shouldIncludeBroadcast)).reduce(VariableUtil._mergeVarRefObjects, {});
  }
  /**
   * Give all variable references provided a new id and possibly new name.
   * @param {Array<object>} referencesToUpdate Context of the change, the object containing variable
   * references to update.
   * @param {string} newId ID of the variable that the old references should be replaced with
   * @param {?string} optNewName New variable name to merge with. The old
   * variable name in the references being updated should be replaced with this new name.
   * If this parameter is not provided or is '', no name change occurs.
   */


  static updateVariableIdentifiers(referencesToUpdate, newId, optNewName) {
    referencesToUpdate.map(ref => {
      ref.referencingField.id = newId;

      if (optNewName) {
        ref.referencingField.value = optNewName;
      }

      return ref;
    });
  }

}

module.exports = VariableUtil;

/***/ }),

/***/ "./src/virtual-machine.js":
/*!********************************!*\
  !*** ./src/virtual-machine.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

const JSZip = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");

const Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

const centralDispatch = __webpack_require__(/*! ./dispatch/central-dispatch */ "./src/dispatch/central-dispatch.js");

const ExtensionManager = __webpack_require__(/*! ./extension-support/extension-manager */ "./src/extension-support/extension-manager.js");

const Runtime = __webpack_require__(/*! ./engine/runtime */ "./src/engine/runtime.js");

const StringUtil = __webpack_require__(/*! ./util/string-util */ "./src/util/string-util.js");

const formatMessage = __webpack_require__(/*! format-message */ "./node_modules/format-message/index.js");

const Variable = __webpack_require__(/*! ./engine/variable */ "./src/engine/variable.js");

const {
  loadCostume
} = __webpack_require__(/*! ./import/load-costume.js */ "./src/import/load-costume.js");

const {
  loadSound
} = __webpack_require__(/*! ./import/load-sound.js */ "./src/import/load-sound.js");
/**
 * 序列化所有给定类型的资源('sounds' or 'costumes')
 * in the provided runtime into an array of file descriptors.
 * A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized asset.
 * @param {Runtime} runtime The runtime with the assets to be serialized
 * @param {string} assetType The type of assets to be serialized: 'sounds' | 'costumes'
 * @param {string=} optTargetId Optional target id to serialize assets for
 * @returns {Array<object>} An array of file descriptors for each asset
 */


const serializeAssets = function (runtime, assetType, optTargetId) {
  console.log("v-m.js 序列化资源");
  const targets = optTargetId ? [runtime.getTargetById(optTargetId)] : runtime.targets;
  const assetDescs = [];

  for (let i = 0; i < targets.length; i++) {
    const currTarget = targets[i];
    const currAssets = currTarget.sprite[assetType];

    for (let j = 0; j < currAssets.length; j++) {
      const currAsset = currAssets[j];
      const asset = currAsset.asset;
      assetDescs.push({
        fileName: `${asset.assetId}.${asset.dataFormat}`,
        fileContent: asset.data
      });
    }
  }

  return assetDescs;
};
/**
 * Serialize all the sounds in the provided runtime or, if a target id is provided,
 * in the specified target into an array of file descriptors.
 * A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized sound.
 * @param {Runtime} runtime The runtime with the sounds to be serialized
 * @param {string=} optTargetId Optional targetid for serializing sounds of a single target
 * @returns {Array<object>} An array of file descriptors for each sound
 */


const serializeSounds = function (runtime, optTargetId) {
  return serializeAssets(runtime, "sounds", optTargetId);
};
/**
 * Serialize all the costumes in the provided runtime into an array of file
 * descriptors. A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized costume.
 * @param {Runtime} runtime The runtime with the costumes to be serialized
 * @param {string} optTargetId Optional targetid for serializing costumes of a single target
 * @returns {Array<object>} An array of file descriptors for each costume
 */


const serializeCostumes = function (runtime, optTargetId) {
  return serializeAssets(runtime, "costumes", optTargetId);
};

const RESERVED_NAMES = ["_mouse_", "_stage_", "_edge_", "_myself_", "_random_"];
const CORE_EXTENSIONS = [// 'motion',
  // 'looks',
  // 'sound',
  // 'events',
  // 'control',
  // 'sensing',
  // 'operators',
  // 'variables',
  // 'myBlocks'
];
/**
 * Handles connections between blocks, stage, and extensions.
 * 块，舞台，和延伸部之间的连接
 * @constructor
 */

class VirtualMachine extends EventEmitter {
  constructor() {
    super();
    /**
     * VM runtime, to store blocks, I/O devices, sprites/targets, etc.
     * @type {!Runtime}
     */

    this.runtime = new Runtime();
    console.log("class VirtualMachine:", this.runtime);
    centralDispatch.setService("runtime", this.runtime).catch(e => {
      console.error(`Failed to register runtime service: ${JSON.stringify(e)}`);
    });
    /**
     * The "currently editing"/selected target ID for the VM.
     * 从任何Blockly工作区块事件路由到该目标.
     * @type {Target}
     */

    this.editingTarget = null;
    /**
     * 当前拖动的目标，用于重定向IO数据.
     * @type {Target}
     */

    this._dragTarget = null; // Runtime emits are passed along as VM emits.

    this.runtime.on(Runtime.SCRIPT_GLOW_ON, glowData => {
      this.emit(Runtime.SCRIPT_GLOW_ON, glowData);
    });
    this.runtime.on(Runtime.SCRIPT_GLOW_OFF, glowData => {
      this.emit(Runtime.SCRIPT_GLOW_OFF, glowData);
    });
    this.runtime.on(Runtime.BLOCK_GLOW_ON, glowData => {
      this.emit(Runtime.BLOCK_GLOW_ON, glowData);
    });
    this.runtime.on(Runtime.BLOCK_GLOW_OFF, glowData => {
      this.emit(Runtime.BLOCK_GLOW_OFF, glowData);
    });
    this.runtime.on(Runtime.PROJECT_START, () => {
      this.emit(Runtime.PROJECT_START);
    });
    this.runtime.on(Runtime.PROJECT_RUN_START, () => {
      this.emit(Runtime.PROJECT_RUN_START);
    });
    this.runtime.on(Runtime.PROJECT_RUN_STOP, () => {
      this.emit(Runtime.PROJECT_RUN_STOP);
    });
    this.runtime.on(Runtime.PROJECT_CHANGED, () => {
      this.emit(Runtime.PROJECT_CHANGED);
    });
    this.runtime.on(Runtime.VISUAL_REPORT, visualReport => {
      this.emit(Runtime.VISUAL_REPORT, visualReport);
    });
    /** targetsUpdate */

    this.runtime.on(Runtime.TARGETS_UPDATE, emitProjectChanged => {
      console.log("vm this.runtime.on(Runtime.TARGETS_UPDATE, (emitProjectChanged):", emitProjectChanged);
      this.emitTargetsUpdate(emitProjectChanged);
    });
    this.runtime.on(Runtime.MONITORS_UPDATE, monitorList => {
      this.emit(Runtime.MONITORS_UPDATE, monitorList);
    });
    this.runtime.on(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui => {
      this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);
    });
    this.runtime.on(Runtime.BLOCK_DRAG_END, (blocks, topBlockId) => {
      this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);
    });
    this.runtime.on(Runtime.EXTENSION_ADDED, categoryInfo => {
      this.emit(Runtime.EXTENSION_ADDED, categoryInfo);
    });
    this.runtime.on(Runtime.EXTENSION_FIELD_ADDED, (fieldName, fieldImplementation) => {
      this.emit(Runtime.EXTENSION_FIELD_ADDED, fieldName, fieldImplementation);
    });
    this.runtime.on(Runtime.BLOCKSINFO_UPDATE, categoryInfo => {
      this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);
    });
    this.runtime.on(Runtime.BLOCKS_NEED_UPDATE, () => {
      this.emitWorkspaceUpdate();
    });
    this.runtime.on(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE, () => {
      this.extensionManager.refreshBlocks();
    });
    this.runtime.on(Runtime.PERIPHERAL_LIST_UPDATE, info => {
      this.emit(Runtime.PERIPHERAL_LIST_UPDATE, info);
    });
    this.runtime.on(Runtime.PERIPHERAL_CONNECTED, () => this.emit(Runtime.PERIPHERAL_CONNECTED));
    this.runtime.on(Runtime.PERIPHERAL_REQUEST_ERROR, () => this.emit(Runtime.PERIPHERAL_REQUEST_ERROR));
    this.runtime.on(Runtime.PERIPHERAL_DISCONNECTED, () => this.emit(Runtime.PERIPHERAL_DISCONNECTED));
    this.runtime.on(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, data => this.emit(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, data));
    this.runtime.on(Runtime.PERIPHERAL_SCAN_TIMEOUT, () => this.emit(Runtime.PERIPHERAL_SCAN_TIMEOUT));
    this.runtime.on(Runtime.MIC_LISTENING, listening => {
      this.emit(Runtime.MIC_LISTENING, listening);
    });
    this.runtime.on(Runtime.RUNTIME_STARTED, () => {
      this.emit(Runtime.RUNTIME_STARTED);
    });
    this.runtime.on(Runtime.HAS_CLOUD_DATA_UPDATE, hasCloudData => {
      this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, hasCloudData);
    }); // 扩展管理器

    this.extensionManager = new ExtensionManager(this.runtime); // 加载核心扩展

    for (const id of CORE_EXTENSIONS) {
      this.extensionManager.loadExtensionIdSync(id);
    }

    this.blockListener = this.blockListener.bind(this);
    this.flyoutBlockListener = this.flyoutBlockListener.bind(this);
    this.monitorBlockListener = this.monitorBlockListener.bind(this);
    this.variableListener = this.variableListener.bind(this);
  }
  /**
   * 开始运行VM-在执行其他操作之前.
   */


  start() {
    this.runtime.start();
  }
  /**
   * "Green flag" handler - 以绿色标志开始所有线程.
   */


  greenFlag() {
    this.runtime.greenFlag();
  }
  /**
   * Stop all threads and running activities.停止所有线程
   */


  stopAll() {
    this.runtime.stopAll();
  }
  /**
   * 设置虚拟机是否处于"turbo模式"
   * When true, turbo mode，加速模式，循环不导致重绘
   * @param {boolean} turboModeOn 是否应设置涡轮增压模式.
   */


  setTurboMode(turboModeOn) {
    this.runtime.turboMode = !!turboModeOn;

    if (this.runtime.turboMode) {
      console.log("启用加速模式", Runtime.TURBO_MODE_ON);
      this.emit(Runtime.TURBO_MODE_ON);
    } else {
      console.log("禁用加速模式", Runtime.TURBO_MODE_OFF);
      this.emit(Runtime.TURBO_MODE_OFF);
    }
  }
  /**
   * Set whether the VM is in 2.0 "compatibility mode."
   * When true, runtime兼容模式，兼容2.0，30TPS
   * @param {boolean} compatibilityModeOn Whether compatibility mode is set.
   */


  setCompatibilityMode(compatibilityModeOn) {
    console.log("设置兼容模式 兼容2.0，30TPS");
    this.runtime.setCompatibilityMode(!!compatibilityModeOn);
  }
  /**
   * 清除当前正在运行的项目数据.
   */


  clear() {
    this.runtime.dispose();
    this.editingTarget = null;
    console.warn("v-m.js清理函数会触发emitTargetsUpdate(false),即不提到项目变更");
    this.emitTargetsUpdate(false
    /* Don't emit project change */
    );
  }
  /**
   * Get data for playground. Data comes back in an emitted event.
   * 获取editingTarget所在的thread里的data
   */


  getPlaygroundData() {
    console.log("获取editingTarget所在的thread里的data");
    const instance = this; // Only send back thread data for the current editingTarget.

    const threadData = this.runtime.threads.filter(thread => thread.target === instance.editingTarget); // Remove the target key, since it's a circular reference.

    const filteredThreadData = JSON.stringify(threadData, (key, value) => {
      if (key === "target" || key === "blockContainer") return;
      return value;
    }, 2);
    this.emit("playgroundData", {
      blocks: this.editingTarget.blocks,
      threads: filteredThreadData
    });
  }
  /**
   * Post I/O data to the virtual devices. 向runtime中的设备发送数据
   * @param {?string} device Name of virtual I/O device.
   * @param {object} data Any data object to post to the I/O device.
   */


  postIOData(device, data) {
    // console.log("向runtime中的设备发送数据", device, data);
    if (this.runtime.ioDevices[device]) {
      this.runtime.ioDevices[device].postData(data);
    }
  }

  setVideoProvider(videoProvider) {
    this.runtime.ioDevices.video.setProvider(videoProvider);
  }

  setCloudProvider(cloudProvider) {
    this.runtime.ioDevices.cloud.setProvider(cloudProvider);
  }
  /**
   * Tell the specified extension to scan for a peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  scanForPeripheral(extensionId) {
    this.runtime.scanForPeripheral(extensionId);
  }
  /**
   * Connect to the extension's specified peripheral.
   * @param {string} extensionId - the id of the extension.
   * @param {number} peripheralId - the id of the peripheral.
   */


  connectPeripheral(extensionId, peripheralId) {
    this.runtime.connectPeripheral(extensionId, peripheralId);
  }
  /**
   * Disconnect from the extension's connected peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  disconnectPeripheral(extensionId) {
    this.runtime.disconnectPeripheral(extensionId);
  }
  /**
   * Returns whether the extension has a currently connected peripheral.
   * @param {string} extensionId - the id of the extension.
   * @return {boolean} - whether the extension has a connected peripheral.
   */


  getPeripheralIsConnected(extensionId) {
    return this.runtime.getPeripheralIsConnected(extensionId);
  }
  /**
   * 从.sb，.sb2，.sb3或json字符串加载项目.
   * @param {string | object} data 代表要加载的项目的json字符串，对象或ArrayBuffer.
   * @return {!Promise} Promise that resolves after targets are installed.
   */


  loadProject(data) {
    console.log("vm.js loadProject()", data); // 如果输入是一个对象，并且没有任何ArrayBuffer或ArrayBuffer视图（包括所有类型的数组和DataViews），则将该对象转换为JSON字符串，因为我们怀疑这是一个project.json，因为对象验证要求字符串或缓冲区为 输入

    if (typeof data === "object" && !(data instanceof ArrayBuffer) && !ArrayBuffer.isView(data)) data = JSON.stringify(data); // 使用校验

    const validate = __webpack_require__(/*! ./parser/index */ "./src/parser/index.js");

    const validationPromise = new Promise((resolve, reject) => {
      try {
        /**
         * 启用parser解析
         * 参数一:传入待解析的数据(项目JSON或元素的……)
         * 参数二:false表示项目数据;true表示单个元素数据
         */
        return resolve(validate(data, false));
      } catch (e) {
        // 由于输入似乎不是SB1File，因此引发原始错误.
        return reject(e);
      }
    });
    return validationPromise.then(res => {
      console.log("validationPromise:", res); // 从JSON加载项目

      this.deserializeProject(res, null);
    }).then(() => {
      console.log("loadProject 调用 runtime.emitProjectLoaded()");
      this.runtime.emitProjectLoaded();
    }).catch(error => {
      return Promise.reject(JSON.stringify(error));
    });
  }
  /**
   * Load a project from the Scratch web site, by ID.
   * 通过projectId，从storage中下载项目(storage封装了本地和网络加载，并缓存)
   * @param {string} id - the ID of the project to download, as a string.
   */


  downloadProjectId(id) {
    const storage = this.runtime.storage;

    if (!storage) {
      console.error("No storage module present; cannot load project: ", id);
      return;
    }

    const vm = this;
    const promise = storage.load(storage.AssetType.Project, id);
    promise.then(projectAsset => {
      vm.loadProject(projectAsset.data);
    });
  }
  /**
   * 导出3.0项目,zip的blob流
   * @returns {string} Project in a Scratch 3.0 JSON representation.
   */


  saveProjectSb3() {
    const soundDescs = serializeSounds(this.runtime);
    const costumeDescs = serializeCostumes(this.runtime);
    const projectJson = this.toJSON(); // 导出project.json
    // TODO want to eventually move zip creation out of here, and perhaps
    // into scratch-storage

    const zip = new JSZip(); // Put everything in a zip file

    zip.file("project.json", projectJson);

    this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);

    return zip.generateAsync({
      type: "blob",
      mimeType: "application/x.scratch.sb3",
      compression: "DEFLATE",
      compressionOptions: {
        level: 6 // Tradeoff between best speed (1) and best compression (9)

      }
    });
  }
  /*
   * @type {Array<object>} 当前运行时中所有服装和声音的数组
   */


  get assets() {
    return this.runtime.targets.reduce((acc, target) => acc.concat(target.sprite.sounds.map(sound => sound.asset)).concat(target.sprite.costumes.map(costume => costume.asset)), []);
  }

  _addFileDescsToZip(fileDescs, zip) {
    for (let i = 0; i < fileDescs.length; i++) {
      const currFileDesc = fileDescs[i];
      zip.file(currFileDesc.fileName, currFileDesc.fileContent);
    }
  }
  /**
   * Exports a sprite in the sprite3 format.
   * @param {string} targetId ID of the target to export
   * @param {string=} optZipType Optional type that the resulting
   * zip should be outputted in. Options are: base64, binarystring,
   * array, uint8array, arraybuffer, blob, or nodebuffer. Defaults to
   * blob if argument not provided.
   * See https://stuk.github.io/jszip/documentation/api_jszip/generate_async.html#type-option
   * for more information about these options.
   * @return {object} A generated zip of the sprite and its assets in the format
   * specified by optZipType or blob by default.
   */


  exportSprite(targetId, optZipType) {
    console.log("v-m.js 导出元素", targetId, optZipType);

    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    const soundDescs = serializeSounds(this.runtime, targetId);
    const costumeDescs = serializeCostumes(this.runtime, targetId);
    const spriteJson = StringUtil.stringify(sb3.serialize(this.runtime, targetId));
    const zip = new JSZip();
    zip.file("sprite.json", spriteJson);

    this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);

    return zip.generateAsync({
      type: typeof optZipType === "string" ? optZipType : "blob",
      mimeType: "application/x.scratch.sprite3",
      compression: "DEFLATE",
      compressionOptions: {
        level: 6
      }
    });
  }
  /**
   * 将项目导出为Scratch 3.0 JSON表示形式.导出project.json
   * @return {string} Serialized state of the runtime.
   */


  toJSON() {
    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    return StringUtil.stringify(sb3.serialize(this.runtime));
  }
  /**
   * 反序列化项目 从JSON表示加载项目.
   * @param {string} projectJSON 代表项目的JSON字符串.
   * @param {?JSZip} zip 可选的压缩项目，其中包含要加载的资产.
   * @returns {Promise} 判断2.0还是3.0的项目，3.0的项目包含meta字段，2.0的项目有自己的特定格式schema.json
   * 调用各自的 deserialize，反序列化project.json
   */


  deserializeProject(projectJSON, zip) {
    console.log("vm.js deserializeProject() 反序列化项目", projectJSON, zip); // Clear the current runtime

    this.clear();
    const runtime = this.runtime;

    const deserializePromise = function () {
      // 当前项目版本
      const projectVersion = projectJSON.projectVersion;

      if (projectVersion === 2) {
        const sb2 = __webpack_require__(/*! ./serialization/sb2 */ "./src/serialization/sb2.js");

        return sb2.deserialize(projectJSON, runtime, false, zip);
      }

      if (projectVersion === 3) {
        const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

        console.log("v-m.js sb3.调用其专属反序列化", projectJSON, runtime, zip);
        return sb3.deserialize(projectJSON, runtime, zip);
      }

      return Promise.reject("Unable to verify Scratch Project version.");
    };

    return deserializePromise().then(({
      targets,
      extensions
    }) => {
      console.log("调用installTargets安装所有解析", targets, extensions); // 解析出所有的targets，调用installTargets安装

      this.installTargets(targets, extensions, true);
    });
  }
  /**
   * Install `deserialize` results: 在这些目标使用的扩展名（如果有）之后添加零个或多个目标.
   * 安装targets,targets可能来自与extension，如果是，则先加载所有的extensions，通过promise.all，等扩展安装之后，再安装所有targets
   * @param {Array.<Target>} targets - 要安装的目标
   * @param {ImportedExtensionsInfo} extensions - 有关这些目标使用的扩展的元数据
   * @param {boolean} wholeProject - 如果安装整个项目，而不是单个精灵，则设置为true.
   * @returns {Promise} 安装目标后解决
   */


  installTargets(targets, extensions, wholeProject) {
    console.log("执行installTargets()", targets, extensions, wholeProject);
    const extensionPromises = [];
    extensions.extensionIDs.forEach(extensionID => {
      if (!this.extensionManager.isExtensionLoaded(extensionID)) {
        const extensionURL = extensions.extensionURLs.get(extensionID) || extensionID;
        extensionPromises.push(this.extensionManager.loadExtensionURL(extensionURL));
      }
    });
    targets = targets.filter(target => !!target);
    return Promise.all(extensionPromises).then(() => {
      targets.forEach(target => {
        console.warn("准备执行this.runtime.addTarget", target);
        this.runtime.addTarget(target);
        /** @type RenderedTarget */

        target.updateAllDrawableProperties(); // 确保唯一的精灵名称

        if (target.isSprite()) this.renameSprite(target.id, target.getName());
      }); // 按层顺序对可执行目标进行排序. 使用后删除layerOrder属性.

      this.runtime.executableTargets.sort((a, b) => a.layerOrder - b.layerOrder);
      targets.forEach(target => {
        delete target.layerOrder;
      }); // 选择要编辑的第一个目标，例如第一个精灵.

      this.editingTarget = wholeProject && targets.length > 1 ? targets[1] : targets[0];
      if (!wholeProject) this.editingTarget.fixUpVariableReferences(); // 更新VM用户对工作空间上的目标和块的了解.

      console.warn("v-m.js installTargets emitTargetsUpdate(false)");
      this.emitTargetsUpdate(false
      /* Don't emit project change */
      );
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(this.editingTarget);
      this.runtime.ioDevices.cloud.setStage(this.runtime.getTargetForStage());
    });
  }
  /**
   * 添加一个精灵，可以是.sprite2或.sprite3。 首先解压缩并验证此类文件.
   * @param {string | object} input 代表要加载的项目的json字符串，对象或ArrayBuffer.
   * @return {!Promise} 在安装目标后解决的承诺.
   */


  addSprite(input) {
    const errorPrefix = "Sprite Upload Error:";

    if (typeof input === "object" && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {
      // If the input is an object and not any ArrayBuffer
      // or an ArrayBuffer view (this includes all typed arrays and DataViews)
      // turn the object into a JSON string, because we suspect
      // this is a project.json as an object
      // validate expects a string or buffer as input
      // TODO not sure if we need to check that it also isn't a data view
      input = JSON.stringify(input);
    }

    const validationPromise = new Promise((resolve, reject) => {
      const validate = __webpack_require__(/*! ./parser/index */ "./src/parser/index.js"); // The second argument of true below indicates to the parser/validator
      // that the given input should be treated as a single sprite and not
      // an entire project


      validate(input, true, (error, res) => {
        if (error) return reject(error);
        resolve(res);
      });
    });
    return validationPromise.then(validatedInput => {
      const projectVersion = validatedInput[0].projectVersion;

      if (projectVersion === 2) {
        // 反序列化2.0的一个sprite，并加载到当前project
        return this._addSprite2(validatedInput[0], validatedInput[1]);
      }

      if (projectVersion === 3) {
        return this._addSprite3(validatedInput[0], validatedInput[1]);
      }

      return Promise.reject(`${errorPrefix} Unable to verify sprite version.`);
    }).then(() => this.runtime.emitProjectChanged()).catch(error => {
      // Intentionally rejecting here (want errors to be handled by caller)
      if (error.hasOwnProperty("validationError")) {
        return Promise.reject(JSON.stringify(error));
      }

      return Promise.reject(`${errorPrefix} ${error}`);
    });
  }
  /**
   * 反序列化2.0的一个sprite，并加载到当前project
   * @param {object} sprite Object representing 2.0 sprite to be added.
   * @param {?ArrayBuffer} zip Optional zip of assets being referenced by json
   * @returns {Promise} Promise that resolves after the sprite is added
   */


  _addSprite2(sprite, zip) {
    console.log("vm.js _addSprite2", sprite, zip); // Validate & parse

    const sb2 = __webpack_require__(/*! ./serialization/sb2 */ "./src/serialization/sb2.js");

    return sb2.deserialize(sprite, this.runtime, true, zip).then(({
      targets,
      extensions
    }) => this.installTargets(targets, extensions, false));
  }
  /**
   * Add a single sb3 sprite.
   * @param {object} sprite Object rperesenting 3.0 sprite to be added.
   * @param {?ArrayBuffer} zip Optional zip of assets being referenced by target json
   * @returns {Promise} Promise that resolves after the sprite is added
   */


  _addSprite3(sprite, zip) {
    console.log("vm.js _addSprite3", sprite, zip); // Validate & parse

    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    return sb3.deserialize(sprite, this.runtime, zip, true).then(({
      targets,
      extensions
    }) => this.installTargets(targets, extensions, false));
  }
  /**
   * @function 增加一个costume
   * @param {string} md5ext - MD5和要加载的costume的扩展名.
   * @param {!object} costumeObject 代表costume的对象.
   * @property {int} skinId - costume渲染皮肤的ID（安装后）.
   * @property {number} rotationCenterX - 旋转中心YX.
   * @property {number} rotationCenterY - 旋转中心Y.
   * @property {number} [bitmapResolution] - 位图costume的分辨率比例.
   * @param {string} optTargetId - 要添加的目标的ID，如果不是编辑目标.
   * @param {string} optVersion - 如果这是2，则将服装加载为sb2，否则将服装加载为sb3.
   * @returns {?Promise} - a promise that resolves when the costume has been added
   */


  addCostume(md5ext, costumeObject, optTargetId, optVersion) {
    console.log("vm.js addCostume", md5ext, costumeObject, optTargetId, optVersion);
    const target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;

    if (target) {
      return loadCostume(md5ext, costumeObject, this.runtime, optVersion).then(() => {
        target.addCostume(costumeObject);
        target.setCostume(target.getCostumes().length - 1);
        this.runtime.emitProjectChanged();
      });
    } // 如果无法通过ID找到目标，则返回 rejected promise


    return Promise.reject();
  }
  /**
   * @function 将从库加载的costume添加到当前编辑目标.
   * @param {string} md5ext - MD5和要加载的costume的扩展名.
   * @param {!object} costumeObject 代表costume的对象.
   * @property {int} skinId - costume渲染皮肤的ID（安装后）.
   * @property {number} rotationCenterX - 旋转中心YX.
   * @property {number} rotationCenterY - 旋转中心Y.
   * @property {number} [bitmapResolution] - 位图costume的分辨率比例.
   * @returns {?Promise} - a promise that resolves when the costume has been added
   */


  addCostumeFromLibrary(md5ext, costumeObject) {
    console.log("v-m.js 将从库加载的costume添加到当前编辑目标", md5ext, costumeObject);
    if (!this.editingTarget) return Promise.reject();
    return this.addCostume(md5ext, costumeObject, this.editingTarget.id, 2
    /* optVersion */
    );
  }
  /**
   * Duplicate the costume at the given index. Add it at that index + 1.复制costume
   * @param {!int} costumeIndex Index of costume to duplicate
   * @returns {?Promise} - a promise that resolves when the costume has been decoded and added
   */


  duplicateCostume(costumeIndex) {
    console.log("v-m.js 复制costume", costumeIndex);
    const originalCostume = this.editingTarget.getCostumes()[costumeIndex];
    const clone = Object.assign({}, originalCostume);
    const md5ext = `${clone.assetId}.${clone.dataFormat}`;
    return loadCostume(md5ext, clone, this.runtime).then(() => {
      this.editingTarget.addCostume(clone, costumeIndex + 1);
      this.editingTarget.setCostume(costumeIndex + 1);
      this.emitTargetsUpdate();
    });
  }
  /**
   * Duplicate the sound at the given index. Add it at that index + 1. 复制sound
   * @param {!int} soundIndex Index of sound to duplicate
   * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
   */


  duplicateSound(soundIndex) {
    const originalSound = this.editingTarget.getSounds()[soundIndex];
    const clone = Object.assign({}, originalSound);
    return loadSound(clone, this.runtime, this.editingTarget.sprite.soundBank).then(() => {
      this.editingTarget.addSound(clone, soundIndex + 1);
      this.emitTargetsUpdate();
    });
  }
  /**
   * Rename a costume on the current editing target. 重命名costume
   * @param {int} costumeIndex - the index of the costume to be renamed.
   * @param {string} newName - the desired new name of the costume (will be modified if already in use).
   */


  renameCostume(costumeIndex, newName) {
    console.log("v-m.js 重命名costume", costumeIndex);
    this.editingTarget.renameCostume(costumeIndex, newName);
    this.emitTargetsUpdate();
  }
  /**
   * Delete a costume from the current editing target. 删除costume
   * @param {int} costumeIndex - the index of the costume to be removed.
   * @return {?function} A function to restore the deleted costume, or null,
   * if no costume was deleted.
   */


  deleteCostume(costumeIndex) {
    console.log("v-m.js 删除costume", costumeIndex);
    const deletedCostume = this.editingTarget.deleteCostume(costumeIndex);

    if (deletedCostume) {
      const target = this.editingTarget;
      this.runtime.emitProjectChanged();
      return () => {
        target.addCostume(deletedCostume);
        this.emitTargetsUpdate();
      };
    }

    return null;
  }
  /**
   * Add a sound to the current editing target.
   * @param {!object} soundObject Object representing the costume.
   * @param {string} optTargetId - the id of the target to add to, if not the editing target.
   * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
   */


  addSound(soundObject, optTargetId) {
    const target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;

    if (target) {
      return loadSound(soundObject, this.runtime, target.sprite.soundBank).then(() => {
        target.addSound(soundObject);
        this.emitTargetsUpdate();
      });
    } // If the target cannot be found by id, return a rejected promise


    return new Promise.reject();
  }
  /**
   * Rename a sound on the current editing target.
   * @param {int} soundIndex - the index of the sound to be renamed.
   * @param {string} newName - the desired new name of the sound (will be modified if already in use).
   */


  renameSound(soundIndex, newName) {
    this.editingTarget.renameSound(soundIndex, newName);
    this.emitTargetsUpdate();
  }
  /**
   * Get a sound buffer from the audio engine. 从audio engine获取一个sound buffer
   * @param {int} soundIndex - the index of the sound to be got.
   * @return {AudioBuffer} the sound's audio buffer.
   */


  getSoundBuffer(soundIndex) {
    const id = this.editingTarget.sprite.sounds[soundIndex].soundId;

    if (id && this.runtime && this.runtime.audioEngine) {
      return this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer;
    }

    return null;
  }
  /**
   * Update a sound buffer.
   * @param {int} soundIndex - the index of the sound to be updated.
   * @param {AudioBuffer} newBuffer - new audio buffer for the audio engine.
   * @param {ArrayBuffer} soundEncoding - the new (wav) encoded sound to be stored
   */


  updateSoundBuffer(soundIndex, newBuffer, soundEncoding) {
    const sound = this.editingTarget.sprite.sounds[soundIndex];
    const id = sound ? sound.soundId : null;

    if (id && this.runtime && this.runtime.audioEngine) {
      this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer = newBuffer;
    } // Update sound in runtime


    if (soundEncoding) {
      // Now that we updated the sound, the format should also be updated
      // so that the sound can eventually be decoded the right way.
      // Sounds that were formerly 'adpcm', but were updated in sound editor
      // will not get decoded by the audio engine correctly unless the format
      // is updated as below.
      sound.format = "";
      const storage = this.runtime.storage;
      sound.asset = storage.createAsset(storage.AssetType.Sound, storage.DataFormat.WAV, soundEncoding, null, true // generate md5
      );
      sound.assetId = sound.asset.assetId;
      sound.dataFormat = storage.DataFormat.WAV;
      sound.md5 = `${sound.assetId}.${sound.dataFormat}`;
      sound.sampleCount = newBuffer.length;
      sound.rate = newBuffer.sampleRate;
    } // If soundEncoding is null, it's because gui had a problem
    // encoding the updated sound. We don't want to store anything in this
    // case, and gui should have logged an error.


    this.emitTargetsUpdate();
  }
  /**
   * Delete a sound from the current editing target.
   * @param {int} soundIndex - the index of the sound to be removed.
   * @return {?Function} A function to restore the sound that was deleted,
   * or null, if no sound was deleted.
   */


  deleteSound(soundIndex) {
    const target = this.editingTarget;
    const deletedSound = this.editingTarget.deleteSound(soundIndex);

    if (deletedSound) {
      this.runtime.emitProjectChanged();

      const restoreFun = () => {
        target.addSound(deletedSound);
        this.emitTargetsUpdate();
      };

      return restoreFun;
    }

    return null;
  }
  /**
   * Get a string representation of the image from storage. 获取costume svg格式
   * @param {int} costumeIndex - the index of the costume to be got.
   * @return {string} the costume's SVG string if it's SVG,
   *     a dataURI if it's a PNG or JPG, or null if it couldn't be found or decoded.
   */


  getCostume(costumeIndex) {
    console.log("v-m.js 获取costume svg格式", costumeIndex);
    const asset = this.editingTarget.getCostumes()[costumeIndex].asset;
    if (!asset || !this.runtime || !this.runtime.storage) return null;
    const format = asset.dataFormat;

    if (format === this.runtime.storage.DataFormat.SVG) {
      return asset.decodeText();
    } else if (format === this.runtime.storage.DataFormat.PNG || format === this.runtime.storage.DataFormat.JPG) {
      return asset.encodeDataURI();
    }

    console.error(`Unhandled format: ${asset.dataFormat}`);
    return null;
  }
  /**
   * Update a costume with the given bitmap
   * @param {!int} costumeIndex - the index of the costume to be updated.
   * @param {!ImageData} bitmap - new bitmap for the renderer.
   * @param {!number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
   * @param {!number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
   * @param {!number} bitmapResolution 1 for bitmaps that have 1 pixel per unit of stage,
   *     2 for double-resolution bitmaps
   */


  updateBitmap(costumeIndex, bitmap, rotationCenterX, rotationCenterY, bitmapResolution) {
    console.log("v-m.js 更新Bitmap", costumeIndex, bitmap, rotationCenterX, rotationCenterY, bitmapResolution);
    const costume = this.editingTarget.getCostumes()[costumeIndex];
    if (!(costume && this.runtime && this.runtime.renderer)) return;
    costume.rotationCenterX = rotationCenterX;
    costume.rotationCenterY = rotationCenterY; // If the bitmap originally had a zero width or height, use that value

    const bitmapWidth = bitmap.sourceWidth === 0 ? 0 : bitmap.width;
    const bitmapHeight = bitmap.sourceHeight === 0 ? 0 : bitmap.height; // @todo: updateBitmapSkin does not take ImageData

    const canvas = document.createElement("canvas");
    canvas.width = bitmapWidth;
    canvas.height = bitmapHeight;
    const context = canvas.getContext("2d");
    context.putImageData(bitmap, 0, 0); // Divide by resolution because the renderer's definition of the rotation center
    // is the rotation center divided by the bitmap resolution

    this.runtime.renderer.updateBitmapSkin(costume.skinId, canvas, bitmapResolution, [rotationCenterX / bitmapResolution, rotationCenterY / bitmapResolution]); // @todo there should be a better way to get from ImageData to a decodable storage format

    canvas.toBlob(blob => {
      const reader = new FileReader();
      reader.addEventListener("loadend", () => {
        const storage = this.runtime.storage;
        costume.dataFormat = storage.DataFormat.PNG;
        costume.bitmapResolution = bitmapResolution;
        costume.size = [bitmapWidth, bitmapHeight];
        costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, costume.dataFormat, Buffer.from(reader.result), null, // id
        true // generate md5
        );
        costume.assetId = costume.asset.assetId;
        costume.md5 = `${costume.assetId}.${costume.dataFormat}`;
        this.emitTargetsUpdate();
      }); // Bitmaps with a zero width or height return null for their blob

      if (blob) {
        reader.readAsArrayBuffer(blob);
      }
    });
  }
  /**
   * Update a costume with the given SVG
   * @param {int} costumeIndex - the index of the costume to be updated.
   * @param {string} svg - new SVG for the renderer.
   * @param {number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
   * @param {number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
   */


  updateSvg(costumeIndex, svg, rotationCenterX, rotationCenterY) {
    console.log("v-m.js 更新造型svg", costumeIndex, svg, rotationCenterX, rotationCenterY);
    const costume = this.editingTarget.getCostumes()[costumeIndex];

    if (costume && this.runtime && this.runtime.renderer) {
      costume.rotationCenterX = rotationCenterX;
      costume.rotationCenterY = rotationCenterY;
      this.runtime.renderer.updateSVGSkin(costume.skinId, svg, [rotationCenterX, rotationCenterY]);
      costume.size = this.runtime.renderer.getSkinSize(costume.skinId);
    }

    const storage = this.runtime.storage; // If we're in here, we've edited an svg in the vector editor,
    // so the dataFormat should be 'svg'

    costume.dataFormat = storage.DataFormat.SVG;
    costume.bitmapResolution = 1;
    costume.asset = storage.createAsset(storage.AssetType.ImageVector, costume.dataFormat, new TextEncoder().encode(svg), null, true // generate md5
    );
    costume.assetId = costume.asset.assetId;
    costume.md5 = `${costume.assetId}.${costume.dataFormat}`;
    this.emitTargetsUpdate();
  }
  /**
   * Add a backdrop to the stage.
   * @param {string} md5ext - the MD5 and extension of the backdrop to be loaded.
   * @param {!object} backdropObject Object representing the backdrop.
   * @property {int} skinId - the ID of the backdrop's render skin, once installed.
   * @property {number} rotationCenterX - the X component of the backdrop's origin.
   * @property {number} rotationCenterY - the Y component of the backdrop's origin.
   * @property {number} [bitmapResolution] - the resolution scale for a bitmap backdrop.
   * @returns {?Promise} - a promise that resolves when the backdrop has been added
   */


  addBackdrop(md5ext, backdropObject) {
    console.log("v-m.js 添加背景", md5ext, backdropObject);
    return loadCostume(md5ext, backdropObject, this.runtime).then(() => {
      const stage = this.runtime.getTargetForStage();
      stage.addCostume(backdropObject);
      stage.setCostume(stage.getCostumes().length - 1);
      this.runtime.emitProjectChanged();
    });
  }
  /**
   * Rename a sprite.
   * @param {string} targetId ID of a target whose sprite to rename.
   * @param {string} newName New name of the sprite.
   */


  renameSprite(targetId, newName) {
    console.log("v-m.js 重命名元素", targetId, newName);
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      if (!target.isSprite()) {
        throw new Error("Cannot rename non-sprite targets.");
      }

      const sprite = target.sprite;

      if (!sprite) {
        throw new Error("No sprite associated with this target.");
      }

      if (newName && RESERVED_NAMES.indexOf(newName) === -1) {
        const names = this.runtime.targets.filter(runtimeTarget => runtimeTarget.isSprite() && runtimeTarget.id !== target.id).map(runtimeTarget => runtimeTarget.sprite.name);
        const oldName = sprite.name;
        const newUnusedName = StringUtil.unusedName(newName, names);
        sprite.name = newUnusedName;
        const allTargets = this.runtime.targets;

        for (let i = 0; i < allTargets.length; i++) {
          const currTarget = allTargets[i];
          currTarget.blocks.updateAssetName(oldName, newName, "sprite");
        }

        if (newUnusedName !== oldName) this.emitTargetsUpdate();
      }
    } else {
      throw new Error("No target with the provided id.");
    }
  }
  /**
   * Delete a sprite and all its clones.
   * @param {string} targetId ID of a target whose sprite to delete.
   * @return {Function} Returns a function to restore the sprite that was deleted
   */


  deleteSprite(targetId) {
    console.log("v-m.js 删除元素", targetId);
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const targetIndexBeforeDelete = this.runtime.targets.map(t => t.id).indexOf(target.id);

      if (!target.isSprite()) {
        throw new Error("Cannot delete non-sprite targets.");
      }

      const sprite = target.sprite;

      if (!sprite) {
        throw new Error("No sprite associated with this target.");
      }

      const spritePromise = this.exportSprite(targetId, "uint8array");

      const restoreSprite = () => spritePromise.then(spriteBuffer => this.addSprite(spriteBuffer)); // Remove monitors from the runtime state and remove the
      // target-specific monitored blocks (e.g. local variables)


      target.deleteMonitors();
      const currentEditingTarget = this.editingTarget;

      for (let i = 0; i < sprite.clones.length; i++) {
        const clone = sprite.clones[i];
        this.runtime.stopForTarget(sprite.clones[i]);
        this.runtime.disposeTarget(sprite.clones[i]); // Ensure editing target is switched if we are deleting it.

        if (clone === currentEditingTarget) {
          const nextTargetIndex = Math.min(this.runtime.targets.length - 1, targetIndexBeforeDelete);

          if (this.runtime.targets.length > 0) {
            this.setEditingTarget(this.runtime.targets[nextTargetIndex].id);
          } else {
            this.editingTarget = null;
          }
        }
      } // Sprite object should be deleted by GC.


      this.emitTargetsUpdate();
      return restoreSprite;
    }

    throw new Error("No target with the provided id.");
  }
  /**
   * Duplicate a sprite.
   * @param {string} targetId ID of a target whose sprite to duplicate.
   * @returns {Promise} Promise that resolves when duplicated target has
   *     been added to the runtime.
   */


  duplicateSprite(targetId) {
    console.log("v-m.js 复制元素", targetId);
    const target = this.runtime.getTargetById(targetId);

    if (!target) {
      throw new Error("No target with the provided id.");
    } else if (!target.isSprite()) {
      throw new Error("Cannot duplicate non-sprite targets.");
    } else if (!target.sprite) {
      throw new Error("No sprite associated with this target.");
    }

    return target.duplicate().then(newTarget => {
      this.runtime.addTarget(newTarget);
      newTarget.goBehindOther(target);
      this.setEditingTarget(newTarget.id);
    });
  }
  /**
   * Set the audio engine for the VM/runtime 关联audio engine，gui项目中(gui.jsx)调用
   * @param {!AudioEngine} audioEngine The audio engine to attach
   */


  attachAudioEngine(audioEngine) {
    this.runtime.attachAudioEngine(audioEngine);
  }
  /**
   * Set the renderer for the VM/runtime 关联渲染器, gui项目中(stage.jsx)调用
   * @param {!RenderWebGL} renderer The renderer to attach
   */


  attachRenderer(renderer) {
    this.runtime.attachRenderer(renderer);
  }
  /**
   * @returns {RenderWebGL} The renderer attached to the vm
   */


  get renderer() {
    return this.runtime && this.runtime.renderer;
  }
  /**
   * 为虚拟机/运行时设置svg适配器，它将临时2 svg转换为临时3 svg
   * @param {!SvgRenderer} svgAdapter The adapter to attach
   */


  attachV2SVGAdapter(svgAdapter) {
    console.log("为虚拟机/运行时设置svg适配器，它将临时2 svg转换为临时3 svg:", svgAdapter);
    this.runtime.attachV2SVGAdapter(svgAdapter);
  }
  /**
   * 设置VM /运行时的位图适配器，该适配器将草稿2位图转换为草稿3位图。 （从头开始的3个位图都是位图分辨率2）
   * @param {!function} bitmapAdapter The adapter to attach
   */


  attachV2BitmapAdapter(bitmapAdapter) {
    this.runtime.attachV2BitmapAdapter(bitmapAdapter);
  }
  /**
   * 关联存储管理器, gui项目中(reducers/vm.js)调用
   * @param {!ScratchStorage} storage The storage module to attach
   */


  attachStorage(storage) {
    this.runtime.attachStorage(storage);
  }
  /**
   * 多语言支持
   * @param {!string} locale       current locale
   * @param {!object} messages     builtin messages map for current locale
   * @returns {Promise} Promise that resolves when all the blocks have been
   *     updated for a new locale (or empty if locale hasn't changed.)
   */


  setLocale(locale, messages) {
    if (locale !== formatMessage.setup().locale) {
      formatMessage.setup({
        locale: locale,
        translations: {
          [locale]: messages
        }
      });
    }

    return this.extensionManager.refreshBlocks();
  }
  /**
   * get the current locale for the VM
   * @returns {string} the current locale in the VM
   */


  getLocale() {
    return formatMessage.setup().locale;
  }
  /**
   * Handle a Blockly event for the current editing target.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  blockListener(e) {
    if (this.editingTarget) {
      this.editingTarget.blocks.blocklyListen(e);
    }
  }
  /**
   * Handle a Blockly event for the flyout.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  flyoutBlockListener(e) {
    this.runtime.flyoutBlocks.blocklyListen(e);
  }
  /**
   * Handle a Blockly event for the flyout to be passed to the monitor container.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  monitorBlockListener(e) {
    // Filter events by type, since monitor blocks only need to listen to these events.
    // Monitor blocks shouldn't be destroyed when flyout blocks are deleted.
    if (["create", "change"].indexOf(e.type) !== -1) {
      this.runtime.monitorBlocks.blocklyListen(e);
    }
  }
  /**
   * Handle a Blockly event for the variable map.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  variableListener(e) {
    // Filter events by type, since blocks only needs to listen to these
    // var events.
    if (["var_create", "var_rename", "var_delete"].indexOf(e.type) !== -1) {
      this.runtime.getTargetForStage().blocks.blocklyListen(e);
    }
  }
  /**
   * Set an editing target. An editor UI can use this function to switch
   * between editing different targets, sprites, etc.
   * After switching the editing target, the VM may emit updates
   * to the list of targets and any attached workspace blocks
   * (see `emitTargetsUpdate` and `emitWorkspaceUpdate`).
   * @param {string} targetId Id of target to set as editing.
   */


  setEditingTarget(targetId) {
    console.log("setEditingTarget", targetId); // Has the target id changed? If not, exit.

    if (this.editingTarget && targetId === this.editingTarget.id) return;
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      this.editingTarget = target; // Emit appropriate UI updates.

      this.emitTargetsUpdate(false
      /* Don't emit project change */
      );
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(target);
    }
  }
  /**
   * Called when blocks are dragged from one sprite to another. Adds the blocks to the
   * workspace of the given target. 当从一个sprite拖拽到另一个sprite时调用
   * @param {!Array<object>} blocks Blocks to add.
   * @param {!string} targetId Id of target to add blocks to.
   * @param {?string} optFromTargetId Optional target id indicating that blocks are being
   * shared from that target. This is needed for resolving any potential variable conflicts.
   * @return {!Promise} Promise that resolves when the extensions and blocks have been added.
   */


  shareBlocksToTarget(blocks, targetId, optFromTargetId) {
    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    const copiedBlocks = JSON.parse(JSON.stringify(blocks));
    Utility.newBlockIds(copiedBlocks);
    const target = this.runtime.getTargetById(targetId);

    if (optFromTargetId) {
      // If the blocks are being shared from another target,
      // resolve any possible variable conflicts that may arise.
      const fromTarget = this.runtime.getTargetById(optFromTargetId);
      fromTarget.resolveVariableSharingConflictsWithTarget(copiedBlocks, target);
    } // Create a unique set of extensionIds that are not yet loaded


    const extensionIDs = new Set(copiedBlocks.map(b => sb3.getExtensionIdForOpcode(b.opcode)).filter(id => !!id) // Remove ids that do not exist
    .filter(id => !this.extensionManager.isExtensionLoaded(id)) // and remove loaded extensions
    ); // Create an array promises for extensions to load

    const extensionPromises = Array.from(extensionIDs, id => this.extensionManager.loadExtensionURL(id));
    return Promise.all(extensionPromises).then(() => {
      copiedBlocks.forEach(block => {
        target.blocks.createBlock(block);
      });
      target.blocks.updateTargetSpecificBlocks(target.isStage);
    });
  }
  /**
   * 当服装从编辑目标拖动到另一个目标时调用.
   * 将新添加的服装设置为当前服装.
   * @param {!number} costumeIndex 分享的编辑对象的服装索引.
   * @param {!string} targetId 要添加服装的目标ID.
   * @return {Promise} 承诺会在装入新服装时解决.
   */


  shareCostumeToTarget(costumeIndex, targetId) {
    const originalCostume = this.editingTarget.getCostumes()[costumeIndex];
    const clone = Object.assign({}, originalCostume);
    const md5ext = `${clone.assetId}.${clone.dataFormat}`;
    return loadCostume(md5ext, clone, this.runtime).then(() => {
      const target = this.runtime.getTargetById(targetId);

      if (target) {
        target.addCostume(clone);
        target.setCostume(target.getCostumes().length - 1);
      }
    });
  }
  /**
   * Called when sounds are dragged from editing target to another target.
   * @param {!number} soundIndex Index of the sound of the editing target to share.
   * @param {!string} targetId Id of target to add the sound.
   * @return {Promise} Promise that resolves when the new sound has been loaded.
   */


  shareSoundToTarget(soundIndex, targetId) {
    const originalSound = this.editingTarget.getSounds()[soundIndex];
    const clone = Object.assign({}, originalSound);
    const target = this.runtime.getTargetById(targetId);
    return loadSound(clone, this.runtime, target.sprite.soundBank).then(() => {
      if (target) {
        target.addSound(clone);
        this.emitTargetsUpdate();
      }
    });
  }
  /**
   * Repopulate the workspace with the blocks of the current editingTarget. This
   * allows us to get around bugs like gui#413.
   * 强制刷新
   */


  refreshWorkspace() {
    if (this.editingTarget) {
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(this.editingTarget);
      this.emitTargetsUpdate(false
      /* Don't emit project change */
      );
    }
  }
  /**
   * Emit metadata about available targets.发出有关可用目标的元数据
   * 编辑器UI可以使用它来显示目标列表并显示当前正在编辑的目标.
   * @param {bool} triggerProjectChange 如果为true，还发出项目更改事件.
   * 有选择地被不影响项目序列化的更新禁用.默认为true.
   */


  emitTargetsUpdate(triggerProjectChange) {
    console.log("vm emitTargetsUpdate():", triggerProjectChange);
    if (typeof triggerProjectChange === "undefined") triggerProjectChange = true;
    this.emit("targetsUpdate", {
      // [[target id, human readable target name], ...].
      targetList: this.runtime.targets.filter( // 不报告克隆.
      target => !target.hasOwnProperty("isOriginal") || target.isOriginal).map(target => target.toJSON()),
      // 当前正在编辑目标ID.
      editingTarget: this.editingTarget ? this.editingTarget.id : null
    });

    if (triggerProjectChange) {
      this.runtime.emitProjectChanged();
    }
  }
  /**
   * Emit an Blockly/scratch-blocks compatible XML representation
   * of the current editing target's blocks.
   */


  emitWorkspaceUpdate() {
    // Create a list of broadcast message Ids according to the stage variables
    const stageVariables = this.runtime.getTargetForStage().variables;
    let messageIds = [];

    for (const varId in stageVariables) {
      if (stageVariables[varId].type === Variable.BROADCAST_MESSAGE_TYPE) {
        messageIds.push(varId);
      }
    } // Go through all blocks on all targets, removing referenced
    // broadcast ids from the list.


    for (let i = 0; i < this.runtime.targets.length; i++) {
      const currTarget = this.runtime.targets[i];
      const currBlocks = currTarget.blocks._blocks;

      for (const blockId in currBlocks) {
        if (currBlocks[blockId].fields.BROADCAST_OPTION) {
          const id = currBlocks[blockId].fields.BROADCAST_OPTION.id;
          const index = messageIds.indexOf(id);

          if (index !== -1) {
            messageIds = messageIds.slice(0, index).concat(messageIds.slice(index + 1));
          }
        }
      }
    } // Anything left in messageIds is not referenced by a block, so delete it.


    for (let i = 0; i < messageIds.length; i++) {
      const id = messageIds[i];
      delete this.runtime.getTargetForStage().variables[id];
    }

    const globalVarMap = Object.assign({}, this.runtime.getTargetForStage().variables);
    const localVarMap = this.editingTarget.isStage ? Object.create(null) : Object.assign({}, this.editingTarget.variables);
    const globalVariables = Object.keys(globalVarMap).map(k => globalVarMap[k]);
    const localVariables = Object.keys(localVarMap).map(k => localVarMap[k]);
    const workspaceComments = Object.keys(this.editingTarget.comments).map(k => this.editingTarget.comments[k]).filter(c => c.blockId === null);
    const xmlString = `<xml xmlns="http://www.w3.org/1999/xhtml">
                            <variables>
                                ${globalVariables.map(v => v.toXML()).join()}
                                ${localVariables.map(v => v.toXML(true)).join()}
                            </variables>
                            ${workspaceComments.map(c => c.toXML()).join()}
                            ${this.editingTarget.blocks.toXML(this.editingTarget.comments)}
                        </xml>`;
    this.emit("workspaceUpdate", {
      xml: xmlString
    });
  }
  /**
   * Get a target id for a drawable id. Useful for interacting with the renderer
   * 通过renderer的drawableid，反向获取targetid
   * @param {int} drawableId The drawable id to request the target id for
   * @returns {?string} The target id, if found. Will also be null if the target found is the stage.
   */


  getTargetIdForDrawableId(drawableId) {
    const target = this.runtime.getTargetByDrawableId(drawableId);

    if (target && target.hasOwnProperty("id") && target.hasOwnProperty("isStage") && !target.isStage) {
      return target.id;
    }

    return null;
  }
  /**
   * Reorder target by index. Return whether a change was made.
   * @param {!string} targetIndex Index of the target.
   * @param {!number} newIndex index that the target should be moved to.
   * @returns {boolean} Whether a target was reordered.
   */


  reorderTarget(targetIndex, newIndex) {
    let targets = this.runtime.targets;
    targetIndex = Utility.clamp(targetIndex, 0, targets.length - 1);
    newIndex = Utility.clamp(newIndex, 0, targets.length - 1);
    if (targetIndex === newIndex) return false;
    const target = targets[targetIndex];
    targets = targets.slice(0, targetIndex).concat(targets.slice(targetIndex + 1));
    targets.splice(newIndex, 0, target);
    this.runtime.targets = targets;
    this.emitTargetsUpdate();
    return true;
  }
  /**
   * Reorder the costumes of a target if it exists. Return whether it succeeded.
   * @param {!string} targetId ID of the target which owns the costumes.
   * @param {!number} costumeIndex index of the costume to move.
   * @param {!number} newIndex index that the costume should be moved to.
   * @returns {boolean} Whether a costume was reordered.
   */


  reorderCostume(targetId, costumeIndex, newIndex) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const reorderSuccessful = target.reorderCostume(costumeIndex, newIndex);

      if (reorderSuccessful) {
        this.runtime.emitProjectChanged();
      }

      return reorderSuccessful;
    }

    return false;
  }
  /**
   * Reorder the sounds of a target if it exists. Return whether it occured.
   * @param {!string} targetId ID of the target which owns the sounds.
   * @param {!number} soundIndex index of the sound to move.
   * @param {!number} newIndex index that the sound should be moved to.
   * @returns {boolean} Whether a sound was reordered.
   */


  reorderSound(targetId, soundIndex, newIndex) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const reorderSuccessful = target.reorderSound(soundIndex, newIndex);

      if (reorderSuccessful) {
        this.runtime.emitProjectChanged();
      }

      return reorderSuccessful;
    }

    return false;
  }
  /**
   * Put a target into a "drag" state, during which its X/Y positions will be unaffected
   * by blocks.
   * 设置某target进入drag mode(this. _dragTarget=target), gui项目中(stage.jsx)调用
   * @param {string} targetId The id for the target to put into a drag state
   */


  startDrag(targetId) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      this._dragTarget = target;
      target.startDrag();
    }
  }
  /**
   * Remove a target from a drag state, so blocks may begin affecting X/Y position again
   * 设置某target离开drag mode(this. _dragTarget=null), gui项目中(stage.jsx)调用
   * @param {string} targetId The id for the target to remove from the drag state
   */


  stopDrag(targetId) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      this._dragTarget = null;
      target.stopDrag();
      this.setEditingTarget(target.sprite && target.sprite.clones[0] ? target.sprite.clones[0].id : target.id);
    }
  }
  /**
   * Post/edit sprite info for the current editing target or the drag target.
   * 向editing target or dragging target 发送sprite信息
   * @param {object} data An object with sprite info data to set.
   */


  postSpriteInfo(data) {
    if (this._dragTarget) {
      this._dragTarget.postSpriteInfo(data);
    } else {
      this.editingTarget.postSpriteInfo(data);
    } // Post sprite info means the gui has changed something about a sprite,
    // either through the sprite info pane fields (e.g. direction, size) or
    // through dragging a sprite on the stage
    // Emit a project changed event.


    this.runtime.emitProjectChanged();
  }
  /**
   * Set a target's variable's value. Return whether it succeeded.
   * @param {!string} targetId ID of the target which owns the variable.
   * @param {!string} variableId ID of the variable to set.
   * @param {!*} value The new value of that variable.
   * @returns {boolean} whether the target and variable were found and updated.
   */


  setVariableValue(targetId, variableId, value) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const variable = target.lookupVariableById(variableId);

      if (variable) {
        variable.value = value;

        if (variable.isCloud) {
          this.runtime.ioDevices.cloud.requestUpdateVariable(variable.name, variable.value);
        }

        return true;
      }
    }

    return false;
  }
  /**
   * Get a target's variable's value. Return null if the target or variable does not exist.
   * @param {!string} targetId ID of the target which owns the variable.
   * @param {!string} variableId ID of the variable to set.
   * @returns {?*} The value of the variable, or null if it could not be looked up.
   */


  getVariableValue(targetId, variableId) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const variable = target.lookupVariableById(variableId);

      if (variable) {
        return variable.value;
      }
    }

    return null;
  }
  /**
   * Allow VM consumer to configure the ScratchLink socket creator.
   * @param {Function} factory The custom ScratchLink socket factory.
   */


  configureScratchLinkSocketFactory(factory) {
    this.runtime.configureScratchLinkSocketFactory(factory);
  }

}

module.exports = VirtualMachine;

/***/ }),

/***/ "./src/vm-blocks.js":
/*!**************************!*\
  !*** ./src/vm-blocks.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * @Author: Satya
 * @Date: 2020-12-22 15:25:23
 * @Last Modified by: Satya
 * @Last Modified time: 2020-12-22 15:52:14
 * doc:所有积木的驱动实现，统一放在这里
 * 由类名作为分类
 */
const Timer = __webpack_require__(/*! ./util/timer */ "./src/util/timer.js");

const RenderedTarget = __webpack_require__(/*! ./sprites/rendered-target */ "./src/sprites/rendered-target.js");

const StageLayering = __webpack_require__(/*! ./engine/stage-layering */ "./src/engine/stage-layering.js");
/** @module 控制分类 */


class KidControlBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The "counter" block value. For compatibility with 2.0.
     * @type {number}
     */

    this._counter = 0;
    this.runtime.on("RUNTIME_DISPOSED", this.clearCounter.bind(this));
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      control_repeat: this.repeat,
      control_repeat_until: this.repeatUntil,
      control_while: this.repeatWhile,
      control_for_each: this.forEach,
      control_forever: this.forever,
      control_wait: this.wait,
      control_wait_until: this.waitUntil,
      control_if: this.if,
      control_if_else: this.ifElse,
      control_stop: this.stop,
      control_create_clone_of: this.createClone,
      control_delete_this_clone: this.deleteClone,
      control_get_counter: this.getCounter,
      control_incr_counter: this.incrCounter,
      control_clear_counter: this.clearCounter,
      control_all_at_once: this.allAtOnce
    };
  }

  getHats() {
    return {
      control_start_as_clone: {
        restartExistingThreads: false
      }
    };
  }

  repeat(args, util) {
    const times = Math.round(Utility.toNumber(args.TIMES)); // Initialize loop

    if (typeof util.stackFrame.loopCounter === "undefined") {
      util.stackFrame.loopCounter = times;
    } // Only execute once per frame.
    // When the branch finishes, `repeat` will be executed again and
    // the second branch will be taken, yielding for the rest of the frame.
    // Decrease counter


    util.stackFrame.loopCounter--; // If we still have some left, start the branch.

    if (util.stackFrame.loopCounter >= 0) {
      util.startBranch(1, true);
    }
  }

  repeatUntil(args, util) {
    const condition = Utility.toBoolean(args.CONDITION); // If the condition is false (repeat UNTIL), start the branch.

    if (!condition) {
      util.startBranch(1, true);
    }
  }

  repeatWhile(args, util) {
    const condition = Utility.toBoolean(args.CONDITION); // If the condition is true (repeat WHILE), start the branch.

    if (condition) {
      util.startBranch(1, true);
    }
  }

  forEach(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);

    if (typeof util.stackFrame.index === "undefined") {
      util.stackFrame.index = 0;
    }

    if (util.stackFrame.index < Number(args.VALUE)) {
      util.stackFrame.index++;
      variable.value = util.stackFrame.index;
      util.startBranch(1, true);
    }
  }

  waitUntil(args, util) {
    const condition = Utility.toBoolean(args.CONDITION);

    if (!condition) {
      util.yield();
    }
  }

  forever(args, util) {
    util.startBranch(1, true);
  }

  wait(args, util) {
    if (util.stackTimerNeedsInit()) {
      const duration = Math.max(0, 1000 * Utility.toNumber(args.DURATION));
      util.startStackTimer(duration);
      this.runtime.requestRedraw();
      util.yield();
    } else if (!util.stackTimerFinished()) {
      util.yield();
    }
  }

  if(args, util) {
    const condition = Utility.toBoolean(args.CONDITION);

    if (condition) {
      util.startBranch(1, false);
    }
  }

  ifElse(args, util) {
    const condition = Utility.toBoolean(args.CONDITION);

    if (condition) {
      util.startBranch(1, false);
    } else {
      util.startBranch(2, false);
    }
  }

  stop(args, util) {
    const option = args.STOP_OPTION;

    if (option === "all") {
      util.stopAll();
    } else if (option === "other scripts in sprite" || option === "other scripts in stage") {
      util.stopOtherTargetThreads();
    } else if (option === "this script") {
      util.stopThisScript();
    }
  }

  createClone(args, util) {
    // Cast argument to string
    args.CLONE_OPTION = String(args.CLONE_OPTION); // Set clone target

    let cloneTarget;

    if (args.CLONE_OPTION === "_myself_") {
      cloneTarget = util.target;
    } else {
      cloneTarget = this.runtime.getSpriteTargetByName(args.CLONE_OPTION);
    } // If clone target is not found, return


    if (!cloneTarget) return; // Create clone

    const newClone = cloneTarget.makeClone();

    if (newClone) {
      this.runtime.addTarget(newClone); // Place behind the original target.

      newClone.goBehindOther(cloneTarget);
    }
  }

  deleteClone(args, util) {
    if (util.target.isOriginal) return;
    this.runtime.disposeTarget(util.target);
    this.runtime.stopForTarget(util.target);
  }

  getCounter() {
    return this._counter;
  }

  clearCounter() {
    this._counter = 0;
  }

  incrCounter() {
    this._counter++;
  }

  allAtOnce(args, util) {
    // Since the "all at once" block is implemented for compatiblity with
    // Scratch 2.0 projects, it behaves the same way it did in 2.0, which
    // is to simply run the contained script (like "if 1 = 1").
    // (In early versions of Scratch 2.0, it would work the same way as
    // "run without screen refresh" custom blocks do now, but this was
    // removed before the release of 2.0.)
    util.startBranch(1, false);
  }

}
/** @module 事件分类 */


class KidEventBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this.runtime.on("KEY_PRESSED", key => {
      this.runtime.startHats("event_whenkeypressed", {
        KEY_OPTION: key
      });
      this.runtime.startHats("event_whenkeypressed", {
        KEY_OPTION: "any"
      });
    });
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      event_whentouchingobject: this.touchingObject,
      event_broadcast: this.broadcast,
      event_broadcastandwait: this.broadcastAndWait,
      event_whengreaterthan: this.hatGreaterThanPredicate
    };
  }

  getHats() {
    return {
      event_whenflagclicked: {
        restartExistingThreads: true
      },
      event_whenkeypressed: {
        restartExistingThreads: false
      },
      event_whenthisspriteclicked: {
        restartExistingThreads: true
      },
      event_whentouchingobject: {
        restartExistingThreads: false,
        edgeActivated: true
      },
      event_whenstageclicked: {
        restartExistingThreads: true
      },
      event_whenbackdropswitchesto: {
        restartExistingThreads: true
      },
      event_whengreaterthan: {
        restartExistingThreads: false,
        edgeActivated: true
      },
      event_whenbroadcastreceived: {
        restartExistingThreads: true
      }
    };
  }

  touchingObject(args, util) {
    return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);
  }

  hatGreaterThanPredicate(args, util) {
    const option = String(args.WHENGREATERTHANMENU).toLowerCase();
    const value = Utility.toNumber(args.VALUE);

    switch (option) {
      case "timer":
        return util.ioQuery("clock", "projectTimer") > value;

      case "loudness":
        return this.runtime.audioEngine && this.runtime.audioEngine.getLoudness() > value;
    }

    return false;
  }

  broadcast(args, util) {
    const broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);

    if (broadcastVar) {
      const broadcastOption = broadcastVar.name;
      util.startHats("event_whenbroadcastreceived", {
        BROADCAST_OPTION: broadcastOption
      });
    }
  }

  broadcastAndWait(args, util) {
    const broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);

    if (broadcastVar) {
      const broadcastOption = broadcastVar.name; // Have we run before, starting threads?

      if (!util.stackFrame.startedThreads) {
        // No - start hats for this broadcast.
        util.stackFrame.startedThreads = util.startHats("event_whenbroadcastreceived", {
          BROADCAST_OPTION: broadcastOption
        });

        if (util.stackFrame.startedThreads.length === 0) {
          // Nothing was started.
          return;
        }
      } // We've run before; check if the wait is still going on.


      const instance = this; // Scratch 2 considers threads to be waiting if they are still in
      // runtime.threads. Threads that have run all their blocks, or are
      // marked done but still in runtime.threads are still considered to
      // be waiting.

      const waiting = util.stackFrame.startedThreads.some(thread => instance.runtime.threads.indexOf(thread) !== -1);

      if (waiting) {
        // If all threads are waiting for the next tick or later yield
        // for a tick as well. Otherwise yield until the next loop of
        // the threads.
        if (util.stackFrame.startedThreads.every(thread => instance.runtime.isWaitingThread(thread))) {
          util.yieldTick();
        } else {
          util.yield();
        }
      }
    }
  }

}
/**
 * @module 外观分类
 * @typedef {object} BubbleState - the bubble state associated with a particular target.
 * @property {Boolean} onSpriteRight - tracks whether the bubble is right or left of the sprite.
 * @property {?int} drawableId - the ID of the associated bubble Drawable, null if none.
 * @property {string} text - the text of the bubble.
 * @property {string} type - the type of the bubble, "say" or "think"
 * @property {?string} usageId - ID indicating the most recent usage of the say/think bubble.
 *      Used for comparison when determining whether to clear a say/think bubble.
 */


class KidLooksBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this._onTargetChanged = this._onTargetChanged.bind(this);
    this._onResetBubbles = this._onResetBubbles.bind(this);
    this._onTargetWillExit = this._onTargetWillExit.bind(this);
    this._updateBubble = this._updateBubble.bind(this); // Reset all bubbles on start/stop

    this.runtime.on("PROJECT_STOP_ALL", this._onResetBubbles);
    this.runtime.on("targetWasRemoved", this._onTargetWillExit); // Enable other blocks to use bubbles like ask/answer

    this.runtime.on(KidLooksBlocks.SAY_OR_THINK, this._updateBubble);
  }
  /**
   * The default bubble state, to be used when a target has no existing bubble state.
   * @type {BubbleState}
   */


  static get DEFAULT_BUBBLE_STATE() {
    return {
      drawableId: null,
      onSpriteRight: true,
      skinId: null,
      text: "",
      type: "say",
      usageId: null
    };
  }
  /**
   * The key to load & store a target's bubble-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.looks";
  }
  /**
   * Event name for a text bubble being created or updated.
   * @const {string}
   */


  static get SAY_OR_THINK() {
    // There are currently many places in the codebase which explicitly refer to this event by the string 'SAY',
    // so keep this as the string 'SAY' for now rather than changing it to 'SAY_OR_THINK' and breaking things.
    return "SAY";
  }
  /**
   * Limit for say bubble string.
   * @const {string}
   */


  static get SAY_BUBBLE_LIMIT() {
    return 330;
  }
  /**
   * Limit for ghost effect
   * @const {object}
   */


  static get EFFECT_GHOST_LIMIT() {
    return {
      min: 0,
      max: 100
    };
  }
  /**
   * Limit for brightness effect
   * @const {object}
   */


  static get EFFECT_BRIGHTNESS_LIMIT() {
    return {
      min: -100,
      max: 100
    };
  }
  /**
   * @param {Target} target - collect bubble state for this target. Probably, but not necessarily, a RenderedTarget.
   * @returns {BubbleState} the mutable bubble state associated with that target. This will be created if necessary.
   * @private
   */


  _getBubbleState(target) {
    let bubbleState = target.getCustomState(KidLooksBlocks.STATE_KEY);

    if (!bubbleState) {
      bubbleState = Utility.cloneSimple(KidLooksBlocks.DEFAULT_BUBBLE_STATE);
      target.setCustomState(KidLooksBlocks.STATE_KEY, bubbleState);
    }

    return bubbleState;
  }
  /**
   * Handle a target which has moved.
   * @param {RenderedTarget} target - the target which has moved.
   * @private
   */


  _onTargetChanged(target) {
    const bubbleState = this._getBubbleState(target);

    if (bubbleState.drawableId) {
      this._positionBubble(target);
    }
  }
  /**
   * Handle a target which is exiting.
   * @param {RenderedTarget} target - the target.
   * @private
   */


  _onTargetWillExit(target) {
    const bubbleState = this._getBubbleState(target);

    if (bubbleState.drawableId && bubbleState.skinId) {
      this.runtime.renderer.destroyDrawable(bubbleState.drawableId, StageLayering.SPRITE_LAYER);
      this.runtime.renderer.destroySkin(bubbleState.skinId);
      bubbleState.drawableId = null;
      bubbleState.skinId = null;
      this.runtime.requestRedraw();
    }

    target.removeListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);
  }
  /**
   * Handle project start/stop by clearing all visible bubbles.
   * @private
   */


  _onResetBubbles() {
    for (let n = 0; n < this.runtime.targets.length; n++) {
      const bubbleState = this._getBubbleState(this.runtime.targets[n]);

      bubbleState.text = "";

      this._onTargetWillExit(this.runtime.targets[n]);
    }

    clearTimeout(this._bubbleTimeout);
  }
  /**
   * Position the bubble of a target. If it doesn't fit on the specified side, flip and rerender.
   * @param {!Target} target Target whose bubble needs positioning.
   * @private
   */


  _positionBubble(target) {
    if (!target.visible) return;

    const bubbleState = this._getBubbleState(target);

    const [bubbleWidth, bubbleHeight] = this.runtime.renderer.getCurrentSkinSize(bubbleState.drawableId);
    let targetBounds;

    try {
      targetBounds = target.getBoundsForBubble();
    } catch (error_) {
      // Bounds calculation could fail (e.g. on empty costumes), in that case
      // use the x/y position of the target.
      targetBounds = {
        left: target.x,
        right: target.x,
        top: target.y,
        bottom: target.y
      };
    }

    const stageSize = this.runtime.renderer.getNativeSize();
    const stageBounds = {
      left: -stageSize[0] / 2,
      right: stageSize[0] / 2,
      top: stageSize[1] / 2,
      bottom: -stageSize[1] / 2
    };

    if (bubbleState.onSpriteRight && bubbleWidth + targetBounds.right > stageBounds.right && targetBounds.left - bubbleWidth > stageBounds.left) {
      // Only flip if it would fit
      bubbleState.onSpriteRight = false;

      this._renderBubble(target);
    } else if (!bubbleState.onSpriteRight && targetBounds.left - bubbleWidth < stageBounds.left && bubbleWidth + targetBounds.right < stageBounds.right) {
      // Only flip if it would fit
      bubbleState.onSpriteRight = true;

      this._renderBubble(target);
    } else {
      this.runtime.renderer.updateDrawableProperties(bubbleState.drawableId, {
        position: [bubbleState.onSpriteRight ? Math.max(stageBounds.left, // Bubble should not extend past left edge of stage
        Math.min(stageBounds.right - bubbleWidth, targetBounds.right)) : Math.min(stageBounds.right - bubbleWidth, // Bubble should not extend past right edge of stage
        Math.max(stageBounds.left, targetBounds.left - bubbleWidth)), // Bubble should not extend past the top of the stage
        Math.min(stageBounds.top, targetBounds.bottom + bubbleHeight)]
      });
      this.runtime.requestRedraw();
    }
  }
  /**
   * Create a visible bubble for a target. If a bubble exists for the target,
   * just set it to visible and update the type/text. Otherwise create a new
   * bubble and update the relevant custom state.
   * @param {!Target} target Target who needs a bubble.
   * @return {undefined} Early return if text is empty string.
   * @private
   */


  _renderBubble(target) {
    if (!this.runtime.renderer) return;

    const bubbleState = this._getBubbleState(target);

    const {
      type,
      text,
      onSpriteRight
    } = bubbleState; // Remove the bubble if target is not visible, or text is being set to blank.

    if (!target.visible || text === "") {
      this._onTargetWillExit(target);

      return;
    }

    if (bubbleState.skinId) {
      this.runtime.renderer.updateTextSkin(bubbleState.skinId, type, text, onSpriteRight, [0, 0]);
    } else {
      target.addListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);
      bubbleState.drawableId = this.runtime.renderer.createDrawable(StageLayering.SPRITE_LAYER);
      bubbleState.skinId = this.runtime.renderer.createTextSkin(type, text, bubbleState.onSpriteRight, [0, 0]);
      this.runtime.renderer.updateDrawableProperties(bubbleState.drawableId, {
        skinId: bubbleState.skinId
      });
    }

    this._positionBubble(target);
  }
  /**
   * Properly format text for a text bubble.
   * @param {string} text The text to be formatted
   * @return {string} The formatted text
   * @private
   */


  _formatBubbleText(text) {
    if (text === "") return text; // Non-integers should be rounded to 2 decimal places (no more, no less), unless they're small enough that
    // rounding would display them as 0.00. This matches 2.0's behavior:
    // https://github.com/LLK/scratch-flash/blob/2e4a402ceb205a042887f54b26eebe1c2e6da6c0/src/scratch/ScratchSprite.as#L579-L585

    if (typeof text === "number" && Math.abs(text) >= 0.01 && text % 1 !== 0) {
      text = text.toFixed(2);
    } // Limit the length of the string.


    text = String(text).substr(0, KidLooksBlocks.SAY_BUBBLE_LIMIT);
    return text;
  }
  /**
   * The entry point for say/think blocks. Clears existing bubble if the text is empty.
   * Set the bubble custom state and then call _renderBubble.
   * @param {!Target} target Target that say/think blocks are being called on.
   * @param {!string} type Either "say" or "think"
   * @param {!string} text The text for the bubble, empty string clears the bubble.
   * @private
   */


  _updateBubble(target, type, text) {
    const bubbleState = this._getBubbleState(target);

    bubbleState.type = type;
    bubbleState.text = this._formatBubbleText(text);
    console.warn("look:", Utility.uid());
    bubbleState.usageId = Utility.uid();

    this._renderBubble(target);
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      /** KID-JR 专属指令 实现 */
      looks_zoomout: this.zoomOut,
      looks_zoomin: this.zoomIn,
      looks_zoomreset: this.zoomReset,

      /** KID-PRO 指令 实现 */
      looks_say: this.say,
      looks_sayforsecs: this.sayforsecs,
      looks_think: this.think,
      looks_thinkforsecs: this.thinkforsecs,
      looks_show: this.show,
      looks_hide: this.hide,
      looks_hideallsprites: () => {},
      // legacy no-op block
      looks_switchcostumeto: this.switchCostume,
      looks_switchbackdropto: this.switchBackdrop,
      looks_switchbackdroptoandwait: this.switchBackdropAndWait,
      looks_nextcostume: this.nextCostume,
      looks_nextbackdrop: this.nextBackdrop,
      looks_changeeffectby: this.changeEffect,
      looks_seteffectto: this.setEffect,
      looks_cleargraphiceffects: this.clearEffects,
      looks_changesizeby: this.changeSize,
      looks_setsizeto: this.setSize,
      looks_changestretchby: () => {},
      // legacy no-op blocks
      looks_setstretchto: () => {},
      looks_gotofrontback: this.goToFrontBack,
      looks_goforwardbackwardlayers: this.goForwardBackwardLayers,
      looks_size: this.getSize,
      looks_costumenumbername: this.getCostumeNumberName,
      looks_backdropnumbername: this.getBackdropNumberName
    };
  }

  getMonitored() {
    return {
      looks_size: {
        isSpriteSpecific: true,
        getId: targetId => `${targetId}_size`
      },
      looks_costumenumbername: {
        isSpriteSpecific: true,
        getId: (targetId, fields) => Utility.getMonitorIdForBlockWithArgs(`${targetId}_costumenumbername`, fields)
      },
      looks_backdropnumbername: {
        getId: (_, fields) => Utility.getMonitorIdForBlockWithArgs("backdropnumbername", fields)
      }
    };
  }
  /** KID-JR 专属指令 实现 */

  /**
   * 自定义  放大函数
   * @param {*} args
   * @param {*} util
   */


  zoomOut(args, util) {
    if (util.stackFrame.timer) {
      const n = util.stackFrame.timer.timeElapsed();

      if (n < 1e3 * util.stackFrame.duration) {
        const r = (n - util.stackFrame.prevTimeElapsed) / (1e3 * util.stackFrame.duration) * util.stackFrame.absPercent; // eslint-disable-next-line no-unused-expressions

        util.target.setSize(util.stackFrame.crtScale + r), util.yield();
      } else {
        util.target.setSize(util.stackFrame.crtScale + util.stackFrame.absPercent);
      }
    } else {
      // const i = Cast.toNumber(args.PERCENT);
      const i = Utility.toNumber(1);
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();

      if (util.stackFrame.duration = 0.1 * i, util.stackFrame.absPercent = 10 * i, util.stackFrame.crtScale = util.target.size, util.stackFrame.prevTimeElapsed = 0, util.stackFrame.duration <= 0) {
        return void util.target.setSize(util.stackFrame.crtScale + util.stackFrame.absPercent);
      }

      util.yield();
    }
  }
  /**
   * 自定义  缩小函数
   * @param {*} args
   * @param {*} util
   */


  zoomIn(args, util) {
    if (util.stackFrame.timer) {
      const n = util.stackFrame.timer.timeElapsed();

      if (n < 1e3 * util.stackFrame.duration) {
        const r = (n - util.stackFrame.prevTimeElapsed) / (1e3 * util.stackFrame.duration) * util.stackFrame.absPercent; // eslint-disable-next-line no-unused-expressions

        util.target.setSize(util.stackFrame.crtScale - r), util.yield();
      } else {
        util.target.setSize(util.stackFrame.crtScale - util.stackFrame.absPercent);
      }
    } else {
      // const i = Cast.toNumber(args.PERCENT);
      const i = Utility.toNumber(1);
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();

      if (util.stackFrame.duration = 0.1 * i, util.stackFrame.absPercent = 10 * i, util.stackFrame.crtScale = util.target.size, util.stackFrame.prevTimeElapsed = 0, util.stackFrame.duration <= 0) {
        return void util.target.setSize(util.stackFrame.crtScale - util.stackFrame.absPercent);
      }

      util.yield();
    }
  }
  /**
   * 自定义  缩放重置函数
   * @param {*} args
   * @param {*} util
   */


  zoomReset(args, util) {
    util.target.setSize(100);
  }
  /** KID-PRO 指令 实现 */


  say(args, util) {
    // @TODO in 2.0 calling say/think resets the right/left bias of the bubble
    this.runtime.emit(KidLooksBlocks.SAY_OR_THINK, util.target, "say", args.MESSAGE);
  }

  sayforsecs(args, util) {
    this.say(args, util);
    const target = util.target;

    const usageId = this._getBubbleState(target).usageId;

    return new Promise(resolve => {
      this._bubbleTimeout = setTimeout(() => {
        this._bubbleTimeout = null; // Clear say bubble if it hasn't been changed and proceed.

        if (this._getBubbleState(target).usageId === usageId) {
          this._updateBubble(target, "say", "");
        }

        resolve();
      }, 1000 * args.SECS);
    });
  }

  think(args, util) {
    this.runtime.emit(KidLooksBlocks.SAY_OR_THINK, util.target, "think", args.MESSAGE);
  }

  thinkforsecs(args, util) {
    this.think(args, util);
    const target = util.target;

    const usageId = this._getBubbleState(target).usageId;

    return new Promise(resolve => {
      this._bubbleTimeout = setTimeout(() => {
        this._bubbleTimeout = null; // Clear think bubble if it hasn't been changed and proceed.

        if (this._getBubbleState(target).usageId === usageId) {
          this._updateBubble(target, "think", "");
        }

        resolve();
      }, 1000 * args.SECS);
    });
  }

  show(args, util) {
    util.target.setVisible(true);

    this._renderBubble(util.target);
  }

  hide(args, util) {
    util.target.setVisible(false);

    this._renderBubble(util.target);
  }
  /**
   * Utility function to set the costume of a target.
   * Matches the behavior of Scratch 2.0 for different types of arguments.
   * @param {!Target} target Target to set costume to.
   * @param {Any} requestedCostume Costume requested, e.g., 0, 'name', etc.
   * @param {boolean=} optZeroIndex Set to zero-index the requestedCostume.
   * @return {Array.<!Thread>} Any threads started by this switch.
   */


  _setCostume(target, requestedCostume, optZeroIndex) {
    if (typeof requestedCostume === "number") {
      // Numbers should be treated as costume indices, always
      target.setCostume(optZeroIndex ? requestedCostume : requestedCostume - 1);
    } else {
      // Strings should be treated as costume names, where possible
      const costumeIndex = target.getCostumeIndexByName(requestedCostume.toString());

      if (costumeIndex !== -1) {
        target.setCostume(costumeIndex);
      } else if (requestedCostume === "next costume") {
        target.setCostume(target.currentCostume + 1);
      } else if (requestedCostume === "previous costume") {
        target.setCostume(target.currentCostume - 1); // Try to cast the string to a number (and treat it as a costume index)
        // Pure whitespace should not be treated as a number
        // Note: isNaN will cast the string to a number before checking if it's NaN
      } else if (!(isNaN(requestedCostume) || Utility.isWhiteSpace(requestedCostume))) {
        target.setCostume(optZeroIndex ? Number(requestedCostume) : Number(requestedCostume) - 1);
      }
    } // Per 2.0, 'switch costume' can't start threads even in the Stage.


    return [];
  }
  /**
   * Utility function to set the backdrop of a target.
   * Matches the behavior of Scratch 2.0 for different types of arguments.
   * @param {!Target} stage Target to set backdrop to.
   * @param {Any} requestedBackdrop Backdrop requested, e.g., 0, 'name', etc.
   * @param {boolean=} optZeroIndex Set to zero-index the requestedBackdrop.
   * @return {Array.<!Thread>} Any threads started by this switch.
   */


  _setBackdrop(stage, requestedBackdrop, optZeroIndex) {
    if (typeof requestedBackdrop === "number") {
      // Numbers should be treated as backdrop indices, always
      stage.setCostume(optZeroIndex ? requestedBackdrop : requestedBackdrop - 1);
    } else {
      // Strings should be treated as backdrop names where possible
      const costumeIndex = stage.getCostumeIndexByName(requestedBackdrop.toString());

      if (costumeIndex !== -1) {
        stage.setCostume(costumeIndex);
      } else if (requestedBackdrop === "next backdrop") {
        stage.setCostume(stage.currentCostume + 1);
      } else if (requestedBackdrop === "previous backdrop") {
        stage.setCostume(stage.currentCostume - 1);
      } else if (requestedBackdrop === "random backdrop") {
        const numCostumes = stage.getCostumes().length;

        if (numCostumes > 1) {
          // Don't pick the current backdrop, so that the block
          // will always have an observable effect.
          const lowerBound = 0;
          const upperBound = numCostumes - 1;
          const costumeToExclude = stage.currentCostume;
          const nextCostume = Utility.inclusiveRandIntWithout(lowerBound, upperBound, costumeToExclude);
          stage.setCostume(nextCostume);
        } // Try to cast the string to a number (and treat it as a costume index)
        // Pure whitespace should not be treated as a number
        // Note: isNaN will cast the string to a number before checking if it's NaN

      } else if (!(isNaN(requestedBackdrop) || Utility.isWhiteSpace(requestedBackdrop))) {
        stage.setCostume(optZeroIndex ? Number(requestedBackdrop) : Number(requestedBackdrop) - 1);
      }
    }

    const newName = stage.getCostumes()[stage.currentCostume].name;
    return this.runtime.startHats("event_whenbackdropswitchesto", {
      BACKDROP: newName
    });
  }

  switchCostume(args, util) {
    this._setCostume(util.target, args.COSTUME);
  }

  nextCostume(args, util) {
    this._setCostume(util.target, util.target.currentCostume + 1, true);
  }

  switchBackdrop(args) {
    this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);
  }

  switchBackdropAndWait(args, util) {
    // Have we run before, starting threads?
    if (!util.stackFrame.startedThreads) {
      // No - switch the backdrop.
      util.stackFrame.startedThreads = this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);

      if (util.stackFrame.startedThreads.length === 0) {
        // Nothing was started.
        return;
      }
    } // We've run before; check if the wait is still going on.


    const instance = this; // Scratch 2 considers threads to be waiting if they are still in
    // runtime.threads. Threads that have run all their blocks, or are
    // marked done but still in runtime.threads are still considered to
    // be waiting.

    const waiting = util.stackFrame.startedThreads.some(thread => instance.runtime.threads.indexOf(thread) !== -1);

    if (waiting) {
      // If all threads are waiting for the next tick or later yield
      // for a tick as well. Otherwise yield until the next loop of
      // the threads.
      if (util.stackFrame.startedThreads.every(thread => instance.runtime.isWaitingThread(thread))) {
        util.yieldTick();
      } else {
        util.yield();
      }
    }
  }

  nextBackdrop() {
    const stage = this.runtime.getTargetForStage();

    this._setBackdrop(stage, stage.currentCostume + 1, true);
  }

  clampEffect(effect, value) {
    let clampedValue = value;

    switch (effect) {
      case "ghost":
        clampedValue = Utility.clamp(value, KidLooksBlocks.EFFECT_GHOST_LIMIT.min, KidLooksBlocks.EFFECT_GHOST_LIMIT.max);
        break;

      case "brightness":
        clampedValue = Utility.clamp(value, KidLooksBlocks.EFFECT_BRIGHTNESS_LIMIT.min, KidLooksBlocks.EFFECT_BRIGHTNESS_LIMIT.max);
        break;
    }

    return clampedValue;
  }

  changeEffect(args, util) {
    const effect = String(args.EFFECT).toLowerCase();
    const change = Utility.toNumber(args.CHANGE);
    if (!util.target.effects.hasOwnProperty(effect)) return;
    let newValue = change + util.target.effects[effect];
    newValue = this.clampEffect(effect, newValue);
    util.target.setEffect(effect, newValue);
  }

  setEffect(args, util) {
    const effect = String(args.EFFECT).toLowerCase();
    let value = Utility.toNumber(args.VALUE);
    value = this.clampEffect(effect, value);
    util.target.setEffect(effect, value);
  }

  clearEffects(args, util) {
    util.target.clearEffects();
  }

  changeSize(args, util) {
    const change = Utility.toNumber(args.CHANGE);
    util.target.setSize(util.target.size + change);
  }

  setSize(args, util) {
    const size = Utility.toNumber(args.SIZE);
    util.target.setSize(size);
  }

  goToFrontBack(args, util) {
    if (!util.target.isStage) {
      if (args.FRONT_BACK === "front") {
        util.target.goToFront();
      } else {
        util.target.goToBack();
      }
    }
  }

  goForwardBackwardLayers(args, util) {
    if (!util.target.isStage) {
      if (args.FORWARD_BACKWARD === "forward") {
        util.target.goForwardLayers(Utility.toNumber(args.NUM));
      } else {
        util.target.goBackwardLayers(Utility.toNumber(args.NUM));
      }
    }
  }

  getSize(args, util) {
    return Math.round(util.target.size);
  }

  getBackdropNumberName(args) {
    const stage = this.runtime.getTargetForStage();

    if (args.NUMBER_NAME === "number") {
      return stage.currentCostume + 1;
    } // Else return name


    return stage.getCostumes()[stage.currentCostume].name;
  }

  getCostumeNumberName(args, util) {
    if (args.NUMBER_NAME === "number") {
      return util.target.currentCostume + 1;
    } // Else return name


    return util.target.getCostumes()[util.target.currentCostume].name;
  }

}
/** @module 运动分类 */


class KidMotionBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      /** 测试 Blockly指令 */
      // colour_picker: this.colourPicker,

      /** KID-JR 专属指令 */
      motion_moveleft: this.moveLeft,
      // 左移
      motion_moveright: this.moveRight,
      // 右移
      motion_moveup: this.moveUp,
      // 上移
      motion_movedown: this.moveDown,
      // 下移
      motion_jump: this.moveJump,
      // 跳跃
      motion_movereset: this.moveReset,
      // 位置重置

      /** KID-PRO 指令 */
      motion_movesteps: this.moveSteps,
      motion_gotoxy: this.goToXY,
      motion_goto: this.goTo,
      motion_turnright: this.turnRight,
      motion_turnleft: this.turnLeft,
      motion_pointindirection: this.pointInDirection,
      motion_pointtowards: this.pointTowards,
      motion_glidesecstoxy: this.glide,
      motion_glideto: this.glideTo,
      motion_ifonedgebounce: this.ifOnEdgeBounce,
      motion_setrotationstyle: this.setRotationStyle,
      motion_changexby: this.changeX,
      motion_setx: this.setX,
      motion_changeyby: this.changeY,
      motion_sety: this.setY,
      motion_xposition: this.getX,
      motion_yposition: this.getY,
      motion_direction: this.getDirection,
      // Legacy no-op blocks:
      motion_scroll_right: () => {},
      motion_scroll_up: () => {},
      motion_align_scene: () => {},
      motion_xscroll: () => {},
      motion_yscroll: () => {}
    };
  }

  getMonitored() {
    return {
      motion_xposition: {
        isSpriteSpecific: true,
        getId: targetId => `${targetId}_xposition`
      },
      motion_yposition: {
        isSpriteSpecific: true,
        getId: targetId => `${targetId}_yposition`
      },
      motion_direction: {
        isSpriteSpecific: true,
        getId: targetId => `${targetId}_direction`
      }
    };
  } // /** 测试 Blockly 积木实现 vm驱动 */
  // colourPicker(args) {
  //   console.log("测试 Blockly积木实现 vm驱动:", args);
  // }

  /** KID-JR 专属指令 实现 */

  /**
   * 自定义  左移函数
   * @param {*} args 对象中属性 STEPS: "10"
   * @param {*} util
   */


  moveLeft(args, util) {
    console.log("左移积木块，新增速度值:", args); // args.STEPS的字符串值转换为数字类型

    const steps = Utility.toNumber(args.STEPS); // 角度值转弧度值

    const radians = Utility.degToRad(-90 - util.target.direction); // 返回一个数值的余弦值

    const dx = steps * Math.cos(radians) * 10; // 返回一个数值的正弦值

    const dy = steps * Math.sin(radians) * 10; // 原本使用输入值/5/输入的速度值。现在扩展一个速度的输入值 2020.09.18。

    const secs = steps / 5 / Utility.toNumber(args.SECS); // 此处 x轴计算时，使用减法，即向左移动
    // util.target.setXY(util.target.x - dx, util.target.y + dy);

    this.glide({
      SECS: secs,
      X: util.target.x + dx,
      Y: util.target.y + dy
    }, util);
  }
  /**
   * 自定义  右移函数
   * @param {*} args
   * @param {*} util
   */


  moveRight(args, util) {
    const steps = Utility.toNumber(args.STEPS);
    const radians = Utility.degToRad(90 - util.target.direction);
    const dx = steps * Math.cos(radians) * 10;
    const dy = steps * Math.sin(radians) * 10; // 原本使用输入值/5/输入的速度值。现在扩展一个速度的输入值 2020.09.22。

    const secs = steps / 5 / Utility.toNumber(args.SECS); // util.target.setXY(util.target.x + dx, util.target.y + dy);

    this.glide({
      SECS: secs,
      X: util.target.x + dx,
      Y: util.target.y + dy
    }, util);
  }
  /**
   * 自定义  上移函数
   * @param {*} args
   * @param {*} util
   */


  moveUp(args, util) {
    const steps = Utility.toNumber(args.STEPS);
    const radians = Utility.degToRad(180 - util.target.direction);
    const dx = steps * Math.cos(radians) * 10;
    const dy = steps * Math.sin(radians) * 10; // 原本使用输入值/5/输入的速度值。现在扩展一个速度的输入值 2020.09.22。

    const secs = steps / 5 / Utility.toNumber(args.SECS);
    this.glide({
      SECS: secs,
      X: util.target.x + dx,
      Y: util.target.y + dy
    }, util);
  }
  /**
   * 自定义  下移函数
   * @param {*} args
   * @param {*} util
   */


  moveDown(args, util) {
    const steps = Utility.toNumber(args.STEPS);
    const radians = Utility.degToRad(0 - util.target.direction);
    const dx = steps * Math.cos(radians) * 10;
    const dy = steps * Math.sin(radians) * 10; // util.target.setXY(util.target.x + dx, util.target.y + dy);
    // 原本使用输入值/5/输入的速度值。现在扩展一个速度的输入值 2020.09.22。

    const secs = steps / 5 / Utility.toNumber(args.SECS);
    this.glide({
      SECS: secs,
      X: util.target.x + dx,
      Y: util.target.y + dy
    }, util);
  }
  /**
   * 自定义  跳跃函数
   * @param {*} args
   * @param {*} util
   */


  moveJump(args, util) {
    const steps = Utility.toNumber(args.HEIGHT);
    const radians = Utility.degToRad(0 - util.target.direction);
    const dx = steps * Math.cos(radians) * 10;
    const dy = steps * Math.sin(radians) * 10; // eslint-disable-next-line no-console
    // this.glide({SECS: '1', X: util.target.x + dx, Y: util.target.y + dy}, util);

    const endX = util.target.x + dx;
    const endY = util.target.y + dy; // 原本使用输入值/5/输入的速度值。现在扩展一个速度的输入值 2020.09.22。

    const SECS = steps / 5 / Utility.toNumber(args.SECS);

    if (util.stackFrame.timer) {
      const timeElapsed = util.stackFrame.timer.timeElapsed();

      if (timeElapsed < util.stackFrame.duration * 500) {
        // 进行中：移至中间位置.
        const frac = timeElapsed / (util.stackFrame.duration * 500);
        const tmpdx = frac * (util.stackFrame.endX - util.stackFrame.startX);
        const tmpdy = frac * (util.stackFrame.endY - util.stackFrame.startY);
        util.target.setXY(util.stackFrame.startX - tmpdx, util.stackFrame.startY - tmpdy);
        util.yield();
      } else if (timeElapsed < util.stackFrame.duration * 1000 && timeElapsed > util.stackFrame.duration * 500) {
        const frac1 = (timeElapsed - util.stackFrame.duration * 500) / (util.stackFrame.duration * 500);
        const tmpdx1 = (1 - frac1) * (util.stackFrame.endX - util.stackFrame.startX);
        const tmpdy1 = (1 - frac1) * (util.stackFrame.endY - util.stackFrame.startY);
        util.target.setXY(util.stackFrame.startX - tmpdx1, util.stackFrame.startY - tmpdy1);
        util.yield();
      } else {
        // 完成：移至最终位置.
        util.target.setXY(util.stackFrame.startX, util.stackFrame.startY);
      }
    } else {
      // 第一次：保存数据以备将来使用.
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();
      util.stackFrame.duration = Utility.toNumber(SECS);
      util.stackFrame.startX = util.target.x;
      util.stackFrame.startY = util.target.y;
      util.stackFrame.endX = Utility.toNumber(endX);
      util.stackFrame.endY = Utility.toNumber(endY);

      if (util.stackFrame.duration <= 0) {
        // 持续时间太短，无法滑行.
        util.target.setXY(util.stackFrame.startX, util.stackFrame.startY);
        return;
      }

      util.yield();
    }
  }
  /**
   * 自定义 位置重置函数,方向亦重置
   * @param {*} args
   * @param {*} util
   */


  moveReset(args, util) {
    util.target.setXY(0, 0); // 角色坐标设置为0,0

    util.target.setDirection(90); // 角色方向设置为正向
  }
  /** KID-PRO 指令 实现 */


  moveSteps(args, util) {
    console.log("pro移动指定步:", args, util);
    const steps = Utility.toNumber(args.STEPS);
    const radians = Utility.degToRad(90 - util.target.direction);
    const dx = steps * Math.cos(radians);
    const dy = steps * Math.sin(radians);
    util.target.setXY(util.target.x + dx, util.target.y + dy);
  }

  goToXY(args, util) {
    const x = Utility.toNumber(args.X);
    const y = Utility.toNumber(args.Y);
    util.target.setXY(x, y);
  }

  getTargetXY(targetName, util) {
    let targetX = 0;
    let targetY = 0;

    if (targetName === "_mouse_") {
      targetX = util.ioQuery("mouse", "getScratchX");
      targetY = util.ioQuery("mouse", "getScratchY");
    } else if (targetName === "_random_") {
      const stageWidth = this.runtime.constructor.STAGE_WIDTH;
      const stageHeight = this.runtime.constructor.STAGE_HEIGHT;
      targetX = Math.round(stageWidth * (Math.random() - 0.5));
      targetY = Math.round(stageHeight * (Math.random() - 0.5));
    } else {
      targetName = String(targetName);
      const goToTarget = this.runtime.getSpriteTargetByName(targetName);
      if (!goToTarget) return;
      targetX = goToTarget.x;
      targetY = goToTarget.y;
    }

    return [targetX, targetY];
  }

  goTo(args, util) {
    const targetXY = this.getTargetXY(args.TO, util);

    if (targetXY) {
      util.target.setXY(targetXY[0], targetXY[1]);
    }
  }

  turnRight(args, util) {
    const degrees = Utility.toNumber(args.DEGREES);
    util.target.setDirection(util.target.direction + degrees);
  }

  turnLeft(args, util) {
    const degrees = Utility.toNumber(args.DEGREES);
    util.target.setDirection(util.target.direction - degrees);
  }

  pointInDirection(args, util) {
    console.log("pro面向:", args, util);
    const direction = Utility.toNumber(args.DIRECTION);
    util.target.setDirection(direction);
  }

  pointTowards(args, util) {
    let targetX = 0;
    let targetY = 0;

    if (args.TOWARDS === "_mouse_") {
      targetX = util.ioQuery("mouse", "getScratchX");
      targetY = util.ioQuery("mouse", "getScratchY");
    } else if (args.TOWARDS === "_random_") {
      util.target.setDirection(Math.round(Math.random() * 360) - 180);
      return;
    } else {
      args.TOWARDS = String(args.TOWARDS);
      const pointTarget = this.runtime.getSpriteTargetByName(args.TOWARDS);
      if (!pointTarget) return;
      targetX = pointTarget.x;
      targetY = pointTarget.y;
    }

    const dx = targetX - util.target.x;
    const dy = targetY - util.target.y;
    const direction = 90 - Utility.radToDeg(Math.atan2(dy, dx));
    util.target.setDirection(direction);
  }

  glide(args, util) {
    if (util.stackFrame.timer) {
      const timeElapsed = util.stackFrame.timer.timeElapsed();

      if (timeElapsed < util.stackFrame.duration * 1000) {
        // In progress: move to intermediate position.
        const frac = timeElapsed / (util.stackFrame.duration * 1000);
        const dx = frac * (util.stackFrame.endX - util.stackFrame.startX);
        const dy = frac * (util.stackFrame.endY - util.stackFrame.startY);
        util.target.setXY(util.stackFrame.startX + dx, util.stackFrame.startY + dy);
        util.yield();
      } else {
        // Finished: move to final position.
        util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
      }
    } else {
      // First time: save data for future use.
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();
      util.stackFrame.duration = Utility.toNumber(args.SECS);
      util.stackFrame.startX = util.target.x;
      util.stackFrame.startY = util.target.y;
      util.stackFrame.endX = Utility.toNumber(args.X);
      util.stackFrame.endY = Utility.toNumber(args.Y);

      if (util.stackFrame.duration <= 0) {
        // Duration too short to glide.
        util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
        return;
      }

      util.yield();
    }
  }

  glideTo(args, util) {
    const targetXY = this.getTargetXY(args.TO, util);

    if (targetXY) {
      this.glide({
        SECS: args.SECS,
        X: targetXY[0],
        Y: targetXY[1]
      }, util);
    }
  }

  ifOnEdgeBounce(args, util) {
    const bounds = util.target.getBounds();

    if (!bounds) {
      return;
    } // Measure distance to edges.
    // Values are positive when the sprite is far away,
    // and clamped to zero when the sprite is beyond.


    const stageWidth = this.runtime.constructor.STAGE_WIDTH;
    const stageHeight = this.runtime.constructor.STAGE_HEIGHT;
    const distLeft = Math.max(0, stageWidth / 2 + bounds.left);
    const distTop = Math.max(0, stageHeight / 2 - bounds.top);
    const distRight = Math.max(0, stageWidth / 2 - bounds.right);
    const distBottom = Math.max(0, stageHeight / 2 + bounds.bottom); // Find the nearest edge.

    let nearestEdge = "";
    let minDist = Infinity;

    if (distLeft < minDist) {
      minDist = distLeft;
      nearestEdge = "left";
    }

    if (distTop < minDist) {
      minDist = distTop;
      nearestEdge = "top";
    }

    if (distRight < minDist) {
      minDist = distRight;
      nearestEdge = "right";
    }

    if (distBottom < minDist) {
      minDist = distBottom;
      nearestEdge = "bottom";
    }

    if (minDist > 0) {
      return; // Not touching any edge.
    } // Point away from the nearest edge.


    const radians = Utility.degToRad(90 - util.target.direction);
    let dx = Math.cos(radians);
    let dy = -Math.sin(radians);

    if (nearestEdge === "left") {
      dx = Math.max(0.2, Math.abs(dx));
    } else if (nearestEdge === "top") {
      dy = Math.max(0.2, Math.abs(dy));
    } else if (nearestEdge === "right") {
      dx = 0 - Math.max(0.2, Math.abs(dx));
    } else if (nearestEdge === "bottom") {
      dy = 0 - Math.max(0.2, Math.abs(dy));
    }

    const newDirection = Utility.radToDeg(Math.atan2(dy, dx)) + 90;
    util.target.setDirection(newDirection); // Keep within the stage.

    const fencedPosition = util.target.keepInFence(util.target.x, util.target.y);
    util.target.setXY(fencedPosition[0], fencedPosition[1]);
  }

  setRotationStyle(args, util) {
    util.target.setRotationStyle(args.STYLE);
  }

  changeX(args, util) {
    const dx = Utility.toNumber(args.DX);
    util.target.setXY(util.target.x + dx, util.target.y);
  }

  setX(args, util) {
    const x = Utility.toNumber(args.X);
    util.target.setXY(x, util.target.y);
  }

  changeY(args, util) {
    const dy = Utility.toNumber(args.DY);
    util.target.setXY(util.target.x, util.target.y + dy);
  }

  setY(args, util) {
    const y = Utility.toNumber(args.Y);
    util.target.setXY(util.target.x, y);
  }

  getX(args, util) {
    console.log("getX args:", args, util);
    return this.limitPrecision(util.target.x);
  }

  getY(args, util) {
    return this.limitPrecision(util.target.y);
  }

  getDirection(args, util) {
    return util.target.direction;
  } // 这对应于Scratch 2中的snapToInteger


  limitPrecision(coordinate) {
    const rounded = Math.round(coordinate);
    const delta = coordinate - rounded;
    const limitedCoord = Math.abs(delta) < 1e-9 ? rounded : coordinate;
    return limitedCoord;
  }

}
/** @module 运算分类 */


class KidOperatorsBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      operator_add: this.add,
      operator_subtract: this.subtract,
      operator_multiply: this.multiply,
      operator_divide: this.divide,
      operator_lt: this.lt,
      operator_equals: this.equals,
      operator_gt: this.gt,
      operator_and: this.and,
      operator_or: this.or,
      operator_not: this.not,
      operator_random: this.random,
      operator_join: this.join,
      operator_letter_of: this.letterOf,
      operator_length: this.length,
      operator_contains: this.contains,
      operator_mod: this.mod,
      operator_round: this.round,
      operator_mathop: this.mathop
    };
  }

  add(args) {
    return Utility.toNumber(args.NUM1) + Utility.toNumber(args.NUM2);
  }

  subtract(args) {
    return Utility.toNumber(args.NUM1) - Utility.toNumber(args.NUM2);
  }

  multiply(args) {
    return Utility.toNumber(args.NUM1) * Utility.toNumber(args.NUM2);
  }

  divide(args) {
    return Utility.toNumber(args.NUM1) / Utility.toNumber(args.NUM2);
  }

  lt(args) {
    return Utility.compare(args.OPERAND1, args.OPERAND2) < 0;
  }

  equals(args) {
    return Utility.compare(args.OPERAND1, args.OPERAND2) === 0;
  }

  gt(args) {
    return Utility.compare(args.OPERAND1, args.OPERAND2) > 0;
  }

  and(args) {
    return Utility.toBoolean(args.OPERAND1) && Utility.toBoolean(args.OPERAND2);
  }

  or(args) {
    return Utility.toBoolean(args.OPERAND1) || Utility.toBoolean(args.OPERAND2);
  }

  not(args) {
    return !Utility.toBoolean(args.OPERAND);
  }

  random(args) {
    const nFrom = Utility.toNumber(args.FROM);
    const nTo = Utility.toNumber(args.TO);
    const low = nFrom <= nTo ? nFrom : nTo;
    const high = nFrom <= nTo ? nTo : nFrom;
    if (low === high) return low; // If both arguments are ints, truncate the result to an int.

    if (Utility.isInt(args.FROM) && Utility.isInt(args.TO)) {
      return low + Math.floor(Math.random() * (high + 1 - low));
    }

    return Math.random() * (high - low) + low;
  }

  join(args) {
    returnString(args.STRING1) + String(args.STRING2);
  }

  letterOf(args) {
    const index = Utility.toNumber(args.LETTER) - 1;
    const str = String(args.STRING); // Out of bounds?

    if (index < 0 || index >= str.length) {
      return "";
    }

    return str.charAt(index);
  }

  length(args) {
    return String(args.STRING).length;
  }

  contains(args) {
    const format = function (string) {
      return String(string).toLowerCase();
    };

    return format(args.STRING1).includes(format(args.STRING2));
  }

  mod(args) {
    const n = Utility.toNumber(args.NUM1);
    const modulus = Utility.toNumber(args.NUM2);
    let result = n % modulus; // Scratch mod uses floored division instead of truncated division.

    if (result / modulus < 0) result += modulus;
    return result;
  }

  round(args) {
    return Math.round(Utility.toNumber(args.NUM));
  }

  mathop(args) {
    const operator = String(args.OPERATOR).toLowerCase();
    const n = Utility.toNumber(args.NUM);

    switch (operator) {
      case "abs":
        return Math.abs(n);

      case "floor":
        return Math.floor(n);

      case "ceiling":
        return Math.ceil(n);

      case "sqrt":
        return Math.sqrt(n);

      case "sin":
        return parseFloat(Math.sin(Math.PI * n / 180).toFixed(10));

      case "cos":
        return parseFloat(Math.cos(Math.PI * n / 180).toFixed(10));

      case "tan":
        return Utility.tan(n);

      case "asin":
        return Math.asin(n) * 180 / Math.PI;

      case "acos":
        return Math.acos(n) * 180 / Math.PI;

      case "atan":
        return Math.atan(n) * 180 / Math.PI;

      case "ln":
        return Math.log(n);

      case "log":
        return Math.log(n) / Math.LN10;

      case "e ^":
        return Math.exp(n);

      case "10 ^":
        return Math.pow(10, n);
    }

    return 0;
  }

}
/**
 * Occluded boolean value to make its use more understandable.
 * @const {boolean}
 */


const STORE_WAITING = true;

class KidSoundBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this.waitingSounds = {}; // Clear sound effects on green flag and stop button events.

    this.stopAllSounds = this.stopAllSounds.bind(this);
    this._stopWaitingSoundsForTarget = this._stopWaitingSoundsForTarget.bind(this);
    this._clearEffectsForAllTargets = this._clearEffectsForAllTargets.bind(this);

    if (this.runtime) {
      this.runtime.on("PROJECT_STOP_ALL", this.stopAllSounds);
      this.runtime.on("PROJECT_STOP_ALL", this._clearEffectsForAllTargets);
      this.runtime.on("STOP_FOR_TARGET", this._stopWaitingSoundsForTarget);
      this.runtime.on("PROJECT_START", this._clearEffectsForAllTargets);
    }

    this._onTargetCreated = this._onTargetCreated.bind(this);

    if (this.runtime) {
      runtime.on("targetWasCreated", this._onTargetCreated);
    }
  }
  /**
   * The key to load & store a target's sound-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.sound";
  }
  /**
   * The default sound-related state, to be used when a target has no existing sound state.
   * @type {SoundState}
   */


  static get DEFAULT_SOUND_STATE() {
    return {
      effects: {
        pitch: 0,
        pan: 0
      }
    };
  }
  /**
   * The minimum and maximum MIDI note numbers, for clamping the input to play note.
   * @type {{min: number, max: number}}
   */


  static get MIDI_NOTE_RANGE() {
    return {
      min: 36,
      max: 96
    }; // C2 to C7
  }
  /**
   * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
   * 100 beats at the default tempo of 60bpm is 100 seconds.
   * @type {{min: number, max: number}}
   */


  static get BEAT_RANGE() {
    return {
      min: 0,
      max: 100
    };
  }
  /** The minimum and maximum tempo values, in bpm.
   * @type {{min: number, max: number}}
   */


  static get TEMPO_RANGE() {
    return {
      min: 20,
      max: 500
    };
  }
  /** The minimum and maximum values for each sound effect.
   * @type {{effect:{min: number, max: number}}}
   */


  static get EFFECT_RANGE() {
    return {
      pitch: {
        min: -360,
        max: 360
      },
      // -3 to 3 octaves
      pan: {
        min: -100,
        max: 100
      } // 100% left to 100% right

    };
  }
  /**
   * @param {Target} target - collect sound state for this target.
   * @returns {SoundState} the mutable sound state associated with that target. This will be created if necessary.
   * @private
   */


  _getSoundState(target) {
    let soundState = target.getCustomState(KidSoundBlocks.STATE_KEY);

    if (!soundState) {
      soundState = Utility.cloneSimple(KidSoundBlocks.DEFAULT_SOUND_STATE);
      target.setCustomState(KidSoundBlocks.STATE_KEY, soundState);
      target.soundEffects = soundState.effects;
    }

    return soundState;
  }
  /**
   * When a Target is cloned, clone the sound state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const soundState = sourceTarget.getCustomState(KidSoundBlocks.STATE_KEY);

      if (soundState && newTarget) {
        newTarget.setCustomState(KidSoundBlocks.STATE_KEY, Utility.cloneSimple(soundState));

        this._syncEffectsForTarget(newTarget);
      }
    }
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      sound_play: this.playSound,
      sound_playuntildone: this.playSoundAndWait,
      sound_stopallsounds: this.stopAllSounds,
      sound_seteffectto: this.setEffect,
      sound_changeeffectby: this.changeEffect,
      sound_cleareffects: this.clearEffects,
      sound_sounds_menu: this.soundsMenu,
      sound_beats_menu: this.beatsMenu,
      sound_effects_menu: this.effectsMenu,
      sound_setvolumeto: this.setVolume,
      sound_changevolumeby: this.changeVolume,
      sound_volume: this.getVolume
    };
  }

  getMonitored() {
    return {
      sound_volume: {
        isSpriteSpecific: true,
        getId: targetId => `${targetId}_volume`
      }
    };
  }

  playSound(args, util) {
    // Don't return the promise, it's the only difference for AndWait
    this._playSound(args, util);
  }

  playSoundAndWait(args, util) {
    return this._playSound(args, util, STORE_WAITING);
  }

  _playSound(args, util, storeWaiting) {
    const index = this._getSoundIndex(args.SOUND_MENU, util);

    if (index >= 0) {
      const {
        target
      } = util;
      const {
        sprite
      } = target;
      const {
        soundId
      } = sprite.sounds[index];

      if (sprite.soundBank) {
        if (storeWaiting === STORE_WAITING) {
          this._addWaitingSound(target.id, soundId);
        } else {
          this._removeWaitingSound(target.id, soundId);
        }

        return sprite.soundBank.playSound(target, soundId);
      }
    }
  }

  _addWaitingSound(targetId, soundId) {
    if (!this.waitingSounds[targetId]) {
      this.waitingSounds[targetId] = new Set();
    }

    this.waitingSounds[targetId].add(soundId);
  }

  _removeWaitingSound(targetId, soundId) {
    if (!this.waitingSounds[targetId]) {
      return;
    }

    this.waitingSounds[targetId].delete(soundId);
  }

  _getSoundIndex(soundName, util) {
    // if the sprite has no sounds, return -1
    const len = util.target.sprite.sounds.length;

    if (len === 0) {
      return -1;
    } // look up by name first


    const index = this.getSoundIndexByName(soundName, util);

    if (index !== -1) {
      return index;
    } // then try using the sound name as a 1-indexed index


    const oneIndexedIndex = parseInt(soundName, 10);

    if (!isNaN(oneIndexedIndex)) {
      return Utility.wrapClamp(oneIndexedIndex - 1, 0, len - 1);
    } // could not be found as a name or converted to index, return -1


    return -1;
  }

  getSoundIndexByName(soundName, util) {
    const sounds = util.target.sprite.sounds;

    for (let i = 0; i < sounds.length; i++) {
      if (sounds[i].name === soundName) {
        return i;
      }
    } // if there is no sound by that name, return -1


    return -1;
  }

  stopAllSounds() {
    if (this.runtime.targets === null) return;
    const allTargets = this.runtime.targets;

    for (let i = 0; i < allTargets.length; i++) {
      this._stopAllSoundsForTarget(allTargets[i]);
    }
  }

  _stopAllSoundsForTarget(target) {
    if (target.sprite.soundBank) {
      target.sprite.soundBank.stopAllSounds(target);

      if (this.waitingSounds[target.id]) {
        this.waitingSounds[target.id].clear();
      }
    }
  }

  _stopWaitingSoundsForTarget(target) {
    if (target.sprite.soundBank) {
      if (this.waitingSounds[target.id]) {
        for (const soundId of this.waitingSounds[target.id].values()) {
          target.sprite.soundBank.stop(target, soundId);
        }

        this.waitingSounds[target.id].clear();
      }
    }
  }

  setEffect(args, util) {
    return this._updateEffect(args, util, false);
  }

  changeEffect(args, util) {
    return this._updateEffect(args, util, true);
  }

  _updateEffect(args, util, change) {
    const effect = String(args.EFFECT).toLowerCase();
    const value = Utility.toNumber(args.VALUE);

    const soundState = this._getSoundState(util.target);

    if (!soundState.effects.hasOwnProperty(effect)) return;

    if (change) {
      soundState.effects[effect] += value;
    } else {
      soundState.effects[effect] = value;
    }

    const {
      min,
      max
    } = KidSoundBlocks.EFFECT_RANGE[effect];
    soundState.effects[effect] = Utility.clamp(soundState.effects[effect], min, max);

    this._syncEffectsForTarget(util.target); // Yield until the next tick.


    return Promise.resolve();
  }

  _syncEffectsForTarget(target) {
    if (!target || !target.sprite.soundBank) return;
    target.soundEffects = this._getSoundState(target).effects;
    target.sprite.soundBank.setEffects(target);
  }

  clearEffects(args, util) {
    this._clearEffectsForTarget(util.target);
  }

  _clearEffectsForTarget(target) {
    const soundState = this._getSoundState(target);

    for (const effect in soundState.effects) {
      if (!soundState.effects.hasOwnProperty(effect)) continue;
      soundState.effects[effect] = 0;
    }

    this._syncEffectsForTarget(target);
  }

  _clearEffectsForAllTargets() {
    if (this.runtime.targets === null) return;
    const allTargets = this.runtime.targets;

    for (let i = 0; i < allTargets.length; i++) {
      this._clearEffectsForTarget(allTargets[i]);
    }
  }

  setVolume(args, util) {
    const volume = Utility.toNumber(args.VOLUME);
    return this._updateVolume(volume, util);
  }

  changeVolume(args, util) {
    const volume = Utility.toNumber(args.VOLUME) + util.target.volume;
    return this._updateVolume(volume, util);
  }

  _updateVolume(volume, util) {
    volume = Utility.clamp(volume, 0, 100);
    util.target.volume = volume;

    this._syncEffectsForTarget(util.target); // Yield until the next tick.


    return Promise.resolve();
  }

  getVolume(args, util) {
    return util.target.volume;
  }

  soundsMenu(args) {
    return args.SOUND_MENU;
  }

  beatsMenu(args) {
    return args.BEATS;
  }

  effectsMenu(args) {
    return args.EFFECT;
  }

}

class KidSensingBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The "answer" block value.
     * @type {string}
     */

    this._answer = "";
    /**
     * The timer utility.
     * @type {Timer}
     */

    this._timer = new Timer();
    /**
     * The stored microphone loudness measurement.
     * @type {number}
     */

    this._cachedLoudness = -1;
    /**
     * The time of the most recent microphone loudness measurement.
     * @type {number}
     */

    this._cachedLoudnessTimestamp = 0;
    /**
     * The list of queued questions and respective `resolve` callbacks.
     * @type {!Array}
     */

    this._questionList = [];
    this.runtime.on("ANSWER", this._onAnswer.bind(this));
    this.runtime.on("PROJECT_START", this._resetAnswer.bind(this));
    this.runtime.on("PROJECT_STOP_ALL", this._clearAllQuestions.bind(this));
    this.runtime.on("STOP_FOR_TARGET", this._clearTargetQuestions.bind(this));
    this.runtime.on("RUNTIME_DISPOSED", this._resetAnswer.bind(this));
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      sensing_touchingobject: this.touchingObject,
      sensing_touchingcolor: this.touchingColor,
      sensing_coloristouchingcolor: this.colorTouchingColor,
      sensing_distanceto: this.distanceTo,
      sensing_timer: this.getTimer,
      sensing_resettimer: this.resetTimer,
      sensing_of: this.getAttributeOf,
      sensing_mousex: this.getMouseX,
      sensing_mousey: this.getMouseY,
      sensing_setdragmode: this.setDragMode,
      sensing_mousedown: this.getMouseDown,
      sensing_keypressed: this.getKeyPressed,
      sensing_current: this.current,
      sensing_dayssince2000: this.daysSince2000,
      sensing_loudness: this.getLoudness,
      sensing_loud: this.isLoud,
      sensing_askandwait: this.askAndWait,
      sensing_answer: this.getAnswer,
      sensing_username: this.getUsername,
      sensing_userid: () => {} // legacy no-op block

    };
  }

  getMonitored() {
    return {
      sensing_answer: {
        getId: () => "answer"
      },
      sensing_loudness: {
        getId: () => "loudness"
      },
      sensing_timer: {
        getId: () => "timer"
      },
      sensing_current: {
        // This is different from the default toolbox xml id in order to support
        // importing multiple monitors from the same opcode from sb2 files,
        // something that is not currently supported in scratch 3.
        getId: (_, fields) => Utility.getMonitorIdForBlockWithArgs("current", fields) // _${param}`

      }
    };
  }

  _onAnswer(answer) {
    this._answer = answer;

    const questionObj = this._questionList.shift();

    if (questionObj) {
      const [_question, resolve, target, wasVisible, wasStage] = questionObj; // If the target was visible when asked, hide the say bubble unless the target was the stage.

      if (wasVisible && !wasStage) {
        this.runtime.emit("SAY", target, "say", "");
      }

      resolve();

      this._askNextQuestion();
    }
  }

  _resetAnswer() {
    this._answer = "";
  }

  _enqueueAsk(question, resolve, target, wasVisible, wasStage) {
    this._questionList.push([question, resolve, target, wasVisible, wasStage]);
  }

  _askNextQuestion() {
    if (this._questionList.length > 0) {
      const [question, _resolve, target, wasVisible, wasStage] = this._questionList[0]; // If the target is visible, emit a blank question and use the
      // say event to trigger a bubble unless the target was the stage.

      if (wasVisible && !wasStage) {
        this.runtime.emit("SAY", target, "say", question);
        this.runtime.emit("QUESTION", "");
      } else {
        this.runtime.emit("QUESTION", question);
      }
    }
  }

  _clearAllQuestions() {
    this._questionList = [];
    this.runtime.emit("QUESTION", null);
  }

  _clearTargetQuestions(stopTarget) {
    const currentlyAsking = this._questionList.length > 0 && this._questionList[0][2] === stopTarget;
    this._questionList = this._questionList.filter(question => question[2] !== stopTarget);

    if (currentlyAsking) {
      this.runtime.emit("SAY", stopTarget, "say", "");

      if (this._questionList.length > 0) {
        this._askNextQuestion();
      } else {
        this.runtime.emit("QUESTION", null);
      }
    }
  }

  askAndWait(args, util) {
    const _target = util.target;
    return new Promise(resolve => {
      const isQuestionAsked = this._questionList.length > 0;

      this._enqueueAsk(String(args.QUESTION), resolve, _target, _target.visible, _target.isStage);

      if (!isQuestionAsked) {
        this._askNextQuestion();
      }
    });
  }

  getAnswer() {
    return this._answer;
  }

  touchingObject(args, util) {
    return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);
  }

  touchingColor(args, util) {
    const color = Utility.toRgbColorList(args.COLOR);
    return util.target.isTouchingColor(color);
  }

  colorTouchingColor(args, util) {
    const maskColor = Utility.toRgbColorList(args.COLOR);
    const targetColor = Utility.toRgbColorList(args.COLOR2);
    return util.target.colorIsTouchingColor(targetColor, maskColor);
  }

  distanceTo(args, util) {
    if (util.target.isStage) return 10000;
    let targetX = 0;
    let targetY = 0;

    if (args.DISTANCETOMENU === "_mouse_") {
      targetX = util.ioQuery("mouse", "getScratchX");
      targetY = util.ioQuery("mouse", "getScratchY");
    } else {
      args.DISTANCETOMENU = String(args.DISTANCETOMENU);
      const distTarget = this.runtime.getSpriteTargetByName(args.DISTANCETOMENU);
      if (!distTarget) return 10000;
      targetX = distTarget.x;
      targetY = distTarget.y;
    }

    const dx = util.target.x - targetX;
    const dy = util.target.y - targetY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  setDragMode(args, util) {
    util.target.setDraggable(args.DRAG_MODE === "draggable");
  }

  getTimer(args, util) {
    return util.ioQuery("clock", "projectTimer");
  }

  resetTimer(args, util) {
    util.ioQuery("clock", "resetProjectTimer");
  }

  getMouseX(args, util) {
    return util.ioQuery("mouse", "getScratchX");
  }

  getMouseY(args, util) {
    return util.ioQuery("mouse", "getScratchY");
  }

  getMouseDown(args, util) {
    return util.ioQuery("mouse", "getIsDown");
  }

  current(args) {
    const menuOption = String(args.CURRENTMENU).toLowerCase();
    const date = new Date();

    switch (menuOption) {
      case "year":
        return date.getFullYear();

      case "month":
        return date.getMonth() + 1;
      // getMonth is zero-based

      case "date":
        return date.getDate();

      case "dayofweek":
        return date.getDay() + 1;
      // getDay is zero-based, Sun=0

      case "hour":
        return date.getHours();

      case "minute":
        return date.getMinutes();

      case "second":
        return date.getSeconds();
    }

    return 0;
  }

  getKeyPressed(args, util) {
    return util.ioQuery("keyboard", "getKeyIsDown", [args.KEY_OPTION]);
  }

  daysSince2000() {
    const msPerDay = 24 * 60 * 60 * 1000;
    const start = new Date(2000, 0, 1); // Months are 0-indexed.

    const today = new Date();
    const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
    let mSecsSinceStart = today.valueOf() - start.valueOf();
    mSecsSinceStart += (today.getTimezoneOffset() - dstAdjust) * 60 * 1000;
    return mSecsSinceStart / msPerDay;
  }

  getLoudness() {
    if (typeof this.runtime.audioEngine === "undefined") return -1;
    if (this.runtime.currentStepTime === null) return -1; // Only measure loudness once per step

    const timeSinceLoudness = this._timer.time() - this._cachedLoudnessTimestamp;

    if (timeSinceLoudness < this.runtime.currentStepTime) {
      return this._cachedLoudness;
    }

    this._cachedLoudnessTimestamp = this._timer.time();
    this._cachedLoudness = this.runtime.audioEngine.getLoudness();
    return this._cachedLoudness;
  }

  isLoud() {
    return this.getLoudness() > 10;
  }

  getAttributeOf(args) {
    let attrTarget;

    if (args.OBJECT === "_stage_") {
      attrTarget = this.runtime.getTargetForStage();
    } else {
      args.OBJECT = String(args.OBJECT);
      attrTarget = this.runtime.getSpriteTargetByName(args.OBJECT);
    } // attrTarget can be undefined if the target does not exist
    // (e.g. single sprite uploaded from larger project referencing
    // another sprite that wasn't uploaded)


    if (!attrTarget) return 0; // Generic attributes

    if (attrTarget.isStage) {
      switch (args.PROPERTY) {
        // Scratch 1.4 support
        case "background #":
          return attrTarget.currentCostume + 1;

        case "backdrop #":
          return attrTarget.currentCostume + 1;

        case "backdrop name":
          return attrTarget.getCostumes()[attrTarget.currentCostume].name;

        case "volume":
          return attrTarget.volume;
      }
    } else {
      switch (args.PROPERTY) {
        case "x position":
          return attrTarget.x;

        case "y position":
          return attrTarget.y;

        case "direction":
          return attrTarget.direction;

        case "costume #":
          return attrTarget.currentCostume + 1;

        case "costume name":
          return attrTarget.getCostumes()[attrTarget.currentCostume].name;

        case "size":
          return attrTarget.size;

        case "volume":
          return attrTarget.volume;
      }
    } // Target variables.


    const varName = args.PROPERTY;
    const variable = attrTarget.lookupVariableByNameAndType(varName, "", true);

    if (variable) {
      return variable.value;
    } // Otherwise, 0


    return 0;
  }

  getUsername(args, util) {
    return util.ioQuery("userData", "getUsername");
  }

}

class KidDataBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      data_variable: this.getVariable,
      data_setvariableto: this.setVariableTo,
      data_changevariableby: this.changeVariableBy,
      data_hidevariable: this.hideVariable,
      data_showvariable: this.showVariable,
      data_listcontents: this.getListContents,
      data_addtolist: this.addToList,
      data_deleteoflist: this.deleteOfList,
      data_deletealloflist: this.deleteAllOfList,
      data_insertatlist: this.insertAtList,
      data_replaceitemoflist: this.replaceItemOfList,
      data_itemoflist: this.getItemOfList,
      data_itemnumoflist: this.getItemNumOfList,
      data_lengthoflist: this.lengthOfList,
      data_listcontainsitem: this.listContainsItem,
      data_hidelist: this.hideList,
      data_showlist: this.showList
    };
  }

  getVariable(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    return variable.value;
  }

  setVariableTo(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    variable.value = args.VALUE;

    if (variable.isCloud) {
      util.ioQuery("cloud", "requestUpdateVariable", [variable.name, args.VALUE]);
    }
  }

  changeVariableBy(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    const castedValue = Utility.toNumber(variable.value);
    const dValue = Utility.toNumber(args.VALUE);
    const newValue = castedValue + dValue;
    variable.value = newValue;

    if (variable.isCloud) {
      util.ioQuery("cloud", "requestUpdateVariable", [variable.name, newValue]);
    }
  }

  changeMonitorVisibility(id, visible) {
    // Send the monitor blocks an event like the flyout checkbox event.
    // This both updates the monitor state and changes the isMonitored block flag.
    this.runtime.monitorBlocks.changeBlock({
      id: id,
      // Monitor blocks for variables are the variable ID.
      element: "checkbox",
      // Mimic checkbox event from flyout.
      value: visible
    }, this.runtime);
  }

  showVariable(args) {
    this.changeMonitorVisibility(args.VARIABLE.id, true);
  }

  hideVariable(args) {
    this.changeMonitorVisibility(args.VARIABLE.id, false);
  }

  showList(args) {
    this.changeMonitorVisibility(args.LIST.id, true);
  }

  hideList(args) {
    this.changeMonitorVisibility(args.LIST.id, false);
  }

  getListContents(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name); // If block is running for monitors, return copy of list as an array if changed.

    if (util.thread.updateMonitor) {
      // Return original list value if up-to-date, which doesn't trigger monitor update.
      if (list._monitorUpToDate) return list.value; // If value changed, reset the flag and return a copy to trigger monitor update.
      // Because monitors use Immutable data structures, only new objects trigger updates.

      list._monitorUpToDate = true;
      return list.value.slice();
    } // Determine if the list is all single letters.
    // If it is, report contents joined together with no separator.
    // If it's not, report contents joined together with a space.


    let allSingleLetters = true;

    for (let i = 0; i < list.value.length; i++) {
      const listItem = list.value[i];

      if (!(typeof listItem === "string" && listItem.length === 1)) {
        allSingleLetters = false;
        break;
      }
    }

    if (allSingleLetters) {
      return list.value.join("");
    }

    return list.value.join(" ");
  }

  addToList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);

    if (list.value.length < KidDataBlocks.LIST_ITEM_LIMIT) {
      list.value.push(args.ITEM);
      list._monitorUpToDate = false;
    }
  }

  deleteOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Utility.toListIndex(args.INDEX, list.value.length, true);

    if (index === Utility.LIST_INVALID) {
      return;
    } else if (index === Utility.LIST_ALL) {
      list.value = [];
      return;
    }

    list.value.splice(index - 1, 1);
    list._monitorUpToDate = false;
  }

  deleteAllOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    list.value = [];
    return;
  }

  insertAtList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Utility.toListIndex(args.INDEX, list.value.length + 1, false);
    if (index === Utility.LIST_INVALID) return;
    const listLimit = KidDataBlocks.LIST_ITEM_LIMIT;
    if (index > listLimit) return;
    list.value.splice(index - 1, 0, item);

    if (list.value.length > listLimit) {
      // If inserting caused the list to grow larger than the limit,
      // remove the last element in the list
      list.value.pop();
    }

    list._monitorUpToDate = false;
  }

  replaceItemOfList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Utility.toListIndex(args.INDEX, list.value.length, false);
    if (index === Utility.LIST_INVALID) return;
    list.value[index - 1] = item;
    list._monitorUpToDate = false;
  }

  getItemOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Utility.toListIndex(args.INDEX, list.value.length, false);
    if (index === Utility.LIST_INVALID) return "";
    return list.value[index - 1];
  }

  getItemNumOfList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name); // Go through the list items one-by-one using Utility.compare. This is for
    // cases like checking if 123 is contained in a list [4, 7, '123'] --
    // Scratch considers 123 and '123' to be equal.

    for (let i = 0; i < list.value.length; i++) {
      if (Utility.compare(list.value[i], item) === 0) {
        return i + 1;
      }
    } // We don't bother using .indexOf() at all, because it would end up with
    // edge cases such as the index of '123' in [4, 7, 123, '123', 9].
    // If we use indexOf(), this block would return 4 instead of 3, because
    // indexOf() sees the first occurence of the string 123 as the fourth
    // item in the list. With Scratch, this would be confusing -- after all,
    // '123' and 123 look the same, so one would expect the block to say
    // that the first occurrence of '123' (or 123) to be the third item.
    // Default to 0 if there's no match. Since Scratch lists are 1-indexed,
    // we don't have to worry about this conflicting with the "this item is
    // the first value" number (in JS that is 0, but in Scratch it's 1).


    return 0;
  }

  lengthOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    return list.value.length;
  }

  listContainsItem(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);

    if (list.value.indexOf(item) >= 0) {
      return true;
    } // Try using Scratch comparison operator on each item.
    // (Scratch considers the string '123' equal to the number 123).


    for (let i = 0; i < list.value.length; i++) {
      if (Utility.compare(list.value[i], item) === 0) {
        return true;
      }
    }

    return false;
  }
  /**
   * Type representation for list variables.
   * @const {number}
   */


  static get LIST_ITEM_LIMIT() {
    return 200000;
  }

}

class KidProcedureBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      procedures_definition: this.definition,
      procedures_call: this.call,
      argument_reporter_string_number: this.argumentReporterStringNumber,
      argument_reporter_boolean: this.argumentReporterBoolean
    };
  }

  definition() {// No-op: execute the blocks.
  }

  call(args, util) {
    if (!util.stackFrame.executed) {
      const procedureCode = args.mutation.proccode;
      const paramNamesIdsAndDefaults = util.getProcedureParamNamesIdsAndDefaults(procedureCode); // If null, procedure could not be found, which can happen if custom
      // block is dragged between sprites without the definition.
      // Match Scratch 2.0 behavior and noop.

      if (paramNamesIdsAndDefaults === null) {
        return;
      }

      const [paramNames, paramIds, paramDefaults] = paramNamesIdsAndDefaults; // Initialize params for the current stackFrame to {}, even if the procedure does
      // not take any arguments. This is so that `getParam` down the line does not look
      // at earlier stack frames for the values of a given parameter (#1729)

      util.initParams();

      for (let i = 0; i < paramIds.length; i++) {
        if (args.hasOwnProperty(paramIds[i])) {
          util.pushParam(paramNames[i], args[paramIds[i]]);
        } else {
          util.pushParam(paramNames[i], paramDefaults[i]);
        }
      }

      util.stackFrame.executed = true;
      util.startProcedure(procedureCode);
    }
  }

  argumentReporterStringNumber(args, util) {
    const value = util.getParam(args.VALUE);

    if (value === null) {
      // When the parameter is not found in the most recent procedure
      // call, the default is always 0.
      return 0;
    }

    return value;
  }

  argumentReporterBoolean(args, util) {
    const value = util.getParam(args.VALUE);

    if (value === null) {
      // When the parameter is not found in the most recent procedure
      // call, the default is always 0.
      return 0;
    }

    return value;
  }

}
/**
 * 笔颜色参数值的枚举.
 * @readonly
 * @enum {string}
 */


const ColorParam = {
  COLOR: "color",
  SATURATION: "saturation",
  BRIGHTNESS: "brightness",
  TRANSPARENCY: "transparency"
};
/**
 * @typedef {object} PenState - 与特定目标关联的笔状态.
 * @property {Boolean} penDown - 跟踪笔是否应为此目标绘制.
 * @property {number} color - 笔的当前颜色（色相）.
 * @property {PenAttributes} penAttributes - 渲染器的缓存笔属性。 这是直径的权威值，而不是笔的颜色.
 */

/**
 * Scratch 3.0中与笔相关的块的主机
 * @param {Runtime} runtime - 运行时实例化此块包
 * @constructor
 */

class KidPenBlocks {
  constructor(runtime) {
    /**
     * 运行时实例化此块包
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * 笔层对应的渲染器Drawable的ID.
     * @type {int}
     * @private
     */

    this._penDrawableId = -1;
    /**
     * 与笔层相对应的渲染器外观的ID.
     * @type {int}
     * @private
     */

    this._penSkinId = -1;
    this._onTargetCreated = this._onTargetCreated.bind(this);
    this._onTargetMoved = this._onTargetMoved.bind(this);
    runtime.on("targetWasCreated", this._onTargetCreated);
    runtime.on("RUNTIME_DISPOSED", this.penClear.bind(this));
  }
  /**
   * 默认画笔状态, 当目标不存在画笔状态时使用.
   * @type {PenState}
   */


  static get DEFAULT_PEN_STATE() {
    return {
      penDown: false,
      color: 66.66,
      saturation: 100,
      brightness: 100,
      transparency: 0,
      _shade: 50,
      // 仅用于遗留的“改变阴影”块
      penAttributes: {
        color4f: [0, 0, 1, 1],
        diameter: 1
      }
    };
  }
  /**
   * 笔的最小和最大尺寸.
   * 最大值是舞台对角线的两倍，因此即使是舞台下的精灵也可以填充它.
   * @type {{min: number, max: number}}
   */


  static get PEN_SIZE_RANGE() {
    return {
      min: 1,
      max: 1200
    };
  }
  /**
   * 加载和存储目标笔相关状态的键.
   * @type {string}
   */


  static get STATE_KEY() {
    return "Scratch.pen";
  }
  /**
   * 检索此程序包实现的块原语
   * @return {object.<string, Function>} 操作码到功能的映射.
   */


  getPrimitives() {
    return {
      pen_clear: this.penClear,
      // 绘画.清理
      pen_down: this.penDown,
      // 绘画.落笔
      pen_up: this.penUp,
      // 绘画.抬笔
      pen_setcolorto: this.setPenColorToColor // 绘画.设置颜色

    };
  }
  /**
   * 将笔大小值限制在笔允许的范围内.
   * @param {number} requestedSize - 要求的笔号.
   * @returns {number} the clamped size.
   * @private
   */


  _clampPenSize(requestedSize) {
    return Utility.clamp(requestedSize, KidPenBlocks.PEN_SIZE_RANGE.min, KidPenBlocks.PEN_SIZE_RANGE.max);
  }
  /**
   * 检索与笔层相对应的渲染器“ Skin”的ID。 如果笔皮肤还不存在，请创建它.
   * @returns {int} 笔层的皮肤ID，如果失败，则为-1.
   * @private
   */


  _getPenLayerID() {
    if (this._penSkinId < 0 && this.runtime.renderer) {
      this._penSkinId = this.runtime.renderer.createPenSkin();
      this._penDrawableId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);
      this.runtime.renderer.updateDrawableProperties(this._penDrawableId, {
        skinId: this._penSkinId
      });
    }

    return this._penSkinId;
  }
  /**
   * @param {Target} target - 收集该目标的笔状态。 可能但不一定是渲染目标.
   * @returns {PenState} 与该目标关联的可变笔状态。 这将在必要时创建.
   * @private
   */


  _getPenState(target) {
    let penState = target.getCustomState(KidPenBlocks.STATE_KEY);

    if (!penState) {
      penState = Utility.cloneSimple(KidPenBlocks.DEFAULT_PEN_STATE);
      target.setCustomState(KidPenBlocks.STATE_KEY, penState);
    }

    return penState;
  }
  /**
   * 克隆使用笔的目标时，克隆笔状态.
   * @param {Target} newTarget - 新创建的目标.
   * @param {Target} [sourceTarget] - 用作新克隆源的目标（如果有）.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const penState = sourceTarget.getCustomState(KidPenBlocks.STATE_KEY);

      if (penState) {
        newTarget.setCustomState(KidPenBlocks.STATE_KEY, Utility.cloneSimple(penState));

        if (penState.penDown) {
          console.log("笔落下:", penState);
          newTarget.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
        }
      }
    }
  }
  /**
   * 处理已移动的目标。 仅在笔落下时才会触发.
   * @param {RenderedTarget} target - 已移动的目标.
   * @param {number} oldX - 先前的X位置.
   * @param {number} oldY - 先前的Y位置.
   * @param {boolean} isForce - 运动是否被迫.
   * @private
   */


  _onTargetMoved(target, oldX, oldY, isForce) {
    // 仅在不强制移动（即拖动）的情况下移动笔.
    if (!isForce) {
      const penSkinId = this._getPenLayerID();

      if (penSkinId >= 0) {
        const penState = this._getPenState(target);

        this.runtime.renderer.penLine(penSkinId, penState.penAttributes, oldX, oldY, target.x, target.y);
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * 将颜色输入包裹在（0,100）范围内.
   * @param {number} value - the value to be wrapped.
   * @returns {number} the wrapped value.
   * @private
   */


  _wrapColor(value) {
    return Utility.wrapClamp(value, 0, 100);
  }
  /**
   * 将笔颜色参数限制在（0,100）范围内.
   * @param {number} value - the value to be clamped.
   * @returns {number} the clamped value.
   * @private
   */


  _clampColorParam(value) {
    return Utility.clamp(value, 0, 100);
  }
  /**
   * 将Alpha值转换为笔透明度值.
   * Alpha的范围是0到1，其中0是透明的，而1是不透明的.
   * 透明度范围是0到100，其中0是不透明的，而100是透明的.
   * @param {number} alpha - 输入的Alpha值.
   * @returns {number} 透明度值.
   * @private
   */


  _alphaToTransparency(alpha) {
    return (1.0 - alpha) * 100.0;
  }
  /**
   * 将笔的透明度值转换为Alpha值.
   * Alpha的范围是0到1，其中0是透明的，而1是不透明的.
   * 透明度范围是0到100，其中0是不透明的，而100是透明的.
   * @param {number} transparency - 输入透明度值.
   * @returns {number} the alpha value.
   * @private
   */


  _transparencyToAlpha(transparency) {
    return 1.0 - transparency / 100.0;
  }
  /**
   * 自定义  擦除函数
   */


  penClear() {
    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penClear(penSkinId);
      this.runtime.requestRedraw();
    }
  }
  /**
   * 自定义  落笔函数
   * "pen down"块使目标在以后的运动中留下笔迹
   * @param {*} args 积木参数
   * @param {*} util 运行时提供的实用程序对象
   */


  penDown(args, util) {
    // console.log("pen_down积木", "args:", args, "util:", util);
    const target = util.target;

    const penState = this._getPenState(target);

    if (!penState.penDown) {
      penState.penDown = true;
      target.addListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
    }

    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penPoint(penSkinId, penState.penAttributes, target.x, target.y);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "pen up" block stops the target from leaving pen trails.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  penUp(args, util) {
    // console.log("pen_up积木", "args:", args, "util:", util);
    const target = util.target;

    const penState = this._getPenState(target);

    if (penState.penDown) {
      penState.penDown = false;
      target.removeListener(RenderedTarget.EVENT_TARGET_MOVED, this._onTargetMoved);
    }
  }
  /**
   * The pen "set pen color to {color}" 将笔设置为特定的RGB颜色
   * 透明度重置为0.
   * @param {object} args - the block arguments.
   *  @property {int} COLOR - 要设置的颜色，表示为24位RGB值（0xRRGGBB）.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenColorToColor(args, util) {
    const penState = this._getPenState(util.target);

    const rgb = Utility.toRgbColorObject(args.COLOR);
    const hsv = Utility.rgbToHsv(rgb);
    penState.color = hsv.h / 360 * 100;
    penState.saturation = hsv.s * 100;
    penState.brightness = hsv.v * 100;

    if (rgb.hasOwnProperty("a")) {
      penState.transparency = 100 * (1 - rgb.a / 255.0);
    } else {
      penState.transparency = 0;
    } // 设置旧的“阴影”值的方法与草稿2相同.


    penState._shade = penState.brightness / 2;

    this._updatePenColor(penState);
  }
  /**
   * 根据提供的PenState对象中的颜色，饱和度，亮度和透明度值更新缓存的颜色.
   * @param {PenState} penState - the pen state to update.
   * @private
   */


  _updatePenColor(penState) {
    const rgb = Utility.hsvToRgb({
      h: penState.color * 360 / 100,
      s: penState.saturation / 100,
      v: penState.brightness / 100
    });
    penState.penAttributes.color4f[0] = rgb.r / 255.0;
    penState.penAttributes.color4f[1] = rgb.g / 255.0;
    penState.penAttributes.color4f[2] = rgb.b / 255.0;
    penState.penAttributes.color4f[3] = this._transparencyToAlpha(penState.transparency);
  }
  /**
   * 在笔状态上设置或更改单一颜色参数，并更新笔颜色.
   * @param {ColorParam} param - 要设置或更改的颜色参数的名称.
   * @param {number} value - 用于设置或更改参数的值.
   * @param {PenState} penState - 笔状态更新.
   * @param {boolean} change - 如果为true，则按值更改参数；如果为false，则将参数设置为value.
   * @private
   */


  _setOrChangeColorParam(param, value, penState, change) {
    switch (param) {
      case ColorParam.COLOR:
        penState.color = this._wrapColor(value + (change ? penState.color : 0));
        break;

      case ColorParam.SATURATION:
        penState.saturation = this._clampColorParam(value + (change ? penState.saturation : 0));
        break;

      case ColorParam.BRIGHTNESS:
        penState.brightness = this._clampColorParam(value + (change ? penState.brightness : 0));
        break;

      case ColorParam.TRANSPARENCY:
        penState.transparency = this._clampColorParam(value + (change ? penState.transparency : 0));
        break;

      default:
        console.warn(`Tried to set or change unknown color parameter: ${param}`);
    }

    this._updatePenColor(penState);
  }
  /**
   * The "change pen {ColorParam} by {number}" block changes one of the pen's color parameters
   * by a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to change the selected parameter by.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenColorParamBy(args, util) {
    const penState = this._getPenState(util.target);

    this._setOrChangeColorParam(args.COLOR_PARAM, Utility.toNumber(args.VALUE), penState, true);
  }
  /**
   * The "set pen {ColorParam} to {number}" block sets one of the pen's color parameters
   * to a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to set the selected parameter to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenColorParamTo(args, util) {
    const penState = this._getPenState(util.target);

    this._setOrChangeColorParam(args.COLOR_PARAM, Utility.toNumber(args.VALUE), penState, false);
  }
  /**
   * The pen "change pen size by {number}" block changes the pen size by the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenSizeBy(args, util) {
    const penAttributes = this._getPenState(util.target).penAttributes;

    penAttributes.diameter = this._clampPenSize(penAttributes.diameter + Utility.toNumber(args.SIZE));
  }
  /**
   * The pen "set pen size to {number}" block sets the pen size to the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenSizeTo(args, util) {
    const penAttributes = this._getPenState(util.target).penAttributes;

    penAttributes.diameter = this._clampPenSize(Utility.toNumber(args.SIZE));
  }
  /* LEGACY OPCODES */

  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount to set the hue to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenHueToNumber(args, util) {
    const penState = this._getPenState(util.target);

    const hueValue = Utility.toNumber(args.HUE);
    const colorValue = hueValue / 2;

    this._setOrChangeColorParam(ColorParam.COLOR, colorValue, penState, false);

    this._setOrChangeColorParam(ColorParam.TRANSPARENCY, 0, penState, false);

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount of desired hue change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenHueBy(args, util) {
    const penState = this._getPenState(util.target);

    const hueChange = Utility.toNumber(args.HUE);
    const colorChange = hueChange / 2;

    this._setOrChangeColorParam(ColorParam.COLOR, colorChange, penState, true);

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Use legacy "set shade" code to calculate RGB value for shade,
   * then convert back to HSV and store those components.
   * It is important to also track the given shade in penState._shade
   * because it cannot be accurately backed out of the new HSV later.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount to set the shade to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenShadeToNumber(args, util) {
    const penState = this._getPenState(util.target);

    let newShade = Utility.toNumber(args.SHADE); // Wrap clamp the new shade value the way scratch 2 did.

    newShade = newShade % 200;
    if (newShade < 0) newShade += 200; // And store the shade that was used to compute this new color for later use.

    penState._shade = newShade;

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Because "shade" cannot be backed out of hsv consistently, use the previously
   * stored penState._shade to make the shade change.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount of desired shade change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenShadeBy(args, util) {
    const penState = this._getPenState(util.target);

    const shadeChange = Utility.toNumber(args.SHADE);
    this.setPenShadeToNumber({
      SHADE: penState._shade + shadeChange
    }, util);
  }
  /**
   * Update the pen state's color from its hue & shade values, Scratch 2.0 style.
   * @param {object} penState - update the HSV & RGB values in this pen state from its hue & shade values.
   * @private
   */


  _legacyUpdatePenColor(penState) {
    // Create the new color in RGB using the scratch 2 "shade" model
    let rgb = Utility.hsvToRgb({
      h: penState.color * 360 / 100,
      s: 1,
      v: 1
    });
    const shade = penState._shade > 100 ? 200 - penState._shade : penState._shade;

    if (shade < 50) {
      rgb = Utility.mixRgb(Utility.RGB_BLACK, rgb, (10 + shade) / 60);
    } else {
      rgb = Utility.mixRgb(rgb, Utility.RGB_WHITE, (shade - 50) / 60);
    } // Update the pen state according to new color


    const hsv = Utility.rgbToHsv(rgb);
    penState.color = 100 * hsv.h / 360;
    penState.saturation = 100 * hsv.s;
    penState.brightness = 100 * hsv.v;

    this._updatePenColor(penState);
  }
  /**
   * The pen "stamp" block stamps the current drawable's image onto the pen layer.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  stamp(args, util) {
    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      const target = util.target;
      this.runtime.renderer.penStamp(penSkinId, target.drawableID);
      this.runtime.requestRedraw();
    }
  }

}

const defaultBlockPackages = {
  /** kid-pro版 目前的积木 */
  kid_control: KidControlBlocks,
  kid_event: KidEventBlocks,
  kid_looks: KidLooksBlocks,
  kid_motion: KidMotionBlocks,
  kid_operators: KidOperatorsBlocks,
  kid_sound: KidSoundBlocks,
  kid_sensing: KidSensingBlocks,
  kid_data: KidDataBlocks,
  kid_procedures: KidProcedureBlocks,

  /** kid-jr版 */
  // 引入 音乐分类 绘画分类 （在blocks文件夹下，自定义绘画类积木块逻辑主文件 ）
  kid_pen: KidPenBlocks //   /** 添加新版的积木脚本 */
  //   control: require("../blocks/control"),
  //   event: require("../blocks/event"),
  //   looks: require("../blocks/looks"),
  //   motion: require("../blocks/motion"),
  //   operators: require("../blocks/operators"),
  //   sound: require("../blocks/sound"),
  //   sensing: require("../blocks/sensing"),
  //   // data: require("../blocks/data"),
  //   // procedures: require("../blocks/procedures"),

};
module.exports = defaultBlockPackages;

/***/ }),

/***/ 0:
/*!*********************************!*\
  !*** readable-stream (ignored) ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});
//# sourceMappingURL=kid-vm.js.map